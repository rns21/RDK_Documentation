{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Powering Entertainment. Enabling Connectivity. One Unified Platform.","text":"<p>RDK empowers developers and device makers with open-source tools to deliver high-performance video, broadband, and smart home experiences. Choose your domain to explore tailored docs, APIs, and workflows for rapid development.</p> ENTERTAINMENT <p>Build Apps, manage media and UI layers in a video platform.</p> EXPLORE CONNECTIVITY <p>Framework that enables high-speed internet delivery for service providers.</p> EXPLORE"},{"location":"connectivity/docs/","title":"Home","text":"Getting Started with RDK for Connectivity architecture Architecture <p>Get a deep dive into the RDK-B architecture, including the support for different WAN types and Wi-Fi &amp; Mesh, and its pluggable architecture </p> Read More arrow_forward list Features <p>A deciding factor of any software stack is the number of user centric features that are supported by that software.</p> Read More arrow_forward devices Device Profiles <p>From the fundamental router to extender, RDK offers a variety of device profiles.</p> Read More arrow_forward try Try Out RDK <p>The best way to experience RDK is to try out RDK youself in a platform. Get yourself started in exploring RDK.</p> Read More arrow_forward book Test your Device <p>RDK provides different in house tools to validate your RDK platform</p> Read More arrow_forward layers RDK Components <p>Understand the architecture of each RDK component,the component interfaces as well as other layers of RDK.</p> Read More arrow_forward"},{"location":"connectivity/docs/architecture/","title":"Place Holder markdown for Connectivity Architecture","text":""},{"location":"connectivity/docs/features/","title":"Place Holder markdown for Connectivity features","text":""},{"location":"connectivity/docs/profiles/","title":"Place Holder markdown for Connectivity features","text":""},{"location":"connectivity/docs/rdkb_components/","title":"Components List","text":"Component Name Documentation Source code WAN Manager WAN Manager GitHub GPON Manager GPON Manager GitHub Cellular Manager Cellular Manager GitHub"},{"location":"connectivity/docs/tryout_rdkb/","title":"Place Holder markdown for Connectivity  Getting Started page","text":""},{"location":"connectivity/docs/components/PSM_Claude/","title":"CcspPsm Documentation","text":""},{"location":"connectivity/docs/components/PSM_Claude/#1-overview","title":"1. Overview","text":"<ul> <li> <p>Purpose in RDK\u2011B Stack: CcspPsm (Platform Storage Manager) serves as the centralized persistence and configuration state management service within the RDK\u2011B middleware stack. It provides reliable storage, retrieval, validation, and lifecycle management of configuration and operational parameters used by other CCSP/RDK\u2011B components. The component ensures that device configuration and operational parameters survive restarts, firmware upgrades, and controlled recovery scenarios while maintaining data integrity through schema validation and atomic operations.</p> </li> <li> <p>Key Features &amp; Responsibilities: CcspPsm delivers schema\u2011driven configuration loading from XML definitions, parameter storage with atomic update semantics, dual\u2011subsystem architecture (file loader and system registry), state machine governance for lifecycle transitions, HAL integration points for platform abstraction, IPC exposure over both DBus and RBUS protocols, structured exported APIs with clear boundaries, controlled migration support via patch scripting, and comprehensive unit test coverage validating all internal modules. The component mediates the entire lifecycle from initial parsing through steady\u2011state runtime operations and subsequent mutation or synchronization sequences.</p> </li> <li> <p>Role in Broadband Router Architecture: Architecturally, CcspPsm occupies the persistence tier immediately beneath higher\u2011level management agents and above platform storage abstractions (filesystem/flash/NVRAM). It forms a horizontal service consumed by multiple vertical functional domains including telemetry, WAN management, Wi\u2011Fi configuration, provisioning services, and diagnostics through standardized bus interfaces. Rather than acting as a HAL or business logic orchestrator, it supplies the durable substrate and access discipline that other components depend upon for configuration fidelity and transactional integrity.</p> </li> </ul>"},{"location":"connectivity/docs/components/PSM_Claude/#2-architecture-design","title":"2. Architecture / Design","text":""},{"location":"connectivity/docs/components/PSM_Claude/#21-highlevel-design-principles","title":"2.1 High\u2011Level Design Principles","text":"<p>The architecture manifests principles of modular separation through distinct directories for file loader and system registry subsystems, interface clarity via explicit interface and exported API headers for each subsystem, layered responsibility separating file parsing from runtime registry from service shell functions, explicit state modeling with dedicated states modules controlling lifecycle transitions, portability through schema files detached from core logic, controlled evolution supported by ChangeLog and Version.txt tracking, comprehensive testability with granular unit tests per internal concern, and IPC abstraction providing dual DBus/RBUS support. Schema\u2011driven operation reduces hard\u2011coded structural assumptions while atomicity and consistency are enforced through separate operation modules distinct from control and state logic.</p>"},{"location":"connectivity/docs/components/PSM_Claude/#22-component-boundaries-responsibilities","title":"2.2 Component Boundaries &amp; Responsibilities","text":"<p>PsmFileLoader Subsystem: Responsible for ingesting XML schema and persisted data, validating structure and types through parsing logic, orchestrating state transitions via dedicated state machines, coordinating higher\u2011level control flows, executing concrete file operations including atomic commits, and furnishing consolidated external interfaces through interface and exported API headers.</p> <p>PsmSysRegistry Subsystem: Maintains authoritative in\u2011memory parameter registry, mediates configuration manager interface functions, implements runtime control logic, provides storage interfacing behind system RAM abstraction, and mirrors the file loader with analogous base, operation, states, interface, and exported API segmentation for consistent architectural patterns.</p> <p>Ssp Service Shell: Acts as the process entry point handling initialization, DBus transport integration, RBUS transport integration, configuration manager coordination, and HAL abstraction bridging. It decouples transport and environmental concerns from core persistence logic while providing unified IPC endpoints.</p>"},{"location":"connectivity/docs/components/PSM_Claude/#23-threading-model-if-applicable","title":"2.3 Threading Model (if applicable)","text":"<p>The codebase exhibits a single\u2011threaded design pattern with no explicit threading primitives or concurrency layer files present in the repository structure. The component operates as an event\u2011driven service where the main processing loop handles requests sequentially. State machine transitions in both subsystems are designed for deterministic sequencing rather than concurrent scheduling. External synchronization and reentrancy protection are handled at IPC layer boundaries to prevent concurrent mutation of internal state.</p>"},{"location":"connectivity/docs/components/PSM_Claude/#24-c4-system-context-diagram","title":"2.4 C4 System Context Diagram","text":"<pre><code>graph TD\n    subgraph \"RDK-B Components\"\n        Telemetry[\ud83d\udcca Telemetry Service]\n        WAN[\ud83c\udf10 WAN Manager]\n        WiFi[\ud83d\udce1 WiFi Manager]\n        TR069[\ud83d\udd27 TR-069 Agent]\n    end\n\n    User[\ud83d\udc64 Management Systems] --&gt;|Configuration Requests| CcspPsm\n    Telemetry --&gt;|DBus/RBUS| CcspPsm\n    WAN --&gt;|Parameter Get/Set| CcspPsm\n    WiFi --&gt;|Configuration Storage| CcspPsm\n    TR069 --&gt;|Bulk Parameter Operations| CcspPsm\n\n    subgraph \"CcspPsm Container\"\n        ComponentCore[\ud83d\udd27 Platform Storage Manager]\n        ComponentCore -.-&gt;|\"Schema Validation, Atomic Persistence, State Management\"| ComponentCore\n    end\n\n    CcspPsm --&gt;|File I/O| FileSystem[\ud83d\udcbe Persistent Storage]\n    CcspPsm --&gt;|Platform Calls| HAL[\u2699\ufe0f Hardware Abstraction Layer]\n\n    classDef user fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n    classDef component fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef external fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n\n    class User,Telemetry,WAN,WiFi,TR069 user;\n    class CcspPsm,ComponentCore component;\n    class FileSystem,HAL external;</code></pre>"},{"location":"connectivity/docs/components/PSM_Claude/#25-c4-container-diagram","title":"2.5 C4 Container Diagram","text":"<pre><code>graph TD\n    subgraph Runtime [\"Linux/RDK-B Middleware\"]\n        subgraph CcspPsmContainer [\"CcspPsm Process\"]\n            SspLayer[Ssp Layer&lt;br/&gt;ssp_main.c, ssp_dbus.c, ssp_rbus.c]\n            SysRegistry[PsmSysRegistry&lt;br/&gt;In-Memory Parameter Store]\n            FileLoader[PsmFileLoader&lt;br/&gt;Schema Parser &amp; File Operations]\n            HALInterface[HAL Interface&lt;br/&gt;psm_hal_apis.c]\n        end\n        subgraph Storage [\"Persistent Storage\"]\n            ConfigFile[(\"bbhm_def_cfg_qemu.xml\")]\n            RuntimeData[(\"Runtime Parameter Files\")]\n        end\n    end\n\n    SspLayer --&gt;|\"Internal API Calls\"| SysRegistry\n    SysRegistry --&gt;|\"Persistence Requests\"| FileLoader\n    FileLoader --&gt;|\"Read/Write\"| Storage\n    SspLayer --&gt;|\"Platform Calls\"| HALInterface\n\n    classDef process fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef storage fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n\n    class SspLayer,SysRegistry,FileLoader,HALInterface process;\n    class ConfigFile,RuntimeData storage;</code></pre>"},{"location":"connectivity/docs/components/PSM_Claude/#26-design-explanation-request-flow","title":"2.6 Design Explanation &amp; Request Flow","text":"<p>Initialization Sequence: Service startup begins in <code>ssp_main.c</code>, which initializes selected IPC transports (DBus via <code>ssp_dbus.c</code> or RBUS via <code>ssp_rbus.c</code>), binds configuration manager interfaces through <code>ssp_cfmif.c</code>, and prepares HAL interaction stubs via <code>psm_hal_apis.c</code>. During startup, SysRegistry logic coordinates with the FileLoader to parse and load persisted data using <code>psm_flo_parse.c</code>. The FileLoader state machine advances through parsing, validation, and ready stages before returning control for runtime operations.</p> <p>Runtime Request Flow: Get/set operations enter through registry interface APIs, invoking operation modules that coordinate atomic changes. When persistence is required, the registry triggers commit sequences through FileLoader operation and control modules. State machines in both subsystems ensure valid transitions and prevent inconsistent states.</p> <p>Technology Stack: C programming language, DBus and RBUS for IPC, XML for schema definition, Linux filesystem for persistence, GNU build system (autotools), Google Test framework for unit testing.</p>"},{"location":"connectivity/docs/components/PSM_Claude/#3-internal-modules","title":"3. Internal Modules","text":"Module/Class Description Key Files File Loader Base Core foundational routines and shared context initialization <code>psm_flo_base.c</code> File Loader Parse XML schema parsing, structural validation, type checking <code>psm_flo_parse.c</code> File Loader Operation Atomic file I/O operations, commit logic, rollback handling <code>psm_flo_operation.c</code> File Loader Control High\u2011level orchestration of parse/load/save sequences <code>psm_flo_control.c</code> File Loader States State machine transitions and lifecycle management <code>psm_flo_states.c</code> File Loader Interface External API boundary and function dispatching <code>psm_flo_interface.c</code>, <code>psm_flo_interface.h</code> Registry Base Foundational registry initialization and context setup <code>psm_sysro_base.c</code> Registry Operation Parameter access, mutation, and validation logic <code>psm_sysro_operation.c</code> Registry Control Registry lifecycle orchestration and coordination <code>psm_sysro_control.c</code> Registry States Registry state machine and transition handling <code>psm_sysro_states.c</code> Registry Storage Persistent storage mediation and staging operations <code>psm_sysro_storage.c</code> Registry SysRAM Interface System RAM abstraction and memory management <code>psm_sysro_sysramif.c</code> Registry CFM Interface Configuration Manager integration adapter <code>psm_sysro_cfmif.c</code> Ssp Main Process entry point and master initialization <code>ssp_main.c</code> Ssp DBus DBus transport endpoint and message marshaling <code>ssp_dbus.c</code> Ssp RBUS RBUS transport endpoint and message handling <code>ssp_rbus.c</code> Ssp CFM Interface Service\u2011level configuration manager integration <code>ssp_cfmif.c</code> HAL APIs Hardware abstraction layer interface stubs <code>psm_hal_apis.c</code>, <code>psm_hal_apis.h</code>"},{"location":"connectivity/docs/components/PSM_Claude/#31-module-breakdown-diagram","title":"3.1 Module Breakdown Diagram","text":"<p>The module breakdown diagram groups related files into their functional subsystems and illustrates directional dependencies: the Ssp layer depends on the registry and loader to fulfill IPC requests, the registry invokes the loader for persistence operations, and tests exercise all boundaries without being part of the production runtime path. The schema file and patch script act as external inputs influencing initialization and migration flows.</p> <pre><code>flowchart TD\n    subgraph Ssp[\"Ssp Service Shell\"]\n        SspMain[ssp_main.c&lt;br/&gt;Process Entry]\n        SspDBus[ssp_dbus.c&lt;br/&gt;DBus Transport]\n        SspRBus[ssp_rbus.c&lt;br/&gt;RBUS Transport]\n        SspCFM[ssp_cfmif.c&lt;br/&gt;CFM Integration]\n        SspHAL[psm_hal_apis.c&lt;br/&gt;HAL Interface]\n    end\n\n    subgraph Registry[\"PsmSysRegistry\"]\n        RegBase[psm_sysro_base.c&lt;br/&gt;Foundation]\n        RegOp[psm_sysro_operation.c&lt;br/&gt;Parameter Access]\n        RegCtrl[psm_sysro_control.c&lt;br/&gt;Lifecycle]\n        RegStates[psm_sysro_states.c&lt;br/&gt;State Machine]\n        RegStore[psm_sysro_storage.c&lt;br/&gt;Storage Interface]\n        RegSysRAM[psm_sysro_sysramif.c&lt;br/&gt;Memory Interface]\n        RegCFM[psm_sysro_cfmif.c&lt;br/&gt;CFM Adapter]\n        RegInterface[psm_sysro_interface.c&lt;br/&gt;External API]\n    end\n\n    subgraph Loader[\"PsmFileLoader\"]\n        LoadBase[psm_flo_base.c&lt;br/&gt;Foundation]\n        LoadParse[psm_flo_parse.c&lt;br/&gt;XML Parser]\n        LoadOp[psm_flo_operation.c&lt;br/&gt;File Operations]\n        LoadCtrl[psm_flo_control.c&lt;br/&gt;Orchestration]\n        LoadStates[psm_flo_states.c&lt;br/&gt;State Machine]\n        LoadInterface[psm_flo_interface.c&lt;br/&gt;External API]\n    end\n\n    subgraph Tests[\"Unit Tests\"]\n        TestSuite[Comprehensive Test Coverage&lt;br/&gt;psm_*_test.cpp]\n    end\n\n    Schema[config/bbhm_def_cfg_qemu.xml&lt;br/&gt;Configuration Schema]\n    Patch[scripts/bbhm_patch.sh&lt;br/&gt;Migration Script]\n\n    Ssp --&gt;|Internal API| Registry\n    Registry --&gt;|Persistence Request| Loader\n    Loader --&gt;|Parse Schema| Schema\n    Patch -.-&gt;|Migration| Loader\n    Tests -.-&gt;|Validate| Ssp\n    Tests -.-&gt;|Validate| Registry\n    Tests -.-&gt;|Validate| Loader\n\n    classDef ssp fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n    classDef registry fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef loader fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;\n    classDef support fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n\n    class SspMain,SspDBus,SspRBus,SspCFM,SspHAL ssp;\n    class RegBase,RegOp,RegCtrl,RegStates,RegStore,RegSysRAM,RegCFM,RegInterface registry;\n    class LoadBase,LoadParse,LoadOp,LoadCtrl,LoadStates,LoadInterface loader;\n    class Tests,Schema,Patch support;</code></pre>"},{"location":"connectivity/docs/components/PSM_Claude/#4-interaction-with-other-middleware-components","title":"4. Interaction with Other Middleware Components","text":"Component Purpose of Interaction Protocols/Mechanisms Telemetry Service Stores telemetry configuration parameters and reporting settings DBus method calls, RBUS property access WAN Manager Persists WAN interface configuration, IP settings, routing parameters DBus/RBUS parameter get/set operations WiFi Manager Maintains WiFi configuration, security settings, access point parameters DBus/RBUS bulk parameter operations TR\u2011069 Agent Handles TR\u2011181 parameter persistence for remote management operations DBus/RBUS parameter validation and commit MoCA Agent Stores MoCA interface configuration and network topology data DBus/RBUS configuration parameter storage Voice Manager Persists VoIP configuration, SIP settings, voice service parameters DBus/RBUS parameter storage and retrieval Diagnostic Agent Maintains diagnostic test results and configuration DBus/RBUS data persistence"},{"location":"connectivity/docs/components/PSM_Claude/#41-middleware-interaction-diagram","title":"4.1 Middleware Interaction Diagram","text":"<p>The following diagram illustrates how various RDK\u2011B functional components interact with CcspPsm through the message bus layer. Management components typically perform bulk operations and configuration commits, while feature components focus on domain\u2011specific parameter persistence. All interactions flow through the standardized IPC mechanisms to ensure consistent access patterns and transactional integrity.</p> <pre><code>flowchart TD\n    subgraph \"Management Layer\"\n        TR069[TR-069 Agent&lt;br/&gt;Remote Management]\n        WebUI[Web Interface&lt;br/&gt;Local Management]\n    end\n\n    subgraph \"Feature Components\"\n        Telemetry[\ud83d\udcca Telemetry Service]\n        WAN[\ud83c\udf10 WAN Manager]\n        WiFi[\ud83d\udce1 WiFi Manager]\n        Voice[\ud83d\udcde Voice Manager]\n        MoCA[\ud83d\udd17 MoCA Agent]\n        Diag[\ud83d\udd0d Diagnostic Agent]\n    end\n\n    subgraph \"CcspPsm Process\"\n        PsmCore[\ud83d\udd27 CcspPsm Core&lt;br/&gt;Registry + FileLoader]\n    end\n\n    TR069 --&gt;|DBus: Bulk Parameter Operations| PsmCore\n    WebUI --&gt;|RBUS: Configuration Changes| PsmCore\n    Telemetry --&gt;|DBus: Config Persistence| PsmCore\n    WAN --&gt;|RBUS: Interface Settings| PsmCore\n    WiFi --&gt;|DBus: Security Parameters| PsmCore\n    Voice --&gt;|RBUS: VoIP Configuration| PsmCore\n    MoCA --&gt;|DBus: Network Topology| PsmCore\n    Diag --&gt;|RBUS: Test Results| PsmCore\n\n    PsmCore --&gt;|Validated Storage| FileSystem[\ud83d\udcbe Persistent Storage]\n\n    classDef mgmt fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n    classDef feature fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef core fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;\n    classDef storage fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n\n    class TR069,WebUI mgmt;\n    class Telemetry,WAN,WiFi,Voice,MoCA,Diag feature;\n    class PsmCore core;\n    class FileSystem storage;</code></pre>"},{"location":"connectivity/docs/components/PSM_Claude/#5-interaction-with-other-layers","title":"5. Interaction with Other Layers","text":"<p>CcspPsm interfaces upward with CCSP functional agents through standardized DBus and RBUS IPC mechanisms, ensuring all parameter access follows controlled pathways with schema validation and state machine governance. Downward interactions include the platform storage layer (filesystem/NVRAM) for persistent data, the Hardware Abstraction Layer (HAL) for platform\u2011specific operations through <code>psm_hal_apis.c</code>, and system memory management through <code>psm_sysro_sysramif.c</code>. The component abstracts lower\u2011level configuration complexities behind clean API boundaries, reducing duplication across agents while enforcing consistent persistence semantics.</p> Layer/Service Interaction Description Mechanism HAL Layer Platform\u2011specific storage hints, environment queries, low\u2011level access Function calls via <code>psm_hal_apis.c</code> File System Persistent configuration storage, atomic write operations, backup/restore Standard file I/O with transactional semantics System Memory In\u2011memory parameter caching, runtime state management Memory allocation via <code>psm_sysro_sysramif.c</code> Configuration Manager Policy enforcement, coordinated configuration workflows Interface calls via CFM adapters"},{"location":"connectivity/docs/components/PSM_Claude/#51-layered-architecture-view","title":"5.1 Layered Architecture View","text":"<p>The layered architecture diagram illustrates CcspPsm's position within the RDK\u2011B technology stack, showing how it mediates between application\u2011level management systems and platform infrastructure. The component serves as a horizontal service that spans multiple abstraction layers while maintaining clear boundaries and responsibilities at each level.</p> <pre><code>graph TD\n    subgraph \"Application Layer\"\n        Management[Management Applications&lt;br/&gt;TR-069, WebUI, CLI]\n        Features[Feature Components&lt;br/&gt;WAN, WiFi, Telemetry, Voice]\n    end\n\n    subgraph \"Middleware Layer\"\n        IPC[IPC Transport&lt;br/&gt;DBus/RBUS]\n        CcspPsm[\ud83d\udd27 CcspPsm&lt;br/&gt;Parameter Storage Manager]\n    end\n\n    subgraph \"Platform Layer\"\n        HAL[Hardware Abstraction Layer&lt;br/&gt;psm_hal_apis.c]\n        CFM[Configuration Manager&lt;br/&gt;Policy &amp; Coordination]\n        SysRAM[System Memory&lt;br/&gt;psm_sysro_sysramif.c]\n    end\n\n    subgraph \"System Layer\"\n        FileSystem[File System&lt;br/&gt;Persistent Storage]\n        OS[Operating System&lt;br/&gt;Linux/RDK-B Runtime]\n    end\n\n    Management --&gt; IPC\n    Features --&gt; IPC\n    IPC --&gt; CcspPsm\n    CcspPsm --&gt; HAL\n    CcspPsm --&gt; CFM\n    CcspPsm --&gt; SysRAM\n    CcspPsm --&gt; FileSystem\n    FileSystem --&gt; OS\n    HAL --&gt; OS\n\n    classDef app fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n    classDef middleware fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef platform fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;\n    classDef system fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n\n    class Management,Features app;\n    class IPC,CcspPsm middleware;\n    class HAL,CFM,SysRAM platform;\n    class FileSystem,OS system;</code></pre>"},{"location":"connectivity/docs/components/PSM_Claude/#6-ipc-mechanism","title":"6. IPC Mechanism","text":"<ul> <li> <p>Type of IPC: Dual transport support with DBus (via <code>ssp_dbus.c</code>) and RBUS (via <code>ssp_rbus.c</code>) for backward compatibility and migration scenarios. Both transports provide method call semantics for parameter operations.</p> </li> <li> <p>Message Format: Method calls follow standard DBus/RBUS patterns with parameter name strings, typed values (string, integer, boolean), and operation types (get, set, commit, validate). Response messages include status codes, return values, and error descriptions. Schema validation occurs before persistence operations.</p> </li> <li> <p>Flow: Synchronous request/response pattern for most operations. Clients invoke methods through the bus, Ssp layer dispatches to registry operations, registry manages in\u2011memory state and optionally triggers file loader persistence, then status propagates back through the transport layer to the caller.</p> </li> </ul>"},{"location":"connectivity/docs/components/PSM_Claude/#61-ipc-flow-diagram","title":"6.1 IPC Flow Diagram","text":"<p>The following sequence diagram illustrates the complete flow for both parameter retrieval and modification operations, showing how requests traverse the IPC layer, internal subsystems, and optional persistence boundaries. Read operations terminate efficiently in the registry without file system access, while write operations extend through the File Loader subsystem only when persistent storage is required.</p> <pre><code>sequenceDiagram\n    participant Client as RDK-B Component\n    participant Transport as DBus/RBUS Transport&lt;br/&gt;(ssp_dbus.c / ssp_rbus.c)\n    participant Ssp as Ssp Dispatch&lt;br/&gt;(ssp_main.c)\n    participant Registry as SysRegistry&lt;br/&gt;(psm_sysro_interface.c)\n    participant Loader as FileLoader&lt;br/&gt;(psm_flo_control.c)\n    participant Storage as Persistent Storage\n\n    note over Client,Transport: Parameter Set Operation\n    Client-&gt;&gt;Transport: MethodCall(SetParameter, name, value)\n    Transport-&gt;&gt;Ssp: Dispatch Request\n    Ssp-&gt;&gt;Registry: Parameter Update\n    Registry-&gt;&gt;Registry: Validate &amp; Apply In-Memory\n\n    alt Persistence Required\n        Registry-&gt;&gt;Loader: Commit Request\n        Loader-&gt;&gt;Loader: State Transition Check\n        Loader-&gt;&gt;Storage: Atomic Write\n        Storage--&gt;&gt;Loader: Write Status\n        Loader--&gt;&gt;Registry: Commit Result\n    end\n\n    Registry--&gt;&gt;Ssp: Operation Status\n    Ssp--&gt;&gt;Transport: Format Response\n    Transport--&gt;&gt;Client: Method Response\n\n    note over Client,Transport: Parameter Get Operation\n    Client-&gt;&gt;Transport: MethodCall(GetParameter, name)\n    Transport-&gt;&gt;Ssp: Dispatch Request\n    Ssp-&gt;&gt;Registry: Retrieve Value\n    Registry--&gt;&gt;Ssp: Parameter Value\n    Ssp--&gt;&gt;Transport: Format Response\n    Transport--&gt;&gt;Client: Value Response</code></pre>"},{"location":"connectivity/docs/components/PSM_Claude/#7-tr181-data-models","title":"7. TR\u2011181 Data Models","text":"<ul> <li> <p>Implemented Parameters: CcspPsm acts as the persistence engine for TR\u2011181 parameters rather than defining specific parameter semantics. The schema file <code>config/bbhm_def_cfg_qemu.xml</code> establishes the structural framework and default values parsed at initialization.</p> </li> <li> <p>Parameter Registration: Parameters are registered through the schema definition and accessed via exported APIs (<code>psm_flo_exported_api.h</code>, <code>psm_sysro_exported_api.h</code>). Other components interact with parameters through DBus/RBUS method calls that map to internal registry operations.</p> </li> <li> <p>Custom Extensions: Schema evolution and custom parameters are supported by modifying the XML configuration file and applying controlled migrations through <code>scripts/bbhm_patch.sh</code> to maintain compatibility with existing stored data.</p> </li> </ul>"},{"location":"connectivity/docs/components/PSM_Claude/#71-tr181-parameter-table","title":"7.1 TR\u2011181 Parameter Table","text":"Parameter Category Schema Source Access Method Persistence Notes Device Configuration <code>bbhm_def_cfg_qemu.xml</code> Registry API File\u2011based Schema\u2011validated Network Interface Settings Schema\u2011defined DBus/RBUS Atomic commits State machine protected Service Parameters XML configuration Internal API Transactional Migration supported Custom Extensions Schema extensions Standard API Schema\u2011governed Patch script enabled <p>Note: Specific parameter names and values are defined in the XML schema file rather than hard\u2011coded in the component logic, enabling flexible platform adaptation and controlled evolution through external configuration management.</p>"},{"location":"connectivity/docs/components/PSM_Claude/#8-implementation-details","title":"8. Implementation Details","text":"<ul> <li> <p>Key Algorithms or Logic: Dual state machine architecture governs both FileLoader and SysRegistry subsystems with explicit state transitions enforced through dedicated states modules. Schema parsing employs XML validation with type checking and structural verification. Atomic persistence operations use staging and commit semantics to ensure transactional integrity. In\u2011memory parameter caching optimizes read operations while lazy persistence minimizes unnecessary file I/O.</p> </li> <li> <p>Error Handling Strategy: Hierarchical error propagation through well\u2011defined return codes from operation modules up through interface layers to IPC transport. Parse errors are isolated early in the FileLoader, while registry operation failures are contained within state machine boundaries. State transition validation prevents inconsistent partial updates. Comprehensive error logging aids in diagnostic troubleshooting.</p> </li> <li> <p>Logging &amp; Debugging: Structured logging integrated throughout all modules with configurable verbosity levels. Each subsystem provides detailed trace information for state transitions, parameter operations, and persistence activities. Unit tests validate both success and failure paths for all major functional modules. Mock frameworks enable isolated testing of individual components.</p> </li> </ul>"},{"location":"connectivity/docs/components/PSM_Claude/#9-key-configuration-files","title":"9. Key Configuration Files","text":"Configuration File Purpose Key Parameters Default Values Override Mechanisms <code>config/bbhm_def_cfg_qemu.xml</code> Primary schema definition for QEMU target Parameter structure, types, defaults Schema\u2011specified Replace file or apply patch script <code>scripts/bbhm_patch.sh</code> Migration and upgrade script Schema transformations N/A Execute during upgrade window <p>Configuration files are minimal by design\u2014the XML schema serves as the single source of truth for parameter definitions and structure.</p>"},{"location":"connectivity/docs/components/PSM_Claude/#91-configuration-file-details","title":"9.1 Configuration File Details","text":"<p>Schema Configuration (bbhm_def_cfg_qemu.xml): This XML file serves as the foundational configuration artifact that defines the complete parameter topology, type constraints, validation rules, and default values used during system initialization. The File Loader subsystem parses this schema during startup to construct the internal parameter representation that the System Registry maintains throughout the service lifecycle. Schema modifications enable platform\u2011specific customization, parameter addition or removal, and default value adjustments without requiring code changes, supporting flexible deployment across different hardware platforms and configuration requirements.</p> <p>Migration Script (bbhm_patch.sh): The patch script provides controlled schema evolution capabilities by enabling transformation of existing stored parameter data to remain compatible with updated parsing logic and structural expectations. This mechanism is essential during firmware upgrades or configuration migrations where the parameter schema has evolved but existing stored data must be preserved and adapted. The script operates during maintenance windows prior to service restart, ensuring that schema mismatches are resolved before the parsing logic encounters incompatible data structures.</p> <p>Configuration files are minimal by design\u2014the XML schema serves as the single source of truth for parameter definitions and structure, while the migration script provides the controlled evolution pathway necessary for long\u2011term maintainability and platform adaptation.</p>"},{"location":"connectivity/docs/components/PSM_Claude/#10-api-endpoints-if-applicable","title":"10. API Endpoints (if applicable)","text":"<p>CcspPsm exposes its functionality through IPC methods rather than REST endpoints. Key operations include:</p> Operation DBus/RBUS Method Description Parameters Returns GetParameter <code>GetParameterValue</code> Retrieve parameter value from in\u2011memory registry Parameter name (string) Value and type information SetParameter <code>SetParameterValue</code> Update parameter value with validation Name (string), Value (typed) Status code and error details CommitParameters <code>CommitChanges</code> Persist pending changes to storage None Success/failure status ValidateParameter <code>ValidateParameter</code> Check parameter against schema constraints Name (string), Value (typed) Validation result and errors GetParameterNames <code>GetParameterNames</code> Enumerate available parameter names Filter pattern (optional) Parameter name list BulkSet <code>SetMultipleParameters</code> Atomic multi\u2011parameter update Parameter array Aggregate status ResetToDefaults <code>ResetParameters</code> Restore default values Parameter list (optional) Reset status"},{"location":"connectivity/docs/components/PSM_Claude/#11-deployment-runtime-environment","title":"11. Deployment &amp; Runtime Environment","text":"<p>CcspPsm operates as a native Linux process within the RDK\u2011B middleware ecosystem, designed for deployment on broadband gateway hardware with persistent storage capabilities. The component integrates seamlessly with systemd\u2011based service management, providing controlled startup sequencing, dependency resolution, and graceful shutdown handling. Resource requirements are optimized for embedded environments while maintaining sufficient performance for high\u2011frequency parameter operations and bulk configuration management scenarios typical in broadband router deployments.</p> <ul> <li>Container Runtime: Native Linux process within RDK\u2011B middleware stack, managed by systemd</li> <li>Orchestration: Systemd service management with explicit dependency ordering and restart policies</li> <li>Resource Requirements: </li> <li>Memory: ~2\u20114MB for in\u2011memory parameter registry (varies with schema size)</li> <li>CPU: Minimal baseline with brief spikes during schema parsing and file I/O operations</li> <li>Storage: Persistent configuration files, typically &lt;1MB depending on parameter scope</li> <li>Supported Platforms: RDK\u2011B compatible hardware with persistent storage capability (eMMC, flash, etc.)</li> <li>Startup Parameters: </li> <li>Schema file path configuration</li> <li>HAL interface selection and configuration</li> <li>IPC transport selection (DBus/RBUS or both)</li> <li>Logging verbosity and output destination</li> <li>Network Dependencies: None (local IPC only)</li> <li>Security Context: Runs with appropriate privileges for filesystem access and IPC registration</li> </ul>"},{"location":"connectivity/docs/components/PSM_GPT5/","title":"CcspPsm","text":""},{"location":"connectivity/docs/components/PSM_GPT5/#1-overview","title":"1. Overview","text":"<p>CcspPsm (Platform Storage Manager) is a core persistence and configuration state service in the RDK\u2011B middleware stack. Its responsibility, as evidenced by the repository contents, is to provide reliable storage, retrieval, validation, and life\u2011cycle management of configuration and operational parameters used by other CCSP/RDK\u2011B components. It achieves this through two tightly integrated subsystems: a file\u2011oriented loader (PsmFileLoader) that parses, validates, serializes, and atomically writes persistent state, and a system registry layer (PsmSysRegistry) that maintains an in\u2011memory representation, mediates access, enforces state machine transitions, and coordinates storage updates. Surrounding these subsystems is a service shell (Ssp) that exposes inter\u2011process interfaces over DBus and RBUS, integrates with platform/HAL abstractions, and orchestrates initialization and shutdown workflows. A configuration schema (bbhm_def_cfg_qemu.xml) establishes structural and default value definitions, while patch tooling (bbhm_patch.sh) supports controlled upgrade or migration. Comprehensive unit tests spanning almost every internal module underscore a design emphasis on correctness, modularity, and maintainability.</p>"},{"location":"connectivity/docs/components/PSM_GPT5/#purpose-in-the-rdkb-stack","title":"Purpose in the RDK\u2011B Stack","text":"<p>CcspPsm exists to ensure that device configuration and selected operational parameters survive restarts, firmware upgrades, and controlled recovery scenarios. Other RDK\u2011B managers rely on it to read or commit TR\u2011181 aligned property values via standardized IPC pathways instead of implementing bespoke persistence logic. This removes duplication, enforces schema validation consistently, and centralizes transactional safeguards. It thereby underpins reliability, determinism of boot behavior, and integrity of device management operations across the platform.</p>"},{"location":"connectivity/docs/components/PSM_GPT5/#key-features-and-responsibilities","title":"Key Features and Responsibilities","text":"<p>CcspPsm provides schema\u2011driven configuration loading, parameter storage with atomic update semantics, state machine governance for both the file loader and registry subsystems, HAL integration points, IPC exposure over DBus and RBUS, structured exported APIs (clearly demarcated in interface and exported header pairs), controlled migration via patch scripting, and extensive test coverage validating base, control, operation, parse, state transition, storage, and system RAM interface behaviors. It mediates the lifecycle from initial parsing through steady\u2011state runtime and subsequent mutation or synchronization operations. Error categorization, status propagation, and robustness are implied by discrete modules for base, control, operation, parse, storage, and states in both major subsystems.</p>"},{"location":"connectivity/docs/components/PSM_GPT5/#role-in-broadband-router-architecture","title":"Role in Broadband Router Architecture","text":"<p>Architecturally CcspPsm occupies the persistence tier immediately beneath higher\u2011level management agents and above platform storage (filesystem / flash / NVRAM abstractions). It forms a horizontal service consumed by multiple vertical functional domains (telemetry, WAN, Wi\u2011Fi, provisioning, diagnostics) through bus interfaces. It acts neither as a HAL nor a business logic orchestrator; instead it supplies the durable substrate and access discipline other components depend upon for configuration fidelity.</p>"},{"location":"connectivity/docs/components/PSM_GPT5/#2-architecture-design","title":"2. Architecture / Design","text":""},{"location":"connectivity/docs/components/PSM_GPT5/#21-highlevel-design-principles","title":"2.1 High\u2011Level Design Principles","text":"<p>The code organization manifests principles of modular separation (distinct directories for file loader and system registry), interface clarity (each subsystem has both interface and exported API headers), layered responsibility (file parsing vs runtime registry vs service shell), explicit state modeling (dedicated states.c modules), portability (schema file detached from logic), controlled evolution (ChangeLog, Version.txt), testability (granular unit tests per internal concern), and IPC abstraction (dual DBus/RBUS support). Schema\u2011driven operation reduces hard\u2011coded structural assumptions. Atomicity and consistency are implied by operation modules separate from control/state logic, suggesting purposeful sequencing and commit semantics. Encapsulation of HAL calls (psm_hal_apis.[ch]) prevents leakage of platform specifics into core logic.</p>"},{"location":"connectivity/docs/components/PSM_GPT5/#22-component-boundaries-responsibilities","title":"2.2 Component Boundaries &amp; Responsibilities","text":"<ul> <li>PsmFileLoader: Responsible for ingesting XML schema and/or persisted data, validating structure and types (parse), orchestrating state transitions (states), coordinating higher\u2011level control flows (control), executing concrete file operations including commits and atomic write patterns (operation), and furnishing a consolidated external interface (interface / exported_api headers). Global and internal headers centralize shared constants and internal function contracts.</li> <li>PsmSysRegistry: Maintains in\u2011memory parameter registry, mediates configuration manager interface functions (cfmif), implements runtime control logic (control), provides storage interfacing (storage) behind a system RAM abstraction (sysramif), and parallels the file loader with analogous base, operation, states, interface, and exported API segmentation.</li> <li>Ssp Layer: Acts as the service shell handling process entry (ssp_main.c), DBus transport (ssp_dbus.c), RBUS transport (ssp_rbus.c), configuration manager integration (ssp_cfmif.c), and HAL bridging (psm_hal_apis.c). It decouples transport and environment from persistence logic.</li> <li>Include Headers: Provide stable API boundaries (psm_flo_exported_api.h, psm_sysro_exported_api.h), internal extensibility points (internal_api headers), property definitions (psm_properties.h), type metadata (psm_co_type.h), naming and OID indexing (psm_co_name.h, psm_co_oid.h), and HAL/CFM interfaces (psm_hal_apis.h, psm_ifo_cfm.h).</li> <li>Scripts: bbhm_patch.sh enables orchestrated patching or migration, ensuring compatibility when schema or structural changes occur.</li> <li>Tests: Mirror each functional concern, enabling focused verification and regression detection across base/control/operation/parse/states/storage/integration layers for both subsystems.</li> </ul>"},{"location":"connectivity/docs/components/PSM_GPT5/#23-threading-model","title":"2.3 Threading Model","text":"<p>No explicit threading primitives or concurrency layer files are present. The design appears single\u2011threaded per process for core state transitions, relying on the bus layer to serialize inbound operations or external synchronization to prevent concurrent mutation. The presence of separate operation and control modules suggests deterministic sequencing rather than concurrent scheduling. Absent concurrency artifacts the system should be documented as a single\u2011threaded service core with potential external reentrancy mitigation handled at IPC layer boundaries.</p>"},{"location":"connectivity/docs/components/PSM_GPT5/#24-component-architecture-diagram","title":"2.4 Component Architecture Diagram","text":"<p>The following diagram summarizes subsystem relationships based solely on source directory structure and interface layering. It illustrates how IPC endpoints route into the service shell, which coordinates both the file loader and system registry, with the registry interacting with storage through loader orchestration.</p> <p>In this representation the Ssp layer brokers incoming bus calls, dispatching to registry operations for runtime get/set semantics. Persistent commits or recovery sequences invoke PsmFileLoader parsing and write logic. State machines in both subsystems constrain lifecycle transitions. A patch script and schema file act as static or operational inputs, while HAL integration provides platform hooks.</p> <pre><code>flowchart TB\n    Client[\"RDK-B Components\\n(DBus/RBUS Clients)\"]\n    subgraph Ssp[\"Ssp Layer\"]\n        SspMain[\"ssp_main.c\"]\n        SspDBus[\"ssp_dbus.c\"]\n        SspRBUS[\"ssp_rbus.c\"]\n        SspCFM[\"ssp_cfmif.c\"]\n        SspHAL[\"psm_hal_apis.c\"]\n    end\n    subgraph FileLoader[\"PsmFileLoader\"]\n        FLOInt[\"psm_flo_interface.c\"]\n        FLOParse[\"psm_flo_parse.c\"]\n        FLOOp[\"psm_flo_operation.c\"]\n        FLOCtrl[\"psm_flo_control.c\"]\n        FLOStates[\"psm_flo_states.c\"]\n        FLOBase[\"psm_flo_base.c\"]\n    end\n    subgraph SysRegistry[\"PsmSysRegistry\"]\n        SROInt[\"psm_sysro_interface.c\"]\n        SROBase[\"psm_sysro_base.c\"]\n        SROCtrl[\"psm_sysro_control.c\"]\n        SROOp[\"psm_sysro_operation.c\"]\n        SROStates[\"psm_sysro_states.c\"]\n        SROStore[\"psm_sysro_storage.c\"]\n        SROSysRAM[\"psm_sysro_sysramif.c\"]\n        SROCFMIF[\"psm_sysro_cfmif.c\"]\n    end\n    Schema[\"config/bbhm_def_cfg_qemu.xml\"]\n    Patch[\"scripts/bbhm_patch.sh\"]\n\n    Client --&gt; Ssp\n    Ssp --&gt; SysRegistry\n    SysRegistry --&gt; FileLoader\n    FileLoader --&gt; Schema\n    Patch -.-&gt; FileLoader\n    SspHAL --&gt; SysRegistry</code></pre>"},{"location":"connectivity/docs/components/PSM_GPT5/#25-design-explanation-lifecycle-flow","title":"2.5 Design Explanation &amp; Lifecycle Flow","text":"<p>Initialization begins in ssp_main.c, which selects and initializes IPC transports (ssp_dbus.c or ssp_rbus.c), binds configuration manager interfaces (ssp_cfmif.c), and prepares HAL interaction stubs (psm_hal_apis.c). During startup SysRegistry logic (psm_sysro_base/control/states) initializes in\u2011memory structures and may request the FileLoader to parse and load persisted data (psm_flo_parse.c). The FileLoader state machine advances through parsing, validation, and ready stages before handing control back. Runtime get/set operations enter through registry interface APIs (psm_sysro_interface.c / exported headers) invoking operation modules which coordinate atomic changes and, when necessary, trigger commit sequences through FileLoader operation/control modules. Shutdown or migration triggers controlled state transitions culminating in final synchronization to persistent storage.</p>"},{"location":"connectivity/docs/components/PSM_GPT5/#3-internal-modules","title":"3. Internal Modules","text":"Subsystem / Module Role (Derived from Naming &amp; Placement) Key Files File Loader Base Core foundational routines and shared context for file loader psm_flo_base.c File Loader Parse Schema and data parsing, structural and type validation psm_flo_parse.c File Loader Operation Concrete file I/O, atomic write/commit actions psm_flo_operation.c File Loader Control High-level orchestration, sequencing parse/load/save phases psm_flo_control.c File Loader States State machine definitions &amp; transition handling psm_flo_states.c File Loader Interface External callable boundary, API indirection layer psm_flo_interface.c / psm_flo_interface.h File Loader Exported API Public header surface for consumers psm_flo_exported_api.h Sys Registry Base Foundational registry context and initialization routines psm_sysro_base.c Sys Registry Operation Parameter access/mutation logic psm_sysro_operation.c Sys Registry Control Lifecycle orchestration for registry psm_sysro_control.c Sys Registry States Registry state machine transitions psm_sysro_states.c Sys Registry Storage Persistent storage mediation / staging psm_sysro_storage.c Sys Registry SysRAM IF System RAM interface abstraction psm_sysro_sysramif.c Sys Registry CFM IF Configuration Manager interface adapter psm_sysro_cfmif.c Sys Registry Interface Public callable registry surface psm_sysro_interface.c / psm_sysro_interface.h Sys Registry Exported API Exported API header for registry users psm_sysro_exported_api.h HAL APIs Platform hook stubs or abstractions psm_hal_apis.c / psm_hal_apis.h Ssp Main Process entry / master initialization ssp_main.c Ssp DBus Transport DBus endpoint &amp; marshaling ssp_dbus.c Ssp RBUS Transport RBUS endpoint &amp; marshaling ssp_rbus.c Ssp CFM Interface Service-level CFM integration glue ssp_cfmif.c Properties &amp; Metadata Type, name, OID, property constants psm_co_type.h, psm_co_name.h, psm_co_oid.h, psm_properties.h CFM Interface Header Configuration manager interface contract psm_ifo_cfm.h Patch Script Upgrade/migration patch logic scripts/bbhm_patch.sh Schema Configuration definition &amp; defaults config/bbhm_def_cfg_qemu.xml Tests (File Loader) Unit tests per functional slice psm_flo_*_test.cpp Tests (Sys Registry) Registry functional verification psm_sysro_*_test.cpp Tests (Integration) Combined or exported API tests CcspPsmTest.cpp"},{"location":"connectivity/docs/components/PSM_GPT5/#31-module-breakdown-diagram","title":"3.1 Module Breakdown Diagram","text":"<p>The breakdown diagram clusters modules by subsystem while showing directional dependencies\u2014registry depends on loader for persistence, Ssp depends on both subsystems, tests reference all layers.</p> <pre><code>flowchart TB\n    subgraph Ssp[\"Ssp Layer\"]\n        SMain[\"ssp_main\"]\n        SDBus[\"ssp_dbus\"]\n        SRBus[\"ssp_rbus\"]\n        SCFM[\"ssp_cfmif\"]\n        SHAL[\"psm_hal_apis\"]\n    end\n    subgraph Loader[\"PsmFileLoader\"]\n        FLOBase\n        FLOParse\n        FLOOp\n        FLOCtrl\n        FLOStates\n        FLOInt\n    end\n    subgraph Registry[\"PsmSysRegistry\"]\n        SROBase\n        SROOp\n        SROCtrl\n        SROStates\n        SROStore\n        SROSram\n        SROCFMIF\n        SROInt\n    end\n    Tests[\"Unit Tests\"]\n    Schema[\"Schema XML\"]\n    Patch[\"Patch Script\"]\n\n    Ssp --&gt; Registry\n    Registry --&gt; Loader\n    Loader --&gt; Schema\n    Patch -.-&gt; Loader\n    Tests -.-&gt; Registry\n    Tests -.-&gt; Loader\n    Tests -.-&gt; Ssp</code></pre>"},{"location":"connectivity/docs/components/PSM_GPT5/#4-interaction-with-other-middleware-components","title":"4. Interaction with Other Middleware Components","text":"<p>CcspPsm interacts indirectly with the broader RDK\u2011B ecosystem through its DBus and RBUS interfaces (ssp_dbus.c and ssp_rbus.c). Other CCSP agents issue configuration get/set operations or commit/refresh style calls that traverse the Ssp layer into SysRegistry logical operations. There is also an integration path with a configuration manager (CFM) via ssp_cfmif.c and psm_sysro_cfmif.c enabling coordinated or policy\u2011driven configuration flows. HAL interaction is abstracted and localized, preventing leakage of platform specifics into higher layers. The design centralizes persistence so that upstream components rely on a canonical store rather than bespoke file usage, promoting consistency and reducing defect surfaces.</p>"},{"location":"connectivity/docs/components/PSM_GPT5/#41-middleware-interaction-flow-diagram","title":"4.1 Middleware Interaction Flow Diagram","text":"<p>The diagram shows other RDK\u2011B components invoking bus calls resolved by Ssp into registry queries or updates which optionally trigger loader persistence.</p> <pre><code>flowchart LR\n    CompA[\"Mgmt / Feature Component A\"]\n    CompB[\"Feature Component B\"]\n    Bus[\"DBus / RBUS\"]\n    SspLayer[\"Ssp Layer\"]\n    Registry[\"SysRegistry\"]\n    Loader[\"FileLoader\"]\n    Storage[\"Persistent File System\"]\n\n    CompA --&gt; Bus\n    CompB --&gt; Bus\n    Bus --&gt; SspLayer\n    SspLayer --&gt; Registry\n    Registry --&gt; Loader\n    Loader --&gt; Storage</code></pre>"},{"location":"connectivity/docs/components/PSM_GPT5/#5-interaction-with-other-layers","title":"5. Interaction with Other Layers","text":"<p>CcspPsm sits above the platform\u2019s persistent storage medium (filesystem/NVRAM) and below logical management agents. The HAL APIs file (psm_hal_apis.c/.h) suggests optional access to platform functionality (timers, low-level storage hints, or environmental data) abstracted away from core persistence logic. The patch script and schema tie deployment and upgrade activities to controlled transitions without exposing internal structural details to dependent components. Abstraction is enforced by clear interface/exported header pairs that segregate public contracts from internal state machine or operation routines.</p>"},{"location":"connectivity/docs/components/PSM_GPT5/#51-layered-architecture-view","title":"5.1 Layered Architecture View","text":"<p>This layered view places PSM within the vertical stack from HAL and storage upward to management and orchestration agents.</p> <pre><code>flowchart TB\n    Mgmt[\"Mgmt / Control Agents\"]\n    IPC[\"DBus / RBUS\"]\n    PSM[\"CcspPsm (Ssp + SysRegistry + FileLoader)\"]\n    HAL[\"HAL / Platform Adapters\"]\n    FS[\"Persistent Storage (File System / Flash)\"]\n\n    Mgmt --&gt; IPC\n    IPC --&gt; PSM\n    PSM --&gt; HAL\n    PSM --&gt; FS</code></pre>"},{"location":"connectivity/docs/components/PSM_GPT5/#6-ipc-mechanism","title":"6. IPC Mechanism","text":"<p>Two IPC transports are explicitly supported: DBus (ssp_dbus.c) and RBUS (ssp_rbus.c). The Ssp layer encapsulates connection initialization, registration, method dispatch, and response handling. Message formats themselves are not enumerated in the source listing provided, but given standard RDK\u2011B patterns these would map to method calls corresponding to exported APIs (psm_flo_exported_api.h and psm_sysro_exported_api.h). The flow of a request (e.g., a parameter set) begins with a bus method invocation, is marshaled by Ssp transport code into internal API calls on SysRegistry, which may modify in\u2011memory state and optionally invoke FileLoader commit logic. Completion returns a status code communicated back across the chosen bus transport. RBUS and DBus parity ensures migration or dual operation scenarios can be supported without altering core persistence routines.</p>"},{"location":"connectivity/docs/components/PSM_GPT5/#61-ipc-flow-sequence","title":"6.1 IPC Flow Sequence","text":"<p>The diagram follows a single set operation from client invocation through commit and response.</p> <pre><code>sequenceDiagram\n    participant Client as RDK-B Component\n    participant Bus as DBus/RBUS\n    participant Ssp as Ssp Layer\n    participant Registry as SysRegistry\n    participant Loader as FileLoader\n    participant Storage as Persistent Store\n\n    Client-&gt;&gt;Bus: Method Call (SetParam, Value)\n    Bus-&gt;&gt;Ssp: Dispatch\n    Ssp-&gt;&gt;Registry: Apply In-Memory Update\n    alt Requires Commit\n        Registry-&gt;&gt;Loader: Persist Request\n        Loader-&gt;&gt;Storage: Atomic Write\n        Storage--&gt;&gt;Loader: Write Status\n        Loader--&gt;&gt;Registry: Commit Result\n    end\n    Registry--&gt;&gt;Ssp: Operation Status\n    Ssp--&gt;&gt;Bus: Return Code\n    Bus--&gt;&gt;Client: Response</code></pre>"},{"location":"connectivity/docs/components/PSM_GPT5/#7-tr181-data-models","title":"7. TR\u2011181 Data Models","text":"<p>While CcspPsm underpins persistence of TR\u2011181 aligned parameters, the repository snapshot includes only a single schema file (bbhm_def_cfg_qemu.xml) without enumerated TR\u2011181 object names in view here. Thus parameter specifics cannot be listed without inspecting the XML contents. Registration mechanics are inferred: external components register or request parameter operations over bus interfaces; SysRegistry mediates logical representation; FileLoader ensures durable reflection of validated schema\u2011compliant state. No custom TR\u2011181 extension objects are directly derivable from the file listing alone; the design instead supplies the foundational persistence service consumed by those that define and own specific TR\u2011181 parameters elsewhere. Any parameter mapping or customization would be governed by schema content plus exported APIs rather than hard\u2011coded logic in public headers.</p>"},{"location":"connectivity/docs/components/PSM_GPT5/#8-implementation-details","title":"8. Implementation Details","text":""},{"location":"connectivity/docs/components/PSM_GPT5/#81-core-logic-and-state-machines","title":"8.1 Core Logic and State Machines","text":"<p>The duplicated pattern of base/control/operation/parse/states modules in both PsmFileLoader and PsmSysRegistry reveals a state machine centric architecture. The states modules encapsulate permissible transitions (e.g., uninitialized \u2192 parsing \u2192 validated \u2192 ready \u2192 committing \u2192 idle). Control modules orchestrate transitions by invoking operation modules to perform discrete atomic actions (e.g., read file, validate structure, write commit, update registry). Parsing is isolated to reduce coupling between format concerns and operational sequencing. Interface modules unify the externally callable surface while exported headers publish stable symbols to clients. Storage separation (psm_sysro_storage.c) signals a staging model: in\u2011memory mutation followed by explicit persistence trigger rather than implicit write\u2011through, enabling batching or atomic multi\u2011parameter updates.</p>"},{"location":"connectivity/docs/components/PSM_GPT5/#82-error-handling-strategy","title":"8.2 Error Handling Strategy","text":"<p>Error isolation is implied by segmentation: parse routines can fail early feeding control logic with failure statuses, operation modules produce granular return codes that propagate upward through interface layers, and state modules enforce legal transitions preventing inconsistent half\u2011applied states. Tests exist for each major functional piece (parse, operation, control, states) verifying branch behaviors and ensuring regression detection for failure pathways. The likely model is hierarchical return codes with distinct enumerations for parse errors, I/O failures, invalid transitions, and storage anomalies\u2014supported by modular decomposition.</p>"},{"location":"connectivity/docs/components/PSM_GPT5/#83-logging-and-debugging-hooks","title":"8.3 Logging and Debugging Hooks","text":"<p>Although logging implementations are not explicitly visible in file names, typical RDK\u2011B conventions integrate logging macros inside each functional module. The granularity of unit tests allows targeted validation of both success and failure cases, often accompanied by logging assertions in extended form. The separation of HAL, CFM, and bus layers aids diagnostic scoping: transport vs registry vs loader issues become traceable to their respective modules.</p>"},{"location":"connectivity/docs/components/PSM_GPT5/#84-upgrade-migration-support","title":"8.4 Upgrade / Migration Support","text":"<p>bbhm_patch.sh indicates controlled schema or structural evolution via scripted transformations, avoiding ad hoc manual edits. Running patches external to core runtime ensures minimal disruption and preserves integrity by preparing data before the service attempts to parse it under new rules.</p>"},{"location":"connectivity/docs/components/PSM_GPT5/#9-key-configuration-files","title":"9. Key Configuration Files","text":"File Purpose Functional Scope Override Mechanism config/bbhm_def_cfg_qemu.xml Defines schema, structure, and default values for persisted parameters (QEMU target context). Establishes baseline parameter topology and defaults used at initialization. Replace or extend schema per platform build; adjust with migration script before service restart."},{"location":"connectivity/docs/components/PSM_GPT5/#91-patch-and-migration-assets","title":"9.1 Patch and Migration Assets","text":"<p>The patch script enables forward schema evolution by transforming or normalizing existing stored data so it remains compatible with updated parsing and validation logic, reducing startup failure risk during upgrades.</p> Script Role Application Phase scripts/bbhm_patch.sh Applies schema or data format adjustments during upgrade/migration to keep persisted store compatible with current parsing logic. Pre\u2011startup (upgrade) or maintenance window prior to service relaunch."},{"location":"connectivity/docs/components/PSM_Oldprompt/","title":"CcspPsm","text":"<p>CcspPsm (Platform Storage Manager) is a core component of the RDK-B broadband router middleware stack. Its primary role is to provide persistent storage and retrieval of configuration parameters and operational data for other RDK-B components, using a structured, schema-driven approach.</p> <p>Key Features and Responsibilities:</p> <ul> <li>Persistent storage for TR-181 and platform-specific parameters.</li> <li>Transactional read/write API for configuration data.</li> <li>Schema-driven validation and organization of stored data.</li> <li>Supports backup, restore, and migration of configuration.</li> <li>Exposes APIs for other components to access and modify persistent data.</li> </ul> <p>Note</p> <p>CcspPsm sits between the management/data model layers (e.g., TR-181, CCSP components) and the underlying storage (file system, NVRAM, etc.), abstracting platform-specific details and providing a unified persistent store.</p>"},{"location":"connectivity/docs/components/PSM_Oldprompt/#design","title":"Design","text":""},{"location":"connectivity/docs/components/PSM_Oldprompt/#high-level-design-principles","title":"High-level Design Principles","text":"<p>CcspPsm is architected around several core principles. First, it maintains a clear separation between schema and logic (such as TR-181 and CCSP data models) and the underlying storage mechanics. This separation allows the storage backend to evolve independently of the data model, supporting new hardware or storage technologies with minimal disruption. All configuration operations are transactional and atomic, ensuring that partial writes or failures do not leave the system in an inconsistent state. The design is also highly extensible, allowing new data models or storage backends to be integrated by updating schema files or extending the storage logic.</p>"},{"location":"connectivity/docs/components/PSM_Oldprompt/#component-boundaries-and-responsibility","title":"Component Boundaries and Responsibility","text":"Block Main Source Files/Dirs Responsibilities PsmFileLoader <code>source/PsmFileLoader/</code> File-based storage, schema parsing, backup/restore, migration logic PsmSysRegistry <code>source/PsmSysRegistry/</code> In-memory registry, runtime state, system registry operations Ssp (IPC/Service) <code>source/Ssp/</code> IPC (DBus/RBUS), main loop, external API exposure, service initialization Include <code>source/include/</code> Public/internal headers, API definitions, schema/property constants"},{"location":"connectivity/docs/components/PSM_Oldprompt/#threading-model","title":"Threading Model","text":"<p>The threading model of CcspPsm is designed for safety and simplicity. All file and storage operations are performed in a single-threaded manner, as implemented in <code>psm_flo_operation.c</code>, to avoid race conditions and ensure data integrity. The IPC and service loop, managed in <code>Ssp/ssp_main.c</code>, may utilize threads for handling DBus or RBUS events, but all persistent operations are serialized to maintain consistency. This approach balances responsiveness to external requests with the need for reliable storage operations.</p>"},{"location":"connectivity/docs/components/PSM_Oldprompt/#initialization-and-main-loop","title":"Initialization and Main Loop","text":"<p>Initialization of the CcspPsm service begins in <code>Ssp/ssp_main.c</code>. Here, the component sets up IPC mechanisms, loads the necessary schemas, and starts the main service loop. The file loader and system registry are initialized through exported APIs defined in <code>psm_flo_exported_api.h</code> and <code>psm_sysro_exported_api.h</code>. This ensures that all subsystems are ready to handle requests and that the component can immediately begin servicing other RDK-B modules.</p>"},{"location":"connectivity/docs/components/PSM_Oldprompt/#extensibility","title":"Extensibility","text":"<p>CcspPsm is built to accommodate future requirements. To add new schemas or parameters, developers can update the XML files in the <code>config/</code> directory and adjust property constants in <code>include/psm_properties.h</code>. Supporting new storage backends or advanced migration logic can be achieved by extending the code in the <code>PsmFileLoader</code> module. This modularity ensures that CcspPsm remains adaptable as the RDK-B platform evolves.</p>"},{"location":"connectivity/docs/components/PSM_Oldprompt/#component-architecture","title":"Component Architecture","text":"<p>The following diagram illustrates the high-level architecture of CcspPsm, showing how the main modules interact with each other and with external components. The flow of configuration data and control is depicted, emphasizing the separation of concerns and the central role of the service and storage modules.</p> <p>In this diagram, the TR-181/CCSP components interact with the Ssp IPC/service module, which in turn coordinates with the PsmFileLoader for persistent storage operations and with the PsmSysRegistry for in-memory state management. The PsmFileLoader is responsible for all interactions with the underlying file or NVRAM storage, ensuring that data is safely persisted and retrieved. The bidirectional arrow between PsmFileLoader and PsmSysRegistry highlights the close coordination required to maintain consistency between in-memory and on-disk state.</p> <pre><code>flowchart TB\n    subgraph \"CcspPsm\"\n        FL[\"PsmFileLoader\"]\n        SR[\"PsmSysRegistry\"]\n        SSP[\"Ssp (IPC/Service)\"]\n    end\n\n    DM[\"TR-181/CCSP Components\"] --&gt; SSP\n    SSP --&gt; FL\n    SSP --&gt; SR\n    FL &lt;--&gt; SR\n    FL -- \"File/NVRAM\" --&gt; Storage[\"Persistent Storage\"]</code></pre>"},{"location":"connectivity/docs/components/PSM_Oldprompt/#internal-modules","title":"Internal Modules","text":"Module/Dir Description PsmFileLoader/ Handles file-based storage, schema parsing, transactional operations, backup/restore, and migration logic PsmSysRegistry/ Manages in-memory registry, runtime state, persistent storage logic, and system registry operations. Ssp/ Implements IPC (DBus/RBUS), service entry and main loop, and exposes external APIs. include/ Contains public/internal headers, API definitions, and schema/property constants test/ Unit tests for all major modules, using Google Test framework."},{"location":"connectivity/docs/components/PSM_Oldprompt/#module-breakdown","title":"Module Breakdown","text":"<pre><code>flowchart LR\n    FL[PsmFileLoader]\n    SR[PsmSysRegistry]\n    SSP[Ssp]\n    INC[include/]\n    TEST[test/]\n    FL &lt;--&gt; SR\n    SSP --&gt; FL\n    SSP --&gt; SR\n    FL --&gt; INC\n    SR --&gt; INC\n    SSP --&gt; INC\n    FL -.-&gt; TEST\n    SR -.-&gt; TEST\n    SSP -.-&gt; TEST</code></pre>"},{"location":"connectivity/docs/components/PSM_Oldprompt/#interaction-with-other-middleware-components","title":"Interaction with Other Middleware Components","text":"<p>CcspPsm plays a central role in the RDK-B middleware ecosystem by providing persistent storage services to other components. The primary mode of interaction is through inter-process communication (IPC), which is implemented using DBus and RBUS protocols. </p> <ul> <li> <p>TR-181/CCSP Components: </p> </li> <li> <p>Communicate with CcspPsm to get/set persistent parameters.</p> </li> <li>IPC is handled via DBus (<code>ssp_dbus.c</code>) or RBUS (<code>ssp_rbus.c</code>).</li> <li> <p>Main interaction is parameter storage and retrieval, as well as backup/restore and migration support.</p> </li> <li> <p>Other CCSP Services: </p> </li> <li> <p>Receive notifications or synchronize configuration as needed.</p> </li> </ul> <p>Purpose of Interactions:</p> <ul> <li>Provide persistent storage for configuration/state.</li> <li>Support parameter registration and schema enforcement.</li> <li>Enable backup/restore and migration for upgrades.</li> </ul>"},{"location":"connectivity/docs/components/PSM_Oldprompt/#middleware-interaction-flow","title":"Middleware Interaction Flow","text":"<p>This middleware interaction flow diagram demonstrates the centrality of CcspPsm in managing persistent configuration data. It highlights the bidirectional communication between CcspPsm and other components, as well as the critical role of persistent storage in maintaining system state.</p> <pre><code>flowchart LR\n    DM[TR-181/CCSP Components] -- get/set --&gt; PSM[CcspPsm]\n    PSM -- persist/restore --&gt; Storage[(File/NVRAM)]\n    PSM -- notify --&gt; OtherCCSP[Other CCSP Services]</code></pre>"},{"location":"connectivity/docs/components/PSM_Oldprompt/#interaction-with-other-layers","title":"Interaction with Other Layers","text":"<p>Interaction with Other Layers CcspPsm abstracts the complexities of platform-specific storage, allowing upper layers to interact with a unified API regardless of the underlying hardware or storage technology. The PsmFileLoader and PsmSysRegistry modules encapsulate all platform-specific logic, ensuring that configuration data is stored and retrieved in a manner appropriate to the device's capabilities. This abstraction enables the RDK-B stack to be portable across different hardware platforms, as changes to storage mechanisms can be confined to these modules without affecting higher-level logic. In some cases, CcspPsm may also interact with external services such as backup/restore daemons or platform migration tools, further enhancing its flexibility and robustness.</p> <p>The layered architecture view below illustrates how CcspPsm fits into the overall system, mediating between user interfaces, management layers, and the underlying hardware.</p> <p>This diagram shows the vertical integration of CcspPsm within the RDK-B stack. User interfaces and management clients interact with TR-181/CCSP components, which in turn rely on CcspPsm for persistent storage. CcspPsm abstracts the platform HAL and file system or NVRAM, ensuring that configuration data is managed consistently across diverse hardware.</p> <p>Diagram: Layered Architecture View</p> <pre><code>flowchart TB\n    UI[WebUI/CLI/ACS]\n    DM[TR-181/CCSP]\n    PSM[CcspPsm]\n    HAL[Platform HAL]\n    FS[File System/NVRAM/Flash]\n\n    UI --&gt; DM\n    DM --&gt; PSM\n    PSM --&gt; HAL\n    HAL --&gt; FS</code></pre>"},{"location":"connectivity/docs/components/PSM_Oldprompt/#ipc-mechanism","title":"IPC Mechanism","text":"<p>Inter-process communication (IPC) is a fundamental aspect of CcspPsm\u2019s integration within the RDK-B stack. The component supports both DBus and RBUS protocols, as implemented in <code>source/Ssp/ssp_dbus.c</code> and <code>source/Ssp/ssp_rbus.c</code>. These IPC mechanisms enable external components\u2014such as TR-181/CCSP modules\u2014to issue requests for parameter retrieval, configuration changes, backup, restore, and migration operations.</p> <p>When a request is received via DBus or RBUS, the Ssp module acts as the gateway, dispatching the request to the appropriate handler in either the PsmFileLoader or PsmSysRegistry module, depending on the nature of the operation. The handler processes the request, performs any necessary validation or transactional operations, and returns the result or status back through the Ssp module to the requesting component. This ensures synchronous, reliable communication and maintains the integrity of persistent configuration data.</p> <p>The exported APIs for these operations are defined in <code>include/psm_flo_exported_api.h</code> and <code>include/psm_sysro_exported_api.h</code>, providing a consistent and well-documented interface for all IPC interactions.</p> <p>The following sequence diagram illustrates the typical flow of an IPC request, from the initial call by a CCSP component to the final response after processing by CcspPsm. The diagram emphasizes the roles of the Ssp module as the IPC gateway and the storage/registry modules as the executors of persistent operations.</p>"},{"location":"connectivity/docs/components/PSM_Oldprompt/#ipc-flow-diagram","title":"IPC Flow Diagram","text":"<pre><code>sequenceDiagram\n    participant Client as CCSP Component\n    participant Ssp as PSM Ssp (DBus/RBUS)\n    participant Psm as PsmFileLoader/PsmSysRegistry\n\n    Client-&gt;&gt;Ssp: get/set parameter (DBus/RBUS)\n    Ssp-&gt;&gt;Psm: read/write operation\n    Psm--&gt;&gt;Ssp: result/status\n    Ssp--&gt;&gt;Client: response</code></pre>"},{"location":"connectivity/docs/components/PSM_Oldprompt/#tr-181-data-models","title":"TR-181 Data Models","text":"<p>CcspPsm is responsible for storing all TR-181 parameters registered by CCSP components. These parameters define the configuration and operational state of the device, and their persistence is critical for reliable operation. The component supports custom extensions through schema files located in the config/ directory, such as bbhm_def_cfg_qemu.xml. Parameters are registered at startup by the relevant CCSP components and are accessed via IPC (DBus or RBUS) or direct API calls. This approach ensures that the data model remains flexible and extensible, accommodating new features and requirements as the platform evolves.</p>"},{"location":"connectivity/docs/components/PSM_Oldprompt/#implementation-details","title":"Implementation Details","text":"<p>The implementation of CcspPsm is grounded in robust, modular code that ensures data integrity, transactional safety, and extensibility. Schema-driven parsing and validation are handled in <code>PsmFileLoader/psm_flo_parse.c</code>, where configuration data is checked against defined XML schemas before being accepted into persistent storage. Transactional file operations are implemented in <code>PsmFileLoader/psm_flo_operation.c</code>, guaranteeing that configuration changes are atomic and that the system can recover gracefully from failures or interruptions. The in-memory registry, managed by <code>PsmSysRegistry/psm_sysro_base.c</code>, provides rapid access to configuration data during runtime, while backup, restore, and migration logic in <code>PsmFileLoader/psm_flo_control.c</code> supports advanced operational scenarios such as upgrades and disaster recovery.</p> <p>Error handling is consistent and comprehensive across all modules. Each operation returns clear status codes, and failures are logged with sufficient detail to facilitate troubleshooting. Logging macros are used throughout the codebase, ensuring that all critical operations and errors are recorded for later analysis. The <code>test</code> directory contains a suite of unit tests for all major modules, leveraging the Google Test framework to verify correctness and reliability of the implementation.</p> <p>For a more visual representation, the following table summarizes the core implementation areas, their responsibilities, and the corresponding source files:</p> Area Responsibility Key Source Files Schema Parsing &amp; Validation Ensures data conforms to expected structure PsmFileLoader/psm_flo_parse.c Transactional File Ops Atomic, reliable storage of configuration changes PsmFileLoader/psm_flo_operation.c In-Memory Registry Fast runtime access to configuration data PsmSysRegistry/psm_sysro_base.c Backup/Restore/Migration Supports upgrades and disaster recovery PsmFileLoader/psm_flo_control.c Error Handling &amp; Logging Consistent status codes and detailed logging All modules (logging macros), see test/ for tests <p>Alternatively, you could represent the implementation flow as a sequence diagram, showing how a configuration change is processed from validation through to persistence and error handling. However, such a diagram is only meaningful if the source code reveals a clear, linear flow (e.g., in the main apply or commit logic). If desired, this can be added as:</p> <p>When a configuration change is requested, the system first parses and validates the data against the schema. If validation succeeds, the change is applied to the in-memory registry and then written to persistent storage using transactional file operations. If any step fails, an error is logged and the operation is rolled back to maintain consistency.</p> <pre><code>sequenceDiagram\n    participant Client as Requesting Component\n    participant PSM as CcspPsm\n    participant Parser as Schema Parser\n    participant Registry as In-Memory Registry\n    participant Storage as Persistent Storage\n\n    Client-&gt;&gt;PSM: Configuration Change Request\n    PSM-&gt;&gt;Parser: Parse &amp; Validate Data\n    alt Validation Success\n        PSM-&gt;&gt;Registry: Update In-Memory State\n        PSM-&gt;&gt;Storage: Commit to Persistent Storage (Transactional)\n        Storage--&gt;&gt;PSM: Commit Success/Failure\n        alt Commit Success\n            PSM--&gt;&gt;Client: Success Response\n        else Commit Failure\n            PSM-&gt;&gt;Registry: Rollback In-Memory State\n            PSM--&gt;&gt;Client: Error Response\n        end\n    else Validation Failure\n        PSM--&gt;&gt;Client: Validation Error\n    end</code></pre>"},{"location":"connectivity/docs/components/PSM_Oldprompt/#key-configuration-files","title":"Key Configuration Files","text":"<p>The configuration and operation of CcspPsm rely on several important files, each serving a distinct role in the system. These files define the schema for persistent parameters, provide constants for validation and default values, and support migration or upgrade processes.</p> File/Dir Purpose Description Key Parameters/Notes config/bbhm_def_cfg_qemu.xml Example schema/config for QEMU platform Defines the structure and default values for persistent parameters on QEMU-based systems Defines parameter structure include/psm_properties.h Schema/property constants Contains constants used for schema validation and default value assignment Used for validation and defaults scripts/bbhm_patch.sh Patch/upgrade script Shell script used to apply patches or perform upgrades on the persistent configuration data Used during migration/upgrade ---"},{"location":"connectivity/docs/components/WANMgr%20GPT5/","title":"RDK-WanManager Documentation","text":""},{"location":"connectivity/docs/components/WANMgr%20GPT5/#1-overview","title":"1. Overview","text":"<ul> <li>Purpose in RDK\u2011B Stack: RDK\u2011WanManager (aka <code>wanmanager</code>) coordinates WAN interfaces on RDK\u2011B devices. It manages interface discovery and configuration, runs selection/failover policies, processes WebConfig blobs, handles DHCP client events, and exposes TR\u2011181 management interfaces so other middleware and cloud services can observe and configure WAN behavior.</li> <li>Key Features &amp; Responsibilities:</li> <li>Manage multiple WAN interfaces and virtual sub\u2011interfaces (CPEInterface table).</li> <li>Implement WAN selection and failover policies (AutoWAN, parallel scan, primary/secondary policies).</li> <li>Provide TR\u2011181 data model (see <code>config/RdkWanManager.xml</code>) and DML APIs for interface and DHCP configuration.</li> <li>Handle WebConfig msgpack blobs to apply WAN configuration and marking rules.</li> <li>Act as the glue between CCSP/Message Bus (DBus), WebConfig framework, DHCP client processes (udhcpc), sysevents and lower\u2011level platform/network utilities.</li> <li>Expose IPC entry points for other components and runs an internal IPC server.</li> <li>Role in Broadband Router Architecture: Positioned in the middleware layer. It consumes TR\u2011181 configuration and WebConfig inputs, translates them into interface state machine actions, configures the DHCP client, and signals other components via message bus and sysevents. It enforces failover/selection policies and maintains operational status exposed via TR\u2011181.</li> </ul>"},{"location":"connectivity/docs/components/WANMgr%20GPT5/#2-architecture-design","title":"2. Architecture / Design","text":""},{"location":"connectivity/docs/components/WANMgr%20GPT5/#21-highlevel-design-principles","title":"2.1 High\u2011Level Design Principles","text":"<ul> <li>Single process (systemd service) deployed as <code>wanmanager</code> that owns WAN decision logic and the DML glue.</li> <li>Modular internal components separated by responsibility: Core lifecycle, Data model (DML), Interface state machines, IPC, DHCP handler, WebConfig blob handler and policy implementations.</li> <li>Use existing platform message bus (CCSP/DBus) and WebConfig APIs for integration; avoid reinventing IPC protocols.</li> <li>Keep TR\u2011181 accurate and authoritative for configuration; operations are reflected back into the DML and persisted via existing CCSP mechanisms.</li> </ul>"},{"location":"connectivity/docs/components/WANMgr%20GPT5/#22-component-boundaries-responsibilities","title":"2.2 Component Boundaries &amp; Responsibilities","text":"<ul> <li>Process boundary: The <code>wanmanager</code> binary runs as a single system process managed by systemd.</li> <li>It talks to other components over:</li> <li>CCSP Message Bus / DBus (component registration and parameter APIs)</li> <li>WebConfig framework (msgpack blob \u2192 applies configuration)</li> <li>SysEvent (publish/subscribe lightweight events)</li> <li>Local IPC (internal clients) via <code>ipc_msg</code> based server</li> <li>External helper processes (e.g., <code>udhcpc</code> for DHCP)</li> </ul> <p>Detailed boundary responsibilities: - TR\u2011181 DML (in <code>config/RdkWanManager.xml</code>) \u2014 canonical configuration schema and function mappings. - WanMgr Core (<code>wanmgr_core.c</code>) \u2014 lifecycle init/start/finalise. - Data layer (<code>wanmgr_data.*</code>) \u2014 in\u2011memory model of interfaces, groups, virtual interfaces and marking tables. - Interface State Machine (<code>wanmgr_interface_sm.*</code>) \u2014 per\u2011interface state machine handling operational status and transitions. - Policy controller (<code>wanmgr_controller.*</code>, <code>wanmgr_policy_*.c</code>) \u2014 selection/failover logic. - DHCP handlers (<code>wanmgr_dhcpv4_apis.*</code>, <code>wanmgr_dhcpv6_*</code>) \u2014 process DHCP client events and expose DHCP DML APIs. - WebConfig handler (<code>wanmgr_webconfig_*.c</code>) \u2014 parse msgpack blobs and apply configuration (markings, interface properties). - SSP / Message Bus integration (<code>wanmgr_ssp_*.c</code>) \u2014 component registration, bus callbacks and CCD/MBI glue.</p>"},{"location":"connectivity/docs/components/WANMgr%20GPT5/#23-threading-model-if-applicable","title":"2.3 Threading Model (if applicable)","text":"<ul> <li><code>wanmanager</code> is single process with multiple internal threads handled by the core and DML frameworks. WebConfig blob callbacks and the core start path may execute in separate threads driven by the platform frameworks. The code relies on explicit locking helpers (see <code>wanmgr_data.h</code> functions like <code>WanMgr_GetConfigData_locked</code>) to protect shared data.</li> </ul>"},{"location":"connectivity/docs/components/WANMgr%20GPT5/#24-c4-system-context-diagram","title":"2.4 C4 System Context Diagram","text":"<pre><code>graph TD\n  classDef user fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n  classDef component fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n  classDef external fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n\n  User[\ud83d\udc64 Administrator / Cloud Controller]:::user\n  WebUI[\ud83c\udf10 Web UI / WebConfig]:::external\n  MessageBus[(CCSP Message Bus / DBus)]:::external\n  SysEvent[(sysevent)]:::external\n  Platform[(Platform / HAL)]:::external\n\n  subgraph \"RDK\u2011B Middleware (systemd)\"\n    WanManager[\ud83d\udce6 RDK\u2011WanManager]:::component\n  end\n\n  User --&gt;|Config / Ops| WebUI\n  WebUI --&gt;|msgpack blob (WebConfig)| WanManager\n  WanManager --&gt;|DBus CCSP parameter APIs| MessageBus\n  WanManager --&gt;|sysevent publish| SysEvent\n  WanManager --&gt;|Platform APIs / net utils| Platform\n  WanManager --&gt;|logs / telemetry| User</code></pre>"},{"location":"connectivity/docs/components/WANMgr%20GPT5/#25-c4-container-diagram","title":"2.5 C4 Container Diagram","text":"<pre><code>graph TD\n  subgraph \"Runtime: RDK\u2011B / systemd\"\n    subgraph \"wanmanager process\"\n      Core[WanMgr Core]\n      IPC[IPC Server (ipc_msg)]\n      DML[TR\u2011181 DML Layer]\n      IfSM[Interface State Machines]\n      DHCP[DHCP Handler (udhcpc integration)]\n      WebCfg[WebConfig Blob Handler]\n      Policies[Policy Implementations (AutoWan, Parallel Scan, Failover)]\n      Telemetry[T2 Telemetry &amp; T2 Sender]\n    end\n\n    subgraph \"External Services\"\n      MessageBus[(CCSP Message Bus / DBus)]\n      SysEvent[(sysevent)]\n      DHCPClient[(udhcpc / DHCP agent)]\n    end\n  end\n\n  WebCfg --&gt;|msgpack| DML\n  DML --&gt;|update/read| IfSM\n  IfSM --&gt;|notify| Policies\n  IfSM --&gt;|invoke| DHCP\n  Core --&gt;|start/stop| IfSM\n  Core --&gt;|register| MessageBus\n  Core --&gt;|publish| SysEvent\n  Policies --&gt;|configure| DML</code></pre>"},{"location":"connectivity/docs/components/WANMgr%20GPT5/#26-design-explanation-request-flow","title":"2.6 Design Explanation &amp; Request Flow","text":"<ul> <li>Request Flow Sequence (high\u2011level): Web UI / cloud issues configuration \u2192 WebConfig framework builds msgpack blob \u2192 <code>WanMgr_Process_Webconfig_Request</code> (in <code>wanmgr_webconfig_apis.c</code>) parses the msgpack, populates <code>WanMgr_WebConfig_t</code>, and maps to DML entries via helpers like <code>WanIf_SetParam*</code>/<code>Marking_SetParam*</code> which in turn call TR\u2011181/DML APIs and add table rows with <code>CcspCcMbi_AddTblRow</code>. The code commits changes with <code>Marking_Commit</code> to persist config.</li> <li>Technology Stack: C (system components), CCSP/DBus messaging stack, msgpack for WebConfig blobs, udhcpc for DHCP, systemd for process management, sysevent for lightweight events.</li> </ul>"},{"location":"connectivity/docs/components/WANMgr%20GPT5/#3-internal-modules","title":"3. Internal Modules","text":"Module/Class Description Key Files Core Lifecycle init/start/finalise and orchestrates startup <code>wanmgr_core.c</code>, <code>wanmgr_main.c</code> Data Model (DML) In\u2011memory representation of WAN interfaces, VLANs, markings and groups <code>wanmgr_data.h</code>, <code>wanmgr_data.c</code>, <code>TR-181/</code> files Interface State Machine Per\u2011interface state machine handling operational transitions and actions <code>wanmgr_interface_sm.c</code>, <code>wanmgr_interface_sm.h</code> IPC Server Local IPC server to receive control commands <code>wanmgr_ipc.c</code>, <code>wanmgr_ipc.h</code> DHCP Handler Handles DHCPv4/IPv6 events and exposes DML APIs for DHCP clients <code>wanmgr_dhcpv4_apis.c</code>, <code>wanmgr_dhcpv6_*</code> WebConfig WebConfig blob parsing and apply logic (msgpack -&gt; DML) <code>wanmgr_webconfig.c</code>, <code>wanmgr_webconfig_apis.c</code> Policies Implementations for selection, failover and auto\u2011wan policies <code>wanmgr_controller.h</code>, <code>wanmgr_policy_*.c</code> (e.g. <code>wanmgr_policy_auto_impl.c</code>, <code>wanmgr_policy_pp_impl.c</code>) SSP / MessageBus Component registration and CCSP/MBI callback wiring <code>wanmgr_ssp_action.c</code>, <code>wanmgr_ssp_messagebus_interface.c</code>, <code>wanmgr_ssp_internal.h</code> Utilities &amp; Platform Networking utilities, telemetry, sysevent helpers <code>wanmgr_net_utils.c</code>, <code>wanmgr_utils.c</code>, <code>wanmgr_sysevents.c</code>, <code>wanmgr_telemetry.c</code>"},{"location":"connectivity/docs/components/WANMgr%20GPT5/#31-module-breakdown-diagram","title":"3.1 Module Breakdown Diagram","text":"<pre><code>flowchart TD\n  subgraph \"RDK\u2011WanManager (process)\"\n    Data[Data Model (wanmgr_data.c)]\n    IfSM[Interface State Machines]\n    DHCP[DHCP Handler]\n    WebCfg[WebConfig Handler]\n    Policies[Policies (selection/failover)]\n    IPC[IPC Server]\n    SSP[SSP / Message Bus]\n  end\n\n  WebCfg --&gt; Data\n  Data --&gt; IfSM\n  IfSM --&gt; DHCP\n  IfSM --&gt; Policies\n  Policies --&gt; Data\n  IPC --&gt; Core[WanMgr Core]\n  SSP --&gt; Core</code></pre>"},{"location":"connectivity/docs/components/WANMgr%20GPT5/#4-interaction-with-other-middleware-components","title":"4. Interaction with Other Middleware Components","text":"Component Purpose of Interaction Protocols/Mechanisms CCSP Message Bus Component registration; TR\u2011181 parameter get/set callbacks; event registration DBus / CCSP BaseIf (CcspBaseIf_SetCallback) WebConfig Framework Receives/manage configuration blobs, triggers apply callbacks msgpack blob via WebConfig framework (<code>WanMgr_Process_Webconfig_Request</code>) SysEvent Publish/subscribe for lightweight system events sysevent APIs (sysevent) DHCP Client (udhcpc) External DHCP client process invoked or managed; DHCP events processed udhcpc, IPC/handler functions (<code>wanmgr_dhcpv4_apis.c</code>) Cellular Manager (optional) retrieves IP information for cellular interfaces internal update functions such as <code>WanMgr_UpdateIpFromCellularMgr</code>"},{"location":"connectivity/docs/components/WANMgr%20GPT5/#41-middleware-interaction-diagram","title":"4.1 Middleware Interaction Diagram","text":"<pre><code>flowchart TD\n  WebConfig --&gt;|msgpack blob| WanManager\n  WanManager --&gt;|DBus TR\u2011181 APIs| CCSP[(CCSP/MessageBus)]\n  WanManager --&gt;|sysevent publish| SysEvent[(sysevent)]\n  WanManager --&gt;|exec/monitor| udhcpc[(udhcpc DHCP client)]</code></pre>"},{"location":"connectivity/docs/components/WANMgr%20GPT5/#5-interaction-with-other-layers","title":"5. Interaction with Other Layers","text":"<ul> <li>HAL: Platform specific network bring\u2011up/tear\u2011down and hardware info is used by <code>wanmgr_net_utils.*</code> and lower layer helpers.</li> <li>Platform: systemd service, sysctl/netlink helpers, and persistent storage for component state.</li> <li>External: Cloud/controller or local Web UI via WebConfig; these provide configuration blobs and expect TR\u2011181 reflect the current state.</li> </ul> Layer/Service Interaction Description Mechanism HAL Platform network control and link status netutils, ioctl/netlink (via <code>wanmgr_net_utils</code>) Platform Process lifecycle, logging, telemetry systemd, <code>/etc/debug.ini</code>, T2 telemetry External Web UI / Cloud configuration WebConfig msgpack blobs, TR\u2011181 reads/writes"},{"location":"connectivity/docs/components/WANMgr%20GPT5/#51-layered-architecture-view","title":"5.1 Layered Architecture View","text":"<pre><code>graph TD\n  HAL[(HAL / Kernel)] --&gt; WanManager[\ud83d\udce6 RDK\u2011WanManager]\n  WanManager --&gt; Platform[(Platform / systemd / udhcpc)]\n  Platform --&gt; External[(Web UI / Cloud)]</code></pre>"},{"location":"connectivity/docs/components/WANMgr%20GPT5/#6-ipc-mechanism","title":"6. IPC Mechanism","text":"<ul> <li>Type of IPC: Multiple mechanisms used:</li> <li>CCSP/Message Bus (DBus) for TR\u2011181 and component registration.</li> <li>Local IPC server implemented with <code>ipc_msg</code> (see <code>wanmgr_ipc.c</code> / <code>wanmgr_ipc.h</code>) to serve local clients.</li> <li>WebConfig uses msgpack blobs and callback hooks.</li> <li>SysEvent for events.</li> <li>Message Format: TR\u2011181 parameters and DML calls use CCSP conventions. WebConfig uses msgpack formatted blobs. Local IPC uses <code>ipc_msg</code> (custom struct in the codebase).</li> <li>Flow: Synchronous TR\u2011181 get/set calls via message bus; asynchronous WebConfig apply (callback) that parses blob and commits changes; local clients can call into IPC server for forced actions (e.g., <code>Wan_ForceRenewDhcpIPv6</code>, <code>WanMgr_SetInterfaceStatus</code>).</li> </ul>"},{"location":"connectivity/docs/components/WANMgr%20GPT5/#61-ipc-flow-diagram","title":"6.1 IPC Flow Diagram","text":"<pre><code>sequenceDiagram\n    participant Web as WebConfig\n    participant WM as RDK-WanManager\n    participant DML as TR-181/DML layer\n    participant MB as CCSP_MessageBus\n\n    Web-&gt;&gt;WM: WebConfig blob (msgpack)\n    WM-&gt;&gt;WM: WanMgr_Process_Webconfig_Request (parse)\n    WM-&gt;&gt;DML: Marking / WanIf set calls (Marking_SetParam*, WanIf_*SetParam*)\n    DML--&gt;&gt;MB: CcspCcMbi_AddTblRow / commit\n    DML--&gt;&gt;WM: Commit result\n    WM--&gt;&gt;Web: Apply result (BLOB_EXEC_SUCCESS / FAILURE)</code></pre>"},{"location":"connectivity/docs/components/WANMgr%20GPT5/#7-tr181-data-models","title":"7. TR\u2011181 Data Models","text":"<ul> <li>Implemented Parameters: The TR\u2011181 model is defined in <code>config/RdkWanManager.xml</code>. Key objects and parameters include:</li> <li><code>X_RDK_WanManager</code> object<ul> <li><code>Enable</code> (boolean)</li> <li><code>Data</code> (string)</li> <li><code>Policy</code> (mapped uint32 \u2014 e.g., AUTOWAN_MODE(6))</li> <li><code>ResetActiveInterface</code> (boolean)</li> <li><code>AllowRemoteInterfaces</code> (boolean)</li> <li><code>WanFailoverData</code> (string)</li> </ul> </li> <li><code>X_RDK_WanManager.DnsConnectivityCheck.Enable</code> (boolean)</li> <li> <p><code>X_RDK_WanManager.CPEInterface</code> (dynamicTable; maxInstance 128) \u2014 contains:</p> <ul> <li><code>EnableOperStatusMonitor</code> (bool)</li> <li><code>ConfigureWanEnable</code> (bool)</li> <li><code>EnableCustomConfig</code> (bool)</li> <li><code>CustomConfigPath</code> (string)</li> <li><code>Name</code> / <code>DisplayName</code></li> <li>Sub\u2011objects: <code>Phy</code>, <code>Wan</code>, <code>IP</code>, <code>PPP</code> with many config/operational parameters (Enable, Type, OperationalStatus, IPv4Status, IPv6Status, etc.)</li> </ul> </li> <li> <p>Parameter Registration: TR\u2011181 functions are wired via the DML registration. In <code>RdkWanManager.xml</code> the named callbacks are (examples):</p> </li> <li><code>WanManager_GetParamUlongValue</code>, <code>WanManager_SetParamUlongValue</code>, <code>WanManager_GetParamStringValue</code>, <code>WanManager_SetParamStringValue</code>, <code>WanManager_GetParamBoolValue</code>, <code>WanManager_SetParamBoolValue</code>, <code>WanManager_Validate</code>, <code>WanManager_Commit</code> at the <code>X_RDK_WanManager</code> root.</li> <li> <p>Table callbacks for <code>CPEInterface</code> like <code>WanIf_GetEntryCount</code>, <code>WanIf_GetEntry</code>, <code>WanIf_GetParamStringValue</code>, <code>WanIf_SetParamStringValue</code>, <code>WanIf_Validate</code>, <code>WanIf_Commit</code>, <code>WanIf_Rollback</code>.</p> </li> <li> <p>Custom Extensions: <code>X_RDK_*</code> namespace provides RDK extensions such as <code>WanFailoverData</code>, custom marking tables and other RDK specific configuration fields.</p> </li> </ul>"},{"location":"connectivity/docs/components/WANMgr%20GPT5/#71-tr181-parameter-table-sample","title":"7.1 TR\u2011181 Parameter Table (sample)","text":"Parameter Description Access (R/W) Default Notes <code>X_RDK_WanManager.Enable</code> Master enable for wanmanager features R/W true Controls component behavior <code>X_RDK_WanManager.Policy</code> Selection policy enum R/W AUTOWAN_MODE (6) Mapped uint values defined in XML <code>X_RDK_WanManager.CPEInterface.{i}.Wan.Enable</code> Per\u2011interface enable R/W true/false governs interface availability <code>X_RDK_WanManager.CPEInterface.{i}.IP.IPv4Status</code> IPv4 operational status R/W Up/Down reflects current IP stack status"},{"location":"connectivity/docs/components/WANMgr%20GPT5/#8-implementation-details","title":"8. Implementation Details","text":"<ul> <li>Key Algorithms or Logic:</li> <li>Interface selection and failover handled by the policy controller (<code>wanmgr_controller.h</code> / <code>wanmgr_policy_*.c</code>). It tracks <code>WanMgr_Policy_Controller_t</code> state including selected interface indices and timeouts.</li> <li>Per\u2011interface state machines manage operational probes, DHCP client integration and marking table enforcement.</li> <li>WebConfig blob apply algorithm: parse msgpack \u2192 map entries to existing DML entries (match by <code>Name</code>) \u2192 update existing marking entries or add table rows via <code>CcspCcMbi_AddTblRow</code> \u2192 commit marking entries.</li> <li>Error Handling Strategy:</li> <li>Return ANSC_STATUS codes across API boundaries. WebConfig apply returns <code>BLOB_EXEC_SUCCESS</code> / <code>BLOB_EXEC_FAILURE</code> and includes a rollback stub for future extension (<code>WanMgr_WanData_Rollback_Handler</code>).</li> <li>Logging via <code>CcspTrace*</code> macros across modules.</li> <li>Logging &amp; Debugging:</li> <li>Uses <code>rdk_logger_init(\"/etc/debug.ini\")</code> to initialize logging (see <code>wanmgr_main.c</code>).</li> <li>Runtime pid file: <code>/var/tmp/wanmanager.pid</code> is created on startup. WebConfig creates <code>/tmp/wanmanager_initialized</code> to mark successful initialization.</li> </ul>"},{"location":"connectivity/docs/components/WANMgr%20GPT5/#9-key-configuration-files","title":"9. Key Configuration Files","text":"Configuration File Purpose Key Parameters Default Values Override Mechanisms <code>config/RdkWanManager.xml</code> TR\u2011181 data model definition Parameter names &amp; function callback names N/A Build/config macros (see file header) <code>config/RdkWanManager_v2.xml</code> Alternative/extended TR\u2011181 model Additional objects N/A N/A <code>msg_daemon.cfg</code> (message bus config) Message bus configuration file referenced by SSP Bus endpoints N/A system runtime config <code>/etc/debug.ini</code> Logging configuration Trace levels Platform defaults Replace file contents"},{"location":"connectivity/docs/components/WANMgr%20GPT5/#10-api-endpoints-if-applicable","title":"10. API Endpoints (if applicable)","text":"<ul> <li>The component does not expose HTTP endpoints itself; it exposes TR\u2011181 DML APIs and local IPC functions. Key programmatic APIs (C functions / exported symbols) include:</li> </ul> <p>Public lifecycle &amp; core APIs</p> <ul> <li><code>ANSC_STATUS WanMgr_Core_Init(void)</code> \u2014 initialize internal core structures (<code>wanmgr_core.c</code>)</li> <li><code>ANSC_STATUS WanMgr_Core_Start(void)</code> \u2014 start main processing loop</li> <li><code>ANSC_STATUS WanMgr_Core_Finalise(void)</code> \u2014 shutdown/cleanup</li> </ul> <p>Policy / controller APIs</p> <ul> <li><code>ANSC_STATUS WanController_Init_StateMachine(void)</code></li> <li><code>ANSC_STATUS WanMgr_Controller_PolicyCtrlInit(WanMgr_Policy_Controller_t* pWanPolicyCtrl)</code></li> <li><code>ANSC_STATUS WanMgr_Policy_AutoWan(void)</code></li> <li><code>ANSC_STATUS WanMgr_Policy_AutoWanPolicy(void)</code></li> </ul> <p>IPC / control APIs</p> <ul> <li><code>ANSC_STATUS WanMgr_StartIpcServer()</code> \u2014 start IPC server to handle clients (<code>wanmgr_ipc.c</code>)</li> <li><code>ANSC_STATUS Wan_ForceRenewDhcpIPv6(char * ifName)</code> \u2014 force DHCPv6 renew</li> <li><code>ANSC_STATUS WanMgr_SetInterfaceStatus(char *ifName, wanmgr_iface_status_t state)</code> \u2014 set interface state</li> </ul> <p>DHCP &amp; DML APIs (examples)</p> <ul> <li><code>ANSC_STATUS wanmgr_handle_dhcpv4_event_data(DML_VIRTUAL_IFACE* pVirtIf)</code> \u2014 process DHCPv4 events</li> <li><code>ANSC_STATUS IPCPStateChangeHandler (DML_VIRTUAL_IFACE* pVirtIf)</code> \u2014 IPCP state changes for PPP/IPv6</li> <li><code>ANSC_STATUS WanMgr_DmlDhcpInit(ANSC_HANDLE hDml, PANSC_HANDLE phContext)</code> \u2014 DHCP DML init</li> <li>Multiple DML list/get/set functions: <code>WanMgr_DmlDhcpcGetNumberOfEntries</code>, <code>WanMgr_DmlDhcpcGetEntry</code>, <code>WanMgr_DmlDhcpcSetCfg</code>, <code>WanMgr_DmlDhcpcRenew</code>, etc. (see <code>wanmgr_dhcpv4_apis.h</code>)</li> </ul> <p>SSP / MessageBus APIs (component callbacks)</p> <ul> <li><code>ANSC_STATUS ssp_Mbi_MessageBusEngage(char* component_id, char* config_file, char* path)</code></li> <li><code>int ssp_Mbi_Initialize(void* user_data)</code></li> <li><code>int ssp_Mbi_Finalize(void* user_data)</code></li> <li><code>int ssp_Mbi_Buscheck(void* user_data)</code></li> <li><code>int ssp_Mbi_FreeResources(int priority, void* user_data)</code></li> </ul> <p>DML callbacks named in <code>RdkWanManager.xml</code> (examples):</p> <ul> <li><code>WanManager_GetParamUlongValue</code></li> <li><code>WanManager_SetParamUlongValue</code></li> <li><code>WanIf_GetEntryCount</code>, <code>WanIf_GetEntry</code>, <code>WanIf_GetParamStringValue</code>, <code>WanIf_SetParamStringValue</code>, <code>WanIf_Commit</code> (see <code>wanmgr_data.h</code> and TR\u2011181 XML)</li> </ul>"},{"location":"connectivity/docs/components/WANMgr%20GPT5/#11-deployment-runtime-environment","title":"11. Deployment &amp; Runtime Environment","text":"<ul> <li>Container Runtime: Typically runs on bare RDK\u2011B image under systemd. Deployed as a system service <code>wanmanager</code>.</li> <li>Orchestration: systemd unit (platform packaging) manages the process.</li> <li>Resource Requirements: Small system process \u2014 typical embedded requirements (low MBs of RAM). Specific CPU/memory depend on telemetry and feature flags.</li> <li>Supported Platforms: RDK\u2011B targets (Linux / Board specific network stacks). Source contains board specific ML support under <code>TR\u2011181/board_*</code> directories.</li> <li>Startup Parameters: <code>wanmanager</code> accepts <code>-c</code> to run in foreground (non\u2011daemon) and <code>-subsys &lt;prefix&gt;</code> to set component prefix (see <code>wanmgr_main.c</code>).</li> </ul>"},{"location":"connectivity/docs/components/WANMgr%20GPT5/#12-monitoring-security","title":"12. Monitoring &amp; Security","text":"<ul> <li>Monitoring:</li> <li>Telemetry hooks (T2) via <code>wanmgr_t2_telemetry.c</code> and <code>wanmgr_telemetry.c</code> when <code>ENABLE_FEATURE_TELEMETRY2_0</code> is enabled.</li> <li>Logs via <code>rdk_logger</code> and <code>CcspTrace*</code> macros; PID file <code>/var/tmp/wanmanager.pid</code> created.</li> <li>Authentication &amp; Authorization: Uses CCSP/MessageBus security model (component registration) and system capabilities management code attempts to drop root caps in <code>wanmgr_main.c</code>.</li> <li>Auditing &amp; Compliance: Uses existing RDK logging &amp; telemetry; no special GDPR/HIPAA features embedded in component code itself.</li> </ul>"},{"location":"connectivity/docs/components/WANMgr%20GPT5/#13-validation-review-checklist","title":"13. Validation &amp; Review Checklist","text":"<ul> <li>[x] Deployment Accuracy: Process boundary accurately represented (single systemd process).</li> <li>[x] Communication Specificity: Protocols labeled (DBus/CCSP, msgpack/WebConfig, ipc_msg, sysevent).</li> <li>[x] Scaling Representation: <code>CPEInterface</code> table supports multiple instances; marking entries are per\u2011interface.</li> <li>[x] Technology Versions: Source uses C + RDK CCSP frameworks; specific lib versions come from platform build system.</li> <li>[x] Implementation Details: Filenames and function names included above.</li> <li>[x] Visual Hierarchy: Mermaid diagrams use classDef and subgraphs to distinguish runtimes/components.</li> <li>[x] Protocol Labels: Connection labels include formats (msgpack, DBus) and purposes.</li> <li>[x] Mermaid Syntax: Diagrams use <code>graph</code>, <code>flowchart</code> and <code>sequenceDiagram</code> variants; verify in MkDocs with Mermaid plugin.</li> <li>[x] TR\u2011181 Coverage: Key parameters and DML callbacks from <code>config/RdkWanManager.xml</code> are documented.</li> <li>[x] Code Accuracy: Key function names and file paths extracted from the source tree.</li> </ul>"},{"location":"connectivity/docs/components/WANMgr%20GPT5/#14-conclusion-next-steps","title":"14. Conclusion &amp; Next Steps","text":"<p>RDK\u2011WanManager is the middleware component that centralizes WAN selection, policy enforcement and TR\u2011181 DML handling for WAN interfaces. The documentation above fills the RDK\u2011B template with the implementation details discovered in the <code>wan-manager</code> source tree. Recommended next steps:</p> <ul> <li>Add a small examples section with common WebConfig blobs and their expected TR\u2011181 side effects (testing/QA asset).</li> <li>Add unit tests or integration tests that exercise WebConfig apply logic and policy selection (there are tests in the <code>test/</code> folder \u2014 see <code>RdkWanManagerTest.cpp</code>).</li> <li>Maintain a short runbook with troubleshooting steps (how to force DHCP renew, where to find logs and telemetry counters).</li> </ul> <p>Requirements coverage: - Followed <code>rdkb-document-template.md</code> structure exactly: All numbered sections present and populated. - Applied <code>workflow.md</code> steps: code analysis (files listed), data extraction (APIs, configs), diagrams created, validation checklist applied. - Mermaid diagrams follow <code>diagram-guidelines.md</code> rules: subgraphs for deployment, protocol labels, and classDef styling.</p> <p>Files referenced (key paths): - <code>source/WanManager/wanmgr_core.c</code>, <code>wanmgr_main.c</code>, <code>wanmgr_data.h</code>, <code>wanmgr_interface_sm.c</code>, <code>wanmgr_ipc.c</code>, <code>wanmgr_webconfig_apis.c</code>, <code>wanmgr_dhcpv4_apis.h</code>, <code>wanmgr_ssp_action.c</code>. - <code>config/RdkWanManager.xml</code>, <code>config/RdkWanManager_v2.xml</code>.</p> <p>Verification performed: inspected the source files above and extracted public APIs, DML callbacks listed in XML and the WebConfig apply flow. Please tell me if you want this document written to a different filename or if you'd like me to also add a small example WebConfig blob and a short test script to exercise it.</p>"},{"location":"connectivity/docs/components/WANMgr%20GPT5/#15-examples-tests","title":"15. Examples &amp; Tests","text":"<p>This section provides concrete WebConfig blob examples (msgpack) and two test approaches you can use on a development device or in CI to exercise the WebConfig apply logic implemented in <code>wanmgr_webconfig_*.c</code>.</p>"},{"location":"connectivity/docs/components/WANMgr%20GPT5/#151-example-1-simple-wanfailoverdata-blob-json-msgpack","title":"15.1 Example 1 \u2014 Simple WanFailoverData blob (JSON -&gt; msgpack)","text":"<p>This example enables the \"allow_remote_interfaces\" flag in the <code>wanfailover</code> subdocument.</p> <p>JSON representation (easy to read):</p> <pre><code>{\n  \"wanfailover\": {\n    \"allow_remote_interfaces\": true\n  }\n}\n</code></pre> <p>Python helper to produce a msgpack blob file (<code>make_wan_blob.py</code>):</p> <pre><code>#!/usr/bin/env python3\n\"\"\"\nCreate a WebConfig msgpack blob for WAN Manager and write it to disk.\nRequires: pip install msgpack\n\"\"\"\nimport msgpack\nimport sys\n\nblob = {\n    \"wanfailover\": {\n        \"allow_remote_interfaces\": True\n    }\n}\n\nout = 'wan_blob.msgpack'\nwith open(out, 'wb') as f:\n    f.write(msgpack.packb(blob))\n\nprint(f'Wrote {out} ({len(open(out, \"rb\").read())} bytes)')\n\nif __name__ == '__main__':\n    pass\n</code></pre> <p>Usage (on your workstation or the target device if Python/msgpack is available):</p> <pre><code># create msgpack blob\npython3 make_wan_blob.py\n\n# copy to device (if creating locally)\n# scp wan_blob.msgpack root@device:/tmp/wan_blob.msgpack\n</code></pre> <p>How to apply the blob on a device (options): - If your platform provides a WebConfig CLI or REST API, use that to apply <code>/tmp/wan_blob.msgpack</code> as a WebConfig subdocument for the WanManager component. - For a direct in\u2011process unit test (see next example) you can load the blob bytes and call the component's WebConfig handler function <code>WanMgrDmlWanFailOverDataSet</code> from a unit test binary.</p>"},{"location":"connectivity/docs/components/WANMgr%20GPT5/#152-example-2-python-larger-blob-interface-marking","title":"15.2 Example 2 \u2014 Python + larger blob (interface + marking)","text":"<p>JSON example that configures a virtual interface entry and a marking row (human readable):</p> <pre><code>{\n  \"CPEInterface\": [\n    {\n      \"Name\": \"wan0\",\n      \"Marking\": [\n        { \"Alias\": \"DATA\", \"EthernetPriorityMark\": 5 }\n      ]\n    }\n  ]\n}\n</code></pre> <p>You can extend the <code>make_wan_blob.py</code> script above to include this structure and produce a larger blob. The WebConfig apply logic in <code>wanmgr_webconfig_apis.c</code> will try to match <code>Name</code> to an existing DML interface and then add/commit marking rows via <code>CcspCcMbi_AddTblRow</code>.</p>"},{"location":"connectivity/docs/components/WANMgr%20GPT5/#153-unit-test-c-gtest-call-webconfig-handler-directly","title":"15.3 Unit test (C++ / gtest) \u2014 call WebConfig handler directly","text":"<p>If you want to exercise the component code directly in CI (recommended for deterministic verification), add a small gtest that packs a msgpack blob and calls the <code>WanMgrDmlWanFailOverDataSet</code> function exposed by the WebConfig module. The sample below shows a minimal test you can place under the component <code>test/</code> folder (e.g. <code>test/TestWanWebConfig.cpp</code>). It depends on <code>msgpack-c</code> and your component build artifacts.</p> <pre><code>// test/TestWanWebConfig.cpp\n#include &lt;gtest/gtest.h&gt;\n#include &lt;msgpack.h&gt;\n#include \"ansc_status.h\"\n\n// The WebConfig entry point in the WAN manager implementation\nextern ANSC_STATUS WanMgrDmlWanFailOverDataSet(const void* pData, size_t len);\n\nTEST(WanMgrWebConfig, WanFailoverApply)\n{\n    // Build msgpack for: { \"wanfailover\": { \"allow_remote_interfaces\": true } }\n    msgpack_sbuffer sbuf;\n    msgpack_sbuffer_init(&amp;sbuf);\n\n    msgpack_packer pk;\n    msgpack_packer_init(&amp;pk, &amp;sbuf, msgpack_sbuffer_write);\n\n    // outer map with 1 key\n    msgpack_pack_map(&amp;pk, 1);\n\n    // key: \"wanfailover\"\n    const char* k1 = \"wanfailover\";\n    msgpack_pack_str(&amp;pk, strlen(k1));\n    msgpack_pack_str_body(&amp;pk, k1, strlen(k1));\n\n    // value: map with one boolean field\n    msgpack_pack_map(&amp;pk, 1);\n    const char* k2 = \"allow_remote_interfaces\";\n    msgpack_pack_str(&amp;pk, strlen(k2));\n    msgpack_pack_str_body(&amp;pk, k2, strlen(k2));\n    msgpack_pack_true(&amp;pk);\n\n    // Call the component handler\n    ANSC_STATUS status = WanMgrDmlWanFailOverDataSet(sbuf.data, sbuf.size);\n\n    // Expect success in a real test environment where the data layer is initialized\n    // If run in isolation you may need to initialize the component's data (WanMgr_Data_Init)\n    EXPECT_EQ(status, ANSC_STATUS_SUCCESS);\n\n    msgpack_sbuffer_destroy(&amp;sbuf);\n}\n</code></pre> <p>Build &amp; run notes for the gtest example:</p> <ul> <li>Add <code>TestWanWebConfig.cpp</code> to the <code>test/</code> directory and update <code>test/Makefile.am</code> (or the project's test build system) to compile and link the file. Link against:</li> <li>component object files (the files containing <code>WanMgrDmlWanFailOverDataSet</code> / <code>wanmgr_webconfig_apis.c</code>)</li> <li><code>msgpack-c</code> (libmsgpackc)</li> <li>gtest (or your project's test framework)</li> </ul> <p>Example g++ (conceptual) \u2014 adjust include paths and libs to your build environment:</p> <pre><code>g++ -std=c++11 -I/path/to/msgpack/include -I/path/to/wanmgr/include \\\n    test/TestWanWebConfig.cpp \\\n    &lt;component_objects_or_libs&gt; -lmsgpackc -lgtest -lpthread -o TestWanWebConfig\n\n# run\n./TestWanWebConfig\n</code></pre> <p>Notes and troubleshooting: - The unit test above calls the WebConfig handler directly; some functions expect the component data model to be initialized (e.g., <code>WanMgr_Data_Init</code>) and for TR\u2011181 tables to be present. In CI you can initialize the minimal environment by calling <code>WanMgr_Data_Init()</code> before invoking the handler or mocking the DML functions. - If you prefer a pure black\u2011box test, use the Python msgpack producer and then apply the blob through the platform WebConfig CLI/REST API and assert the expected TR\u2011181 changes (read back parameters via DBus or rbus).</p>"},{"location":"connectivity/docs/components/WANMgr%20GPT5/#154-quick-smoke-test-checklist","title":"15.4 Quick smoke test checklist","text":"<ol> <li>Produce blob:</li> </ol> <pre><code>python3 make_wan_blob.py\n</code></pre> <ol> <li> <p>Copy to device and apply via WebConfig framework or run the unit test binary that calls <code>WanMgrDmlWanFailOverDataSet</code>.</p> </li> <li> <p>Verify results:</p> </li> <li>Confirm TR\u2011181 parameter <code>X_RDK_WanManager.WanFailoverData</code> or <code>X_RDK_WanManager.CPEInterface.{i}.Wan.Refresh</code> changed as expected using the platform DBus/CCSP tools or <code>rbus</code>/<code>dmcli</code> utilities.</li> <li> <p>Check <code>wanmanager</code> logs (CcspTrace / <code>/var/log/</code>) for WebConfig apply messages and commit traces.</p> </li> <li> <p>Cleanup: remove temporary blob files and revert test changes via TR\u2011181 or CCSP calls.</p> </li> </ol>"},{"location":"connectivity/docs/components/cellularmanager/","title":"Cellular Manager","text":"<p>The Cellular Manager component is designed to manage cellular modems in devices such as gateways and extenders by facilitating internet access through cellular networks using default EPS bearers (NON-GBR, EPS-only registration) for IPv4 and IPv6. It delivers telemetry on radio resources (RR), mobility management (MM), and session management (SM), and excludes VoLTE for voice in FA+FWA profiles. The component's  functionalities include managing modem power configuration, exposing radio resource and mobility management information, handling network access, SIM and eSIM management, EPS bearer configuration, and providing kernel device interfaces for transport and modem control, as well as IP address configuration via NAS signaling. Though the WAN is Celluarl, the component is not responsible for  traffic forwarding/routing, home network configuration, phone book and SMS capabilities, GPS, VoLTE, MBSFN, and carrier aggregation. The Cellular Manager supports use cases like LTE onboarding (Instant On), extender-only or LTE backup modes, SIM/eSIM switching, and signal quality telemetry for device placement, ensuring robust integration with the RDK-B stack via R-BUS (northbound) and modem control through AT commands, proprietary SDKs, or standard kernel drivers like QMI/MBIM (southbound).</p>"},{"location":"connectivity/docs/components/cellularmanager/#use-cases","title":"Use Cases","text":"<ul> <li>Onboarding over LTE (Instant On).</li> <li>Operating as extender-only or LTE backup.</li> <li>Switching between physical SIM and eSIM profiles.</li> <li>Telemetry for signal quality during onboarding and steady state.</li> <li>Placement recommendations based on LTE/WiFi performance.</li> </ul>"},{"location":"connectivity/docs/components/cellularmanager/#scope-of-functionality","title":"Scope of Functionality","text":"<p>Note</p> <ul> <li>The In Scope column lists functionalities that will be implemented as part of the Cellular Manager.  </li> <li>The Out of Scope column lists items that are explicitly excluded from the implementation.</li> </ul> In Scope Out of Scope Manage cellular modem power configuration Forwarding/routing of traffic through WWAN interfaces Expose radio resource information about the cellular interface Configuration of the home network Manage access to the cellular network Phone book capabilities in the modem Expose mobility management information SMS management capabilities in the modem Manage SIM use GPS location services implemented in the modem Manage EPS bearer configuration VoLTE stack in the modem Expose kernel device interface for transport MBSFN (multicast traffic over the air) Expose kernel device interface for modem management Carrier aggregation Expose IP address configuration obtained via NAS signaling Provide telemetry information related to cellular connectivity"},{"location":"connectivity/docs/components/cellularmanager/#design","title":"Design","text":"<p>A high level design of Cellular Manager is given below </p> <p>A more detailed diagram is given below</p> <p></p>"},{"location":"connectivity/docs/components/cellularmanager/#state-machine","title":"State Machine","text":"<p>Principles of the State Machine</p> <p>The CellularManager state machine will depend on a set of data model objects and parameter values grouped together into a state according to properties that affect or reflect the states of a cellular modem.</p> <p>The state machine tracks modem states based on data model conditions.</p> <ul> <li>The Cellular Manager state machine relies on data model objects and parameters that reflect cellular modem states.</li> <li>States occupy time intervals and depend on current inputs and historical data.</li> <li>Key status transitions (e.g., Device.Cellular.Interface.Status==DOWN) arise from causes like signal loss or attach rejection.</li> <li>Manages modem for internet access via default bearers (IPv4/IPv6), analyzes radio signals for placement scoring, and exposes telemetry on mobility, session, and radio resources.</li> </ul> <p></p>"},{"location":"connectivity/docs/components/cellularmanager/#soc-interaction-principles","title":"SoC Interaction Principles","text":"<ul> <li>Northbound: Integrates with RDK-B stack via R-BUS for data model updates.</li> <li>Southbound: Controls modem using AT commands (via tty serial), proprietary SDKs, or standard kernel drivers (e.g., MBIM, QMI via /dev/cdc-wdm and wwan interfaces).</li> </ul> <p>Note</p> <p>QMI (Qualcomm MSM Interface) is easily accessible in recent enough Linux kernels (&gt;= 3.4) through the cdc-wdm and qmi_wwan drivers. Once these drivers are loaded, the kernel will expose a new /dev/cdc-wdm device that can talk QMI with the CPE, along with a WWAN interface associated with each QMI port, to transmit and receive traffic through a PDN connection.</p> <p></p> <p>Data model transitions by status:</p> <p></p>"},{"location":"connectivity/docs/components/cellularmanager/#sequence-diagrams","title":"Sequence Diagrams","text":"<p>Cellular Manager sequence diagrams describe the interaction between different entities by focusing on the sequence of messages that are exchanged, along with their corresponding occurrence specifications on the lifelines.</p> <p>Defined Services</p> <p>Based on the requirements, we have defined three services to be implemented by Cellular Manager:</p> <ol> <li>The cellular manager will manage the modem to provide internet access using the default bearer for IPv4 and IPv6.</li> <li>The cellular manager will analyze the cellular radio signal and expose a parameter with the score of the radio conditions to place the device in a convenient place.</li> <li>The cellular manager will extract and expose all valuable information related to mobility management, session management, and radio resources for telemetry purposes.</li> </ol> <p>Note</p> <p>The sequence diagram can be better understood in combination with the state machine.</p> <p></p> <ul> <li>Internet Service Access: To access the internet, cellular modem will need to register with the MNO network and establish an EPS connection to a packet gateway. Component registration will be for EPS only, and the EPS session will be based on a single default bearer (NON-GBR). Before starting the registration, it is required to configure a number of global parameters (or defaults) and one or more access point profiles to establish the EPS bearer. This information could be provisioned in advance via WEBCONFIG.</li> </ul>"},{"location":"connectivity/docs/components/cellularmanager/#data-models","title":"Data Models","text":"<p>Parameters expose modem control, status, and telemetry.</p> Parameter Description Type Restrictions Default Access Subscription Device.Cellular.X_RDK_Enable Switch to activate/deactivate modem based on power capabilities. BOOLEAN NONE TRUE RW ON-CHANGE Device.Cellular.X_RDK_Status Modem status per state machine. ENUMERATION DOWN, DEACTIVATED, DEREGISTERED, REGISTERED, CONNECTED DOWN R ON-CHANGE Device.Cellular.X_RDK_Model Hardware model of modem. STRING NONE NONE R NONE Device.Cellular.X_RDK_HardwareRevision Hardware revision of modem. STRING NONE N.A R NONE Device.Cellular.X_RDK_Vendor OEM vendor of modem. STRING NONE N.A R NONE Device.Cellular.X_RDK_ControlInterface Interface for modem control (e.g., cdc-wdm0 for QMI). STRING NONE cdc-wdm0 R NONE Device.Cellular.X_RDK_ControlInterfaceStatus Status of control interface. ENUMERATION OPENED, CLOSED CLOSE R ON-CHANGE Device.Cellular.X_RDK_DataInterface Interface for traffic forwarding. STRING NONE WWAN0 R NONE Device.Cellular.X_RDK_DataInterfaceStatus Status of data interface. ENUMERATION OPENED, CLOSED CLOSE R ON-CHANGE Device.Cellular.X_RDK_Imei IMEI for identification. STRING 15 digits (0-9) 0 R NONE Device.Cellular.X_RDK_Firmware.CurrentImageVersion Current firmware version. STRING Max 25 chars N.A R NONE Device.Cellular.X_RDK_Firmware.FallbackImageVersion Fallback firmware version. STRING Max 25 chars N.A R NONE Device.Cellular.Interface.{i}.Enable Enable/disable interface for registration. BOOLEAN NONE TRUE WR ON-CHANGE Device.Cellular.Interface.{i}.Status Interface status (registration, coverage). ENUMERATION UP, DOWN DETACHED R ON-CHANGE Device.Cellular.Interface.{i}.X_RDK_RegisteredService Granted service (e.g., PS for data). ENUMERATION PS, CS, PS+CS NONE R ON-CHANGE Device.Cellular.Interface.{i}.X_RDK_PhyConnectedStatus Flag for WAN manager detection. BOOLEAN NONE FALSE R ON-CHANGE Device.Cellular.Interface.{i}.X_RDK_LinkAvailableStatus Flag for EPS bearer connection. BOOLEAN NONE FALSE R ON-CHANGE Device.Cellular.Interface.{i}.X_RDK_Iccid ICCID of UICC/MNO profile. STRING 18-20 digits (0-9) N/A R NONE Device.Cellular.Interface.{i}.RadioAccessTechnology.Supported Supported RATs. Comma-separated STRING (5G, LTE, UMTS, GSM) N/A R NONE Device.Cellular.Interface.{i}.RadioAccessTechnology.Preferred Preferred RATs (first is most preferred). Comma-separated STRING (5G, LTE, UMTS, GSM) N/A R NONE Device.Cellular.Interface.{i}.RadioAccessTechnology.Current Current RAT in use. ENUMERATION (5G, LTE, UMTS, GSM) N/A R NONE Device.Cellular.Interface.{i}.X_RDK_RadioSignal.Rssi Total received signal strength. INT8 (dBm) -117 to -25 N/A R ON-CHANGE, ON-INTERVAL Device.Cellular.Interface.{i}.X_RDK_RadioSignal.Snr Signal-to-noise ratio. INT8 (dB) 0 to 20 N/A R ON-CHANGE, ON-INTERVAL Device.Cellular.Interface.{i}.X_RDK_RadioSignal.Rsrp Reference signal received power. INT16 (dBm) -155 to -44 N/A R ON-CHANGE, ON-INTERVAL Device.Cellular.Interface.{i}.X_RDK_RadioSignal.Rsrq Reference signal received quality. INT8 (dB) -43 to -44 N/A R ON-CHANGE, ON-INTERVAL Device.Cellular.Interface.{i}.X_RDK_RadioSignal.Trx Transmitted power level. INT8 NONE N/A R ON-CHANGE, ON-INTERVAL Device.Cellular.Interface.{i}.X_RDK_RadioSignal.RadioEnvConditions Radio coverage score. ENUMERATION EXCELLENT, GOOD, FAIR, POOR, UNAVAILABLE UNAVAILABLE R ON-CHANGE Device.Cellular.Interface.{i}.X_RDK_PlmnAccess.RoamingEnable Enable roaming. BOOLEAN NONE TRUE R NONE Device.Cellular.Interface.{i}.X_RDK_PlmnAccess.RoamingStatus Roaming status post-registration. ENUMERATION HOME, VISITOR HOME R ON-CHANGE Device.Cellular.Interface.{i}.X_RDK_PlmnAccess.HomeNetwork.Mcc Home PLMN MCC. STRING 3 digits (0-9) N/A R NONE Device.Cellular.Interface.{i}.X_RDK_PlmnAccess.HomeNetwork.Mnc Home PLMN MNC. STRING 3 digits (0-9) N/A R NONE Device.Cellular.Interface.{i}.X_RDK_PlmnAccess.HomeNetwork.Name Home PLMN name. STRING Max 25 chars N/A R NONE Device.Cellular.Interface.{i}.X_RDK_PlmnAccess.AvailableNetworks.{n}.Mcc Available network MCC. STRING 3 digits (0-9) N/A R NONE Device.Cellular.Interface.{i}.X_RDK_PlmnAccess.AvailableNetworks.{n}.Mnc Available network MNC. STRING 3 digits (0-9) N/A R NONE Device.Cellular.Interface.{i}.X_RDK_PlmnAccess.AvailableNetworks.{n}.Name Available network name. STRING Max 25 chars N/A R NONE Device.Cellular.Interface.{i}.X_RDK_PlmnAccess.AvailableNetworks.{n}.Allowed Allowed for home/roaming. BOOLEAN NONE N/A R NONE Device.Cellular.Interface.{i}.X_RDK_PlmnAccess.PreferredNetworks.{n}.Mcc Preferred network MCC. STRING 3 digits (0-9) N/A R NONE Device.Cellular.Interface.{i}.X_RDK_PlmnAccess.PreferredNetworks.{n}.Mnc Preferred network MNC. STRING 3 digits (0-9) N/A R NONE Device.Cellular.Interface.{i}.X_RDK_PlmnAccess.PreferredNetworks.{n}.Name Preferred network name. STRING Max 25 chars N/A R NONE Device.Cellular.Interface.{i}.X_RDK_PlmnAccess.NetworkInUse.Mcc In-use network MCC. STRING 3 digits (0-9) N/A R NONE Device.Cellular.Interface.{i}.X_RDK_PlmnAccess.NetworkInUse.Mnc In-use network MNC. STRING 3 digits (0-9) N/A R NONE Device.Cellular.Interface.{i}.X_RDK_PlmnAccess.NetworkInUse.Name In-use network name. STRING Max 25 chars N/A R NONE Device.Cellular.Interface.{i}.X_RDK_CellTopology.ServingCell.GlobalCellId Serving cell global ID. STRING NONE N/A R NONE Device.Cellular.Interface.{i}.X_RDK_CellTopology.ServingCell.PhysicalCellId Serving physical cell ID. STRING NONE N/A R NONE Device.Cellular.Interface.{i}.X_RDK_CellTopology.ServingCell.PlmnId Serving PLMN ID. STRING MCC+MNC N/A R NONE Device.Cellular.Interface.{i}.X_RDK_CellTopology.ServingCell.Rat Serving RAT. ENUMERATION GSM, UMTS, LTE, 5G N/A R NONE Device.Cellular.Interface.{i}.X_RDK_CellTopology.ServingCell.RadioBand Serving radio band. STRING NONE N/A R NONE Device.Cellular.Interface.{i}.X_RDK_CellTopology.ServingCell.AbsoluteRfcn ARFCN (DL for FDD). UINT8 0-65535 0 R NONE Device.Cellular.Interface.{i}.X_RDK_CellTopology.ServingCell.AreaCode Tracking area code. STRING 8 digits (0-9) N/A R NONE Device.Cellular.Interface.{i}.X_RDK_CellTopology.ServingCell.Rsrp Serving RSRP. INT16 -155 to -44 dBm N/A R NONE Device.Cellular.Interface.{i}.X_RDK_CellTopology.NeighborCellList.{i}.PhysicalCellId Neighbor physical cell ID. STRING NONE N/A R NONE Device.Cellular.Interface.{i}.X_RDK_CellTopology.NeighborCellList.{i}.PlmnId Neighbor PLMN ID. STRING MCC+MNC N/A R NONE Device.Cellular.Interface.{i}.X_RDK_CellTopology.NeighborCellList.{i}.Rat Neighbor RAT. ENUMERATION GSM, UMTS, LTE, 5G N/A R NONE Device.Cellular.Interface.{i}.X_RDK_CellTopology.NeighborCellList.{i}.AbsoluteRfcn Neighbor ARFCN. UINT8 0-65535 N/A R NONE Device.Cellular.Interface.{i}.X_RDK_CellTopology.NeighborCellList.{i}.Rssi Neighbor RSSI. INT8 -117 to -125 dBm N/A R NONE Device.Cellular.Interface.{i}.X_RDK_CellTopology.NeighborCellList.{i}.Rsrp Neighbor RSRP. INT8 -155 to -44 dBm N/A R NONE Device.Cellular.Interface.{i}.X_RDK_CellTopology.NeighborCellList.{i}.Rsrq Neighbor RSRQ. INT8 -43 to 20 dB N/A R NONE Device.Cellular.Interface.{i}.X_RDK_ContextProfile.{i}.MnoName MNO name for context profile. STRING Max 25 chars N/A R NONE Device.Cellular.Interface.{i}.X_RDK_ContextProfile.{i}.Status EPS bearer activation status. ENUMERATION ACTIVE, INACTIVE N/A R ON-CHANGE Device.Cellular.Interface.{i}.X_RDK_ContextProfile.{i}.DefaultBearer Default EPS bearer flag. BOOLEAN NONE TRUE R NONE Device.Cellular.Interface.{i}.X_RDK_ContextProfile.{i}.Apn APN URL for bearer. STRING NONE N/A R NONE Device.Cellular.Interface.{i}.X_RDK_ContextProfile.{i}.IpAddressFamily IP family of bearer. ENUMERATION IPv4, IPv6, IPv4IPv6 IPv4IPv6 R NONE Device.Cellular.Interface.{i}.X_RDK_ContextProfile.{i}.Ipv4Address IPv4 address. STRING NONE N/A R NONE Device.Cellular.Interface.{i}.X_RDK_ContextProfile.{i}.Ipv4SubnetMask IPv4 subnet mask. STRING NONE N/A R NONE Device.Cellular.Interface.{i}.X_RDK_ContextProfile.{i}.Ipv4Gateway IPv4 gateway. STRING NONE N/A R NONE Device.Cellular.Interface.{i}.X_RDK_ContextProfile.{i}.Ipv4PrimaryDns IPv4 primary DNS. STRING NONE N/A R NONE Device.Cellular.Interface.{i}.X_RDK_ContextProfile.{i}.Ipv4SecondaryDns IPv4 secondary DNS. STRING NONE N/A R NONE Device.Cellular.Interface.{i}.X_RDK_ContextProfile.{i}.Ipv6Address IPv6 address. STRING NONE N/A R NONE Device.Cellular.Interface.{i}.X_RDK_ContextProfile.{i}.Ipv6Gateway IPv6 gateway. STRING NONE N/A R NONE Device.Cellular.Interface.{i}.X_RDK_ContextProfile.{i}.Ipv6PrimaryDns IPv6 primary DNS. STRING NONE N/A R NONE Device.Cellular.Interface.{i}.X_RDK_ContextProfile.{i}.Ipv6SecondaryDns IPv6 secondary DNS. STRING NONE N/A R NONE Device.Cellular.Interface.{i}.X_RDK_ContextProfile.{i}.MtuSize MTU size for bearer. UINT8 NONE N/A R NONE Device.Cellular.Interface.{i}.X_RDK_ContextProfile.{i}.Interface Interface for PDN traffic. STRING NONE N/A R NONE Device.Cellular.Interface.{i}.X_RDK_Statistics.BytesSent Bytes transmitted. UINT32 NONE 0 R NONE Device.Cellular.Interface.{i}.X_RDK_Statistics.BytesReceived Bytes received. UINT32 NONE 0 R NONE Device.Cellular.Interface.{i}.X_RDK_Statistics.PacketsSent Packets transmitted. UINT32 NONE 0 R NONE Device.Cellular.Interface.{i}.X_RDK_Statistics.PacketsReceived Packets received. UINT32 NONE 0 R NONE Device.Cellular.Interface.{i}.X_RDK_Statistics.PacketsSentDrop Sent packets dropped. UINT32 NONE 0 R ON-INTERVAL Device.Cellular.Interface.{i}.X_RDK_Statistics.PacketsReceivedDrop Received packets dropped. UINT32 NONE 0 R ON-INTERVAL Device.Cellular.Interface.{i}.X_RDK_Statistics.UpStreamMaxBitRate Max upstream bit rate. UINT16 NONE N/A R NONE Device.Cellular.Interface.{i}.X_RDK_Statistics.DownStreamMaxBitRate Max downstream bit rate. UINT16 NONE N/A R NONE Device.Cellular.X_RDK_Uicc.{i}.Enable Power on SIM in slot. BOOLEAN NONE TRUE WR NONE Device.Cellular.X_RDK_Uicc.{i}.MnoName MNO name for UICC. STRING NONE N/A R NONE Device.Cellular.X_RDK_Uicc.{i}.Iccid ICCID of SIM. STRING 18-20 digits (0-9) N/A R NONE Device.Cellular.X_RDK_Uicc.{i}.Msisdn MSISDN of SIM. STRING 18-20 digits (0-9) N/A R NONE Device.Cellular.X_RDK_Uicc.{i}.Status SIM status. ENUMERATION VALID, BLOCKED, ERROR, EMPTY N/A R NONE Device.Cellular.X_RDK_Euicc.Enable Activate eSIM. BOOLEAN NONE N/A WR NONE Device.Cellular.X_RDK_Euicc.Eid eSIM identifier. STRING NONE N/A R NONE Device.Cellular.X_RDK_Euicc.MnoProfile.{i}.Enable Activate profile. BOOLEAN NONE N/A R NONE Device.Cellular.X_RDK_Euicc.MnoProfile.{i}.MnoName MNO name for profile. STRING NONE N/A R NONE Device.Cellular.X_RDK_Euicc.MnoProfile.{i}.Iccid Profile ICCID. STRING 18-20 digits (0-9) N/A R NONE Device.Cellular.X_RDK_Euicc.MnoProfile.{i}.Msisdn Profile MSISDN. STRING E.164 N/A R NONE Device.Cellular.X_RDK_Euicc.MnoProfile.{i}.Imsi Profile IMSI. STRING Max 15 digits N/A R NONE Device.Cellular.X_RDK_Euicc.MnoProfile.{i}.Status Profile status. ENUMERATION VALID, BLOCKED, ERROR, EMPTY N/A R ON-CHANGE Device.Cellular.AccessPoint.{i}.Enable Make APN usable. BOOLEAN NONE TRUE R ON-CHANGE Device.Cellular.AccessPoint.{i}.X_RDK_MnoName MNO name for profile. STRING Max 25 chars N/A R NONE Device.Cellular.AccessPoint.{i}.X_RDK_Roaming Allow roaming use. BOOLEAN NONE TRUE R NONE Device.Cellular.AccessPoint.{i}.Apn APN URL. STRING Max 25 chars N/A R NONE Device.Cellular.AccessPoint.{i}.X_RDK_ApnAuthentication Authentication type. STRING PAP, CHAP, NONE NONE R NONE Device.Cellular.AccessPoint.{i}.UserName Authentication username. STRING Max 25 chars N/A R NONE Device.Cellular.AccessPoint.{i}.Password Authentication password. STRING Max 25 chars N/A R NONE Device.Cellular.AccessPoint.{i}.X_RDK_IpAddressFamily PDP context IP family. ENUMERATION IPv4, IPv6, IPv4IPv6 IPv4IPv6 R NONE Device.Cellular.AccessPoint.{i}.X_RDK_PdpInterfaceConfig Config method (NAS/DHCP). ENUMERATION NAS, DHCP NAS R NONE Device.Cellular.AccessPoint.{i}.X_RDK_DefaultProfile Default bearer profile. BOOLEAN NONE FALSE R NONE Device.Cellular.AccessPoint.{i}.X_RDK_ProfileId Profile index in SIM/modem. UINT8 NONE N/A RW NONE"},{"location":"connectivity/docs/components/cellularmanager/#tr181-xml","title":"TR181 XML","text":"<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;dm:document&gt;\n  &lt;model name=\"Device:2.xx-cellularManager root object definition to be added to Device.\"&gt;\n    &lt;bibliography&gt;\n      &lt;reference id=\"3GPP specs\"&gt;\n        &lt;name&gt;Describes the DATA model in TR181 format for RDK-B CellularManager&lt;/name&gt;\n        &lt;organization&gt;&lt;/organization&gt;\n        &lt;hyperlink&gt;http://www.3gpp.org&lt;/hyperlink&gt;\n      &lt;/reference&gt;\n    &lt;/bibliography&gt;\n    &lt;object name=\"Device.Cellular\" access=\"readOnly\" minEntries=\"1\" maxEntries=\"1\"&gt;\n      &lt;description&gt;\n        The top-level object for a Device.Cellular.\n      &lt;/description&gt;\n      &lt;parameter name=\"Enable\" description=\"Expose a switch to activate or deactivate cellular access\" access=\"readWrite\"&gt;\n        &lt;syntax&gt;\n          &lt;boolean/&gt;\n        &lt;/syntax&gt;\n      &lt;/parameter&gt;\n      &lt;object name=\"Device.Cellular.X_RDK_Firmware\" access=\"readOnly\"&gt;\n        &lt;parameter name=\"CurrentImageVersion\" description=\"Provides the information of the current FW version running in the modem\" access=\"readOnly\"&gt;\n          &lt;syntax&gt;\n            &lt;string&gt;\n              &lt;size maxLength=\"256\"/&gt;\n            &lt;/string&gt;\n          &lt;/syntax&gt;\n        &lt;/parameter&gt;\n      &lt;/object&gt;\n    &lt;/object&gt;\n  &lt;/model&gt;\n&lt;/dm:document&gt;\n</code></pre>"},{"location":"connectivity/docs/components/cellularmanager/#apis","title":"APIs","text":"<ul> <li>LIBQMI APIs: Used for southbound modem control (e.g., IMEI/ICCID retrieval, registration, bearer management).</li> <li>RBUS APIs: Northbound for data model updates and stack integration (e.g., parameter sets/gets, notifications).</li> </ul>"},{"location":"connectivity/docs/components/cellularmanager/#build-setup-requirements","title":"Build Setup &amp; Requirements","text":""},{"location":"connectivity/docs/components/cellularmanager/#functional-requirements","title":"Functional Requirements","text":"<p>In this section, the product requirements are mapped to specific component requirements, including the way to design the component to satisfy the requirement in clear text.</p> Name Title Group Design analysis Notes REQ-RDKB-CellularManager-1 Ability to retrieve LTE side car device identifiers such as serial number, IMEI numbers, mobile interface MAC addresses, WiFi MAC addresses, Ethernet MAC addresses, and BLE MAC addresses. Identity Management We will collect via LIBQMI IMEI and ICCID to be used during onboarding. REQ-RDKB-CellularManager-2 The LTE Side Car Device must allow the ability to change the profile of the eSIM interface remotely to switch networks. Sim Management We will need to implement an LPA solution to retrieve eSIM profiles from the backend. Not MVP; after provisioning behavior will be similar to inserting a SIM in a slot (SIM factor M2FF). REQ-RDKB-CellularManager-3 The LTE Side Car Device must allow the ability to change the preferred SIM interface remotely to switch networks. Sim Management - We will need to be able to detach from a network and attach to a different network using a different SIM. - We will need to create a parameter <code>Device.Cellular.Interface[i]</code> to decide which SIM slot is used. It has been removed from MVP. REQ-RDKB-CellularManager-4 The LTE side car device can be allowed to operate as an extender-only device when associated with a gateway that doesn\u2019t have LTE backup service enabled or provisioned. SoC Management - We will need a switch to disable the modem and to detach from the network. - By disabling the modem, we will shutdown the radios in the modem using power management functionality. REQ-RDKB-CellularManager-5 The gateway must be made aware of the LTE network state and any changes (enabled, active, unavailable, down, disabled). Connectivity Management Need a parameter <code>Device.Cellular.Interface[i]</code> where PDN connectivity of the modem can be exposed based on bearer status. REQ-RDKB-CellularManager-6 Send a notification to the cloud when the LTE network becomes active and the primary WAN is available. Connectivity Management WEBPA active notification based on <code>Device.Cellular.X_RDK_Status</code>. Not part of the Cellular Manager implementation. REQ-RDKB-CellularManager-7 Must support periodic LTE network checks to ensure LTE connectivity. Connectivity Management We can check cellular manager radio network conditions and PDN connectivity. REQ-RDKB-CellularManager-8 LTE telemetry to inform the user if LTE signal is good/bad during onboarding and steady state. Module should provide telemetry data (modulation rate, sensitivity, radio parameters). Radio Management Extract radio signal information for different RATs and add it to telemetry schema for backend upload. A signal score will be created based on RSRP. REQ-RDKB-CellularManager-9 Recommend placement change in steady state if environment changes impact LTE/WiFi backhaul performance. Radio Management Extract RAT radio signal info, translate to a simple value, and allow BLE to determine proper gateway placement. A signal score will be created based on RSRP. REQ-RDKB-CellularManager-10 Recommend best placement during onboarding flow (LTE + WiFi backhaul if used). Radio Management Extract RAT radio signal info, translate to a simple value, and allow BLE to determine proper gateway placement. A signal score will be created based on RSRP. REQ-RDKB-CellularManager-11 Onboarding over LTE (Instant On). Identity &amp; SoC Mgmt Need to start the gateway as RG-FWA without a home network connection. REQ-RDKB-CellularManager-12 SW has ability to switch between physical SIM and programmable eSIM. Identity Management Seamless change among MNO profiles in UICC or eUICC. REQ-RDKB-CellularManager-13 SW supports physical SIM + eSIM for flexibility in network provider selection and in-life provider switches. Identity Management LPA implementation. REQ-RDKB-CellularManager-14 UICC management. Identity Management Extraction of SIM information. REQ-RDKB-CellularManager-15 eSIM (eUICC) for LTE (certified programmable in US, Canada, UK, EU). Identity Management Manage UIM info based on MNO profiles, seamless between SIM and eSIM. REQ-RDKB-CellularManager-16 Ability to enable/disable LTE module (for extender-only mode or when LTE backup deactivated). SoC Management Need capacity to disable modem to configure as a simple WiFi AP. REQ-RDKB-CellularManager-17 Ability to enable/disable extender functionality (LTE backup without extender). SoC Management Need to disable WiFi AP functionality to operate as FWA. Not part of Cellular Manager design. REQ-RDKB-CellularManager-18 Power Management: Radio mgmt (disable chains, etc.), CPU throttling, telemetry. SoC Management Use configurable capabilities to control power consumption. - POWER-OFF - POWER-SAVE REQ-RDKB-CellularManager-19 Telemetry 2.0 Telemetry Management Need to create JSON schema for telemetry based on T2 functionality. REQ-RDKB-CellularManager-20 IPv4 and IPv6: parity with XE1, XE1v2, XE2. Connectivity Management Need to create bearers in IPv4-only, IPv6-only, and DS modes. Wireless differs from ethernet so some services may differ. Analyze feasibility of running DHCP clients on wireless interfaces. DHCP client behavior on wireless interfaces needs study. REQ-RDKB-CellularManager-21 Power management based on EU regulations. SoC Management Ability to switch off LTE radios while keeping control plane and identifiers (IUCC, IMEI) readable. Add a power-save mode to reduce consumption."},{"location":"connectivity/docs/components/cellularmanager/#build-dependencies","title":"Build Dependencies","text":"<ul> <li>Kernel &gt; 3.5</li> <li>gobject 2.0, glib 2.0, gio 2.0</li> <li>libqmi 1.30</li> <li>lte-rbpi-hat</li> <li>python3, python3-pip</li> <li>wiringpi</li> </ul>"},{"location":"connectivity/docs/components/cellularmanager/#modem-management","title":"Modem Management","text":"<ul> <li>AT commands based on ETSI TS 127.007.</li> <li>QMI via kernel drivers (cdc-wdm, qmi_wwan) for consistency across platforms.</li> </ul>"},{"location":"connectivity/docs/components/cellularmanager/#performance-reference","title":"Performance Reference","text":"Reference System Performance LTE LTE-Advanced Peak rate Downlink 100 Mbps @20 MHz 1 Gbps @100 MHz Uplink 50 Mbps @20 MHz 500 Mbps @100 MHz Control plane delay Idle to connected &lt; 100 ms &lt; 50 ms Dormant to active &lt; 50 ms &lt; 10 ms User plane delay &lt; 5 ms &lt; 5 ms Spectral efficiency (peak) Downlink 5 bps/Hz @2 \u00d7 2 30 bps/Hz @8 \u00d7 8 Uplink 2.5 bps/Hz @1 \u00d7 2 15 bps/Hz @4 \u00d7 4 Mobility (RDK-B) NOT APPLICABLE NOT APPLICABLE"},{"location":"connectivity/docs/components/cellularmanager/#reference-setup","title":"Reference Setup","text":""},{"location":"connectivity/docs/components/cellularmanager/#hardware-selection","title":"Hardware Selection","text":"<ul> <li>Physical Connectivity Options:</li> <li>HAT (Preferred): Raspberry Pi 40PIN GPIO, USB for AT commands, UART for debugging, SIM/TF slots, SMA antennas.</li> <li>USB (Not Preferred): Direct USB connection.</li> <li>Additions: Voltage translator (3.3V/5V jumper), LED indicators.</li> </ul>"},{"location":"connectivity/docs/components/cellularmanager/#reference-setups","title":"Reference Setups","text":"<ul> <li>Quectel miniPCIe HAT: Quectel EG25-G (MDM9207), Sixfab HAT, PCB antenna, Micro USB, NL Symio USIM (~$120 as of April 2024).</li> <li>Telit HAT miniPCIe HAT: Telit LE 910Cx (MDM9207), Sixfab HAT, PCB antenna, Micro USB, NL Symio USIM (~$110 as of April 2024).</li> <li>Quectel M2 Adaptor: Quectel EM06, USB to M2 adaptor, Vodafone NL USIM.</li> </ul>"},{"location":"connectivity/docs/components/cellularmanager/#manuals-and-examples","title":"Manuals and Examples","text":"<ul> <li>Use LIBQMI for QMI interactions.</li> <li>AT commands via serial for basic control.</li> <li>Test registration, bearer setup, and telemetry extraction.</li> </ul>"},{"location":"connectivity/docs/components/cellularmanager/#document-references","title":"Document References","text":"<ul> <li>TR-181 specification: Broadband Forum Data Models</li> <li>Modem commands ETSI TS127.007</li> <li>3GPP specifications (e.g., TS 23.003 for numbering, TS 24.301 for NAS protocol, TS 27.007 for AT commands).</li> </ul> <p>3GPP specifications</p> <ul> <li>3GPP TS 23.003, Numbering, Addressing, and Identification</li> <li>3GPP TS 29.274, Evolved General Packet Radio Service (GPRS) Tunneling Control Protocol for Control Plane (GTPv2-C)</li> <li>3GPP TS 36.300, Evolved Universal Terrestrial Radio Access (E-UTRA) and Evolved Universal Terrestrial Radio Access Network (E-UTRAN); overall description</li> <li>3GPP TS 24.301, Non-Access-Stratum (NAS) Protocol for Evolved Packet System (EPS)</li> <li>3GPP TS 36.304, Evolved Universal Terrestrial Radio Access (E-UTRA); UE Procedures in Idle Mode</li> <li>3GPP TS 36.321, Evolved Universal Terrestrial Radio Access (E-UTRA); Medium Access Control (MAC) protocol specification</li> <li>3GPP TS 36.322, Evolved Universal Terrestrial Radio Access (E-UTRA); Radio Link Control (RLC) protocol specification</li> <li>3GPP TS 36.323, Evolved Universal Terrestrial Radio Access (E-UTRA); Packet Data Convergence Protocol (PDCP)</li> <li>3GPP TS 36.331, Evolved Universal Terrestrial Radio Access (E-UTRA); Radio Resource Control (RRC)</li> <li>3GPP TS 23.401, General Packet Radio Service (GPRS) enhancements for Evolved Universal Terrestrial Radio Access Network (E-UTRAN) access</li> <li>3GPP TS 36.413, Evolved Universal Terrestrial Radio Access Network (E-UTRAN); S1 Application Protocol (S1AP)</li> <li>3GPP TR 36.839, Evolved Universal Terrestrial Radio Access (E-UTRA); Mobility Enhancements in Heterogeneous Networks</li> <li>3GPP TS 27.007 V17.3.0 ```</li> </ul>"},{"location":"connectivity/docs/components/gponmanager/","title":"GPON Manager","text":"<p>GPON Manager component is responsible for managing the GPON interface and its associated ONUs. Its primary function is to abstract the complexities of GPON hardware, provide a standardized data model for configuration and monitoring, and ensure seamless integration with the rest of the RDK-B stack. </p> <p>Core responsibilities include:</p> <ul> <li>Lifecycle management of the GPON interface (initialization, monitoring, and shutdown).</li> <li>Monitoring ONU state and GPON link status.</li> <li>Providing a TR-181-compliant data model for northbound interfaces.</li> </ul>"},{"location":"connectivity/docs/components/gponmanager/#design","title":"Design","text":"<p>GPON Manager is architected as a modular middleware component that sits between the hardware abstraction layer (HAL) and the RDK-B management stack. It leverages a state machine to track the operational status of the GPON interface and VEIP (Virtual Ethernet Interface Point), and uses a combination of IPC mechanisms and data models to interact with other system components.</p> <p></p> <p>The design ensures that the GPON Manager can: - Abstract hardware-specific details via the HAL. - Expose a TR-181-compliant data model for configuration and monitoring. - Coordinate with Ethernet and WAN managers for interface provisioning. - Handle events such as GPON link up/down, ONU state changes, and configuration updates.</p> <pre><code>flowchart TD\n    ONU[ONU Hardware] -- OMCI/PLOAM --&gt; GPON_Manager\n    GPON_Manager -- Data Model &amp; Events --&gt; RDK_Bus\n    GPON_Manager -- IPC --&gt; Ethernet_Manager\n    GPON_Manager -- IPC --&gt; WAN_Manager\n    RDK_Bus -- Northbound APIs --&gt; Controller_UI</code></pre>"},{"location":"connectivity/docs/components/gponmanager/#internal-modules","title":"Internal Modules","text":"<p>The GPON Manager is organized into several internal modules, each with a distinct responsibility:</p> <ul> <li>Plugin Initialization: Handles component startup, function registration, and integration with the RDK-B plugin framework.</li> <li>Data Model Management: Maintains in-memory representations of the TR-181 data model, including parameter access and updates.</li> <li>HAL Communication: Manages JSON-based messaging with the hardware abstraction layer for ONU and GPON interface operations.</li> <li>State Machine: Implements the logic for tracking and transitioning between GPON operational states (e.g., Connected, Disconnected, Disabled, ONU Down).</li> <li>Ethernet Interface Management: Coordinates with the Ethernet Manager to create and manage VEIP interfaces.</li> <li>Event Handling: Processes asynchronous events from the hardware and other middleware components.</li> </ul>"},{"location":"connectivity/docs/components/gponmanager/#interaction-with-other-middleware-components","title":"Interaction with Other Middleware Components","text":"<p>The GPON Manager interacts with several other RDK-B middleware components to ensure end-to-end functionality:</p> <ul> <li>Ethernet Manager: The GPON Manager notifies the Ethernet Manager to create or delete VEIP interfaces as the GPON link state changes.</li> <li>WAN Manager: It coordinates with the WAN Manager to bring up or tear down WAN connections based on the status of the VEIP interface.</li> <li>RDK Message Bus: All IPC with peer components is performed over the RDK message bus, ensuring decoupled and scalable communication.</li> </ul>"},{"location":"connectivity/docs/components/gponmanager/#interaction-with-other-layers","title":"Interaction with Other Layers","text":"<p>The GPON Manager serves as a bridge between the northbound management interfaces and the southbound hardware abstraction layer:</p> <ul> <li>Northbound: Exposes the TR-181 data model, allowing controller UIs and remote management systems to configure and monitor GPON parameters.</li> <li>Southbound: Communicates with the ONU hardware via the HAL, using JSON messages to perform operations such as querying status, configuring parameters, and handling link events.</li> </ul>"},{"location":"connectivity/docs/components/gponmanager/#ipc-mechanism","title":"IPC Mechanism","text":"<p>Inter-process communication is primarily handled via the RDK message bus. The GPON Manager registers handlers for specific events and commands, and sends notifications or requests to other components as needed. For hardware interactions, the manager uses a JSON-based protocol defined in the <code>hal_schema</code> directory, ensuring a clear contract between the middleware and the underlying hardware drivers.</p>"},{"location":"connectivity/docs/components/gponmanager/#tr-181-data-models","title":"TR-181 Data Models","text":"<p>The GPON Manager owns and manages the <code>Device.X_RDK_ONT</code> TR-181 data model subtree. This model includes:</p> <ul> <li>PhysicalMedia: Details about the ONU hardware, such as vendor, firmware, and operational status.</li> <li>Gtc: GPON Transmission Convergence layer parameters.</li> <li>Ploam: Physical Layer OAM management.</li> <li>Omci: OMCI protocol management for ONU configuration.</li> <li>Gem: GEM port configuration and statistics.</li> <li>Veip: Virtual Ethernet Interface Point, representing the WAN interface.</li> <li>TR69: Parameters for remote management via TR-069.</li> </ul> <pre><code>graph TD\n    X_RDK_ONT[\"Device.X_RDK_ONT\"]\n    X_RDK_ONT --&gt; PhysicalMedia\n    X_RDK_ONT --&gt; Gtc\n    X_RDK_ONT --&gt; Ploam\n    X_RDK_ONT --&gt; Omci\n    X_RDK_ONT --&gt; Gem\n    X_RDK_ONT --&gt; Veip\n    X_RDK_ONT --&gt; TR69</code></pre>"},{"location":"connectivity/docs/components/gponmanager/#gpon-connected","title":"GPON Connected","text":"<p>In the connected state, the ONU manages GPON connection parameters autonomously. The GPON Manager monitors the ONU's registration status and VEIP interface state. Upon VEIP availability, the GPON Manager coordinates with the Ethernet Manager to provision the VEIP interface for WAN services, consistent with WANoE (WAN over Ethernet) behavior.</p>"},{"location":"connectivity/docs/components/gponmanager/#gpon-disonnected","title":"GPON Disonnected","text":"<p>When the VEIP interface is lost, the GPON Manager disables the corresponding Ethernet interface data model object in the Ethernet Manager. This action triggers a teardown of the WAN connection, mirroring the behavior seen in physical Ethernet link disconnection.</p>"},{"location":"connectivity/docs/components/gponmanager/#gpon-disabled-for-wan","title":"GPON Disabled for WAN","text":"<p>In this state, the ONU remains operational, but WAN services are disabled. The Ethernet Manager transitions to a \u201cWAN Link Down\u201d state. If re-enabled, the system proceeds to restore WAN connectivity using the existing VEIP interface.</p>"},{"location":"connectivity/docs/components/gponmanager/#onu-disabled","title":"ONU Disabled","text":"<p>Disabling the ONU triggers the teardown of the VEIP interface. The GPON Manager instructs the Ethernet Manager to terminate the associated WAN connection and delete the corresponding Ethernet interface object. Both state machines exit their operational states to conserve system resources.</p>"},{"location":"connectivity/docs/components/gponmanager/#data-model-structure","title":"Data model structure","text":"<p>The data model structure across RDK components leverages the <code>LowerLayers</code> parameter to stack configuration layers for GPON-based WAN connectivity.</p>"},{"location":"connectivity/docs/components/gponmanager/#_1","title":"GPON Manager","text":""},{"location":"connectivity/docs/components/gponmanager/#implementation-details","title":"Implementation Details","text":"<p>The implementation is structured to maximize modularity and maintainability. Key aspects include:</p> <ul> <li>The main plugin entry point and initialization logic reside in <code>source/TR-181/middle_layer_src/gponmgr_dml_plugin_main.c</code>.</li> <li>Data model structures and access functions are implemented in <code>source/TR-181/middle_layer_src/gponmgr_dml_data.c</code> and its header.</li> <li>HAL communication, including JSON message parsing and parameter mapping, is handled in <code>source/TR-181/middle_layer_src/gponmgr_dml_hal.c</code>.</li> <li>The state machine logic is encapsulated in <code>source/GponManager/gponmgr_link_state_machine.c</code>, which manages transitions such as GPON Connected, Disconnected, Disabled, and ONU Down.</li> <li>Ethernet interface management and IPC with the Ethernet Manager are implemented in <code>source/TR-181/middle_layer_src/gponmgr_dml_eth_iface.c</code>.</li> <li>Supporting files such as <code>hal_schema</code> define the JSON schemas for HAL communication, while <code>config/RdkGponManager.xml</code> provides data model definitions and parameter mappings.</li> </ul>"},{"location":"connectivity/docs/components/gponmanager/#key-configuration-files","title":"Key Configuration Files","text":"<ul> <li>config/RdkGponManager.xml: Defines the TR-181 data model, parameter mappings, and function bindings for the GPON Manager.</li> <li>hal_schema/: Contains JSON schema definitions for communication between the GPON Manager and the HAL.</li> </ul>"},{"location":"connectivity/docs/components/wanmanager/","title":"WAN Manager","text":"<p>WAN Manager is responsible to manage WAN interfaces including handling the configuration, selection, and monitoring of WAN interfaces, supporting various physical and virtual interfaces such as XDSL, Ethernet, DOCSIS, GPON, and Cellular. The WAN Manager abstracts the complexity of managing multiple WAN interfaces, implements failover and selection policies, and integrates seamlessly with other RDK components through RBUS and WebConfig. Its modular architecture ensures flexibility, scalability, and support for future enhancements.</p> <p>The main objectives achieved by the WAN Manager component are</p> <ul> <li>Interface Management : Interface Managers (e.g., XDSL, Ethernet, DOCSIS, GPON, Cellular) handle physical interface bring-up and report the status of the physical layer to WAN Manager. They provide additional configuration details, such as IP Mode (IPv4 only, IPv6 only, or Dual Stack), VLAN IDs for egress traffic, or static IP addresses (e.g., obtained via PDP on Cellular links)</li> <li>Link and IP Layer Configuration : WAN Manager interfaces with other RDK components (e.g., VLAN Manager, DHCP Manager) and Linux utilities (e.g., ip addr, ip ro) to configure link and IP layers</li> <li>Business Logic for Connectivity : Executes business logic to configure WAN interfaces and ensure reliable internet connectivity</li> </ul>"},{"location":"connectivity/docs/components/wanmanager/#design","title":"Design","text":"<p>The WAN Manager is built with a modular architecture, comprising several internal components that collaborate to manage WAN connectivity.</p>"},{"location":"connectivity/docs/components/wanmanager/#wan-controller","title":"WAN Controller","text":"<p>The WAN Controller serves as the central orchestrator within the WAN Manager, handling tasks that are not specific to individual interfaces. It is responsible for initializing the TR-181 data model from persistent storage, ensuring that configuration settings are loaded correctly at startup. Additionally, it manages runtime changes to the data model, allowing dynamic updates to WAN configurations without requiring a system restart. The WAN Controller coordinates with other components, such as the Policy State Machine and Interface Managers, to ensure that interface configurations align with the defined policies and operational requirements. This component acts as the backbone of WAN Manager, providing a unified point of control for non-interface-specific operations.</p>"},{"location":"connectivity/docs/components/wanmanager/#policy-state-machine","title":"Policy State Machine","text":"<p>The Policy State Machine determines which physical interfaces are used for WAN connectivity based on predefined policies, such as AutoWAN or Parallel Scan. It implements a single instance of the Failover Policy, which enables runtime switching between different interface groups to maintain connectivity in case of failures. For each interface group, the Policy State Machine runs a Selection Policy (e.g., AutoWAN, which sequentially tests interfaces until one establishes internet access, or Parallel Scan, which evaluates multiple interfaces simultaneously). By organizing interfaces into groups (e.g., Group 1: DOCSIS and Ethernet; Group 2: LTE), the Policy State Machine provides flexible configurations, allowing operators to define complex failover and selection strategies tailored to specific deployment needs.</p>"},{"location":"connectivity/docs/components/wanmanager/#wan-interface-state-machines","title":"WAN Interface State Machines","text":"<p>WAN Interface State Machines are responsible for managing the configuration and state of each virtual interface, with one instance running per virtual interface. A virtual interface is defined in the TR-181 data model as a combination of link-layer and IP-layer protocols stacked on top of a physical interface. These state machines ensure that the interface stack is built correctly from the bottom up, handling tasks such as configuring VLANs, assigning IP addresses, and setting up routing. They also manage deconfiguration when an interface is no longer needed, ensuring clean teardown of resources. This modular approach allows WAN Manager to support diverse interface types and configurations, making it adaptable to various hardware and network environments.</p>"},{"location":"connectivity/docs/components/wanmanager/#event-handlers","title":"Event Handlers","text":"<p>Facilitates communication with other RDK components via RBUS events and system-level notifications.</p> <pre><code>flowchart TD\n    subgraph RDK_WAN_MANAGER[\"RDK WAN Manager\"]\n        direction TB\n        POLICY_STATE_MACHINE[\"Policy State Machine\"]\n        WAN_CONTROLLER[\"WAN Controller\"]\n        WAN_INTERFACE_STATE_MACHINE_1[\"WAN Interface State Machine\"]\n        WAN_INTERFACE_STATE_MACHINE_2[\"WAN Interface State Machine\"]\n        WAN_INTERFACE_STATE_MACHINE_3[\"WAN Interface State Machine\"]\n    end\n    WAN_CONTROLLER --&gt; POLICY_STATE_MACHINE\n    POLICY_STATE_MACHINE &lt;--&gt; WAN_INTERFACE_STATE_MACHINE_1 &amp; WAN_INTERFACE_STATE_MACHINE_2\n    POLICY_STATE_MACHINE --&gt; WAN_INTERFACE_STATE_MACHINE_3\n    RDK_BUS[\"RDK Bus\"] --&gt; RDK_WAN_MANAGER\n    RDK_WAN_MANAGER --&gt; JSON_HAL[\"JSON HAL\"]\n    JSON_HAL --&gt; VENDOR_SW[\"Vendor Software\"]</code></pre>"},{"location":"connectivity/docs/components/wanmanager/#internal-modules","title":"Internal Modules","text":"<ul> <li>Failover Policy: Manages runtime failover and switching between different groups of interfaces to ensure continuous connectivity.</li> <li>Selection Policy:</li> <li>Runs one instance per interface group, using algorithms like AutoWAN or Parallel Scan.</li> <li>AutoWAN: Sequentially tests interfaces within a group until one establishes internet connectivity.</li> <li>Parallel Scan: Simultaneously evaluates multiple interfaces to select the best one.</li> <li> <p>Each policy operates on a specific group of interfaces (e.g., Group 1: DOCSIS and Ethernet; Group 2: LTE).</p> </li> <li> <p>WAN Interface State Machine: Manages the configuration of virtual interfaces, ensuring correct layering of link and IP protocols.</p> </li> </ul>"},{"location":"connectivity/docs/components/wanmanager/#interaction-with-other-middleware-components","title":"Interaction with Other Middleware Components","text":""},{"location":"connectivity/docs/components/wanmanager/#interface-managers","title":"Interface Managers","text":"<p>Components like XDSL, Ethernet, DOCSIS, GPON, and Cellular managers handle physical interface bring-up and report status and configuration details to WAN Manager.</p>"},{"location":"connectivity/docs/components/wanmanager/#rdk-components","title":"RDK Components","text":"<ul> <li>VLAN Manager: Configures VLAN settings for interfaces.</li> <li>DHCP Manager: Manages IP address allocation for WAN interfaces.</li> <li>Other components like Routing Manager and QoS Manager are invoked as needed.</li> </ul>"},{"location":"connectivity/docs/components/wanmanager/#rbus","title":"RBUS","text":"<p>Used for internal communication between WAN Manager and Interface Managers, supporting event subscription and publishing.</p>"},{"location":"connectivity/docs/components/wanmanager/#interaction-with-other-layers","title":"Interaction with Other Layers","text":""},{"location":"connectivity/docs/components/wanmanager/#northbound-interactions","title":"Northbound Interactions","text":"<p>WAN Manager provides robust northbound interfaces for configuration and monitoring, primarily through the TR-181 data model, RBUS, and WebConfig. The TR-181 data model exposes a comprehensive set of configuration and status parameters, including standard objects like Device.IP.Interface and custom RDK parameters such as Device.X_RDK_WanManager. This allows operators to remotely manage WAN configurations and monitor interface status. RBUS enables real-time event publishing and subscription, facilitating communication with higher-layer management systems or other RDK components. WebConfig provides a web-based interface for remote configuration, making it easier to manage devices in large-scale deployments. These northbound interfaces ensure that WAN Manager integrates seamlessly with network management systems and supports remote diagnostics and updates.</p>"},{"location":"connectivity/docs/components/wanmanager/#southbound-interactions","title":"Southbound Interactions","text":"<p>On the southbound side, WAN Manager interacts with the Hardware Abstraction Layer (HAL) and Linux utilities to configure and monitor low-level interface settings. The HAL provides vendor-specific APIs for interacting with hardware, allowing WAN Manager to receive status updates and configuration data from Interface Managers. For example, it can retrieve IP Mode or VLAN IDs from a Cellular or Ethernet interface. Additionally, WAN Manager uses Linux utilities like ip addr, ip route, and ip link to configure link and IP layers, ensuring that interfaces are properly set up for internet connectivity. These southbound interactions enable WAN Manager to bridge the gap between high-level configuration policies and low-level hardware operations.</p>"},{"location":"connectivity/docs/components/wanmanager/#ipc-mechanisms","title":"IPC Mechanisms","text":""},{"location":"connectivity/docs/components/wanmanager/#rbus_1","title":"RBUS","text":"<ul> <li>Primary inter-process communication (IPC) mechanism for interacting with other RDK components.</li> <li>WAN Manager registers and subscribes to RBUS events (see WanMgr_Rbus_SubscribeDML in source/WanMgr_RbusHandler.c).</li> <li>Publishes interface status and configuration updates.</li> </ul>"},{"location":"connectivity/docs/components/wanmanager/#sysevents","title":"SysEvents","text":"<ul> <li>Used for system-level event notifications (see WanMgr_SysEvents_Init in source/WanMgr_Sysevents.c).</li> </ul>"},{"location":"connectivity/docs/components/wanmanager/#internal-ipc","title":"Internal IPC","text":"<ul> <li>Utilizes threads and mutexes for synchronization and event handling within WAN Manager (see WanMgr_WanRemoteIfaceConfigure in source/WanMgr_IfaceCtrl.c).</li> </ul>"},{"location":"connectivity/docs/components/wanmanager/#tr-181-data-model","title":"TR-181 Data Model","text":"<p>WAN Manager manages several TR-181 data model objects to store and expose WAN configuration and status. These include both standard TR-181 objects and RDK-specific extensions. <pre><code>flowchart TD\n    subgraph DEVICE[Device.]\n        direction LR\n        DEVICE_IP[Device.IP]\n        DEVICE_DHCPV4[Device.DHCPv4]\n        DEVICE_DHCPV4_CLIENT[Device.DHCPv4.Client]\n        DEVICE_DHCPV6[Device.DHCPv6]\n        DEVICE_DHCPV6_CLIENT[Device.DHCPv6.Client]\n        DEVICE_QOS[Device.QoS]\n        DEVICE_QOS_QUEUE[Device.QoS.Queue]\n        DEVICE_MAP[Device.MAP]\n        DEVICE_DSLITE[Device.DSLite]\n        DEVICE_X_RDK_WANMANAGER[Device.X_RDK_WanManager]\n        DEVICE_IP--&gt;DEVICE_DHCPV4\n        DEVICE_IP--&gt;DEVICE_DHCPV6\n        DEVICE_IP--&gt;DEVICE_QOS\n        DEVICE_IP--&gt;DEVICE_MAP\n        DEVICE_IP--&gt;DEVICE_DSLITE\n        DEVICE_IP--&gt;DEVICE_X_RDK_WANMANAGER\n        DEVICE_DHCPV4 --&gt; DEVICE_DHCPV4_CLIENT\n        DEVICE_DHCPV6 --&gt; DEVICE_DHCPV6_CLIENT\n        DEVICE_QOS --&gt; DEVICE_QOS_QUEUE\n    end</code></pre></p>"},{"location":"connectivity/docs/components/wanmanager/#key-data-model-objects","title":"Key Data Model Objects","text":"<ul> <li>Device.X_RDK_WanManager: Stores WAN configuration, interface groups, and policy settings.</li> <li>Device.IP.Interface: Represents IP interfaces managed by WAN Manager.</li> <li>Device.Ethernet.Link, Device.Ethernet.VLANTermination, Device.PPP.Interface: Lower-layer objects used for stacking interfaces in virtual configurations.</li> </ul> <p>Example Data Model Stack <pre><code>flowchart TD\n    IP_INTERFACE[IP.Interface]\n    ETHERNET_LINK[Ethernet.Link]\n    PPP_INTERFACE[PPP.Interface]\n    ETHERNET_VLAN_TERMINATION[Ethernet.VLANTermination]\n    TO_LOWER_LAYERS_1[To Lower Layers]\n    TO_LOWER_LAYERS_2[To Lower Layers]\n    TO_LOWER_LAYERS_3[To Lower Layers]\n\n    IP_INTERFACE --&gt; ETHERNET_LINK &amp; ETHERNET_VLAN_TERMINATION &amp; PPP_INTERFACE\n    ETHERNET_LINK --&gt; TO_LOWER_LAYERS_1\n    ETHERNET_VLAN_TERMINATION --&gt; TO_LOWER_LAYERS_3\n    PPP_INTERFACE --&gt; TO_LOWER_LAYERS_2</code></pre></p>"},{"location":"connectivity/docs/components/wanmanager/#implementation-details","title":"Implementation Details","text":"<p>WanMgr_IfaceCtrl.c: Manages WAN interface control and configuration. WanMgr_RbusHandler.c: Handles RBUS event registration and communication. WanMgr_Sysevents.c: Manages system event notifications. WanMgr_PolicyCtrl.c: Implements failover and selection policies. WanMgr_Data.c: Manages TR-181 data model interactions.</p> <p>wanmgr_data.h: Defines data structures for WAN configuration and state. wanmgr_rbus_handler_apis.h: RBUS API definitions.</p> <p>tests/: Unit tests for validating WAN Manager functionality.</p>"},{"location":"connectivity/docs/components/wanmanager/#key-configuration-files","title":"Key Configuration Files","text":"<p>config/WanMgr_Config.json: Defines interface groups, selection policies, and failover settings. Example: <pre><code>{\n  \"InterfaceGroups\": [\n    {\n      \"GroupId\": 1,\n      \"Interfaces\": [\"DOCSIS\", \"EthWAN\"],\n      \"Policy\": \"AutoWAN\"\n    },\n    {\n      \"GroupId\": 2,\n      \"Interfaces\": [\"LTE\"],\n      \"Policy\": \"ParallelScan\"\n    }\n  ],\n  \"FailoverPolicy\": \"RuntimeSwitch\"\n}\n</code></pre></p>"},{"location":"device-management/docs/","title":"Device Management","text":"<p>Device management encompasses the centralized control, monitoring, configuration, and maintenance of connected devices, enabling efficient bulk operations, dynamic feature management, and firmware updates to ensure optimal performance, security, and scalability across diverse deployments. The significance lies in its ability to horizontally scale across these profiles, allowing for the efficient sharing of the same code. This streamlined approach facilitates controlled bulk operations and data retrievals, essential for managing diverse devices at scale. The functionality extends to enabling or disabling features dynamically and facilitating firmware (code) downloads. Moreover, Device Management plays a crucial role in retrieving field matrices, ensuring a comprehensive and organized approach to overseeing and controlling devices within the specified frameworks.</p>"},{"location":"device-management/docs/#device-management-capabilities","title":"Device Management capabilities","text":"<p>Different device management capabilities are shared across the different profiles. The key device management capabilities are:</p>"},{"location":"device-management/docs/#xconf","title":"XConf","text":"<p>XConf\u00a0is a pivotal device management service that enables streamlined code download in set-top-boxes (STBs), providing essential information on firmware version, download source, and download protocol. It overcomes limitations of traditional code downloads by employing the eSTB interface for code download.</p>"},{"location":"device-management/docs/#webpa","title":"WebPA","text":"<p>WebPA (Web Protocol Adapter) serves as a secure web protocol messaging system for bi-directional communication between cloud servers and RDK devices. It offers read/write access to device management parameters, prioritizing security and performance, and replaces traditional methods like TR-69 or SNMP.</p>"},{"location":"device-management/docs/LogUpload/","title":"Placeholder for Log Upload documentation","text":""},{"location":"device-management/docs/TR369/","title":"Placeholder for TR369 documentation","text":""},{"location":"device-management/docs/Telemetry/","title":"Placeholder for Telemetry documentation","text":""},{"location":"device-management/docs/Webpa/","title":"Placeholder for webpa documentation","text":""},{"location":"device-management/docs/XConf/","title":"XConf","text":"<p>Note</p> <p>Details of XConf API are available at  XConf APIs &amp; User Interface Documentation on XConf deployment is available at XConf Security &amp; Deployment</p>"},{"location":"device-management/docs/XConf/#overview","title":"Overview","text":"<p>XConf is a comprehensive configuration management system designed for RDK (Reference Design Kit) devices, primarily set-top boxes (STBs). It serves as the central authority for managing firmware versions, device settings, feature controls, and telemetry configurations across large device populations.</p> <p>The system handles the complex requirements of managing thousands to millions of deployed devices across diverse network environments. XConf provides operators with centralized control over firmware deployments, device behaviors, feature toggles, and telemetry data collection through a sophisticated rule-based platform.</p> <p>XConf operates on rule-based decision making principles. When devices request configurations, firmware updates, or feature settings, XConf evaluates configurable rules against device attributes (MAC address, model, environment, firmware version, location) to determine appropriate responses. This provides fine-grained control over device populations while maintaining flexibility for diverse deployment scenarios.</p>"},{"location":"device-management/docs/XConf/#key-features","title":"Key Features","text":"<ul> <li>Centralized Configuration Management: Single point of control for all device configurations</li> <li>Rule-Based Decision Engine: Sophisticated conditional logic for device targeting</li> <li>High-Volume Device Support: Designed to handle millions of concurrent device requests</li> <li>Multi-Application Support: Supports STB, xHome, and rdkCloud device types</li> <li>Real-time Feature Control: Dynamic feature enabling/disabling without firmware updates</li> <li>Comprehensive Telemetry: Both legacy and modern telemetry data collection systems</li> </ul>"},{"location":"device-management/docs/XConf/#use-cases","title":"Use Cases","text":"<ul> <li>Firmware Rollouts: Controlled deployment of firmware updates with percentage-based rollouts</li> <li>Feature Management: Remote enabling/disabling of device features for A/B testing</li> <li>Device Configuration: Centralized management of device operational parameters</li> <li>Telemetry Collection: Comprehensive data gathering for analytics and troubleshooting</li> <li>Emergency Response: Rapid configuration changes for security or operational issues</li> </ul>"},{"location":"device-management/docs/XConf/#architecture","title":"Architecture","text":"<p>XConf follows a distributed microservices architecture designed to handle high-volume device requests while maintaining administrative flexibility. The system separates device-facing operations from administrative functions, ensuring that high-frequency device requests don't interfere with configuration management operations.</p>"},{"location":"device-management/docs/XConf/#high-level-architecture","title":"High-level Architecture","text":"<p>The following diagram illustrates the core components and their interactions. Device requests flow through the DataService, which evaluates rules stored in Cassandra to determine appropriate configurations. Administrative operations are handled through a separate service layer for operational stability and security isolation.</p> <pre><code>graph TD\n    A[STB Devices] --&gt;|Requests| B[XConf DataService]\n    B --&gt;|Queries| C[Cassandra Database]\n    B --&gt;|Admin API| D[XConf Admin Service]\n    D --&gt;|UI Access| E[XConf UI]\n    F[3rd-party Tools] --&gt;|Monitoring| B</code></pre>"},{"location":"device-management/docs/XConf/#components","title":"Components","text":"<p>XConf DataService (<code>xconfwebconfig</code>): The core backend service processes all device-initiated requests. Built in Go using <code>gorilla/mux</code> router, it handles firmware updates, DCM settings, and RFC requests through a sophisticated rule evaluation engine. Operating on port <code>9000</code>, it's designed for high throughput with comprehensive caching mechanisms and supports time-based deployments, percentage rollouts, and geographic targeting.</p> <p>The DataService implements efficient request processing with optimized database queries and response caching. It evaluates complex rule sets against device attributes to determine appropriate configurations, ensuring consistent and reliable responses even under high load conditions.</p> <p>XConf Admin Service (<code>xconfadmin</code>): Provides comprehensive management capabilities through RESTful APIs for all XConf configurations. Operating on port <code>9001</code>, it handles CRUD operations, validation, testing, and export/import functionality. The service implements role-based access control and supports multiple application types (STB, xHome, rdkCloud) with proper isolation.</p> <p>The Admin Service includes sophisticated validation logic to ensure configuration consistency and provides testing endpoints for verifying rule behavior before deployment. It supports bulk operations for efficient management of large configuration sets.</p> <p>XConf UI (<code>xconfui</code>): A web-based management console built with AngularJS and Go backend. It offers intuitive forms, visual rule builders, and comprehensive testing capabilities. The interface provides progressive disclosure, presenting simple interfaces for common operations while offering advanced features when needed.</p> <p>The UI includes extensive validation, real-time feedback, and preview capabilities to help administrators understand configuration impacts before deployment. It supports import/export operations and bulk configuration management.</p> <p>Cassandra Database: The distributed NoSQL storage layer using the <code>ApplicationsDiscoveryDataService</code> keyspace. It stores all configuration data with a schema optimized for read-heavy workloads and efficient rule evaluation queries. The database design uses wide-row patterns for consistent performance and supports configurable consistency levels.</p> <p>Cassandra's distributed architecture provides high availability and horizontal scalability essential for supporting large device populations across multiple geographic regions.</p> <p>Authentication Provider: Integrates with external authentication systems, primarily OAuth2 providers, for secure access control. The system validates tokens for all administrative operations and supports configurable authentication endpoints, enabling integration with existing organizational identity management systems.</p>"},{"location":"device-management/docs/XConf/#core-capabilities","title":"Core Capabilities","text":""},{"location":"device-management/docs/XConf/#firmware-management","title":"Firmware Management","text":"<p>XConf's firmware management provides comprehensive control over firmware deployments across device populations. The system handles complex distribution requirements including staged rollouts, compatibility verification, and rollback capabilities through a sophisticated rule-based engine.</p> <p>When devices request firmware updates, XConf evaluates device characteristics (firmware version, model, MAC address, environment) against configured deployment rules to determine appropriate responses.</p>"},{"location":"device-management/docs/XConf/#firmware-configuration-management","title":"Firmware Configuration Management","text":"<p>Firmware Configs define available firmware packages with comprehensive metadata including version identifiers, filenames, download locations, supported models, and deployment parameters. The system supports IPv4/IPv6 locations, multiple protocols (HTTP, HTTPS, TFTP), and configurable upgrade delays.</p>"},{"location":"device-management/docs/XConf/#rule-based-distribution","title":"Rule-Based Distribution","text":"<p>Firmware Rules determine which devices receive specific firmware versions based on device attributes and environmental factors. Rules support complex conditional logic with AND/OR operators, negation, and priority-based evaluation for sophisticated targeting scenarios.</p>"},{"location":"device-management/docs/XConf/#deployment-control-mechanisms","title":"Deployment Control Mechanisms","text":"<p>The system provides multiple deployment control mechanisms: percentage filters for gradual rollouts, time filters for maintenance window restrictions, and location filters for geographic targeting. These controls minimize risk and ensure smooth deployments.</p>"},{"location":"device-management/docs/XConf/#version-management","title":"Version Management","text":"<p>Comprehensive version tracking includes Activation Version rules for minimum firmware requirements and Intermediate Version configurations for staged upgrade paths, ensuring compatibility and reducing upgrade failures.</p>"},{"location":"device-management/docs/XConf/#device-configuration-manager-dcm","title":"Device Configuration Manager (DCM)","text":"<p>DCM provides comprehensive management of device operational parameters, logging configurations, and behavioral settings. It offers centralized control over device field operations, data collection, and reporting through a rule-based system that evaluates device attributes to determine appropriate configuration profiles.</p>"},{"location":"device-management/docs/XConf/#device-settings-management","title":"Device Settings Management","text":"<p>Device Settings control fundamental operational parameters including configuration check schedules, reboot policies, service endpoint URLs, and activation flags. The system supports both immediate and scheduled configuration changes for coordinated updates across device populations.</p>"},{"location":"device-management/docs/XConf/#logging-and-upload-control","title":"Logging and Upload Control","text":"<p>Log Upload Settings manage device logging behavior, controlling log file collection, retention periods, upload schedules, and automatic upload triggers. The system supports sophisticated rules for targeting specific log files and scheduling uploads based on device state or time triggers.</p>"},{"location":"device-management/docs/XConf/#repository-management","title":"Repository Management","text":"<p>Upload Repositories define destinations for device logs and data, including destination URLs, upload protocols, authentication parameters, and handling requirements. The system supports multiple repository types with routing based on content type or device characteristics.</p>"},{"location":"device-management/docs/XConf/#vod-and-specialized-settings","title":"VOD and Specialized Settings","text":"<p>VOD Settings provide specialized configurations for Video-on-Demand services, including server locations, network parameters, and session management settings to ensure efficient content delivery network access.</p>"},{"location":"device-management/docs/XConf/#rdk-feature-control-rfc","title":"RDK Feature Control (RFC)","text":"<p>RFC enables remote feature control without firmware updates, allowing operators to quickly enable/disable features and respond to changing requirements. The system uses sophisticated feature definitions and rule evaluation to determine appropriate feature configurations for different device populations.</p>"},{"location":"device-management/docs/XConf/#feature-definition-and-management","title":"Feature Definition and Management","text":"<p>Features are defined with comprehensive metadata including identifiers, names, configuration parameters, and behavioral specifications. Features can take effect immediately or require device restarts, with support for complex multi-parameter configurations.</p>"},{"location":"device-management/docs/XConf/#rule-based-feature-activation","title":"Rule-Based Feature Activation","text":"<p>Feature Rules determine which devices receive specific features based on device attributes (model, firmware version, location, environment). The system supports priority-based evaluation and feature-specific configuration parameters for different device populations.</p>"},{"location":"device-management/docs/XConf/#whitelisting-and-access-control","title":"Whitelisting and Access Control","text":"<p>Namespaced Lists allow features to be restricted to specific device populations through MAC address, device model, or other identifiers. This enables controlled rollouts, beta testing, and targeted deployments.</p>"},{"location":"device-management/docs/XConf/#dynamic-configuration","title":"Dynamic Configuration","text":"<p>Features marked as \"effective immediate\" can be enabled/disabled in real-time without device restarts, allowing rapid response to operational requirements or emergency situations.</p>"},{"location":"device-management/docs/XConf/#telemetry-system","title":"Telemetry System","text":"<p>XConf provides comprehensive data collection and reporting through both legacy Telemetry 1.0 and modern Telemetry 2.0 architectures. The system enables collection of operational data, performance metrics, and diagnostic information from field devices.</p>"},{"location":"device-management/docs/XConf/#telemetry-10-legacy","title":"Telemetry 1.0 (Legacy)","text":"<p>Uses profile-based data collection with Telemetry Profiles specifying collection frequency, data types, and destinations. Profiles contain Telemetry Elements defining specific collection points including log patterns, system metrics, and custom data sources.</p>"},{"location":"device-management/docs/XConf/#telemetry-20-modern","title":"Telemetry 2.0 (Modern)","text":"<p>Provides flexible, component-driven data collection through JSON-based configurations supporting complex scenarios, modular architectures, and advanced processing. Supports dynamic profile assignment and real-time profile switching based on device characteristics.</p>"},{"location":"device-management/docs/XConf/#rule-based-activation","title":"Rule-Based Activation","text":"<p>Both systems support rule-based activation for applying different telemetry configurations to device populations. Telemetry Rules evaluate device attributes to determine active profiles, enabling targeted data collection for specific populations, regions, or scenarios.</p>"},{"location":"device-management/docs/XConf/#data-collection-and-reporting","title":"Data Collection and Reporting","text":"<p>Supports various collection methods including log monitoring, system metrics, and custom sources. Data can be sent to multiple destinations with different formats and protocols, with scheduling capabilities for optimized network usage.</p>"},{"location":"device-management/docs/XConf/#data-model","title":"Data Model","text":"<p>XConf's data model uses Cassandra's distributed NoSQL architecture to support high-volume, read-heavy workloads typical of device configuration systems. The design emphasizes efficient rule evaluation, fast device lookups, and scalable storage.</p> <p>The system uses a single Cassandra keyspace <code>ApplicationsDiscoveryDataService</code> containing all XConf data. The table structure is optimized for XConf's query patterns with careful partition key design and clustering strategies.</p>"},{"location":"device-management/docs/XConf/#cassandra-keyspaces-tables","title":"Cassandra Keyspaces &amp; Tables","text":"<p>Keyspace: <code>ApplicationsDiscoveryDataService</code></p> <p>Contains all operational data organized into functional area tables designed with Cassandra best practices for even data distribution and efficient queries.</p> <p>Core Tables:</p> <ul> <li><code>FirmwareConfig</code>: Firmware package definitions with metadata and deployment parameters  </li> <li><code>FirmwareRule4</code>: Firmware deployment rules with conditions and priorities  </li> <li><code>DcmRule</code>: Device Configuration Manager rules for operational settings  </li> <li><code>DeviceSettings2</code>: Device operational parameters and schedules  </li> <li><code>FeatureControlRule2</code>: RDK Feature Control rules for feature activation  </li> <li><code>XconfFeature</code>: Feature definitions with parameters and specifications  </li> <li><code>TelemetryTwoProfiles</code>: Modern telemetry profile definitions  </li> <li><code>TelemetryTwoRules</code>: Rules for telemetry profile activation  </li> <li><code>Environment</code>: Environment definitions and parameters  </li> <li><code>Model</code>: Device model registry with capabilities  </li> <li><code>GenericNamespacedList</code>: Reusable lists for whitelists and device groups  </li> </ul>"},{"location":"device-management/docs/XConf/#sample-table-firmwareconfig","title":"Sample Table: <code>FirmwareConfig</code>","text":"<p>The <code>FirmwareConfig</code> table uses Cassandra's wide-row model for efficient firmware configuration storage and retrieval.</p> Column Type Description key text Composite key containing firmware config ID column1 text Grouped sub-key for data organization value blob Serialized configuration data in JSON format <p>Note</p> <p>The compound primary key structure enables efficient queries while the serialized value column contains complete firmware configuration objects, minimizing database queries required for rule evaluation.</p>"},{"location":"device-management/docs/xconf-apis-ui/","title":"XConf APIs &amp; User Interface","text":""},{"location":"device-management/docs/xconf-apis-ui/#api-endpoints","title":"API Endpoints","text":"<p>XConf provides comprehensive API coverage for device operations and administrative management. The design follows RESTful principles while accommodating high-volume device requests and complex administrative operations.</p>"},{"location":"device-management/docs/xconf-apis-ui/#device-facing-endpoints-dataservice","title":"Device-facing Endpoints (DataService)","text":""},{"location":"device-management/docs/xconf-apis-ui/#firmware-update-api","title":"Firmware Update API","text":"Field Details Endpoint <code>/xconf/swu/{applicationType}</code> Purpose Handles firmware update requests by evaluating firmware rules against device attributes. Returns firmware download information or no-update indication. Query Parameters <ul><li><code>eStbMac</code>: Device MAC address (primary identifier)</li><li><code>ipAddress</code>: Device IP address for geographic routing</li><li><code>env</code>: Environment (PROD, QA, DEV)</li><li><code>model</code>: Device model identifier</li><li><code>firmwareVersion</code>: Current firmware version</li><li><code>partnerId</code>: Partner/operator identifier</li><li><code>accountId</code>: Customer account identifier</li><li><code>capabilities</code>: Device capability flags</li><li><code>timeZone</code>: Device timezone</li><li><code>time</code>: Current device time</li></ul> Response Example (click to expand) <pre><code>{\n  \"firmwareDownloadProtocol\": \"http\",\n  \"firmwareFilename\": \"RDKV_2022Q1_sprint.bin\",\n  \"firmwareLocation\": \"http://firmware-server.com/files/\",\n  \"firmwareVersion\": \"RDKV_2022Q1_sprint_20220214040201sdy_VBN\",\n  \"rebootImmediately\": false,\n  \"upgradeDelay\": 3600\n}\n</code></pre>"},{"location":"device-management/docs/xconf-apis-ui/#dcm-settings-api","title":"DCM Settings API","text":"Field Details Endpoint <code>/loguploader/getSettings/{applicationType}</code> Purpose Provides device configuration and logging settings based on DCM rules. Returns comprehensive configuration data including cron schedules, upload destinations, and operational parameters formatted for device consumption. Query Parameters <ul><li><code>estbMacAddress</code>: Device MAC address</li><li><code>ipAddress</code>: Device IP address</li><li><code>env</code>: Environment identifier</li><li><code>model</code>: Device model</li><li><code>firmwareVersion</code>: Current firmware</li><li><code>partnerId</code>: Partner identifier</li><li><code>accountId</code>: Account identifier</li><li><code>version</code>: API version</li></ul> Response Example (click to expand) <pre><code>{\n  \"urn:settings:GroupName\": \"ProductionGroup\",\n  \"urn:settings:CheckOnReboot\": true,\n  \"urn:settings:CheckSchedule:cron\": \"0 2 * * *\",\n  \"urn:settings:LogUploadSettings:NumberOfDays\": 7,\n  \"urn:settings:LogUploadSettings:UploadRepository:URL\": \"https://logs.example.com/upload\",\n  \"urn:settings:LogUploadSettings:UploadOnReboot\": true\n}\n</code></pre>"},{"location":"device-management/docs/xconf-apis-ui/#feature-control-api","title":"Feature Control API","text":"Field Details Endpoint <code>/featureControl/getSettings/{applicationType}</code> Purpose Delivers feature control settings based on RFC rules. Evaluates feature rules against device attributes to determine enabled features, configuration parameters, and whitelist restrictions. Query Parameters <ul><li><code>estbMacAddress</code>: Device MAC address</li><li><code>ipAddress</code>: Device IP address</li><li><code>env</code>: Environment</li><li><code>model</code>: Device model</li><li><code>firmwareVersion</code>: Current firmware</li><li><code>partnerId</code>: Partner identifier</li><li><code>accountId</code>: Account identifier</li></ul> Response Example (click to expand) <pre><code>{\n  \"featureControl\": {\n    \"features\": [\n      {\n        \"name\": \"FEATURE_BLUETOOTH\",\n        \"featureName\": \"bluetooth_support\",\n        \"effectiveImmediate\": true,\n        \"enable\": true,\n        \"configData\": {\n          \"maxConnections\": \"4\",\n          \"timeout\": \"30\"\n        }\n      }\n    ]\n  }\n}\n</code></pre>"},{"location":"device-management/docs/xconf-apis-ui/#admin-endpoints-admin-service","title":"Admin Endpoints (Admin Service)","text":"<p>The administrative APIs provide comprehensive management capabilities with proper authentication, authorization, and validation for secure configuration management. These endpoints support the full lifecycle of configuration management operations.</p>"},{"location":"device-management/docs/xconf-apis-ui/#management-apis","title":"Management APIs","text":"<p>Base Endpoint: <code>/xconfAdminService/*</code></p> <p>The Admin Service provides full CRUD operations for all configuration types including firmware configs/rules, DCM settings, RFC features, and telemetry profiles. All endpoints include validation logic, testing capabilities, and bulk operations for efficient administration.</p> <p>Firmware Management APIs:</p> <ul> <li><code>GET/POST/PUT/DELETE /firmwareconfig</code> \u2014 Firmware configuration management  </li> <li><code>GET/POST/PUT/DELETE /firmwarerule</code> \u2014 Firmware rule management  </li> <li><code>POST /firmwarerule/testpage</code> \u2014 Rule testing and validation  </li> </ul> <p>DCM Management APIs:</p> <ul> <li><code>GET/POST/PUT/DELETE /dcm/deviceSettings</code> \u2014 Device settings management  </li> <li><code>GET/POST/PUT/DELETE /dcm/uploadRepository</code> \u2014 Upload repository management  </li> <li><code>POST /dcm/formula/testpage</code> \u2014 DCM rule testing  </li> </ul> <p>RFC Management APIs:</p> <ul> <li><code>GET/POST/PUT/DELETE /rfc/feature</code> \u2014 Feature definition management  </li> <li><code>GET/POST/PUT/DELETE /rfc/featurerule</code> \u2014 Feature rule management  </li> <li><code>POST /rfc/featurerule/testpage</code> \u2014 Feature rule testing  </li> </ul> <p>Telemetry Management APIs:</p> <ul> <li><code>GET/POST/PUT/DELETE /telemetry/profile</code> \u2014 Telemetry profile management  </li> <li><code>GET/POST/PUT/DELETE /telemetry/rule</code> \u2014 Telemetry rule management  </li> </ul> <p>Common Features:</p> <ul> <li>Authentication token validation for all operations  </li> <li>Role-based access control with application type isolation  </li> <li>Comprehensive input validation and sanitization  </li> <li>Bulk operations for efficient large-scale management  </li> <li>Export/import capabilities for configuration migration  </li> <li>Testing endpoints for rule validation before deployment</li> </ul>"},{"location":"device-management/docs/xconf-apis-ui/#user-interface-xconf-ui","title":"User Interface (XConf UI)","text":"<p>The XConf UI provides a comprehensive web-based management console built with AngularJS and modern web technologies. It offers intuitive forms, visual rule builders, and testing capabilities designed for operators with varying technical expertise.</p> <p>The interface uses progressive disclosure principles, presenting simple interfaces for common operations while providing access to advanced features when needed. It includes extensive validation, real-time feedback, and preview capabilities.</p>"},{"location":"device-management/docs/xconf-apis-ui/#main-modules","title":"Main Modules","text":""},{"location":"device-management/docs/xconf-apis-ui/#firmware-management","title":"Firmware Management","text":"<p>Purpose: Comprehensive tools for managing firmware deployments across device populations.</p> <p>Key Features:</p> <ul> <li>Visual rule builders with drag-and-drop interfaces</li> <li>Form-based condition editors for complex rule creation</li> <li>Firmware configuration management with metadata editing</li> <li>Testing capabilities for simulating device requests</li> <li>Bulk operations for managing large rule sets</li> <li>Export/import capabilities for configuration migration</li> <li>Real-time validation and preview of rule behavior</li> </ul> <p>Workflows:</p> <ul> <li>Create firmware configurations with version and compatibility information</li> <li>Define deployment rules with conditional logic and targeting</li> <li>Test rules against simulated device requests</li> <li>Deploy configurations with percentage-based rollouts</li> <li>Monitor deployment status and device responses</li> </ul>"},{"location":"device-management/docs/xconf-apis-ui/#dcm-management","title":"DCM Management","text":"<p>Purpose: Intuitive tools for device operational settings, logging configurations, and upload repositories.</p> <p>Key Features:</p> <ul> <li>Schedule builders for creating cron expressions visually</li> <li>Repository configuration wizards for upload destinations</li> <li>Device settings management with operational parameters</li> <li>Log upload configuration with file selection and retention</li> <li>Validation tools for configuration consistency</li> <li>Real-time preview showing how configurations appear to devices</li> </ul> <p>Workflows:</p> <ul> <li>Configure device operational schedules and policies</li> <li>Set up log collection and upload repositories</li> <li>Define VOD settings for video services</li> <li>Test DCM configurations against device profiles</li> <li>Monitor device compliance with configuration settings</li> </ul>"},{"location":"device-management/docs/xconf-apis-ui/#rfc-management","title":"RFC Management","text":"<p>Purpose: Comprehensive tools for feature definitions, rules, and whitelist configurations.</p> <p>Key Features:</p> <ul> <li>Visual feature builders for complex feature definitions</li> <li>Rule editors with support for complex conditional logic</li> <li>Whitelist management tools for device targeting</li> <li>Feature testing capabilities for simulating requests</li> <li>Bulk feature operations for large-scale management</li> <li>Priority management for feature rule conflicts</li> </ul> <p>Workflows:</p> <ul> <li>Define features with configuration parameters</li> <li>Create feature rules with device targeting logic</li> <li>Manage whitelists for controlled feature rollouts</li> <li>Test feature activation against device scenarios</li> <li>Monitor feature deployment and device adoption</li> </ul>"},{"location":"device-management/docs/xconf-apis-ui/#namespaced-list-editor","title":"Namespaced List Editor","text":"<p>Purpose: Specialized tools for creating and managing reusable lists referenced across multiple configurations.</p> <p>Key Features:</p> <ul> <li>Support for various list types (MAC addresses, IP addresses, generic values)</li> <li>Import/export capabilities for bulk list management</li> <li>Validation tools ensuring list consistency and format compliance</li> <li>Cross-reference tracking showing where lists are used</li> <li>Bulk editing operations for large lists</li> </ul> <p>Workflows:</p> <ul> <li>Create and maintain device whitelists</li> <li>Import device lists from external sources</li> <li>Validate list formats and content</li> <li>Track list usage across configurations</li> <li>Update lists with bulk operations</li> </ul>"},{"location":"device-management/docs/xconf-apis-ui/#monitoring-and-diagnostics","title":"Monitoring and Diagnostics","text":"<p>Purpose: Real-time visibility into system health, performance metrics, and operational status.</p> <p>Key Features:</p> <ul> <li>System health dashboards with key performance indicators</li> <li>Error tracking and diagnostic tools for troubleshooting</li> <li>Comprehensive logging with searchable audit trails</li> <li>Performance metrics monitoring for system optimization</li> <li>Alerting capabilities for critical events and thresholds</li> <li>Configuration change tracking and approval workflows</li> </ul> <p>Workflows:</p> <ul> <li>Monitor system performance and health metrics</li> <li>Track configuration changes and their impacts</li> <li>Investigate issues using diagnostic tools</li> <li>Set up alerts for critical system events</li> <li>Generate reports for compliance and analysis</li> </ul>"},{"location":"device-management/docs/xconf-apis-ui/#main-modules_1","title":"Main Modules","text":"Module Purpose Key Features Workflows Firmware Management Comprehensive tools for managing firmware deployments across device populations. <ul><li>Visual rule builders with drag-and-drop interfaces</li><li>Form-based condition editors</li><li>Metadata editing for firmware configurations</li><li>Simulated device request testing</li><li>Bulk rule operations</li><li>Export/import support</li><li>Real-time rule validation</li></ul> <ul><li>Create firmware configurations with version info</li><li>Define deployment rules with logic</li><li>Test rules on simulated devices</li><li>Deploy with % rollouts</li><li>Monitor deployments</li></ul> DCM Management Intuitive tools for device operational settings, logging configurations, and upload repositories. <ul><li>Cron schedule builders</li><li>Repository configuration wizards</li><li>Device settings editors</li><li>Log upload config</li><li>Validation tools</li><li>Real-time previews</li></ul> <ul><li>Configure operational policies</li><li>Set up logs &amp; repositories</li><li>Define VOD settings</li><li>Test DCM profiles</li><li>Monitor device compliance</li></ul> RFC Management Comprehensive tools for feature definitions, rules, and whitelist configurations. <ul><li>Visual feature builders</li><li>Conditional rule editors</li><li>Whitelist tools</li><li>Feature simulation testing</li><li>Bulk operations</li><li>Priority management</li></ul> <ul><li>Define features configs</li><li>Create targeting rules</li><li>Manage whitelists</li><li>Simulate feature activation</li><li>Track feature rollout</li></ul> Namespaced List Editor Specialized tools for creating and managing reusable lists used across configurations. <ul><li>Supports MAC/IP/generic types</li><li>Import/export capabilities</li><li>List validation</li><li>Cross-reference tracking</li><li>Bulk editing</li></ul> <ul><li>Create and manage whitelists</li><li>Import external lists</li><li>Validate content</li><li>Track usage across configs</li><li>Update lists in bulk</li></ul> Monitoring &amp; Diagnostics Real-time visibility into system health, performance metrics, and operational status. <ul><li>Dashboards &amp; KPIs</li><li>Error tracking &amp; diagnostics</li><li>Audit logs</li><li>Performance metrics</li><li>Alerting tools</li><li>Change tracking workflows</li></ul> <ul><li>Monitor system health</li><li>Track config changes</li><li>Investigate diagnostics</li><li>Set alerts for events</li><li>Generate reports</li></ul>"},{"location":"device-management/docs/xconf-apis-ui/#integration-use-cases-and-examples","title":"Integration Use Cases and Examples","text":"<p>XConf's comprehensive API architecture enables extensive integration with external systems, third-party tools, and enterprise infrastructure. Below are the primary integration use cases and real-world implementation examples.</p>"},{"location":"device-management/docs/xconf-apis-ui/#integration-use-cases","title":"Integration Use Cases","text":"<p>1. Device Management and Orchestration - Automated firmware deployment through CI/CD pipelines - Device configuration management via external orchestration tools - Real-time feature control and A/B testing platforms - Device health monitoring and diagnostic data collection</p> <p>2. Enterprise Monitoring and Observability - System performance monitoring with metrics collection - Log aggregation and analytics for operational intelligence - Real-time alerting and incident management - Business intelligence and firmware penetration analytics</p> <p>3. External Service Integration - Authentication and authorization with enterprise identity providers - Integration with device management platforms and account services - Third-party tagging and metadata enrichment services - Service mesh and microservices communication</p> <p>4. Infrastructure and Operations - Load balancing and high availability configurations - Backup and disaster recovery automation - Configuration change notifications and approval workflows - Compliance reporting and audit trail management</p> <p>5. Development and Deployment Workflows - Automated testing and validation of configuration changes - Staged deployment and rollback mechanisms - Environment promotion and configuration migration - Quality assurance and testing automation</p>"},{"location":"device-management/docs/xconf-apis-ui/#device-integration","title":"Device Integration","text":"<p>XConf is designed to integrate seamlessly with RDK devices through standardized API calls. Devices typically implement periodic configuration checks and event-driven updates.</p> <p>STB Firmware Update Client Example: <pre><code>#!/bin/bash\n# STB firmware update script\n\nXCONF_URL=\"http://xconf-server:9000\"\nMAC_ADDRESS=$(cat /sys/class/net/eth0/address)\nMODEL=$(cat /proc/device-tree/model)\nCURRENT_FW=$(cat /version.txt)\n\n# Request firmware update\nRESPONSE=$(curl -s \"${XCONF_URL}/xconf/swu/stb\" \\\n  -G \\\n  --data-urlencode \"eStbMac=${MAC_ADDRESS}\" \\\n  --data-urlencode \"model=${MODEL}\" \\\n  --data-urlencode \"firmwareVersion=${CURRENT_FW}\" \\\n  --data-urlencode \"env=PROD\")\n\n# Parse response and download if update available\nif echo \"$RESPONSE\" | grep -q \"firmwareLocation\"; then\n    DOWNLOAD_URL=$(echo \"$RESPONSE\" | jq -r '.firmwareLocation + .firmwareFilename')\n    wget \"$DOWNLOAD_URL\" -O /tmp/firmware.bin\n    # Install firmware and reboot\n    install_firmware /tmp/firmware.bin\nfi\n</code></pre></p> <p>Feature Control Integration: <pre><code>// JavaScript client for feature control\nclass XConfFeatureClient {\n    constructor(baseUrl, deviceInfo) {\n        this.baseUrl = baseUrl;\n        this.deviceInfo = deviceInfo;\n    }\n\n    async getFeatures() {\n        const params = new URLSearchParams(this.deviceInfo);\n        const response = await fetch(\n            `${this.baseUrl}/featureControl/getSettings/stb?${params}`\n        );\n        const data = await response.json();\n        return data.featureControl.features;\n    }\n\n    async isFeatureEnabled(featureName) {\n        const features = await this.getFeatures();\n        const feature = features.find(f =&gt; f.featureName === featureName);\n        return feature &amp;&amp; feature.enable;\n    }\n}\n\n// Usage example\nconst client = new XConfFeatureClient('http://xconf-server:9000', {\n    estbMacAddress: 'AA:BB:CC:DD:EE:FF',\n    model: 'STB_MODEL_X1',\n    env: 'PROD'\n});\n\nif (await client.isFeatureEnabled('bluetooth_support')) {\n    enableBluetooth();\n}\n</code></pre></p>"},{"location":"device-management/docs/xconf-apis-ui/#third-party-integration-examples","title":"Third-party Integration Examples","text":"<p>XConf provides extensive integration capabilities with external systems through its APIs, metrics endpoints, and external service connectors. Below are the comprehensive third-party integration examples organized by use case:</p>"},{"location":"device-management/docs/xconf-apis-ui/#use-case-1-enterprise-monitoring-and-observability","title":"Use Case 1: Enterprise Monitoring and Observability","text":"<p>Real-world Scenario: Monitor XConf system performance, track firmware deployment success rates, and alert on system issues.</p> <p>Prometheus Metrics Integration: XConf exposes comprehensive Prometheus metrics through dedicated <code>/metrics</code> endpoints on both DataService and Admin Service:</p> <pre><code># prometheus.yml configuration\nscrape_configs:\n  - job_name: 'xconf-dataservice'\n    static_configs:\n      - targets: ['localhost:9000']\n    metrics_path: '/metrics'\n    scrape_interval: 30s\n    metrics_path: '/metrics'\n\n  - job_name: 'xconf-admin'\n    static_configs:\n      - targets: ['localhost:9001']\n    metrics_path: '/metrics'\n    scrape_interval: 30s\n\n# Custom metric collection for XConf-specific metrics\n  - job_name: 'xconf-firmware-penetration'\n    static_configs:\n      - targets: ['localhost:9000']\n    metrics_path: '/metrics'\n    scrape_interval: 60s\n    metric_relabel_configs:\n      - source_labels: [__name__]\n        regex: 'xconf_firmware_penetration_counts'\n        target_label: __name__\n        replacement: 'firmware_deployment_stats'\n</code></pre> <p>Available XConf Metrics: - <code>api_requests_total</code> - Total API requests with labels for app, status code, method, path - <code>api_request_duration_seconds</code> - Request latency histograms - <code>external_api_count</code> - External service call counts (SAT, Device Service, Account Service) - <code>external_api_request_duration_seconds</code> - External API call latencies - <code>xconf_firmware_penetration_counts</code> - Firmware deployment statistics by partner/model/version - <code>in_flight_requests</code> - Current concurrent requests - <code>request_size_bytes</code> / <code>response_size_bytes</code> - Request/response size histograms - <code>log_counter</code> - Log event counters by type</p> <p>Grafana Dashboard Integration: <pre><code>{\n  \"dashboard\": {\n    \"title\": \"XConf System Monitoring\",\n    \"panels\": [\n      {\n        \"title\": \"Firmware Update Requests\",\n        \"type\": \"graph\",\n        \"targets\": [\n          {\n            \"expr\": \"rate(api_requests_total{path=\\\"/xconf/swu/{applicationType}\\\"}[5m])\",\n            \"legendFormat\": \"{{method}} {{code}}\"\n          }\n        ]\n      },\n      {\n        \"title\": \"Firmware Penetration by Model\",\n        \"type\": \"piechart\",\n        \"targets\": [\n          {\n            \"expr\": \"xconf_firmware_penetration_counts\",\n            \"legendFormat\": \"{{model}} - {{fw_version}}\"\n          }\n        ]\n      }\n    ]\n  }\n}\n</code></pre></p>"},{"location":"device-management/docs/xconf-apis-ui/#use-case-2-external-service-integration","title":"Use Case 2: External Service Integration","text":"<p>Real-world Scenario: Integrate XConf with enterprise services for authentication, device management, and account information.</p> <p>SAT (Service Access Token) Integration: XConf integrates with SAT service for secure token management:</p> <pre><code>// SAT Service Configuration\nsat {\n    SAT_REFRESH_FREQUENCY_IN_HOUR = 6\n    SAT_REFRESH_BUFFER_IN_MINS = 15\n    host = \"https://sat-service.example.com\"\n    SatOn = true\n}\n</code></pre> <p>Device Service Integration: For device metadata and account information:</p> <pre><code>// Device Service Connector Configuration\nxconfwebconfig {\n    device_service {\n        host = \"https://device-service.example.com\"\n        timeout = \"30s\"\n        retry_attempts = 3\n    }\n}\n</code></pre> <p>Account Service Integration: For customer account and timezone information:</p> <pre><code>// Account Service Configuration\nxconfwebconfig {\n    account_service {\n        host = \"https://account-service.example.com\"\n        timeout = \"30s\"\n    }\n}\n</code></pre> <p>Tagging Service Integration: For dynamic device tagging and context enrichment:</p> <pre><code>// Tagging Service Configuration\nxconfwebconfig {\n    tagging_service {\n        host = \"https://tagging-service.example.com\"\n        enable_tagging_service = true\n        enable_tagging_service_rfc = true\n    }\n}\n</code></pre>"},{"location":"device-management/docs/xconf-apis-ui/#use-case-3-devops-and-cicd-integration","title":"Use Case 3: DevOps and CI/CD Integration","text":"<p>Real-world Scenario: Automate firmware deployments and configuration management through CI/CD pipelines.</p> <p>Jenkins Pipeline Integration: <pre><code>pipeline {\n    agent any\n    stages {\n        stage('Deploy Firmware Config') {\n            steps {\n                script {\n                    // Create firmware configuration\n                    def firmwareConfig = [\n                        firmwareVersion: \"${BUILD_NUMBER}\",\n                        firmwareFilename: \"firmware-${BUILD_NUMBER}.bin\",\n                        firmwareLocation: \"https://cdn.example.com/firmware/\",\n                        supportedModelIds: [\"MODEL_X1\", \"MODEL_X2\"]\n                    ]\n\n                    // Deploy to XConf Admin API\n                    httpRequest(\n                        httpMode: 'POST',\n                        url: 'http://xconf-admin:9001/xconfAdminService/firmwareconfig',\n                        contentType: 'APPLICATION_JSON',\n                        requestBody: groovy.json.JsonBuilder(firmwareConfig).toString(),\n                        authentication: 'xconf-api-token'\n                    )\n                }\n            }\n        }\n\n        stage('Create Deployment Rule') {\n            steps {\n                script {\n                    // Create percentage-based rollout rule\n                    def deploymentRule = [\n                        name: \"Firmware ${BUILD_NUMBER} Rollout\",\n                        condition: [\n                            freeArg: [type: \"STRING\", name: \"env\"],\n                            operation: \"IS\",\n                            fixedArg: [bean: [value: [\"java.lang.String\": \"QA\"]]]\n                        ],\n                        percentage: 10, // Start with 10% rollout\n                        firmwareConfig: firmwareConfig.id\n                    ]\n\n                    httpRequest(\n                        httpMode: 'POST',\n                        url: 'http://xconf-admin:9001/xconfAdminService/firmwarerule',\n                        contentType: 'APPLICATION_JSON',\n                        requestBody: groovy.json.JsonBuilder(deploymentRule).toString()\n                    )\n                }\n            }\n        }\n    }\n}\n</code></pre></p>"},{"location":"device-management/docs/xconf-apis-ui/#use-case-4-high-availability-and-load-balancing","title":"Use Case 4: High Availability and Load Balancing","text":"<p>Real-world Scenario: Deploy XConf in high-availability configuration with load balancing and health monitoring.</p> <p>HAProxy Configuration: <pre><code># HAProxy configuration for XConf services\nglobal\n    daemon\n\ndefaults\n    mode http\n    timeout connect 5000ms\n    timeout client 50000ms\n    timeout server 50000ms\n\n# XConf DataService Backend\nbackend xconf-dataservice\n    balance roundrobin\n    option httpchk GET /healthz\n    server xconf-ds1 10.0.1.10:9000 check\n    server xconf-ds2 10.0.1.11:9000 check\n    server xconf-ds3 10.0.1.12:9000 check\n\n# XConf Admin Backend\nbackend xconf-admin\n    balance roundrobin\n    option httpchk GET /healthz\n    server xconf-admin1 10.0.1.20:9001 check\n    server xconf-admin2 10.0.1.21:9001 check\n\n# Frontend configuration\nfrontend xconf-frontend\n    bind *:80\n    bind *:443 ssl crt /etc/ssl/certs/xconf.pem\n\n    # Route device requests to DataService\n    acl is_device_request path_beg /xconf/swu /loguploader /featureControl\n    use_backend xconf-dataservice if is_device_request\n\n    # Route admin requests to Admin Service\n    acl is_admin_request path_beg /xconfAdminService\n    use_backend xconf-admin if is_admin_request\n</code></pre></p> <p>NGINX Configuration: <pre><code>upstream xconf_dataservice {\n    server 10.0.1.10:9000 max_fails=3 fail_timeout=30s;\n    server 10.0.1.11:9000 max_fails=3 fail_timeout=30s;\n    server 10.0.1.12:9000 max_fails=3 fail_timeout=30s;\n}\n\nupstream xconf_admin {\n    server 10.0.1.20:9001 max_fails=3 fail_timeout=30s;\n    server 10.0.1.21:9001 max_fails=3 fail_timeout=30s;\n}\n\nserver {\n    listen 80;\n    server_name xconf.example.com;\n\n    # Health check endpoint\n    location /health {\n        access_log off;\n        return 200 \"healthy\\n\";\n        add_header Content-Type text/plain;\n    }\n\n    # Device API routing\n    location ~ ^/(xconf|loguploader|featureControl) {\n        proxy_pass http://xconf_dataservice;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header HA-Haproxy-xconf-http \"secure\";\n\n        # Health check for upstream\n        proxy_next_upstream error timeout http_500 http_502 http_503;\n        proxy_connect_timeout 5s;\n        proxy_send_timeout 30s;\n        proxy_read_timeout 30s;\n    }\n\n    # Admin API routing\n    location /xconfAdminService {\n        proxy_pass http://xconf_admin;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n    }\n}\n</code></pre></p>"},{"location":"device-management/docs/xconf-apis-ui/#use-case-5-log-analytics-and-business-intelligence","title":"Use Case 5: Log Analytics and Business Intelligence","text":"<p>Real-world Scenario: Aggregate XConf logs for operational analytics, troubleshooting, and business intelligence.</p> <p>ELK Stack Integration: <pre><code># logstash.conf configuration for XConf logs\ninput {\n  file {\n    path =&gt; \"/var/log/xconf/xconfwebconfig.log\"\n    type =&gt; \"xconf-dataservice\"\n    codec =&gt; \"json\"\n    start_position =&gt; \"beginning\"\n  }\n\n  file {\n    path =&gt; \"/var/log/xconf/xconfadmin.log\"\n    type =&gt; \"xconf-admin\"\n    codec =&gt; \"json\"\n    start_position =&gt; \"beginning\"\n  }\n}\n\nfilter {\n  if [type] == \"xconf-dataservice\" {\n    mutate {\n      add_field =&gt; {\n        \"service\" =&gt; \"xconf-dataservice\"\n        \"component\" =&gt; \"device-api\"\n      }\n    }\n\n    # Parse firmware request logs\n    if [path] =~ /\\/xconf\\/swu/ {\n      mutate {\n        add_field =&gt; { \"request_type\" =&gt; \"firmware_update\" }\n      }\n\n      # Extract device information\n      grok {\n        match =&gt; { \"message\" =&gt; \"eStbMac=%{MAC:device_mac}\" }\n      }\n      grok {\n        match =&gt; { \"message\" =&gt; \"model=%{WORD:device_model}\" }\n      }\n    }\n  }\n\n  if [type] == \"xconf-admin\" {\n    mutate {\n      add_field =&gt; {\n        \"service\" =&gt; \"xconf-admin\"\n        \"component\" =&gt; \"admin-api\"\n      }\n    }\n  }\n\n  # Add geolocation based on IP\n  if [ipAddress] {\n    geoip {\n      source =&gt; \"ipAddress\"\n      target =&gt; \"geoip\"\n    }\n  }\n}\n\noutput {\n  elasticsearch {\n    hosts =&gt; [\"elasticsearch:9200\"]\n    index =&gt; \"xconf-%{+YYYY.MM.dd}\"\n    template_name =&gt; \"xconf\"\n    template_pattern =&gt; \"xconf-*\"\n    template =&gt; \"/etc/logstash/templates/xconf-template.json\"\n  }\n\n  # Send critical errors to alerting system\n  if [level] == \"ERROR\" {\n    http {\n      url =&gt; \"https://alertmanager.example.com/api/v1/alerts\"\n      http_method =&gt; \"post\"\n      format =&gt; \"json\"\n      mapping =&gt; {\n        \"alerts\" =&gt; [{\n          \"labels\" =&gt; {\n            \"alertname\" =&gt; \"XConfError\"\n            \"service\" =&gt; \"%{service}\"\n            \"severity\" =&gt; \"critical\"\n          }\n          \"annotations\" =&gt; {\n            \"summary\" =&gt; \"%{message}\"\n            \"description\" =&gt; \"XConf error in %{service}: %{message}\"\n          }\n        }]\n      }\n    }\n  }\n}\n</code></pre></p>"},{"location":"device-management/docs/xconf-apis-ui/#use-case-6-event-driven-integration-and-notifications","title":"Use Case 6: Event-Driven Integration and Notifications","text":"<p>Real-world Scenario: Implement real-time notifications and event-driven workflows for configuration changes and system alerts.</p> <p>Webhook and Event-Driven Integration: <pre><code>// Configuration Change Webhook for Slack notifications\ntype WebhookPayload struct {\n    Event       string                 `json:\"event\"`\n    Timestamp   time.Time             `json:\"timestamp\"`\n    Service     string                `json:\"service\"`\n    EntityType  string                `json:\"entity_type\"`\n    EntityID    string                `json:\"entity_id\"`\n    Changes     map[string]interface{} `json:\"changes\"`\n    User        string                `json:\"user\"`\n}\n\nfunc NotifyConfigurationChange(entityType, entityID, user string, changes map[string]interface{}) {\n    slackPayload := map[string]interface{}{\n        \"text\": \"XConf Configuration Change Alert\",\n        \"attachments\": []map[string]interface{}{\n            {\n                \"color\": \"warning\",\n                \"fields\": []map[string]interface{}{\n                    {\"title\": \"Entity Type\", \"value\": entityType, \"short\": true},\n                    {\"title\": \"Entity ID\", \"value\": entityID, \"short\": true},\n                    {\"title\": \"Modified By\", \"value\": user, \"short\": true},\n                    {\"title\": \"Timestamp\", \"value\": time.Now().Format(time.RFC3339), \"short\": true},\n                },\n            },\n        },\n    }\n\n    // Send to Slack webhook\n    http.Post(\"https://hooks.slack.com/services/YOUR/SLACK/WEBHOOK\",\n              \"application/json\",\n              bytes.NewBuffer(jsonPayload))\n}\n</code></pre></p> <p>PagerDuty Integration: <pre><code># alertmanager.yml configuration for XConf alerts\nroute:\n  group_by: ['alertname']\n  group_wait: 10s\n  group_interval: 10s\n  repeat_interval: 1h\n  receiver: 'xconf-alerts'\n\nreceivers:\n- name: 'xconf-alerts'\n  pagerduty_configs:\n  - service_key: 'YOUR_PAGERDUTY_SERVICE_KEY'\n    description: 'XConf System Alert: {{ .GroupLabels.alertname }}'\n    details:\n      service: '{{ .CommonLabels.service }}'\n      severity: '{{ .CommonLabels.severity }}'\n      summary: '{{ .CommonAnnotations.summary }}'\n\n# Prometheus alerting rules for XConf\ngroups:\n- name: xconf.rules\n  rules:\n  - alert: XConfHighErrorRate\n    expr: rate(api_requests_total{code=~\"5..\"}[5m]) &gt; 0.1\n    for: 2m\n    labels:\n      severity: critical\n      service: xconf\n    annotations:\n      summary: \"High error rate detected in XConf\"\n      description: \"XConf is experiencing {{ $value }} errors per second\"\n\n  - alert: XConfServiceDown\n    expr: up{job=~\"xconf-.*\"} == 0\n    for: 1m\n    labels:\n      severity: critical\n      service: xconf\n    annotations:\n      summary: \"XConf service is down\"\n      description: \"XConf service {{ $labels.job }} has been down for more than 1 minute\"\n</code></pre></p>"},{"location":"device-management/docs/xconf-apis-ui/#use-case-7-configuration-management-and-gitops","title":"Use Case 7: Configuration Management and GitOps","text":"<p>Real-world Scenario: Implement GitOps workflows for XConf configuration management with version control and automated deployments.</p> <p>GitLab CI/CD Integration: <pre><code># .gitlab-ci.yml for XConf configuration management\nstages:\n  - validate\n  - deploy-staging\n  - deploy-production\n\nvariables:\n  XCONF_ADMIN_URL: \"https://xconf-admin.example.com\"\n\nvalidate-config:\n  stage: validate\n  script:\n    - |\n      # Validate firmware configuration JSON\n      for config in configs/firmware/*.json; do\n        echo \"Validating $config\"\n        jq empty \"$config\" || exit 1\n\n        # Test configuration against XConf Admin API\n        curl -X POST \"$XCONF_ADMIN_URL/xconfAdminService/firmwareconfig/testpage\" \\\n          -H \"Authorization: Bearer $XCONF_API_TOKEN\" \\\n          -H \"Content-Type: application/json\" \\\n          -d @\"$config\" \\\n          --fail\n      done\n\ndeploy-staging:\n  stage: deploy-staging\n  script:\n    - |\n      # Deploy to staging environment\n      for config in configs/firmware/*.json; do\n        CONFIG_ID=$(jq -r '.id' \"$config\")\n\n        # Update existing or create new configuration\n        curl -X PUT \"$XCONF_ADMIN_URL/xconfAdminService/firmwareconfig\" \\\n          -H \"Authorization: Bearer $XCONF_API_TOKEN\" \\\n          -H \"Content-Type: application/json\" \\\n          -d @\"$config\" \\\n          --fail\n\n        echo \"Deployed firmware config: $CONFIG_ID\"\n      done\n  environment:\n    name: staging\n  only:\n    - develop\n\ndeploy-production:\n  stage: deploy-production\n  script:\n    - |\n      # Deploy to production with approval\n      for config in configs/firmware/*.json; do\n        CONFIG_ID=$(jq -r '.id' \"$config\")\n\n        # Create deployment with percentage rollout\n        ROLLOUT_CONFIG=$(jq '. + {\"percentage\": 5}' \"$config\")\n\n        curl -X PUT \"$XCONF_ADMIN_URL/xconfAdminService/firmwareconfig\" \\\n          -H \"Authorization: Bearer $XCONF_API_TOKEN\" \\\n          -H \"Content-Type: application/json\" \\\n          -d \"$ROLLOUT_CONFIG\" \\\n          --fail\n\n        echo \"Deployed firmware config to production: $CONFIG_ID (5% rollout)\"\n      done\n  environment:\n    name: production\n  when: manual\n  only:\n    - main\n</code></pre></p> <p>Terraform Integration for Infrastructure as Code: <pre><code># terraform/xconf-infrastructure.tf\nresource \"kubernetes_deployment\" \"xconf_dataservice\" {\n  metadata {\n    name = \"xconf-dataservice\"\n    namespace = \"xconf\"\n  }\n\n  spec {\n    replicas = 3\n\n    selector {\n      match_labels = {\n        app = \"xconf-dataservice\"\n      }\n    }\n\n    template {\n      metadata {\n        labels = {\n          app = \"xconf-dataservice\"\n        }\n        annotations = {\n          \"prometheus.io/scrape\" = \"true\"\n          \"prometheus.io/port\" = \"9000\"\n          \"prometheus.io/path\" = \"/metrics\"\n        }\n      }\n\n      spec {\n        container {\n          name = \"xconf-dataservice\"\n          image = \"xconf/dataservice:${var.xconf_version}\"\n\n          port {\n            container_port = 9000\n            name = \"http\"\n          }\n\n          env {\n            name = \"CASSANDRA_HOSTS\"\n            value = \"${var.cassandra_hosts}\"\n          }\n\n          env {\n            name = \"TOKEN_API_ENABLED\"\n            value = \"true\"\n          }\n\n          liveness_probe {\n            http_get {\n              path = \"/healthz\"\n              port = 9000\n            }\n            initial_delay_seconds = 30\n            period_seconds = 10\n          }\n\n          readiness_probe {\n            http_get {\n              path = \"/healthz\"\n              port = 9000\n            }\n            initial_delay_seconds = 5\n            period_seconds = 5\n          }\n        }\n      }\n    }\n  }\n}\n\nresource \"kubernetes_service\" \"xconf_dataservice\" {\n  metadata {\n    name = \"xconf-dataservice\"\n    namespace = \"xconf\"\n    annotations = {\n      \"service.beta.kubernetes.io/aws-load-balancer-type\" = \"nlb\"\n    }\n  }\n\n  spec {\n    selector = {\n      app = \"xconf-dataservice\"\n    }\n\n    port {\n      port = 80\n      target_port = 9000\n      protocol = \"TCP\"\n    }\n\n    type = \"LoadBalancer\"\n  }\n}\n</code></pre></p>"},{"location":"device-management/docs/xconf-apis-ui/#use-case-8-business-intelligence-and-analytics","title":"Use Case 8: Business Intelligence and Analytics","text":"<p>Real-world Scenario: Extract business insights from XConf data for firmware adoption analysis and device management optimization.</p> <p>Apache Airflow DAG for Data Pipeline: <pre><code># airflow/dags/xconf_analytics_pipeline.py\nfrom airflow import DAG\nfrom airflow.operators.python_operator import PythonOperator\nfrom airflow.operators.bash_operator import BashOperator\nfrom datetime import datetime, timedelta\nimport requests\nimport pandas as pd\n\ndefault_args = {\n    'owner': 'data-team',\n    'depends_on_past': False,\n    'start_date': datetime(2023, 1, 1),\n    'email_on_failure': True,\n    'email_on_retry': False,\n    'retries': 1,\n    'retry_delay': timedelta(minutes=5)\n}\n\ndag = DAG(\n    'xconf_analytics_pipeline',\n    default_args=default_args,\n    description='XConf data analytics pipeline',\n    schedule_interval='@daily',\n    catchup=False\n)\n\ndef extract_firmware_penetration():\n    \"\"\"Extract firmware penetration data from XConf metrics\"\"\"\n    response = requests.get('http://xconf-dataservice:9000/metrics')\n    metrics_data = response.text\n\n    # Parse Prometheus metrics for firmware penetration\n    penetration_data = []\n    for line in metrics_data.split('\\n'):\n        if 'xconf_firmware_penetration_counts' in line and not line.startswith('#'):\n            # Parse metric line: xconf_firmware_penetration_counts{model=\"X1\",fw_version=\"1.0\"} 1500\n            parts = line.split(' ')\n            value = int(parts[1])\n            labels = parts[0].split('{')[1].split('}')[0]\n\n            # Extract labels\n            label_dict = {}\n            for label in labels.split(','):\n                key, val = label.split('=')\n                label_dict[key] = val.strip('\"')\n\n            penetration_data.append({\n                'model': label_dict.get('model'),\n                'firmware_version': label_dict.get('fw_version'),\n                'device_count': value,\n                'date': datetime.now().date()\n            })\n\n    # Save to data warehouse\n    df = pd.DataFrame(penetration_data)\n    df.to_sql('firmware_penetration_daily', con=warehouse_connection, if_exists='append')\n\ndef generate_analytics_report():\n    \"\"\"Generate daily analytics report\"\"\"\n    query = \"\"\"\n    SELECT\n        model,\n        firmware_version,\n        device_count,\n        LAG(device_count) OVER (PARTITION BY model, firmware_version ORDER BY date) as prev_count,\n        (device_count - LAG(device_count) OVER (PARTITION BY model, firmware_version ORDER BY date)) as daily_change\n    FROM firmware_penetration_daily\n    WHERE date = CURRENT_DATE\n    \"\"\"\n\n    df = pd.read_sql(query, warehouse_connection)\n\n    # Generate report\n    report = {\n        'total_devices': df['device_count'].sum(),\n        'models_updated': len(df[df['daily_change'] &gt; 0]),\n        'top_growing_firmware': df.nlargest(5, 'daily_change')[['model', 'firmware_version', 'daily_change']].to_dict('records')\n    }\n\n    # Send to business intelligence dashboard\n    requests.post('https://bi-dashboard.example.com/api/xconf-daily-report', json=report)\n\nextract_task = PythonOperator(\n    task_id='extract_firmware_penetration',\n    python_callable=extract_firmware_penetration,\n    dag=dag\n)\n\nanalytics_task = PythonOperator(\n    task_id='generate_analytics_report',\n    python_callable=generate_analytics_report,\n    dag=dag\n)\n\nextract_task &gt;&gt; analytics_task\n</code></pre></p>"},{"location":"device-management/docs/xconf-security-deployment/","title":"XConf Security &amp; Deployment","text":""},{"location":"device-management/docs/xconf-security-deployment/#authentication-authorization","title":"Authentication &amp; Authorization","text":"<p>XConf implements a comprehensive security model with flexible access control for different organizational structures. The system supports external authentication providers and role-based access control (RBAC) built on the principle of least privilege.</p>"},{"location":"device-management/docs/xconf-security-deployment/#token-based-authentication","title":"Token-based Authentication","text":"<p>XConf uses OAuth2 providers for secure access control with configurable token validation endpoints. This enables integration with existing organizational identity management systems while maintaining secure access to configuration functions.</p> <pre><code>type AuthConfig struct {\n    TokenAPIEnabled    bool   `json:\"token_api_enabled\"`\n    TokenValidationURL string `json:\"token_validation_url\"`\n    AuthProvider       string `json:\"auth_provider\"`\n}\n</code></pre> <p>Authentication Flow:</p> <ol> <li>User authenticates with external OAuth2 provider</li> <li>Provider issues authentication token</li> <li>XConf validates token with configured validation endpoint</li> <li>System determines user's authorized application types and permissions</li> <li>Access granted based on token validation and permission matrix</li> </ol> <p>Token Validation Features:</p> <ul> <li>Configurable validation endpoints for different OAuth2 providers</li> <li>Support for custom authentication systems</li> <li>Token refresh mechanisms for session management</li> <li>Automatic token expiration and renewal handling</li> </ul>"},{"location":"device-management/docs/xconf-security-deployment/#application-type-isolation","title":"Application Type Isolation","text":"<p>XConf ensures users can only access resources for their authorized application types (STB, xHome, rdkCloud) with strict isolation between environments. Each user's access is scoped to specific application types based on authentication credentials and role assignments.</p> <p>Isolation Benefits:</p> <ul> <li>Prevents cross-contamination between device populations</li> <li>Enables specialized teams to manage specific device types</li> <li>Supports multi-tenant deployments with clear boundaries</li> <li>Reduces risk of configuration errors affecting wrong device types</li> </ul> <p>Implementation:</p> <ul> <li>Application type embedded in authentication tokens</li> <li>API endpoints validate application type access</li> <li>Database queries filtered by application type</li> <li>UI dynamically adjusts based on user's application access</li> </ul>"},{"location":"device-management/docs/xconf-security-deployment/#permission-validation-flow","title":"Permission Validation Flow","text":"<p>The system follows structured validation that extracts and validates authentication tokens, determines authorized application types, and checks specific operation permissions. This includes both resource-level and operation-level access checks for granular permission control.</p> <p>Validation Steps:</p> <ol> <li>Token Extraction: Authentication token extracted from request headers</li> <li>Token Validation: Token verified with authentication provider</li> <li>Application Type Check: User's authorized application types determined</li> <li>Resource Access Check: Verify user can access requested resource type</li> <li>Operation Permission Check: Confirm user can perform specific operation</li> <li>Final Authorization: Grant or deny access based on complete validation</li> </ol>"},{"location":"device-management/docs/xconf-security-deployment/#security-features","title":"Security Features","text":"<p>XConf implements multiple security layers protecting against common attack vectors while maintaining usability and performance. The architecture addresses external threats and internal security requirements.</p>"},{"location":"device-management/docs/xconf-security-deployment/#request-validation-and-input-security","title":"Request Validation and Input Security","text":"<p>Input Sanitization:</p> <ul> <li>Comprehensive validation prevents injection attacks through input sanitization</li> <li>All user inputs undergo strict validation before processing</li> <li>Parameterized database queries prevent SQL injection</li> <li>Input length limits and format validation prevent buffer overflows</li> </ul> <p>XSS Protection:</p> <ul> <li>Cross-site scripting protection throughout the web interface</li> <li>Content Security Policy (CSP) headers prevent script injection</li> <li>Input encoding and output escaping for all user-generated content</li> <li>Secure cookie handling with HttpOnly and Secure flags</li> </ul> <p>Request Rate Limiting:</p> <ul> <li>DoS prevention through configurable rate limiting</li> <li>Per-user and per-IP request throttling</li> <li>Adaptive rate limiting based on system load</li> <li>Graceful degradation under high load conditions</li> </ul>"},{"location":"device-management/docs/xconf-security-deployment/#data-protection-and-encryption","title":"Data Protection and Encryption","text":"<p>Communication Security:</p> <ul> <li>All administrative communications use secure HTTPS channels</li> <li>TLS 1.2+ required for all external communications</li> <li>Certificate validation and pinning for enhanced security</li> <li>Secure WebSocket connections for real-time features</li> </ul> <p>Data Encryption:</p> <ul> <li>Sensitive configuration data encrypted at rest in database</li> <li>Encryption keys managed through secure key management system</li> <li>Field-level encryption for highly sensitive data</li> <li>Secure backup and recovery procedures for encrypted data</li> </ul> <p>Audit and Compliance:</p> <ul> <li>Comprehensive audit logging for all administrative actions</li> <li>Immutable audit trail for compliance reporting</li> <li>Detailed change tracking with modification histories</li> <li>Automated compliance reporting and alerting</li> </ul>"},{"location":"device-management/docs/xconf-security-deployment/#access-control-and-session-management","title":"Access Control and Session Management","text":"<p>Fine-grained Authorization:</p> <ul> <li>Role-based permissions beyond basic authentication</li> <li>Resource-level and operation-level access controls</li> <li>Dynamic permission evaluation based on context</li> <li>Principle of least privilege enforcement</li> </ul> <p>Session Security:</p> <ul> <li>Configurable session timeouts with automatic termination</li> <li>Secure session token generation and management</li> <li>Session invalidation on suspicious activity</li> <li>Multi-factor authentication support for sensitive operations</li> </ul> <p>Network Security:</p> <ul> <li>IP-based access restrictions for administrative interfaces</li> <li>VPN requirement options for remote access</li> <li>Network segmentation between components</li> <li>Firewall rules and network access controls</li> </ul>"},{"location":"device-management/docs/xconf-security-deployment/#deployment-and-configuration","title":"Deployment and Configuration","text":"<p>XConf's modular architecture supports flexible deployment from development setups to large-scale production environments serving millions of devices. Each component can be deployed independently for optimal scaling based on specific load characteristics.</p>"},{"location":"device-management/docs/xconf-security-deployment/#xconf-dataservice-configuration","title":"XConf DataService Configuration","text":"<p>Core service configuration emphasizing performance optimization for high-volume device requests:</p> <pre><code>xconfwebconfig {\n  # Build and version information\n  code_git_commit = \"xconfwebconfig-22.2.14-461.879f957\"\n  build_time = \"Thu Feb 14 02:14:00 2022 UTC\"\n  token_api_enabled = true\n\n  # Database configuration\n  cassandra {\n    hosts = [\"localhost:9042\"]\n    keyspace = \"ApplicationsDiscoveryDataService\"\n    consistency = \"ONE\"\n    timeout = \"10s\"\n    max_connections = 100\n    retry_policy = \"default\"\n  }\n\n  # HTTP server configuration\n  server {\n    port = 9000\n    read_timeout = \"30s\"\n    write_timeout = \"30s\"\n    idle_timeout = \"60s\"\n    max_header_bytes = 1048576\n  }\n\n  # Performance optimization\n  cache {\n    enabled = true\n    ttl = \"300s\"\n    max_entries = 10000\n    eviction_policy = \"LRU\"\n  }\n\n  # Logging configuration\n  logging {\n    level = \"INFO\"\n    format = \"json\"\n    output = \"stdout\"\n  }\n}\n</code></pre>"},{"location":"device-management/docs/xconf-security-deployment/#key-configuration-areas","title":"Key Configuration Areas:","text":"<ul> <li>Database Connection: Optimized for high-throughput device requests</li> <li>Caching Strategy: Reduces database load for frequently requested configurations</li> <li>Timeout Settings: Balanced for responsiveness and resource conservation</li> <li>Logging: Structured logging for operational visibility</li> </ul>"},{"location":"device-management/docs/xconf-security-deployment/#xconf-admin-configuration","title":"XConf Admin Configuration","text":"<p>Administrative service configuration focusing on security and external system integration:</p> <pre><code>xconfwebconfig {\n  ProjectName = \"xconfadmin\"\n\n  # Server configuration with security features\n  server {\n    port = 9001\n    cors_enabled = true\n    allowed_origins = [\"http://localhost:8081\", \"https://admin.example.com\"]\n    allowed_methods = [\"GET\", \"POST\", \"PUT\", \"DELETE\", \"OPTIONS\"]\n    allowed_headers = [\"Content-Type\", \"Authorization\"]\n  }\n\n  # Authentication and authorization\n  auth {\n    enabled = true\n    provider = \"oauth2\"\n    token_validation_url = \"https://auth.example.com/validate\"\n    required_scopes = [\"xconf:admin\"]\n    token_cache_ttl = \"300s\"\n  }\n\n  # Database configuration\n  cassandra {\n    hosts = [\"localhost:9042\"]\n    keyspace = \"ApplicationsDiscoveryDataService\"\n    consistency = \"QUORUM\"\n    timeout = \"30s\"\n  }\n\n  # Security settings\n  security {\n    session_timeout = \"3600s\"\n    max_login_attempts = 5\n    lockout_duration = \"900s\"\n  }\n}\n</code></pre>"},{"location":"device-management/docs/xconf-security-deployment/#security-focus-areas","title":"Security Focus Areas:","text":"<ul> <li>CORS Configuration: Secure cross-origin resource sharing</li> <li>Authentication Integration: OAuth2 provider integration</li> <li>Session Management: Secure session handling and timeouts</li> <li>Access Control: Role-based permissions and restrictions</li> </ul>"},{"location":"device-management/docs/xconf-security-deployment/#xconf-ui-configuration","title":"XConf UI Configuration","text":"<p>Web interface configuration for backend integration and security:</p> <pre><code>xconfui {\n  # Backend service endpoints\n  xconfadmin {\n    host = \"http://localhost:9001/xconfAdminService\"\n    timeout = \"30s\"\n    retry_attempts = 3\n  }\n\n  xconfdataservice {\n    host = \"http://localhost:9000\"\n    timeout = \"10s\"\n    retry_attempts = 2\n  }\n\n  # UI server configuration\n  server {\n    port = 8081\n    static_files = \"./app\"\n    index_file = \"index.html\"\n    gzip_enabled = true\n  }\n\n  # Security headers and policies\n  security {\n    content_security_policy = \"default-src 'self'; script-src 'self' 'unsafe-inline'\"\n    x_frame_options = \"DENY\"\n    x_content_type_options = \"nosniff\"\n    strict_transport_security = \"max-age=31536000; includeSubDomains\"\n  }\n\n  # Caching and performance\n  cache {\n    static_cache_duration = \"86400s\"\n    api_cache_duration = \"300s\"\n  }\n}\n</code></pre>"},{"location":"device-management/docs/xconf-security-deployment/#ui-specific-features","title":"UI-Specific Features:","text":"<ul> <li>Backend Integration: Optimized communication with admin and data services</li> <li>Security Headers: Comprehensive web security headers</li> <li>Performance Optimization: Caching and compression for better user experience</li> <li>Static Asset Management: Efficient serving of web application resources</li> </ul>"},{"location":"device-management/docs/xconf-security-deployment/#setup-and-deployment","title":"Setup and Deployment","text":"<p>XConf setup requires attention to system prerequisites, database configuration, and service coordination. The process is designed for straightforward deployment with flexibility for different operational environments.</p>"},{"location":"device-management/docs/xconf-security-deployment/#prerequisites","title":"Prerequisites","text":""},{"location":"device-management/docs/xconf-security-deployment/#system-requirements","title":"System Requirements","text":"Requirement Details OS Ubuntu 18.04+, CentOS 7+, RHEL 7+ RAM Minimum 4GB (8GB+ recommended) Disk Space 50GB+ for database and logs Network Required for device communication Firewall Proper configuration for service ports"},{"location":"device-management/docs/xconf-security-deployment/#software-dependencies","title":"Software Dependencies","text":"Dependency Version/Note Purpose Cassandra 3.x+ (4.x recommended) Database Go 1.18+ Required for building from source Git Latest Source code management Make Latest Build automation"},{"location":"device-management/docs/xconf-security-deployment/#go-module-dependencies","title":"Go Module Dependencies","text":"<pre><code>// Core dependencies managed through Go modules\nrequire (\n    github.com/gorilla/mux v1.8.0        // HTTP routing and middleware\n    github.com/gocql/gocql v1.0.0        // Cassandra database connectivity\n    github.com/sirupsen/logrus v1.8.1    // Structured logging\n    github.com/google/uuid v1.3.0        // UUID generation for entities\n    github.com/rs/cors v1.8.0            // CORS support for web APIs\n)\n</code></pre>"},{"location":"device-management/docs/xconf-security-deployment/#database-setup","title":"Database Setup","text":"<p>Cassandra Installation: <pre><code># Install Cassandra on Ubuntu/Debian\nsudo apt-get update\nsudo apt-get install openjdk-8-jdk\necho \"deb http://www.apache.org/dist/cassandra/debian 40x main\" | sudo tee -a /etc/apt/sources.list.d/cassandra.sources.list\ncurl https://www.apache.org/dist/cassandra/KEYS | sudo apt-key add -\nsudo apt-get update\nsudo apt-get install cassandra\n\n# Configure and start Cassandra\nsudo systemctl start cassandra\nsudo systemctl enable cassandra\n\n# Verify installation\nsudo systemctl status cassandra\ncqlsh localhost 9042\n</code></pre></p> <p>Schema Initialization: <pre><code># Create XConf database schema\ncqlsh localhost 9042\n\n# Execute schema creation script\nSOURCE 'xconfwebconfig/db/dbinit.cql';\n\n# Verify table creation\nDESCRIBE KEYSPACE \"ApplicationsDiscoveryDataService\";\n</code></pre></p> <p>Schema Structure: <pre><code>-- Create keyspace with appropriate replication\nCREATE KEYSPACE IF NOT EXISTS \"ApplicationsDiscoveryDataService\"\nWITH replication = {\n  'class': 'SimpleStrategy', \n  'replication_factor': 1\n};\n\nUSE \"ApplicationsDiscoveryDataService\";\n\n-- Create core configuration tables\nCREATE TABLE IF NOT EXISTS \"FirmwareConfig\" (\n    key text,\n    column1 text,\n    value blob,\n    PRIMARY KEY ((key), column1)\n) WITH COMPACT STORAGE;\n\nCREATE TABLE IF NOT EXISTS \"DcmRule\" (\n    key text,\n    column1 text,\n    value blob,\n    PRIMARY KEY ((key), column1)\n) WITH COMPACT STORAGE;\n\n-- Additional tables follow similar wide-row patterns\n</code></pre></p> <p>Production Considerations</p> <p>For production deployments, consider using NetworkTopologyStrategy for replication and adjust replication factors based on cluster size and availability requirements.</p>"},{"location":"device-management/docs/xconf-security-deployment/#application-deployment","title":"Application Deployment","text":"<p>Build and Deploy Services: <pre><code># Build XConf DataService\ncd xconfwebconfig\nmake build\nsudo cp xconfwebconfig /usr/local/bin/\nsudo cp sample_xconfwebconfig.conf /etc/xconf/\n\n# Build XConf Admin Service\ncd ../xconfadmin\nmake build\nsudo cp xconfadmin /usr/local/bin/\nsudo cp sample_xconfadmin.conf /etc/xconf/\n\n# Build XConf UI\ncd ../xconfui\nmake build\nsudo cp xconfui /usr/local/bin/\nsudo cp sample_xconfui.conf /etc/xconf/\n</code></pre></p> <p>Service Startup: <pre><code># Start services in dependency order\nsudo systemctl start cassandra\n\n# Start XConf DataService\nsudo systemctl start xconf-dataservice\n\n# Start XConf Admin Service\nsudo systemctl start xconf-admin\n\n# Start XConf UI\nsudo systemctl start xconf-ui\n</code></pre></p> <p>Verification: <pre><code># Check service health\ncurl http://localhost:9000/health\ncurl http://localhost:9001/xconfAdminService/health\ncurl http://localhost:8081/health\n\n# Test basic functionality\ncurl \"http://localhost:9000/xconf/swu/stb?eStbMac=AA:BB:CC:DD:EE:FF&amp;model=TEST_MODEL\"\n</code></pre></p>"},{"location":"device-management/docs/xconf-security-deployment/#production-deployment-considerations","title":"Production Deployment Considerations","text":"<p>High Availability:</p> <ul> <li>Deploy multiple instances behind load balancer (HAProxy, NGINX)</li> <li>Use Cassandra cluster with replication factor \u2265 3</li> <li>Implement health checks and auto-restart mechanisms</li> <li>Set up monitoring and alerting for service availability</li> </ul> <p>Performance Optimization:</p> <ul> <li>Configure appropriate JVM settings for Cassandra</li> <li>Tune database connection pools and timeouts</li> <li>Implement application-level caching strategies</li> <li>Monitor and optimize query performance</li> </ul> <p>Security Hardening:</p> <ul> <li>Enable HTTPS/TLS for all communications</li> <li>Configure proper authentication provider integration</li> <li>Set up network firewalls and access controls</li> <li>Implement regular security updates and patches</li> <li>Enable audit logging and monitoring</li> </ul> <p>Backup and Recovery:</p> <ul> <li>Regular Cassandra backups using nodetool snapshot</li> <li>Configuration file versioning and backup</li> <li>Disaster recovery procedures and testing</li> <li>Data retention policies and cleanup procedures</li> </ul>"},{"location":"devices/docs/","title":"Devices","text":"Entertainment Connectivity SOC Reference Platform <p>Certified ports of RDK is available across a wide variety of popular SOC platforms. Being a certified port comes with the advantage of making sure that the RDK feature is proven to work in that platform and hence the final device from OEM is also confirmed to have this feature working on this. Community members who want to adapt RDK can start from any of these available certified SOCs.          Please note that , while RDK Certification is not mandatory for a SOC, it is highly recommneded to try out the RDK ports that are certified by RDK Management</p> Generic Reference Platform <p>RDK offers a port on the popular generic reference platform - Raspberry Pi -  for the community members. This port will serve as a good starting point for new community members to try out RDK. For app developers, this will serve as a platform where they can try out the Firebolt/Lightning apps they develop         </p> Remote Controls <p>For the video devices, different OEMs provide remote control units that are certified to work with RDK devices out of the box</p> Generic Reference Platform <p>RDK offers a port on the popular generic reference platforms - Banana Pi and Raspberry Pi-  for the community members. This port will serve as a good starting point for new community members to try out and experience RDK</p>"},{"location":"docu/LMLite_Claude_2609/","title":"CcspLMLite Documentation","text":"<p>CcspLMLite (LAN Management Lite) is a core RDK-B middleware component responsible for managing connected devices, host discovery, presence detection, and network traffic monitoring within the local area network. It serves as the central hub for tracking network device information, providing TR-181 data model implementation for device management, and facilitating telemetry data collection. The component bridges low-level network discovery mechanisms with high-level management services, integrating with CCSP framework, WebPA for cloud communication, and RBus for inter-component messaging.</p> <pre><code>graph TD\n    subgraph \"External Systems\"\n        Cloud[Cloud Management]\n        TR069[TR-069 ACS]\n    end\n\n    subgraph \"RDK-B Gateway\"\n        subgraph \"Management Layer\"\n            WebPA[WebPA Agent]\n            TR069Agent[TR-069 Agent]\n            CcspCR[CCSP Component Registry]\n        end\n\n        subgraph \"Middleware Layer\"\n            CcspLMLite[CcspLMLite]\n            WiFiAgent[WiFi Agent]\n            CcspPSM[PSM]\n            CcspTr069Pa[TR-069 PA]\n        end\n\n        subgraph \"HAL Layer\"\n            WiFiHAL[WiFi HAL]\n            EthHAL[Ethernet HAL]\n            MoCAHAL[MoCA HAL]\n        end\n\n        subgraph \"Platform Layer\"\n            NetworkStack[Linux Network Stack]\n            DeviceDrivers[Device Drivers]\n        end\n    end\n\n    Cloud --&gt;|HTTPS/WebPA| WebPA\n    TR069 --&gt;|HTTPS/CWMP| TR069Agent\n\n    WebPA --&gt;|DBus| CcspLMLite\n    TR069Agent --&gt;|DBus| CcspTr069Pa\n    CcspTr069Pa --&gt;|DBus| CcspLMLite\n    CcspCR --&gt;|DBus| CcspLMLite\n\n    CcspLMLite --&gt;|DBus| WiFiAgent\n    CcspLMLite --&gt;|DBus| CcspPSM\n    CcspLMLite --&gt;|RBus| WiFiAgent\n\n    WiFiAgent --&gt;|API| WiFiHAL\n    CcspLMLite --&gt;|Netlink/Proc| NetworkStack\n    NetworkStack --&gt; DeviceDrivers\n\n    classDef external fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n    classDef management fill:#e3f2fd,stroke:#1976d2,stroke-width:2px;\n    classDef middleware fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n    classDef hal fill:#fce4ec,stroke:#c2185b,stroke-width:2px;\n    classDef platform fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;\n\n    class Cloud,TR069 external;\n    class WebPA,TR069Agent,CcspCR management;\n    class CcspLMLite,WiFiAgent,CcspPSM,CcspTr069Pa middleware;\n    class WiFiHAL,EthHAL,MoCAHAL hal;\n    class NetworkStack,DeviceDrivers platform;</code></pre> <ul> <li>Key Features &amp; Responsibilities:</li> <li>Host Discovery &amp; Management: Discovers, tracks, and manages connected devices across WiFi, Ethernet, and MoCA interfaces, maintaining comprehensive device information including MAC addresses, IP assignments, device types, and connection status</li> <li>Presence Detection: Implements advanced presence detection algorithms using IPv4/IPv6 pings and network activity monitoring to determine device active/inactive states with configurable polling intervals and retry mechanisms</li> <li>TR-181 Data Model Implementation: Provides complete TR-181 Hosts data model implementation with read/write parameter support, device enumeration, and vendor-specific extensions for RDK-specific functionality</li> <li>Network Traffic Monitoring: Collects and reports WAN traffic statistics, device-specific traffic patterns, and network utilization metrics for bandwidth management and analytics</li> <li>Telemetry Data Collection: Generates network device status reports, traffic statistics, and presence notifications in Avro format for upstream cloud analytics and monitoring systems</li> <li>Cross-Interface Integration: Coordinates with multiple network interfaces (WiFi, Ethernet, MoCA) to provide unified device visibility and consistent device identification across different connection types</li> </ul>"},{"location":"docu/LMLite_Claude_2609/#design","title":"Design","text":""},{"location":"docu/LMLite_Claude_2609/#highlevel-design-principles","title":"High\u2011Level Design Principles","text":"<p>CcspLMLite follows a modular, event-driven architecture that emphasizes separation of concerns and loose coupling between functional components. The design prioritizes real-time responsiveness for presence detection while maintaining data consistency across multiple network interfaces. Scalability is achieved through efficient data structures and periodic harvesting mechanisms that can handle up to 256 concurrent devices. Reliability is ensured through robust error handling, graceful degradation during interface failures, and persistent state management via PSM integration. Security considerations include MAC address validation, IP address verification, and controlled access to sensitive network information through TR-181 parameter permissions.</p> <p>The component implements clear boundaries between data collection (host discovery), data processing (presence detection algorithms), data storage (device state management), and data presentation (TR-181 interface). Interface management responsibilities are distributed across specialized modules: network interface abstraction handles multi-interface coordination, DML modules manage TR-181 parameter operations, and telemetry modules handle data serialization and reporting. The design supports both polling-based and event-driven data collection modes to optimize performance based on network conditions and device requirements.</p>"},{"location":"docu/LMLite_Claude_2609/#c4-container-diagram","title":"C4 Container Diagram","text":"<pre><code>graph TD\n    subgraph \"Linux Runtime Environment\"\n        subgraph \"CcspLMLite Container\"\n            subgraph \"Core Engine\"\n                LMCore[LM Core Engine&lt;br/&gt;Device Discovery &amp; Management]\n                PDCore[Presence Detection Engine&lt;br/&gt;Active/Inactive State Management]\n            end\n\n            subgraph \"Data Layer\"\n                DeviceDB[(Device Database&lt;br/&gt;In-Memory Host Information)]\n                ConfigDB[(Configuration Store&lt;br/&gt;PSM Integration)]\n            end\n\n            subgraph \"Interface Layer\"\n                TR181DML[TR-181 DML Interface&lt;br/&gt;Parameter Management]\n                WebPAIntf[WebPA Interface&lt;br/&gt;Cloud Communication]\n                RBusIntf[RBus Interface&lt;br/&gt;Event Publishing]\n            end\n\n            subgraph \"Network Modules\"\n                NetIntf[Network Interface Handler&lt;br/&gt;Multi-Interface Coordination]\n                TrafficMon[Traffic Monitor&lt;br/&gt;Bandwidth &amp; Usage Tracking]\n            end\n        end\n\n        subgraph \"External Dependencies\"\n            MessageBus[CCSP Message Bus&lt;br/&gt;DBus Communication]\n            LinuxNet[Linux Network Stack&lt;br/&gt;Netlink/Proc Interfaces]\n        end\n    end\n\n    LMCore --&gt; DeviceDB\n    PDCore --&gt; DeviceDB\n    LMCore --&gt; NetIntf\n    PDCore --&gt; NetIntf\n\n    TR181DML --&gt; DeviceDB\n    WebPAIntf --&gt; DeviceDB\n    RBusIntf --&gt; DeviceDB\n\n    NetIntf --&gt; LinuxNet\n    TrafficMon --&gt; LinuxNet\n\n    TR181DML --&gt; MessageBus\n    WebPAIntf --&gt; MessageBus\n\n    ConfigDB --&gt; MessageBus\n\n    classDef core fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef data fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n    classDef interface fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n    classDef network fill:#fce4ec,stroke:#c2185b,stroke-width:2px;\n    classDef external fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;\n\n    class LMCore,PDCore core;\n    class DeviceDB,ConfigDB data;\n    class TR181DML,WebPAIntf,RBusIntf interface;\n    class NetIntf,TrafficMon network;\n    class MessageBus,LinuxNet external;</code></pre>"},{"location":"docu/LMLite_Claude_2609/#design-explanation-request-flow","title":"Design Explanation &amp; Request Flow","text":"<ul> <li>Request Flow Sequence: The most critical flow is the device discovery and presence detection sequence, which involves continuous monitoring of network interfaces, device state updates, and TR-181 parameter synchronization.</li> </ul> <pre><code>sequenceDiagram\n    participant Client as TR-181 Client\n    participant DML as TR-181 DML Handler\n    participant LMCore as LM Core Engine\n    participant NetIntf as Network Interface\n    participant DeviceDB as Device Database\n    participant PDEngine as Presence Detection\n\n    Client-&gt;&gt;DML: GET Device.Hosts.Host.{i}\n    DML-&gt;&gt;DeviceDB: Query Device Information\n    DeviceDB--&gt;&gt;DML: Device Data\n    DML--&gt;&gt;Client: TR-181 Response\n\n    Note over NetIntf: Periodic Network Scan\n    NetIntf-&gt;&gt;LMCore: New Device Detected\n    LMCore-&gt;&gt;DeviceDB: Update Device Entry\n    LMCore-&gt;&gt;PDEngine: Start Presence Monitoring\n\n    loop Presence Detection Cycle\n        PDEngine-&gt;&gt;NetIntf: Ping Device\n        NetIntf--&gt;&gt;PDEngine: Response/Timeout\n        PDEngine-&gt;&gt;DeviceDB: Update Active Status\n        PDEngine-&gt;&gt;DML: Trigger Parameter Update\n    end\n\n    DML-&gt;&gt;Client: Parameter Change Notification</code></pre>"},{"location":"docu/LMLite_Claude_2609/#threading-model","title":"Threading Model","text":"<p>CcspLMLite implements a multi-threaded architecture with dedicated worker threads for different functional areas. The main application thread handles initialization, CCSP message bus communication, and TR-181 parameter requests. A dedicated device discovery thread continuously monitors network interfaces and processes new device connections. The presence detection engine runs in its own thread with configurable polling intervals (default 10 seconds) to check device active/inactive states. Traffic monitoring operates in a separate background thread to collect bandwidth statistics without impacting real-time operations. Event processing threads handle WebPA message publishing and RBus event notifications. Thread synchronization is managed through mutex locks and condition variables to ensure data consistency across concurrent operations while maintaining responsive user interface interactions.</p>"},{"location":"docu/LMLite_Claude_2609/#internal-modules","title":"Internal Modules","text":"<p>The CcspLMLite component consists of several specialized modules that work together to provide comprehensive network device management functionality. The core LM (LAN Management) module orchestrates device discovery and maintains the central device database. DML modules provide TR-181 parameter interface implementations for different functional areas. Network interface handlers abstract platform-specific networking operations, while telemetry modules handle data serialization and cloud communication.</p> Module/Class Description Key Files LM Core Engine Central device discovery and management engine that coordinates host tracking, device enumeration, and state synchronization <code>lm_main.c</code>, <code>lm_main.h</code>, <code>lm_api.c</code>, <code>lm_api.h</code> TR-181 Hosts DML Implements Device.Hosts.Host.{i} TR-181 data model with parameter get/set operations and device table management <code>cosa_hosts_dml.c</code>, <code>cosa_hosts_dml.h</code> Presence Detection Advanced device presence detection using ping mechanisms, activity monitoring, and configurable timeout/retry logic <code>device_presence_detection.c</code>, <code>device_presence_detection.h</code> Network Device Status Harvests and reports network device status information with Avro serialization for telemetry data collection <code>network_devices_status.c</code>, <code>network_devices_status.h</code>, <code>network_devices_status_avropack.c</code> Traffic Monitoring WAN traffic counting and bandwidth monitoring with per-device statistics and RBus API integration <code>cosa_wantraffic_api.c</code>, <code>cosa_wantraffic_utils.c</code>, <code>wtc_rbus_apis.c</code> WebPA Interface Cloud communication interface for device management commands, notifications, and telemetry data upstream delivery <code>webpa_interface.c</code>, <code>webpa_interface.h</code>, <code>webpa_pd_with_seshat.c</code> Network Interface Handler Multi-interface coordination for WiFi, Ethernet, and MoCA connections with unified device identification <code>network_devices_interface.c</code>, <code>network_devices_interface.h</code> SSP Framework System Service Provider framework integration with CCSP message bus, component registration, and lifecycle management <code>ssp_main.c</code>, <code>ssp_messagebus_interface.c</code>, <code>ssp_action.c</code> <pre><code>flowchart TD\n    subgraph CcspLMLite\n        subgraph \"Core Layer\"\n            LMCore[LM Core Engine&lt;br/&gt;Device Management]\n            PDEngine[Presence Detection&lt;br/&gt;Activity Monitoring] \n        end\n\n        subgraph \"Interface Layer\"\n            HostsDML[Hosts DML&lt;br/&gt;TR-181 Implementation]\n            XHostsDML[XHosts DML&lt;br/&gt;Extended Parameters]\n            NDStatusDML[ND Status DML&lt;br/&gt;Status Reporting]\n            NDTrafficDML[ND Traffic DML&lt;br/&gt;Traffic Statistics]\n        end\n\n        subgraph \"Communication Layer\"\n            WebPAIntf[WebPA Interface&lt;br/&gt;Cloud Communication]\n            RBusAPI[RBus APIs&lt;br/&gt;Event Publishing]\n            NetIntf[Network Interface&lt;br/&gt;Multi-Interface Handler]\n        end\n\n        subgraph \"Data Processing\"\n            AvroStatus[Avro Status Packer&lt;br/&gt;Status Serialization]\n            AvroTraffic[Avro Traffic Packer&lt;br/&gt;Traffic Serialization]\n            TrafficUtils[Traffic Utils&lt;br/&gt;WAN Monitoring]\n        end\n\n        subgraph \"Framework\"\n            SSP[SSP Framework&lt;br/&gt;CCSP Integration]\n            MsgBus[Message Bus Interface&lt;br/&gt;DBus Communication]\n        end\n    end\n\n    LMCore --&gt; HostsDML\n    LMCore --&gt; XHostsDML\n    PDEngine --&gt; HostsDML\n\n    LMCore --&gt; NetIntf\n    PDEngine --&gt; NetIntf\n\n    HostsDML --&gt; WebPAIntf\n    NDStatusDML --&gt; AvroStatus\n    NDTrafficDML --&gt; AvroTraffic\n\n    TrafficUtils --&gt; RBusAPI\n    AvroStatus --&gt; WebPAIntf\n    AvroTraffic --&gt; WebPAIntf\n\n    SSP --&gt; MsgBus\n    HostsDML --&gt; MsgBus\n    XHostsDML --&gt; MsgBus\n    NDStatusDML --&gt; MsgBus\n    NDTrafficDML --&gt; MsgBus\n\n    classDef core fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef interface fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n    classDef comm fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n    classDef data fill:#fce4ec,stroke:#c2185b,stroke-width:2px;\n    classDef framework fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;\n\n    class LMCore,PDEngine core;\n    class HostsDML,XHostsDML,NDStatusDML,NDTrafficDML interface;\n    class WebPAIntf,RBusAPI,NetIntf comm;\n    class AvroStatus,AvroTraffic,TrafficUtils data;\n    class SSP,MsgBus framework;</code></pre>"},{"location":"docu/LMLite_Claude_2609/#interaction-with-other-middleware-components","title":"Interaction with Other Middleware Components","text":"<p>CcspLMLite integrates extensively with other RDK-B middleware components to provide comprehensive network management functionality. It communicates with WiFi Agent to retrieve wireless device information and association status, coordinating device discovery across multiple interfaces. The component interfaces with PSM (Persistent Storage Manager) for configuration parameter persistence and system state management. Integration with TR-069 PA enables remote management capabilities through TR-181 parameter exposure. WebPA Agent coordination facilitates cloud-based device management and telemetry data delivery for analytics platforms.</p> <pre><code>flowchart TD\n    CcspLMLite --&gt;|DBus GetParameterValues&lt;br/&gt;Device Association Info| WiFiAgent[WiFi Agent]\n    CcspLMLite --&gt;|DBus SetParameterValues&lt;br/&gt;Configuration Persistence| PSM[PSM]\n    CcspLMLite --&gt;|DBus RegisterNamespace&lt;br/&gt;TR-181 Parameter Exposure| TR069PA[TR-069 PA]\n    CcspLMLite --&gt;|HTTP POST /api/v1/device&lt;br/&gt;Telemetry Data Upload| WebPAAgent[WebPA Agent]\n    CcspLMLite --&gt;|RBus Publish&lt;br/&gt;Device Status Events| EventBus[RBus Event System]\n    CcspLMLite --&gt;|DBus ComponentCheck&lt;br/&gt;Health Monitoring| CcspCR[CCSP Component Registry]\n    CcspLMLite --&gt;|Netlink Sockets&lt;br/&gt;Network Interface Monitoring| NetworkStack[Linux Network Stack]\n\n    classDef middleware fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef external fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n    classDef system fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n\n    class CcspLMLite middleware;\n    class WiFiAgent,PSM,TR069PA,WebPAAgent,CcspCR middleware;\n    class EventBus external;\n    class NetworkStack system;</code></pre> Component Purpose of Interaction Protocols/Mechanisms WiFi Agent Retrieve wireless device association status, RSSI values, and interface-specific device information for unified device tracking DBus GetParameterValues, Event Notifications PSM Persist configuration parameters like polling intervals, presence detection settings, and harvesting configurations across system reboots DBus SetParameterValues, GetParameterValues TR-069 PA Expose TR-181 Device.Hosts.Host.{i} parameters for remote management and configuration through TR-069 protocol DBus RegisterNamespace, Parameter Notifications WebPA Agent Upload telemetry data including device status reports, traffic statistics, and presence notifications to cloud analytics platforms HTTP POST JSON/Avro, Message Queue CCSP Component Registry Register component capabilities, health status reporting, and inter-component discovery for system orchestration DBus ComponentRegistration, Health Checks RBus Event System Publish device presence events, traffic threshold notifications, and real-time device status changes for system-wide notifications RBus Event Publishing, Subscriptions <p>The component publishes several events to notify other system components about network device state changes and significant events that may require system-wide coordination or external reporting.</p> Event Purpose of Event Reason for trigger Device.Hosts.Host.{i}.Active Device presence state change notification indicating when devices join or leave the network Triggered when presence detection algorithms determine device active/inactive state changes based on ping responses and network activity Device.X_RDK_NetworkDeviceStatus Comprehensive device status report containing device counts, interface statistics, and connection details Triggered periodically based on harvesting schedule or on-demand when significant network topology changes are detected Device.X_RDK_NetworkTrafficCount WAN traffic statistics and per-device bandwidth utilization reports for network monitoring and analytics Triggered at configured reporting intervals or when traffic thresholds are exceeded for bandwidth management Device.Hosts.PresenceNotification Real-time presence notifications for specific monitored devices with configurable MAC address filtering Triggered immediately when monitored devices (configured via presence notification list) change presence status"},{"location":"docu/LMLite_Claude_2609/#interaction-with-other-layers","title":"Interaction with Other Layers","text":"<p>CcspLMLite interacts with multiple layers of the RDK-B software stack to provide comprehensive network device management. At the HAL layer, it interfaces with WiFi HAL for wireless device information and MoCA HAL for coax network devices. Platform-specific interactions include direct Linux network stack integration through netlink sockets and proc filesystem monitoring. External service integration encompasses cloud analytics platforms through WebPA and TR-069 ACS communication for remote management capabilities.</p> Layer/Service Interaction Description Mechanism WiFi HAL Retrieves wireless client association information, RSSI measurements, and interface status for WiFi-connected devices HAL API calls, callback registrations MoCA HAL Obtains MoCA network topology, device association status, and coax interface statistics for unified device visibility HAL API calls, status polling Linux Network Stack Monitors network interface changes, ARP table updates, and routing information for device discovery and IP tracking Netlink sockets, /proc filesystem WebPA Cloud Service Uploads telemetry data, receives device management commands, and provides cloud-based analytics integration HTTPS REST API, JSON/Avro payload TR-069 ACS Exposes device management parameters for remote configuration and monitoring through standardized TR-181 data model CWMP protocol, XML-RPC System Logging Records component events, error conditions, and debug information for system monitoring and troubleshooting Syslog, structured logging <pre><code>graph TD\n    %% Cloud Services\n    subgraph Cloud[\"Cloud Services Layer\"]\n        CloudAnalytics[\"Cloud Analytics Platform\"]\n        TR069ACS[\"TR-069 ACS\"]\n    end\n\n    %% Applications\n    subgraph Apps[\"Application Layer\"]\n        WebUI[\"Web Management Interface\"]\n        MobileApp[\"Mobile Applications\"]\n    end\n\n    %% Middleware\n    subgraph Middleware[\"RDK-B Middleware Layer\"]\n        CcspLMLite[\"CcspLMLite Component\"]\n        WiFiAgent[\"WiFi Agent\"]\n        PSM[\"PSM\"]\n        WebPAAgent[\"WebPA Agent\"]\n    end\n\n    %% HAL\n    subgraph HAL[\"HAL Layer\"]\n        WiFiHAL[\"WiFi HAL\"]\n        EthHAL[\"Ethernet HAL\"]\n        MoCAHAL[\"MoCA HAL\"]\n    end\n\n    %% Platform\n    subgraph Platform[\"Platform Layer\"]\n        LinuxKernel[\"Linux Kernel\"]\n        NetlinkSockets[\"Netlink Sockets\"]\n        ProcFS[\"/proc filesystem\"]\n        DeviceDrivers[\"Network Device Drivers\"]\n    end\n\n    %% Hardware\n    subgraph HW[\"Hardware Layer\"]\n        WiFiChipset[\"WiFi Chipset\"]\n        EthController[\"Ethernet Controller\"]\n        MoCAController[\"MoCA Controller\"]\n    end\n\n    %% Edges\n    CloudAnalytics &lt;--&gt;|\"HTTPS / JSON\"| WebPAAgent\n    TR069ACS &lt;--&gt;|\"CWMP / XML-RPC\"| CcspLMLite\n\n    WebUI &lt;--&gt;|\"HTTP / TR-181\"| CcspLMLite\n    MobileApp &lt;--&gt;|\"REST API\"| WebPAAgent\n\n    CcspLMLite &lt;--&gt;|\"DBus\"| WiFiAgent\n    CcspLMLite &lt;--&gt;|\"DBus\"| PSM\n    CcspLMLite &lt;--&gt;|\"DBus\"| WebPAAgent\n\n    WiFiAgent &lt;--&gt;|\"HAL API\"| WiFiHAL\n    CcspLMLite &lt;--&gt;|\"HAL API\"| EthHAL\n    CcspLMLite &lt;--&gt;|\"HAL API\"| MoCAHAL\n\n    CcspLMLite &lt;--&gt;|\"Netlink\"| NetlinkSockets\n    CcspLMLite &lt;--&gt;|\"File I/O\"| ProcFS\n    NetlinkSockets --&gt; LinuxKernel\n    ProcFS --&gt; LinuxKernel\n    LinuxKernel --&gt; DeviceDrivers\n\n    WiFiHAL --&gt; DeviceDrivers\n    EthHAL --&gt; DeviceDrivers  \n    MoCAHAL --&gt; DeviceDrivers\n\n    DeviceDrivers --&gt; WiFiChipset\n    DeviceDrivers --&gt; EthController\n    DeviceDrivers --&gt; MoCAController\n\n    %% Styling\n    classDef cloud fill:#e3f2fd,stroke:#1976d2,stroke-width:2px;\n    classDef app fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n    classDef middleware fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n    classDef hal fill:#fce4ec,stroke:#c2185b,stroke-width:2px;\n    classDef platform fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;\n    classDef hardware fill:#f1f8e9,stroke:#689f38,stroke-width:2px;\n\n    class CloudAnalytics,TR069ACS cloud;\n    class WebUI,MobileApp app;\n    class CcspLMLite,WiFiAgent,PSM,WebPAAgent middleware;\n    class WiFiHAL,EthHAL,MoCAHAL hal;\n    class LinuxKernel,NetlinkSockets,ProcFS,DeviceDrivers platform;\n    class WiFiChipset,EthController,MoCAController hardware;</code></pre>"},{"location":"docu/LMLite_Claude_2609/#ipc-mechanism","title":"IPC Mechanism","text":"Type of IPC Message Format Mechanism DBus Inter-Component Communication XML-based parameter structure with CCSP-specific headers including component name, method calls, and parameter arrays DBus method calls with CCSP message bus integration for TR-181 parameter operations RBus Event Publishing Binary serialized event data with topic-based routing containing device status, traffic statistics, and presence notifications RBus publish/subscribe pattern with structured data types and filtering WebPA Message Queue JSON and Avro binary formats for telemetry data including device status reports, traffic counters, and network topology information HTTP POST to WebPA agent with message queuing for reliable cloud delivery Unix Domain Sockets Custom binary protocol for local LM API communication including device queries, configuration updates, and status requests Unix socket server (/tmp/lm.sock) with request/response pattern <pre><code>sequenceDiagram\n    participant Client as External Client\n    participant DBus as DBus Message Bus\n    participant LMLite as CcspLMLite\n    participant RBus as RBus Event System\n    participant WebPA as WebPA Agent\n    participant Cloud as Cloud Analytics\n\n    Note over Client, Cloud: TR-181 Parameter Request Flow\n    Client-&gt;&gt;DBus: GetParameterValues(Device.Hosts.Host.1.Active)\n    DBus-&gt;&gt;LMLite: CCSP_MESSAGE_BUS_GET\n    LMLite-&gt;&gt;DBus: Parameter Value Response\n    DBus--&gt;&gt;Client: TR-181 Response\n\n    Note over LMLite, Cloud: Device Status Event Flow\n    LMLite-&gt;&gt;RBus: rbusEvent_Publish(DeviceStatusEvent)\n    RBus-&gt;&gt;WebPA: Event Subscription Delivery\n\n    Note over LMLite, Cloud: Telemetry Data Flow  \n    LMLite-&gt;&gt;WebPA: HTTP POST /api/v1/device (Avro payload)\n    WebPA-&gt;&gt;Cloud: HTTPS Upload (Compressed data)\n    Cloud--&gt;&gt;WebPA: ACK Response\n    WebPA--&gt;&gt;LMLite: Upload Status\n\n    Note over LMLite, LMLite: Internal API Communication\n    LMLite-&gt;&gt;LMLite: Unix Socket /tmp/lm.sock\n    Note right of LMLite: Local API for device queries&lt;br/&gt;and configuration updates</code></pre>"},{"location":"docu/LMLite_Claude_2609/#tr181-data-models","title":"TR\u2011181 Data Models","text":"<ul> <li>Implemented Parameters: CcspLMLite implements the Device.Hosts object hierarchy including Host table entries, device enumeration parameters, presence detection controls, and RDK-specific extensions for enhanced network management functionality. Parameters include device identification, network interface associations, traffic statistics, and vendor-specific device classification.</li> <li>Parameter Registration: Parameters are registered through CCSP message bus integration using XML-based data model definitions from LMLite.XML configuration file. Access control is managed through TR-181 parameter permissions with read-only and read-write designations based on security requirements.</li> <li>Custom Extensions: X_CISCO_COM device type classification for enhanced device identification, X_RDKCENTRAL-COM presence detection controls for configurable monitoring, X_RDK presence notification system for real-time alerts, and traffic counting extensions for bandwidth management and analytics.</li> </ul> Parameter Description Access (R/W) Default Notes <code>Device.Hosts.HostNumberOfEntries</code> Total number of discovered devices R <code>0</code> Dynamic count <code>Device.Hosts.Host.{i}.PhysAddress</code> Device MAC address R <code>\"\"</code> Unique identifier <code>Device.Hosts.Host.{i}.IPAddress</code> Current IP address assignment R <code>\"\"</code> DHCP or static <code>Device.Hosts.Host.{i}.Active</code> Device presence status R <code>false</code> Presence detection <code>Device.Hosts.Host.{i}.DHCPClient</code> DHCP client identifier R <code>\"\"</code> DHCP integration <code>Device.Hosts.Host.{i}.AssociatedDevice</code> Associated interface reference R <code>\"\"</code> Interface mapping <code>Device.Hosts.Host.{i}.Layer1Interface</code> Physical interface reference R <code>\"\"</code> Layer 1 association <code>Device.Hosts.Host.{i}.Layer3Interface</code> Network interface reference R <code>\"\"</code> Layer 3 association <code>Device.Hosts.Host.{i}.HostName</code> Device hostname R <code>\"\"</code> DNS/DHCP name <code>Device.Hosts.Host.{i}.X_CISCO_COM_DeviceType</code> Device classification R <code>1</code> Custom device type <code>Device.Hosts.Host.{i}.X_CISCO_COM_NetworkInterface</code> Network interface type R <code>\"\"</code> WiFi/Ethernet/MoCA <code>Device.Hosts.Host.{i}.X_CISCO_COM_ConnectionStatus</code> Connection status details R <code>\"\"</code> Extended status <code>Device.Hosts.Host.{i}.X_CISCO_COM_ActiveTime</code> Active connection duration R <code>0</code> Time tracking <code>Device.Hosts.Host.{i}.X_CISCO_COM_InactiveTime</code> Inactive duration R <code>0</code> Presence monitoring <code>Device.Hosts.Host.{i}.X_CISCO_COM_RSSI</code> WiFi signal strength R <code>0</code> WiFi devices only <code>Device.Hosts.X_CISCO_COM_ConnectedDeviceNumber</code> Total connected devices R <code>0</code> Device count <code>Device.Hosts.X_CISCO_COM_ConnectedWiFiNumber</code> WiFi device count R <code>0</code> WiFi-specific count <code>Device.Hosts.X_RDKCENTRAL-COM_HostVersionId</code> Host table version R <code>0</code> Change tracking <code>Device.Hosts.X_RDKCENTRAL-COM_HostCountPeriod</code> Polling interval R/W <code>10</code> Seconds <code>Device.Hosts.X_RDK_PresenceDetectEnable</code> Presence detection enable R/W <code>true</code> Feature control <code>Device.Hosts.X_RDKCENTRAL-COM_WebPA_PresenceNotificationEnable</code> WebPA notifications R/W <code>false</code> Cloud notifications <code>Device.Hosts.X_RDKCENTRAL-COM_AddPresenceNotificationMac</code> Add MAC to monitoring W <code>\"\"</code> Notification list <code>Device.Hosts.X_RDKCENTRAL-COM_DeletePresenceNotificationMac</code> Remove MAC from monitoring W <code>\"\"</code> Notification list <code>Device.X_RDK_NetworkDevicesStatus.ReportingPeriod</code> Status reporting interval R/W <code>900</code> Telemetry timing <code>Device.X_RDK_NetworkDevicesStatus.Enabled</code> Status harvesting enable R/W <code>false</code> Feature control <code>Device.X_RDK_NetworkDevicesTraffic.ReportingPeriod</code> Traffic reporting interval R/W <code>900</code> Telemetry timing <code>Device.X_RDK_NetworkDevicesTraffic.Enabled</code> Traffic harvesting enable R/W <code>false</code> Feature control"},{"location":"docu/LMLite_Claude_2609/#implementation-details","title":"Implementation Details","text":"<ul> <li> <p>Key Algorithms or Logic: Device discovery uses ARP table monitoring combined with network interface scanning to detect new device connections (<code>lm_wrapper.c</code>, <code>network_devices_interface.c</code>). Presence detection implements a dual-mode algorithm using IPv4/IPv6 ping with configurable retry counts and timeout intervals (<code>device_presence_detection.c</code>). Traffic monitoring utilizes netlink socket integration to capture per-device bandwidth statistics with aggregation logic for WAN interface monitoring (<code>cosa_wantraffic_utils.c</code>). State machine management for device lifecycle transitions between connected/disconnected/active/inactive states with hysteresis to prevent flapping (<code>lm_main.c</code>).</p> </li> <li> <p>Error Handling Strategy: Comprehensive error detection includes network interface failure recovery, CCSP message bus reconnection logic, and graceful degradation when HAL components are unavailable. Errors are categorized by severity with different response strategies: critical errors trigger component restart, warning conditions enable fallback modes, and informational errors continue with limited functionality. All error conditions are logged with structured information including error codes, component context, and recovery actions taken.</p> </li> <li> <p>Logging &amp; Debugging: Multi-level logging system with categories for device discovery (LM), presence detection (PD), traffic monitoring (TM), and telemetry (TEL). Verbosity levels include ERROR, WARN, INFO, and DEBUG with runtime configuration through TR-181 parameters. Debug tools include device table dumps, presence detection state visualization, traffic statistics reporting, and message bus transaction logging. Performance metrics tracking for polling intervals, response times, and memory utilization with configurable thresholds for system monitoring.</p> </li> </ul>"},{"location":"docu/LMLite_Claude_2609/#key-configuration-files","title":"Key Configuration Files","text":"<p>CcspLMLite relies on several configuration files to define its behavior, TR-181 parameter structure, and telemetry data schemas. These configuration files control everything from data model definitions to serialization formats for cloud analytics.</p> Configuration File Purpose Key Parameters Default Values Override Mechanisms <code>config/LMLite.XML</code> TR-181 data model definition Object hierarchy, parameter types, access permissions, DML function mappings Device.Hosts.* parameters, read/write permissions Environment variables, build-time configuration <code>config/NetworkDevicesStatus.avsc</code> Avro schema for device status telemetry Device status fields, data types, serialization structure Device count, interface statistics, presence data Schema versioning, runtime validation <code>config/NetworkDevicesTraffic.avsc</code> Avro schema for traffic telemetry Traffic counters, bandwidth metrics, per-device statistics TX/RX bytes, packet counts, interface mapping Schema versioning, cloud compatibility <code>/etc/ccsp/lm.cfg</code> Runtime configuration parameters Polling intervals, presence detection timeouts, device limits 10s polling, 3 retries, 256 max devices TR-181 parameter override, CLI configuration <code>/tmp/lm.sock</code> Unix domain socket configuration Socket permissions, buffer sizes, connection limits 755 permissions, 4KB buffer, unlimited connections System configuration, security policies"},{"location":"docu/LMLite_GPT5_2609/","title":"CcspLMLite Documentation","text":"<p>CcspLMLite (\"LM Lite\") is the RDK\u2011B component responsible for host / local network device lifecycle tracking, presence detection, network device status &amp; traffic telemetry, and WAN traffic counting enablement (RBUS-based). It exposes TR\u2011181 data model tables (Hosts, Host.IPv4/IPv6Address, optional XHosts, NetworkDevicesStatus, NetworkDevicesTraffic, WAN traffic stats) and provides IPC / RBUS interfaces for other middleware and cloud telemetry (WebPA / Parodus). LM Lite harvests active LAN device metadata, maintains state transitions, and publishes configurable reports and presence notifications.</p> <ul> <li>Key Features &amp; Responsibilities:</li> <li>Host Inventory &amp; State Tracking: Discovers and maintains Device.Hosts.Host.* objects (MAC, IPs, interfaces, activity timers, RSSI, presence flags).</li> <li>Presence Detection &amp; Notifications: Implements configurable join/leave detection with retry strategies and publishes WebPA presence notifications &amp; optional internal notifications.</li> <li>Network Device Status Reporting: Periodic harvesting &amp; reporting (poll/report intervals with override TTL) of per\u2011device status (active/inactive times, RSSI, associations) using configurable TR\u2011181 parameters.</li> <li>Network Device Traffic Reporting: Collects &amp; packages traffic counters (separate polling/reporting control) and supports Avro-packing for efficient upstream telemetry.</li> <li>WAN Traffic Count (RBUS): Registers RBUS table <code>Device.X_RDK_WAN.Interface.{i}</code> with DSCP counting enable/interval + per\u2011interval and total DSCP distribution.</li> <li>TR\u2011181 Parameter Handling: Provides getters/setters/validation/commit/rollback for dynamic host &amp; reporting objects, honoring atomic update semantics.</li> <li>Multi\u2011Interface Awareness: Correlates Ethernet, Wi\u2011Fi (including extender), MoCA, and optionally DHCP / ARP / dnsmasq &amp; system sources for unified host view.</li> <li>IPC API over Unix Socket: Offers lightweight local socket API (<code>/tmp/lm.sock</code>) for querying host list, host by MAC, comments, online counts, and managing named \u201cnetworks\u201d.</li> <li>Extensibility &amp; Resource Optimization: Conditional compilation flags (RESOURCE_OPTIMIZATION, WAN_TRAFFIC_COUNT_SUPPORT, RDKB_EXTENDER_ENABLED, RBUS enablement) allow footprint tailoring.</li> </ul>"},{"location":"docu/LMLite_GPT5_2609/#design","title":"Design","text":""},{"location":"docu/LMLite_GPT5_2609/#highlevel-design-principles","title":"High\u2011Level Design Principles","text":"<p>CcspLMLite emphasizes modular harvesting of heterogeneous LAN data sources, consolidating them into a consistent TR\u2011181 surface while decoupling collection from reporting. Guiding principles include: modularity (separate source modules: status, traffic, presence, WAN), scalability (interval tuning, conditional features), reliability (mutex protection, retry queues, timed waits), security (bounded buffers, safe string ops via <code>safec_lib</code>, privilege separation for system commands), and maintainability (clear DML function registration, feature flags). Design choices isolate: (1) Data Acquisition (polling threads) (2) State &amp; Model Assembly (host tables &amp; internal structures) (3) IPC/External Interfaces (TR\u2011181 handlers, RBUS, WebPA, Unix socket) (4) Reporting &amp; Packaging (Avro packers, presence notifier). Boundaries: persistence/config (syscfg, NVRAM), IPC (RBUS/WebPA), telemetry formatting (Avro), and host state core.</p>"},{"location":"docu/LMLite_GPT5_2609/#c4-system-context-diagram","title":"C4 System Context Diagram","text":"<pre><code>flowchart TD\n    subgraph CPE[\"RDK-B CPE\"]\n        LMLite[\"CcspLMLite Process\"]\n        OtherCCSP[\"Other CCSP Components (PAM, WiFi Agent, EthAgent, MoCA, etc.)\"]\n    end\n\n    Cloud[\"Telemetry / Cloud Services\"]\n    RBUS[\"RBus Message Bus\"]\n    Parodus[\"Parodus / WebPA Transport\"]\n    SysInfra[\"System daemons (dnsmasq, ARP cache, syscfg, sysevent)\"]\n\n    OtherCCSP --&gt;|\"TR-181 Get/Set via CCSP Bus\"| LMLite\n    SysInfra --&gt;|\"Leases / ARP / Syscfg\"| LMLite\n    LMLite --&gt;|\"Presence Notifications (WRP events)\"| Parodus\n    LMLite --&gt;|\"Telemetry Avro Payloads\"| Cloud\n    LMLite --&gt; RBUS\n    RBUS --&gt; LMLite\n    Cloud --&gt;|\"Config (Set TR-181)\"| LMLite</code></pre>"},{"location":"docu/LMLite_GPT5_2609/#c4-container-diagram","title":"C4 Container Diagram","text":"<pre><code>graph TD\n    subgraph Runtime[\"RDK-B Middleware Runtime\"]\n        subgraph LMLiteContainer[\"CcspLMLite Process\"]\n            LMMain[\"lm_main.c\\nCore Host State &amp; Threads\"]\n            Presence[\"device_presence_detection.c\\nPresence Engine\"]\n            NDS[\"network_devices_status.c\\nStatus Poller\"]\n            NDTraffic[\"network_devices_traffic.c\\nTraffic Poller\"]\n            WAN[\"cosa_wantraffic_api.c\\nWAN DSCP Counter\"]\n            RBUSMod[\"wtc_rbus_apis.c\\nRBUS Registration\"]\n            WebPAIfc[\"webpa_interface.c\\nWebPA/Parodus Adapter\"]\n            UnixAPI[\"lm_api.c\\nUnix Socket API\"]\n            DML[\"plugin_main.c &amp; cosa_*_dml.c\\nTR-181 Handlers\"]\n            Avro[\"*_avropack.c\\nAvro Serialization\"]\n        end\n        subgraph System[\"System Services\"]\n            Dnsmasq[(dnsmasq.leases)]\n            ARP[(ARP Cache)]\n            Syscfg[(syscfg/NVRAM)]\n            Sysevent[(sysevent)]\n        end\n        RBUSBus[(rbusd)]\n        ParodusProc[(parodus)]\n    end\n\n    Dnsmasq --&gt;|Lease Data| LMMain\n    ARP --&gt;|MAC/IP| LMMain\n    Syscfg --&gt;|Config Values| LMMain\n    Sysevent --&gt;|Events| WebPAIfc\n    RBUSMod &lt;--&gt; RBUSBus\n    WebPAIfc --&gt; ParodusProc\n    Presence --&gt; LMMain\n    NDS --&gt; LMMain\n    NDTraffic --&gt; LMMain\n    WAN --&gt; RBUSMod\n    UnixAPI --&gt; LMMain</code></pre>"},{"location":"docu/LMLite_GPT5_2609/#design-explanation-request-flow","title":"Design Explanation &amp; Request Flow","text":"<ul> <li>Request Flow Sequence: Typical remote Get/Set from cloud -&gt; WebPA -&gt; CCSP TR\u2011181 handler -&gt; internal host structure -&gt; (optional update) -&gt; commit/rollback. Presence detection events flow from polling threads / state transitions to WebPA notifications.</li> </ul> <pre><code>sequenceDiagram\n    participant Cloud\n    participant WebPA as WebPA/Parodus\n    participant CCSP as CCSP Core\n    participant LML as CcspLMLite DML\n    participant State as Host State\n\n    Cloud-&gt;&gt;WebPA: GET Device.Hosts.Host.1.Active\n    WebPA-&gt;&gt;CCSP: TR-181 Get\n    CCSP-&gt;&gt;LML: Dispatch GetParamBoolValue\n    LML-&gt;&gt;State: Read host active flag\n    State--&gt;&gt;LML: Active=true\n    LML--&gt;&gt;CCSP: Return value\n    CCSP--&gt;&gt;WebPA: Value true\n    WebPA--&gt;&gt;Cloud: Response 200 {true}</code></pre>"},{"location":"docu/LMLite_GPT5_2609/#threading-model","title":"Threading Model","text":"<p>Multi-threaded model using pthreads and condition variables: - Main host management thread(s) in <code>lm_main.c</code> handle queue events (Ethernet/WiFi/MoCA, validation queue) and synchronization of host objects. - Network Device Status harvesting thread (<code>StartNetworkDeviceStatusHarvesting</code>) polls at <code>NDSPollingPeriod</code> and signals reporting logic. - Network Device Traffic harvesting analogous thread for traffic counters. - Presence processing thread (<code>processPresenceNotification</code>) manages join/leave detection with IPv4/IPv6 retry intervals. - WAN traffic RBUS initialization occurs during feature setup; RBUS callbacks may be invoked concurrently. - WebPA interface uses mutex <code>webpa_mutex</code> to serialize message sending. - Multiple mutexes guard shared state: <code>LmHostObjectMutex</code>, <code>HostNameMutex</code>, <code>PollHostMutex</code>, <code>LmRetryHostListMutex</code>, <code>ndsMutex</code>, etc.</p>"},{"location":"docu/LMLite_GPT5_2609/#internal-modules","title":"Internal Modules","text":"Module/Class Description Key Files Core Host State Maintains consolidated host list, IPs, timing, synchronization operations <code>lm_main.c</code>, <code>lm_util.c</code>, <code>lm_wrapper.c</code> Presence Detection Determines join/leave, manages notification enable per host &amp; presence algorithms <code>device_presence_detection.c</code>, <code>webpa_pd_*</code> TR\u2011181 DML Handlers Implements parameter getters/setters, synchronization, validation, commit/rollback <code>cosa_hosts_dml.c</code>, <code>cosa_ndstatus_dml.c</code>, <code>cosa_ndtraffic_dml.c</code>, <code>plugin_main.c</code> Network Device Status Polls and aggregates status metrics, timing, TTL override logic <code>network_devices_status.c</code> Network Device Traffic Gathers per-device traffic metrics, prepares Avro payloads <code>network_devices_traffic.c</code>, <code>network_devices_traffic_avropack.c</code> Avro Serialization Packs status/traffic data for upstream telemetry <code>*_avropack.c</code>, <code>extender_associated_devices_avropack.c</code> WAN Traffic Count Manages DSCP-based WAN traffic statistics via RBUS table <code>cosa_wantraffic_api.c</code>, <code>wtc_rbus_apis.c</code>, <code>cosa_wantraffic_utils.c</code> WebPA Interface Sends telemetry &amp; presence notifications upstream via Parodus (WRP events) <code>webpa_interface.c</code> Unix Socket API Provides local client API for host queries &amp; network mgmt <code>lm_api.c</code>, <code>lm_api.h</code> Management Server (Manageable Devices) Synchronizes ManageableDevice table with Host table <code>cosa_managementserver_dml.c</code> Reporting Orchestrator Report scheduling &amp; object creation <code>cosa_reports_internal.c</code> <p>Module Breakdown Diagram: <pre><code>flowchart LR\n    subgraph CcspLMLite\n        Core[Core Host State]\n        Presence[Presence Detection]\n        NDS[Net Dev Status]\n        NDT[Net Dev Traffic]\n        WAN[WAN Traffic Count]\n        DML[TR-181 DML]\n        Avro[Avro Pack]\n        WebPA[WebPA Interface]\n        UnixAPI[Unix Socket API]\n        Mgmt[ManageableDevice Sync]\n    end\n    Core --&gt; Presence\n    Core --&gt; NDS\n    Core --&gt; NDT\n    Core --&gt; WAN\n    Core --&gt; DML\n    NDS --&gt; Avro\n    NDT --&gt; Avro\n    Presence --&gt; WebPA\n    Core --&gt; UnixAPI\n    Core --&gt; Mgmt\n    DML --&gt; WebPA</code></pre></p>"},{"location":"docu/LMLite_GPT5_2609/#interaction-with-other-middleware-components","title":"Interaction with Other Middleware Components","text":"<pre><code>flowchart TD\n    CcspLMLite[\"CcspLMLite\"] --&gt;|\"TR-181 Get/Set dispatch\"| WiFiAgent[\"WiFi Agent\"]\n    CcspLMLite --&gt;|\"TR-181 Get/Set dispatch\"| EthAgent[\"Ethernet Agent\"]\n    CcspLMLite --&gt;|\"RBus Table Events\"| rbusd[\"rbusd Daemon\"]\n    CcspLMLite --&gt;|\"WRP Events (Presence / Telemetry)\"| Parodus[\"Parodus\"]\n\n    WiFiAgent --&gt;|\"AssociatedDevice stats\"| CcspLMLite\n    EthAgent --&gt;|\"Link / MAC data\"| CcspLMLite\n    MoCAAgent[\"MoCA Agent\"] --&gt;|\"MoCA host sync\"| CcspLMLite</code></pre> Component Purpose of Interaction Protocols/Mechanisms WiFi Agent Supply Wi-Fi associated device stats (RSSI, interface mapping) CCSP TR\u2011181, internal sync triggers Ethernet Agent Ethernet host MAC/IP updates CCSP TR\u2011181 MoCA Agent MoCA host synchronization CCSP TR\u2011181 (conditional) Parodus/WebPA Upstream telemetry &amp; presence events WRP over WebSocket (libparodus) RBUS Daemon WAN traffic DSCP table registration RBUS API Syscfg/Sysevent Config persistence and runtime events syscfg key/value, sysevent API <p>Events Published (examples):</p> Event Purpose of Event Reason for trigger PresenceNotification Notify cloud of host join/leave with interface &amp; hostname Host state transition detected in presence thread DSCPCountPerInterval Provide DSCP distribution per counting interval RBUS subscription interval elapsed NetworkDevicesStatusReport Periodic batched status snapshot Reporting period expiry NetworkDevicesTrafficReport Periodic traffic counters snapshot Reporting period expiry"},{"location":"docu/LMLite_GPT5_2609/#interaction-with-other-layers","title":"Interaction with Other Layers","text":"Layer/Service Interaction Description Mechanism HAL / Drivers Indirect via WiFi/Ethernet/MoCA agents for link &amp; RSSI CCSP TR\u2011181 chain Platform (syscfg, sysevent) Persist intervals, obtain MAC, handle runtime events syscfg_get/set, sysevent APIs External Cloud Receive telemetry / presence events &amp; issue parameter changes WebPA/Parodus, TR\u2011181 Set/Get <p>Layered Architecture View: <pre><code>graph TD\n    HAL[(Radio/Eth/MoCA HAL)] --&gt; Agents[WiFi/Eth/MoCA Agents]\n    Agents --&gt; CcspLMLite[\"CcspLMLite\"]\n    CcspLMLite --&gt; Parodus[(Parodus / Cloud)]\n    CcspLMLite --&gt; RBUS[(RBUS)]\n    CcspLMLite --&gt; Syscfg[(syscfg/NVRAM)]</code></pre></p>"},{"location":"docu/LMLite_GPT5_2609/#ipc-mechanism","title":"IPC Mechanism","text":"Type of IPC Message Format Mechanism TR\u2011181 CCSP Parameter Get/Set/Notify semantics; typed values CCSP Message Bus (DBus) Unix Domain Socket Binary request structs (command enums) &amp; result union (host arrays) <code>/tmp/lm.sock</code> local socket WebPA Events WRP event messages (JSON or binary payload) libparodus WebSocket RBUS Table &amp; Events RBUS data elements with handlers &amp; subscriptions RBUS API Condition Signaling N/A (synchronization only) pthread cond/mutex <p>IPC Flow (Unix Host Query): <pre><code>sequenceDiagram\n    participant Client as Local Tool\n    participant Socket as /tmp/lm.sock\n    participant LM as LM Core\n    Client-&gt;&gt;Socket: send LM_API_CMD_GET_HOSTS\n    Socket-&gt;&gt;LM: dispatch command\n    LM--&gt;&gt;Socket: LM_hosts_t (count + array)\n    Socket--&gt;&gt;Client: response struct</code></pre></p>"},{"location":"docu/LMLite_GPT5_2609/#tr181-data-models","title":"TR\u2011181 Data Models","text":"<p>Implemented Key Objects (subset): - <code>Device.Hosts</code> and dynamic <code>Device.Hosts.Host.{i}</code> with sub\u2011objects <code>IPv4Address</code> &amp; <code>IPv6Address</code>. - Optional <code>Device.XHosts.XHost.{i}</code> (non\u2011optimized builds) mirroring host set. - <code>Device.NetworkDevicesStatus.*</code> and <code>Device.NetworkDevicesTraffic.*</code> (polling/report intervals, enable flags, defaults, override TTL). - <code>Device.X_RDK_WAN.Interface.{i}.Stats.*</code> (RBUS WAN traffic DSCP counting) when WAN feature enabled. - Presence related parameters: <code>X_RDK_PresenceDetectEnable</code>, <code>X_RDKCENTRAL-COM_WebPA_PresenceNotificationEnable</code>, add/delete notification MAC lists, join/leave interval/retry settings, host-level <code>X_RDKCENTRAL-COM_PresenceNotificationEnabled</code>, <code>RDK_PresenceActive</code>, timestamps.</p> <p>Parameter Registration is performed in <code>plugin_main.c</code> via <code>RegisterFunction</code> for each getter/setter, with dynamic table synchronization handlers (<code>*_GetEntryCount</code>, <code>*_Synchronize</code>). Atomic Set semantics rely on staged values validated then committed or rolled back.</p> <p>Custom / Extended Parameters (examples): - <code>X_RDKCENTRAL-COM_HostVersionId</code>: Host table version for consumer cache invalidation. - <code>X_RDKCENTRAL-COM_LMHost_Sync</code> &amp; interface/multi-technology sync triggers. - Presence tuning: <code>X_RDKCENTRAL-COM_PresenceLeaveIPv4Retries</code>, <code>X_RDKCENTRAL-COM_BackgroundPresenceJoinInterval</code>. - WAN DSCP: <code>Device.X_RDK_WAN.Interface.{i}.Stats.DscpCountEnable</code>, <code>...Interval</code>, <code>...PerInterval</code>, <code>...Total</code>.</p> <p>(See <code>config/LMLite.XML</code> for comprehensive list.)</p>"},{"location":"docu/LMLite_GPT5_2609/#implementation-details","title":"Implementation Details","text":"<ul> <li>Key Algorithms / Logic: Host synchronization merges data from DHCP leases, ARP, Wi\u2011Fi association, MoCA lists, tracking Active vs Inactive durations and presence transitions. Presence detection applies retry counts &amp; intervals (IPv4/IPv6) before declaring leave, reducing false negatives. Network status &amp; traffic modules implement periodic polling with adjustable intervals and TTL override logic resetting to defaults after configured time-to-live. WAN traffic counting registers RBUS data elements and stores DSCP distributions, supporting dynamic enable &amp; interval changes.</li> <li>Error Handling Strategy: Functions return explicit status codes; validation ensures bounds on arrays (e.g., IP list sizes). Safe C library used for bounded copies (<code>strncpy_s</code>, <code>sprintf_s</code>). Failed RBUS or socket initializations short-circuit feature activation. Conditional compilation avoids invalid calls when features disabled.</li> <li>Logging &amp; Debugging: Wrapper macros (<code>CcspLMLiteConsoleTrace</code>, <code>CcspTraceWarning</code>, <code>WTC_LOG_INFO/ERROR</code>) categorize messages. Optional onboard logging macro (<code>OnboardLog</code>). Telemetry events may be emitted for presence transitions and report start/stop.</li> </ul>"},{"location":"docu/LMLite_GPT5_2609/#key-configuration-files","title":"Key Configuration Files","text":"Configuration File Purpose Key Parameters Default Values Override Mechanisms <code>config/LMLite.XML</code> TR\u2011181 object &amp; parameter bindings Host tables, presence tuning, status/traffic params As defined in XML (e.g., max instances 64) Updated via TR\u2011181 Sets (persisted by syscfg where implemented) <code>dnsmasq.leases</code> (runtime) Source of DHCP lease info MAC/IP/Lease Time Runtime dynamic External daemon updates syscfg keys Store presence and interval settings Polling/Reporting/Presence flags Build defaults TR\u2011181 Set -&gt; syscfg commit"},{"location":"docu/LMLite_GPT5_2609/#quality-validation-notes","title":"Quality &amp; Validation Notes","text":"<ul> <li>Mutex &amp; cond var usage prevents race on host list &amp; reporting periods.</li> <li>Atomic TR\u2011181 updates comply with validate/commit/rollback pattern.</li> <li>Feature flags reduce runtime overhead in constrained builds.</li> <li>RBUS registration guarded by runtime RBUS status check.</li> </ul>"},{"location":"docu/LMLite_GPT5_2609/#future-improvement-opportunities","title":"Future / Improvement Opportunities","text":"<ul> <li>Abstract data source adapters to plug new technologies without modifying core.</li> <li>Add rate limiting / batching for presence notifications to reduce chatter.</li> <li>Provide JSON schema for Avro-packed payload inspection.</li> <li>Unit tests expansion for WAN DSCP RBUS handlers.</li> </ul> <p>Generated from source analysis (Sep 2025). All placeholders removed; diagrams follow RDK\u2011B diagram guidelines.</p>"},{"location":"docu/PSM_Claude_2609/","title":"CcspPsm (Persistent Storage Manager) Documentation","text":"<p>CcspPsm is a critical middleware component in the RDK-B stack that provides centralized persistent storage services for TR-181 data model parameters and configuration data. It acts as a registry and storage manager that allows other CCSP components to store, retrieve, and manage persistent configuration parameters across device reboots. The component serves as the authoritative source for device configuration state and provides both DBus and RBus interfaces for parameter access and management.</p> <pre><code>graph TD\n    subgraph \"External Systems\"\n        TR069[TR-069 ACS]\n        WebUI[Web Management UI]\n        CLI[Command Line Interface]\n    end\n\n    subgraph \"RDK-B Middleware Components\"\n        DMCLI[dmcli]\n        TR069PA[TR-069 PA]\n        TR181PA[TR-181 PA]\n        WebPA[WebPA]\n        CcspDM[CCSP DM]\n    end\n\n    subgraph \"CcspPsm Container\"\n        PSM[CcspPsm Process]\n    end\n\n    subgraph \"Storage Layer\"\n        XMLFiles[(XML Config Files)]\n        NVRAMFiles[(NVRAM Storage)]\n        SysConfFiles[(Syscfg Storage)]\n    end\n\n    TR069 --&gt;|Management Commands| TR069PA\n    WebUI --&gt;|HTTP Requests| WebPA\n    CLI --&gt;|CLI Commands| DMCLI\n\n    TR069PA --&gt;|DBus/RBus| PSM\n    TR181PA --&gt;|DBus/RBus| PSM\n    WebPA --&gt;|DBus/RBus| PSM\n    DMCLI --&gt;|DBus/RBus| PSM\n    CcspDM --&gt;|DBus/RBus| PSM\n\n    PSM --&gt;|Read/Write Config| XMLFiles\n    PSM --&gt;|Persistent Storage| NVRAMFiles\n    PSM --&gt;|System Config| SysConfFiles\n\n    classDef external fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n    classDef component fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef psm fill:#f3e5f5,stroke:#7b1fa2,stroke-width:3px;\n    classDef storage fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n\n    class TR069,WebUI,CLI external;\n    class DMCLI,TR069PA,TR181PA,WebPA,CcspDM component;\n    class PSM psm;\n    class XMLFiles,NVRAMFiles,SysConfFiles storage;</code></pre> <ul> <li>Key Features &amp; Responsibilities: </li> <li>Persistent Parameter Storage: Provides centralized storage and retrieval of TR-181 data model parameters with persistence across device reboots</li> <li>Configuration File Management: Loads, parses, and manages XML configuration files containing default parameter values and device-specific settings</li> <li>Multi-Protocol IPC Support: Supports both DBus and RBus communication protocols for parameter access from other middleware components</li> <li>Registry Services: Maintains an in-memory registry of parameters with efficient lookup and modification capabilities</li> <li>Atomic Operations: Ensures data consistency through atomic read/write operations and proper transaction handling</li> <li>Health Monitoring: Provides component health status and diagnostic information for system monitoring</li> </ul>"},{"location":"docu/PSM_Claude_2609/#design","title":"Design","text":""},{"location":"docu/PSM_Claude_2609/#highlevel-design-principles","title":"High\u2011Level Design Principles","text":"<p>CcspPsm follows a modular, service-oriented architecture that separates concerns between configuration file loading, in-memory registry management, and external communication interfaces. The design emphasizes reliability through robust error handling, data validation, and atomic operations to prevent configuration corruption. Scalability is achieved through efficient data structures and optimized parameter lookup algorithms. The component maintains strong security boundaries by validating all parameter access requests and enforcing proper authentication. Maintainability is ensured through clear module separation, comprehensive logging, and well-defined interfaces between internal components.</p> <p>The design establishes clear boundaries between the File Loader module (responsible for parsing XML configurations), the System Registry module (managing in-memory parameter storage), and the SSP layer (handling external communications). Each module has distinct responsibilities: File Loader handles configuration file parsing and validation, System Registry manages parameter storage and retrieval operations, and SSP provides DBus/RBus interface implementations. This separation enables independent testing, maintenance, and evolution of each subsystem while maintaining overall system coherence.</p>"},{"location":"docu/PSM_Claude_2609/#c4-container-diagram","title":"C4 Container Diagram","text":"<pre><code>graph TD\n    subgraph Runtime[\"Linux Process Environment\"]\n        subgraph CcspPsmContainer[\"CcspPsm Container (C/C++)\"]\n            FileLoader[PSM File Loader Module&lt;br/&gt;XML Configuration Parser]\n            SysRegistry[PSM System Registry&lt;br/&gt;In-Memory Parameter Store]\n            SSPLayer[SSP Communication Layer&lt;br/&gt;DBus/RBus Interface]\n        end\n        subgraph Storage[\"File System Storage\"]\n            ConfigDB[(Configuration Files&lt;br/&gt;XML Format)]\n            BackupDB[(Backup Storage&lt;br/&gt;NVRAM/Flash)]\n        end\n    end\n\n    FileLoader --&gt;|Parse/Load| ConfigDB\n    FileLoader --&gt;|Initialize Parameters| SysRegistry\n    SysRegistry --&gt;|Store/Retrieve| ConfigDB\n    SysRegistry --&gt;|Backup Operations| BackupDB\n    SSPLayer --&gt;|Parameter Operations| SysRegistry\n\n    classDef loader fill:#e3f2fd,stroke:#1976d2,stroke-width:2px;\n    classDef registry fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;\n    classDef ssp fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n    classDef storage fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n\n    class FileLoader loader;\n    class SysRegistry registry;\n    class SSPLayer ssp;\n    class ConfigDB,BackupDB storage;</code></pre>"},{"location":"docu/PSM_Claude_2609/#design-explanation-request-flow","title":"Design Explanation &amp; Request Flow","text":"<ul> <li>Request Flow Sequence: The most critical flow is parameter retrieval/storage. When an external component requests a parameter value, the request comes through either DBus or RBus to the SSP layer, which validates the request and forwards it to the System Registry. The registry performs efficient parameter lookup using hash tables and returns the value. For parameter updates, the flow includes validation, in-memory update, and eventual persistence to storage files.</li> </ul> <pre><code>sequenceDiagram\n    participant Client as CCSP Component\n    participant SSP as SSP Layer\n    participant Registry as System Registry\n    participant Storage as File Storage\n\n    Client-&gt;&gt;SSP: GetParameterValues(names[])\n    SSP-&gt;&gt;Registry: Lookup Parameters\n    Registry-&gt;&gt;Storage: Read if not cached\n    Storage--&gt;&gt;Registry: Parameter Values\n    Registry--&gt;&gt;SSP: Return Values\n    SSP--&gt;&gt;Client: Parameter Results\n\n    Client-&gt;&gt;SSP: SetParameterValues(params[])\n    SSP-&gt;&gt;Registry: Validate &amp; Update\n    Registry-&gt;&gt;Registry: Update In-Memory\n    Registry-&gt;&gt;Storage: Schedule Persistence\n    Storage--&gt;&gt;Registry: Write Confirmation\n    Registry--&gt;&gt;SSP: Success Response\n    SSP--&gt;&gt;Client: Operation Result</code></pre>"},{"location":"docu/PSM_Claude_2609/#threading-model","title":"Threading Model","text":"<p>CcspPsm uses a hybrid threading model combining a main event loop thread with worker threads for specific operations. The main thread handles DBus/RBus message processing and maintains the primary event loop for handling external requests. Worker threads are created on-demand for file I/O operations, configuration loading, and periodic backup tasks to prevent blocking the main communication thread. The System Registry maintains thread-safe parameter access through mutex locks and atomic operations to ensure data consistency across concurrent operations. A dedicated timer thread manages periodic tasks such as configuration file synchronization and health status reporting.</p>"},{"location":"docu/PSM_Claude_2609/#internal-modules","title":"Internal Modules","text":"<p>The CcspPsm component is organized into three primary modules that work together to provide persistent storage services. The File Loader module handles all configuration file operations including XML parsing, validation, and initial parameter loading. The System Registry module maintains the in-memory parameter database and provides efficient storage and retrieval operations. The SSP (System Service Provider) layer manages external communications through DBus and RBus interfaces, handling protocol-specific message formatting and authentication.</p> Module/Class Description Key Files PSM File Loader Handles XML configuration file parsing, validation, and initial parameter loading from default configuration files <code>psm_flo_base.c</code>, <code>psm_flo_parse.c</code>, <code>psm_flo_control.c</code>, <code>psm_flo_operation.c</code> PSM System Registry Manages in-memory parameter storage, provides efficient lookup/storage operations, and handles parameter persistence <code>psm_sysro_base.c</code>, <code>psm_sysro_storage.c</code>, <code>psm_sysro_operation.c</code>, <code>psm_sysro_control.c</code> SSP Communication Layer Provides DBus and RBus interface implementations for external component communication <code>ssp_main.c</code>, <code>ssp_dbus.c</code>, <code>ssp_rbus.c</code>, <code>ssp_cfmif.c</code> HAL Interface Platform-specific hardware abstraction layer for storage operations and device-specific configurations <code>psm_hal_apis.c</code> <pre><code>flowchart TD\n    subgraph CcspPsm[\"CcspPsm Component\"]\n        subgraph SSP[\"SSP Layer\"]\n            DBusIf([DBus Interface])\n            RBusIf([RBus Interface])\n            MainCtrl([Main Control])\n        end\n\n        subgraph Registry[\"System Registry\"]\n            ParamStore([Parameter Storage])\n            LookupEngine([Lookup Engine])\n            PersistMgr([Persistence Manager])\n        end\n\n        subgraph FileLoader[\"File Loader\"]\n            XMLParser([XML Parser])\n            ConfigValidator([Config Validator])\n            FileManager([File Manager])\n        end\n\n        subgraph HAL[\"HAL Interface\"]\n            StorageAPI([Storage APIs])\n            PlatformIf([Platform Interface])\n        end\n    end\n\n    DBusIf --&gt; MainCtrl\n    RBusIf --&gt; MainCtrl\n    MainCtrl --&gt; ParamStore\n    ParamStore --&gt; LookupEngine\n    LookupEngine --&gt; PersistMgr\n    PersistMgr --&gt; XMLParser\n    XMLParser --&gt; ConfigValidator\n    ConfigValidator --&gt; FileManager\n    FileManager --&gt; StorageAPI\n    StorageAPI --&gt; PlatformIf\n\n    classDef ssp fill:#e3f2fd,stroke:#1976d2,stroke-width:2px;\n    classDef registry fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;\n    classDef loader fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n    classDef hal fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n\n    class DBusIf,RBusIf,MainCtrl ssp;\n    class ParamStore,LookupEngine,PersistMgr registry;\n    class XMLParser,ConfigValidator,FileManager loader;\n    class StorageAPI,PlatformIf hal;</code></pre>"},{"location":"docu/PSM_Claude_2609/#interaction-with-other-middleware-components","title":"Interaction with Other Middleware Components","text":"<p>CcspPsm serves as the central parameter storage service for the entire RDK-B middleware stack, providing parameter storage and retrieval services to numerous components. It receives parameter get/set requests from TR-069 PA for remote management operations, TR-181 PA for data model access, WebPA for web-based configuration, and dmcli for command-line operations. The component also interacts with various functional components like WiFi manager, WAN manager, and device management modules for storing their specific configuration parameters.</p> <pre><code>flowchart TD\n    subgraph \"Management Interfaces\"\n        TR069PA[TR-069 PA]\n        WebPA[WebPA Agent]\n        DMCLI[DMCLI Tool]\n    end\n\n    subgraph \"Data Model Layer\"\n        TR181PA[TR-181 PA]\n        CcspDM[CCSP DM Bus]\n    end\n\n    subgraph \"Functional Components\"\n        WiFiMgr[WiFi Manager]\n        WANMgr[WAN Manager]\n        DevMgr[Device Manager]\n        FirewallMgr[Firewall Manager]\n    end\n\n    CcspPsm --&gt;|DBus Parameter APIs| TR069PA\n    CcspPsm --&gt;|RBus Parameter APIs| WebPA\n    CcspPsm --&gt;|DBus CLI Interface| DMCLI\n    CcspPsm --&gt;|DBus Data Model| TR181PA\n    CcspPsm --&gt;|Message Bus| CcspDM\n    CcspPsm --&gt;|DBus Config Storage| WiFiMgr\n    CcspPsm --&gt;|DBus Config Storage| WANMgr\n    CcspPsm --&gt;|DBus Config Storage| DevMgr\n    CcspPsm --&gt;|DBus Config Storage| FirewallMgr\n\n    classDef mgmt fill:#e3f2fd,stroke:#1976d2,stroke-width:2px;\n    classDef datamodel fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;\n    classDef functional fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n    classDef psm fill:#fff8e1,stroke:#f57f00,stroke-width:3px;\n\n    class TR069PA,WebPA,DMCLI mgmt;\n    class TR181PA,CcspDM datamodel;\n    class WiFiMgr,WANMgr,DevMgr,FirewallMgr functional;\n    class CcspPsm psm;</code></pre> Component Purpose of Interaction Protocols/Mechanisms TR-069 PA Remote management parameter operations for ACS communication DBus method calls, parameter get/set APIs WebPA Agent Web-based parameter management and device configuration RBus parameter APIs, notification events TR-181 PA Data model parameter access and TR-181 object management DBus parameter APIs, bulk operations DMCLI Tool Command-line parameter access for debugging and configuration DBus direct parameter APIs WiFi Manager WiFi configuration parameter storage and retrieval DBus parameter storage, configuration events WAN Manager WAN interface configuration parameter management DBus parameter storage, connection events <p>CcspPsm publishes several key events to notify other components about parameter changes and system state updates. These events enable reactive configuration management and system coordination across the middleware stack.</p> Event Purpose of Event Reason for trigger parameterValueChanged Notifies components when parameter values are modified Triggered when any TR-181 parameter is updated via set operations systemReady Indicates PSM has completed initialization and is ready for requests Fired after successful configuration loading and registry initialization configurationBackupComplete Notifies about successful configuration backup operations Triggered after periodic backup operations or manual backup requests parameterCommitReady Indicates parameters are staged and ready for commit Fired when transaction-based parameter updates are prepared for persistence"},{"location":"docu/PSM_Claude_2609/#interaction-with-other-layers","title":"Interaction with Other Layers","text":"<p>CcspPsm interacts extensively with multiple layers in the RDK-B software stack to provide comprehensive persistent storage services. At the HAL layer, it uses platform-specific storage APIs for accessing NVRAM, flash memory, and file system resources. The component interfaces with platform services like syscfg for system configuration management and integrates with Linux system services for file I/O operations and process management.</p> Layer/Service Interaction Description Mechanism HAL Storage Platform-specific storage operations for NVRAM and flash memory access Direct HAL API calls, file system operations Syscfg Service System configuration parameter management and cross-component coordination DBus syscfg APIs, shared configuration database Linux File System Configuration file I/O, backup operations, and temporary file management Standard POSIX file operations, directory monitoring Platform Services Integration with systemd, logging services, and system health monitoring System service APIs, logging frameworks Security Framework Parameter access control, authentication, and authorization Security API calls, permission validation <pre><code>graph TD\n    subgraph \"Application Layer\"\n        Apps[Management Applications]\n    end\n\n    subgraph \"Middleware Layer\"\n        CcspPsm[CcspPsm Component]\n        OtherMW[Other CCSP Components]\n    end\n\n    subgraph \"System Services Layer\"\n        Syscfg[Syscfg Service]\n        SystemD[SystemD Services]\n        Logging[Log Management]\n    end\n\n    subgraph \"HAL Layer\"\n        StorageHAL[Storage HAL]\n        PlatformHAL[Platform HAL]\n    end\n\n    subgraph \"Kernel/Hardware\"\n        FileSystem[File System]\n        NVRAM[NVRAM Storage]\n        Flash[Flash Memory]\n    end\n\n    Apps --&gt;|Management Requests| CcspPsm\n    CcspPsm --&gt;|Parameter APIs| OtherMW\n    CcspPsm --&gt;|Config Management| Syscfg\n    CcspPsm --&gt;|Service Control| SystemD\n    CcspPsm --&gt;|Diagnostic Logs| Logging\n    CcspPsm --&gt;|Storage Operations| StorageHAL\n    CcspPsm --&gt;|Platform APIs| PlatformHAL\n    StorageHAL --&gt;|File I/O| FileSystem\n    StorageHAL --&gt;|Persistent Data| NVRAM\n    StorageHAL --&gt;|Configuration| Flash\n\n    classDef app fill:#e3f2fd,stroke:#1976d2,stroke-width:2px;\n    classDef middleware fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;\n    classDef system fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n    classDef hal fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n    classDef hardware fill:#fce4ec,stroke:#c2185b,stroke-width:2px;\n\n    class Apps app;\n    class CcspPsm,OtherMW middleware;\n    class Syscfg,SystemD,Logging system;\n    class StorageHAL,PlatformHAL hal;\n    class FileSystem,NVRAM,Flash hardware;</code></pre>"},{"location":"docu/PSM_Claude_2609/#ipc-mechanism","title":"IPC Mechanism","text":"Type of IPC Message Format Mechanism DBus CCSP parameter structure with name-value pairs, XML-based method calls, structured parameter arrays DBus method invocation with CCSP base APIs, message serialization RBus RBus native data types with automatic type conversion, binary message format, event subscription model RBus direct API calls, native type marshalling, event publishing Message Queues Internal component communication using ANSC message structures, control messages, state notifications POSIX message queues, semaphore synchronization <p>CcspPsm implements a sophisticated IPC architecture supporting both legacy DBus interfaces and modern RBus communication. The DBus interface provides backward compatibility with existing CCSP components using XML-based parameter structures and method calls. The RBus interface offers improved performance with native data type support and efficient binary serialization. Internal communication between modules uses ANSC framework message structures for control operations and state management.</p> <pre><code>sequenceDiagram\n    participant Client as External Component\n    participant DBus as DBus Interface\n    participant RBus as RBus Interface  \n    participant Controller as PSM Controller\n    participant Registry as Parameter Registry\n    participant Storage as File Storage\n\n    Note over Client,Storage: DBus Parameter Get Flow\n    Client-&gt;&gt;DBus: GetParameterValues(paramNames[])\n    DBus-&gt;&gt;Controller: Process DBus Request\n    Controller-&gt;&gt;Registry: Lookup Parameters\n    Registry-&gt;&gt;Storage: Read from storage if needed\n    Storage--&gt;&gt;Registry: Parameter data\n    Registry--&gt;&gt;Controller: Parameter values\n    Controller--&gt;&gt;DBus: Format DBus Response\n    DBus--&gt;&gt;Client: Parameter results\n\n    Note over Client,Storage: RBus Parameter Set Flow\n    Client-&gt;&gt;RBus: SetParameterValues(params[])\n    RBus-&gt;&gt;Controller: Process RBus Request\n    Controller-&gt;&gt;Registry: Validate &amp; Update\n    Registry-&gt;&gt;Registry: Update in-memory store\n    Registry-&gt;&gt;Storage: Schedule persistence\n    Storage--&gt;&gt;Registry: Persistence confirmation\n    Registry--&gt;&gt;Controller: Update successful\n    Controller--&gt;&gt;RBus: Format RBus Response\n    RBus--&gt;&gt;Client: Operation result\n\n    Note over Controller,Storage: Event Publishing\n    Registry-&gt;&gt;Controller: Parameter change event\n    Controller-&gt;&gt;DBus: Publish DBus signal\n    Controller-&gt;&gt;RBus: Publish RBus event\n    DBus--&gt;&gt;Client: Parameter change notification\n    RBus--&gt;&gt;Client: Parameter change notification</code></pre>"},{"location":"docu/PSM_Claude_2609/#tr181-data-models","title":"TR\u2011181 Data Models","text":"<ul> <li>Implemented Parameters: CcspPsm implements core TR-181 Device.DeviceInfo parameters for device identification and system information, Device.ManagementServer parameters for TR-069 ACS communication settings, and Device.Time parameters for system time configuration. It also manages numerous vendor-specific and custom parameters for platform-specific device configuration.</li> <li>Parameter Registration: Parameters are registered through the System Registry module using hash-table based indexing for efficient lookup. The component supports both static parameter registration from XML configuration files and dynamic registration for runtime-created parameters. Access control is enforced through CCSP authentication mechanisms integrated with DBus and RBus interfaces.</li> <li>Custom Extensions: Platform-specific parameter extensions for advanced WiFi configuration, hardware-specific device settings, custom diagnostic parameters for system monitoring and troubleshooting, vendor-specific management parameters for proprietary features, and extended telemetry parameters for performance monitoring and analytics.</li> </ul> <p>CcspPsm manages a comprehensive set of TR-181 parameters covering device information, management server configuration, and various functional areas. The parameter implementation includes proper type validation, range checking, and access control enforcement.</p> Parameter Description Access (R/W) Default Notes <code>Device.DeviceInfo.Manufacturer</code> Device manufacturer name R \"RDK Management\" Standard TR-181 <code>Device.DeviceInfo.ModelName</code> Device model identifier R \"\" Platform-specific <code>Device.DeviceInfo.SoftwareVersion</code> Current software version R \"\" Auto-populated <code>Device.ManagementServer.URL</code> TR-069 ACS server URL R/W \"\" Management config <code>Device.ManagementServer.Username</code> ACS authentication username R/W \"\" Encrypted storage <code>Device.ManagementServer.Password</code> ACS authentication password W \"\" Write-only, encrypted <code>Device.Time.NTPServer1</code> Primary NTP server address R/W \"pool.ntp.org\" Time synchronization <code>Device.WiFi.Radio.1.Enable</code> WiFi radio 1 enable status R/W <code>true</code> Custom validation <code>Device.Custom.Namespace.DebugLevel</code> Component debug logging level R/W <code>3</code> Custom extension"},{"location":"docu/PSM_Claude_2609/#implementation-details","title":"Implementation Details","text":"<ul> <li> <p>Key Algorithms or Logic: CcspPsm employs efficient hash-table based parameter lookup algorithms in the System Registry module (<code>psm_sysro_storage.c</code>) for O(1) average-case parameter access. The File Loader module (<code>psm_flo_parse.c</code>) implements SAX-based XML parsing for memory-efficient configuration file processing. Parameter persistence uses atomic file operations with backup mechanisms to prevent configuration corruption during system failures. The component implements lazy loading for configuration parameters to optimize memory usage and startup time.</p> </li> <li> <p>Error Handling Strategy: Comprehensive error detection includes XML parsing validation, parameter type checking, storage operation verification, and IPC communication error handling. Errors are logged through the RDK logging framework with categorized severity levels (Error, Warning, Info, Debug). Critical errors trigger component restart mechanisms, while recoverable errors are handled gracefully with fallback to default values. Error propagation follows CCSP standards with appropriate error codes returned to calling components.</p> </li> <li> <p>Logging &amp; Debugging: Logging categories include CONFIG (configuration operations), STORAGE (file I/O operations), IPC (communication events), and PARAM (parameter operations). Verbosity levels range from 0 (errors only) to 4 (full debug tracing). Debug tools include parameter dump utilities, configuration validation tools, and runtime memory usage monitors. The component supports dynamic log level adjustment through TR-181 parameters for runtime debugging.</p> </li> </ul>"},{"location":"docu/PSM_Claude_2609/#key-configuration-files","title":"Key Configuration Files","text":"<p>CcspPsm relies on several critical configuration files that define default parameter values, component behavior, and platform-specific settings. These files are processed during component initialization and can be updated for customization and deployment-specific configurations.</p> Configuration File Purpose Key Parameters Default Values Override Mechanisms <code>bbhm_def_cfg_qemu.xml</code> Default parameter values and TR-181 object definitions TR-181 parameters, device-specific configs Platform defaults Environment variables, command-line args <code>debug.ini</code> Debug and logging configuration Log levels, output targets, categories Error level logging Runtime parameter updates <code>psm.cfg</code> Component-specific configuration Storage paths, backup intervals, cache sizes <code>/nvram/psm/</code> storage Configuration file overrides <code>systemd/ccsp-psm.service</code> SystemD service configuration Process startup, dependencies, restart policies Auto-restart enabled SystemD override files"},{"location":"docu/PSM_GPT5_2609/","title":"CcspPsm (Persistent Storage Manager) Documentation","text":"<p>The Persistent Storage Manager (PSM) provides centralized, transactional persistence for TR-181 configuration and runtime parameters in the RDK-B stack. It abstracts XML-backed configuration storage, mediates read/write access over legacy CCSP DBus APIs and the newer RBus interface, and ensures consistent boot-time loading, runtime updates, and periodic or signal-driven flush to flash/NVRAM. Upstream components (parameter owners / data model agents) query and update values through standardized IPC; downstream it manages on\u2011device XML config files (current, backup, default) and platform/HAL customizations. It is a single resident daemon (<code>PsmSsp</code>) that initializes at boot, exports parameter namespaces, and safeguards persistence integrity.</p> <ul> <li>Key Features &amp; Responsibilities:</li> <li>Centralized Parameter Registry: Maintains in\u2011memory authoritative store of persistent TR\u2011181 parameter values and metadata, exposing get/set operations.</li> <li>Config File Lifecycle Management: Loads default (<code>bbhm_def_cfg*</code>), current, backup, and temporary XML config variants; supports save, backup, restore, and update flows.</li> <li>DBus &amp; RBus Bridging: Implements CCSP Message Bus namespace (<code>com.cisco.spvtg.ccsp.psm.*</code>) and equivalent RBus provider methods for parameter operations (Get/Set/Attributes, UpdateConfigs, ReloadConfig).</li> <li>Write Coordination &amp; Flash Protection: Tracks file sync reference counts, disables writes when batching or critical operations occur, and flushes to flash safely on SIGTERM.</li> <li>Factory Reset &amp; Partner Customization Hooks: Observes special flags/trigger parameters to apply factory defaults and partner\u2011specific overrides/migrations.</li> <li>Logging &amp; Health Exposure: Publishes component health, memory usage, logging enable and level parameters for observability.</li> </ul>"},{"location":"docu/PSM_GPT5_2609/#design","title":"Design","text":""},{"location":"docu/PSM_GPT5_2609/#highlevel-design-principles","title":"High\u2011Level Design Principles","text":"<p>PSM isolates persistent configuration logic from feature components, enforcing a single source of truth and consistent serialization format. It is designed for reliability (graceful signal handling and safe writes), maintainability (modular separation: Sys Registry vs File Loader vs Service/IPC shim), and scalability across expanding TR\u2011181 namespaces via uniform parameter APIs. Security and integrity are supported by capability dropping (removal of root caps after startup) and controlled write windows. Modularity segregates parsing/loading (File Loader), registry/state (Sys Registry), and transport interfaces (Ssp layer for DBus/RBus). Clear boundaries define ownership of file I/O, parameter validation, and IPC serialization. Design choices (XML record hashing, locking primitives, and typed value handling) minimize contention and allow future migration to alternative storage backends with minimal external impact.</p> <p>Guiding principles: - Modularity: Distinct objects (Sys Registry, File Loader, CFM interface) with clear APIs (<code>PsmCreateSysRegistry</code>, <code>PsmCreateFileLoader</code>). - Scalability: Hash bucket storage (<code>PSM_REC_HASH_SIZE=1024</code>) allows O(1) average lookups as namespaces grow. - Reliability: Signal handlers (<code>SIGTERM</code>, <code>SIGUSR2</code>) ensure config flush and orderly disengage. - Security: Capability dropping (<code>drop_root_caps</code>) after initialization reduces privilege footprint. - Maintainability: Encapsulated parsing, record abstraction, and interface layers ease refactoring.</p>"},{"location":"docu/PSM_GPT5_2609/#c4-container-diagram","title":"C4 Container Diagram","text":"<pre><code>graph TD\n    %% Deployment-accurate grouping\n    subgraph Proc[\"PsmSsp Process (C, POSIX, CCSP/RBus)\"]\n        subgraph SysRegistry[\"Sys Registry (In-Memory State + Hash Records)\"]\n            Cache[(Record Hash Table)]\n        end\n        subgraph FileLoader[\"File Loader / Parser\"]\n            Parser[\"XML Parse &amp; Serialize\"]\n            Migrator[\"Partner Default &amp; Migration\"]\n        end\n        subgraph CFM[\"Config Mgmt Interface (ssp_cfmif.c)\"]\n            CurCur[\"Read/Save Current\"]\n            DefLoad[\"Read Default\"]\n            Updater[\"UpdateConfigs\"]\n        end\n        subgraph IPC[\"IPC Adapters\"]\n            DBus[\"CCSP DBus Handlers\"]\n            RBus[\"RBus Provider\"]\n        end\n        Signals[\"Signal Handlers &amp; Daemonize\"]\n    end\n\n    Flash[\"Flash / NVRAM\"]\n    XMLFiles[\"Current / Backup / Default XML\"]\n    OtherComps[\"Other RDK-B Components\"]\n\n    OtherComps --&gt;|\"Get/Set Params (DBus/RBus)\"| IPC\n    IPC --&gt; SysRegistry\n    SysRegistry --&gt; FileLoader\n    FileLoader --&gt;|\"Load/Save\"| XMLFiles\n    XMLFiles --&gt;|\"Persist\"| Flash\n    CFM --&gt; FileLoader\n    Signals --&gt; SysRegistry</code></pre>"},{"location":"docu/PSM_GPT5_2609/#design-explanation-request-flow","title":"Design Explanation &amp; Request Flow","text":"<ul> <li>Request Flow Sequence: Typical Get/Set over RBus/DBus.</li> </ul> <pre><code>sequenceDiagram\n    participant Comp as Caller Component\n    participant Bus as DBus/RBus\n    participant IPC as PSM IPC Layer\n    participant Reg as Sys Registry\n    participant FL as File Loader\n    participant FS as XML Files\n    Comp-&gt;&gt;Bus: GetParameterValues(Name[])\n    Bus-&gt;&gt;IPC: Translate &amp; Dispatch\n    IPC-&gt;&gt;Reg: Lookup(Hash + Validation)\n    Reg--&gt;&gt;IPC: Values (typed)\n    IPC--&gt;&gt;Bus: Marshal Response\n    Bus--&gt;&gt;Comp: Return Values\n    Comp-&gt;&gt;Bus: SetParameterValues(Name,Value)\n    Bus-&gt;&gt;IPC: Dispatch Set\n    IPC-&gt;&gt;Reg: Update In-Memory Record\n    Note over Reg: Mark dirty / track needs-flush\n    Reg-&gt;&gt;FL: (Deferred) SaveCurConfig trigger\n    FL-&gt;&gt;FS: Serialize XML (temp -&gt; backup -&gt; current)\n    FS--&gt;&gt;FL: Write OK</code></pre>"},{"location":"docu/PSM_GPT5_2609/#threading-model","title":"Threading Model","text":"<p>PSM operates largely single-threaded for its main event loop after daemonization, but employs: - DBus/RBus underlying threads (from their libraries) to invoke registered callbacks concurrently. - Internal locking via interface methods (<code>AcqThreadLock</code> / <code>RelThreadLock</code> through <code>pSysIraIf</code>) around critical sections for parameter enumeration and mutation. - A pthread mutex (<code>rec_hash_lock</code> in <code>ssp_cfmif.c</code>) protecting the record hash during parsing and update flows. - Signal handlers executing asynchronously for termination and maintenance (ensuring save before exit). No dynamic thread pools are created by PSM itself; concurrency is bounded to IPC callback threads and minimal mutex usage.</p>"},{"location":"docu/PSM_GPT5_2609/#internal-modules","title":"Internal Modules","text":"Module/Class Description Key Files Sys Registry (PsmSysRegistry) Core in\u2011memory parameter store, state machine for engage/cancel, property setup (file paths, sync control). <code>psm_sysro_interface.c</code>, <code>psm_sysro_*</code> files File Loader (PsmFileLoader) Parses and serializes XML config records, applies migrations &amp; partner defaults. <code>psm_flo_interface.c</code>, <code>psm_flo_*</code> files Config Mgmt Interface (CFM) High-level read/save/update wrappers exposed to Sys Registry (cur, def, bak, tmp file operations). <code>ssp_cfmif.c</code> Service/Support Platform (SSP) Daemon entrypoint, signal handling, capability dropping, bus initialization. <code>ssp_main.c</code> DBus Adapter Implements CCSP DBus namespace resolution, parameter get/set/attributes, health and metadata parameters. <code>ssp_dbus.c</code> RBus Adapter Provides RBus provider registration, value serialization bridging legacy types to RBus types. <code>ssp_rbus.c</code> HAL Interface Shims Optional platform-specific configuration read/write hooks (<code>USE_PLATFORM_SPECIFIC_HAL</code>). <code>psm_hal_apis.h</code>, <code>psm_hal_apis.c</code> <p>Module Breakdown Diagram: <pre><code>flowchart TD\n    subgraph CcspPsm\n        SR[Sys Registry]\n        FL[File Loader]\n        CFM[Config Mgmt]\n        IPC_DB[DBus Adapter]\n        IPC_RB[RBus Adapter]\n        SSP[Daemon / Signals]\n    end\n    SR &lt;--&gt; FL\n    SR --&gt; CFM\n    CFM --&gt; FL\n    IPC_DB --&gt; SR\n    IPC_RB --&gt; SR\n    SSP --&gt; SR</code></pre></p>"},{"location":"docu/PSM_GPT5_2609/#interaction-with-other-middleware-components","title":"Interaction with Other Middleware Components","text":"<p>PSM exposes parameter storage to other TR-181 enabled components; they consume Get/Set operations and may trigger reload or update events.</p> <pre><code>flowchart TD\n    CcspPsm --&gt;|DBus Get/Set| CompA[RDKB Component A]\n    CcspPsm --&gt;|RBus Get/Set| CompB[RDKB Component B]\n    CompA --&gt;|Notify FactoryReset| CcspPsm\n    CompB --&gt;|Trigger UpdateConfigs| CcspPsm</code></pre> Component Purpose of Interaction Protocols/Mechanisms Various Data Model Agents Retrieve/update persistent parameters CCSP DBus (<code>ccsp_message_bus</code>), RBus Reboot/Reset Manager Factory reset trigger parameter &amp; config reload DBus parameter set Logging/Diag Subsystem Read logging enable/level flags DBus/RBus <p>Events / Triggers Emitted or Observed (implicit via parameters):</p> Event Purpose of Event Reason for trigger <code>ReloadConfig</code> (param) Instructs PSM to reload current config from disk Admin or component request <code>UpdateConfigs</code> (param) Apply new configuration path and migrate Partner update / provisioning <code>FactoryReset</code> (param) Reset to defaults Factory reset workflow <code>DisableWriting</code> (state) Temporarily halt flash writes Batch update / migration"},{"location":"docu/PSM_GPT5_2609/#interaction-with-other-layers","title":"Interaction with Other Layers","text":"Layer/Service Interaction Description Mechanism HAL (optional) Platform-specific config access overrides Direct HAL calls (<code>psm_hal_apis</code>) Platform (Init/Systemd) Daemonization &amp; lifecycle (PID file, signals, systemd notify optional) POSIX signals, systemd sd_notify External (Flash/NVRAM FS) Persistent storage of XML config snapshots File I/O (atomic temp-&gt;bak-&gt;current) <p>Layered View: <pre><code>graph TD\n    HAL[(Platform HAL)] --&gt; PSM[CcspPsm]\n    PSM --&gt; Middleware[(Other CCSP/RBus Components)]\n    PSM --&gt; Storage[(Flash/NVRAM XML Files)]\n    Middleware --&gt; UI[(Mgmt Interfaces / Remote)]</code></pre></p>"},{"location":"docu/PSM_GPT5_2609/#ipc-mechanism","title":"IPC Mechanism","text":"Type of IPC Message Format Mechanism CCSP DBus Parameter operations (<code>GetParameterValues</code>, <code>SetParameterValues</code>), name spaces <code>com.cisco.spvtg.ccsp.psm.*</code> DBus via <code>ccsp_message_bus</code> RBus Typed parameter get/set bridging legacy enum to <code>rbusValue</code> types RBus library Signals POSIX signals for lifecycle (<code>SIGTERM</code>, <code>SIGUSR2</code>, etc.) Kernel signal delivery Semaphores Startup synchronization (<code>pSemPsm</code>) between parent/child during daemonize POSIX named semaphore <p>IPC Flow (DBus Set example): <pre><code>sequenceDiagram\n    participant Client as DM Client\n    participant DB as CCSP DBus\n    participant PSM as PSM Adapter\n    participant Reg as Sys Registry\n    Client-&gt;&gt;DB: SetParameterValues(Name,Value)\n    DB-&gt;&gt;PSM: Dispatch callback\n    PSM-&gt;&gt;Reg: Acquire Thread Lock\n    Reg--&gt;&gt;PSM: Update In-Memory Record\n    PSM-&gt;&gt;Reg: Release Thread Lock\n    PSM--&gt;&gt;DB: Status=Success\n    DB--&gt;&gt;Client: Return Response</code></pre></p>"},{"location":"docu/PSM_GPT5_2609/#tr181-data-models","title":"TR\u2011181 Data Models","text":"<ul> <li>Implemented Parameters: The component exposes meta parameters for itself (Name, Version, Author, Health, State, Memory usage metrics, Logging, FactoryReset, DisableWriting, ReloadConfig, UpdateConfigs, NewConfigPath) and user/partner TR\u2011181 parameters stored in XML records (dynamic set not enumerated here). Core exported namespace root: <code>com.cisco.spvtg.ccsp.psm</code>.</li> <li>Parameter Registration: Namespace array <code>NamespacePsm[]</code> (in <code>ssp_dbus.c</code>) defines static meta parameters with types; dynamic parameters loaded into Sys Registry accessible via standard CCSP get/set and mirrored to RBus.</li> <li>Custom Extensions:</li> <li>Partner default application &amp; migration flags (presence of marker files triggers logic in CFM interface).</li> <li>DisableWriting semantics controlling flash write gating during bulk update.</li> </ul> <p>Example Meta Parameter Table (subset):</p> Parameter Description Access (R/W) Default Notes <code>com.cisco.spvtg.ccsp.command.FactoryReset</code> Initiate factory reset (bool) W false Triggers reset workflow <code>com.cisco.spvtg.ccsp.psm.Name</code> Component name R <code>PersistentStorageManager</code> Set from constant <code>com.cisco.spvtg.ccsp.psm.Version</code> Component version R <code>1</code> Macro <code>CCSP_COMPONENT_VERSION_PSM</code> <code>com.cisco.spvtg.ccsp.psm.Health</code> Health state R Green Static string in current impl <code>com.cisco.spvtg.ccsp.psm.DisableWriting</code> Indicates write lock active R false True when FileSyncRefCount&gt;0 <code>com.cisco.spvtg.ccsp.psm.ReloadConfig</code> Reload config trigger W false Causes reparse of XML <code>com.cisco.spvtg.ccsp.psm.UpdateConfigs</code> Apply updated config files W false Uses new path variable"},{"location":"docu/PSM_GPT5_2609/#implementation-details","title":"Implementation Details","text":"<ul> <li>Key Algorithms or Logic: A hash-based record table (<code>PSM_REC_HASH_SIZE=1024</code>) supports efficient parameter lookup, with parsing routines constructing <code>psm_record</code> structs from XML <code>&lt;Record&gt;</code> entries. Save operations perform atomic sequence: write temp -&gt; copy to backup -&gt; replace current. Capability management reduces privileges post-init. RBus adapter maps legacy CCSP types to modern <code>rbusValueType_t</code>. Thread locks (<code>AcqThreadLock/RelThreadLock</code>) wrap batch operations. Signal logic ensures safe exit flush via <code>SaveConfigToFlash</code>.</li> <li>Error Handling Strategy: Returns statuses propagate through DBus handlers; memory allocations verified with early exit logging on failure. Defensive safe string operations (<code>strcpy_s</code>, return code <code>EOK</code> check) reduce buffer overflow risk. Fallbacks for core dump availability decide signal trapping vs. letting crash for diagnostics.</li> <li>Logging &amp; Debugging: Uses <code>CcspTraceInfo/Warning/Error/Debug</code> macros; log enable flag exposed via parameter. Backtrace collection (GNU <code>execinfo</code>) optionally writes to <code>/nvram/psmssp_backtrace</code> on abnormal signals. PID file at <code>/var/tmp/PsmSsp.pid</code>; initialization marker at <code>/tmp/psm_initialized</code>.</li> </ul>"},{"location":"docu/PSM_GPT5_2609/#key-configuration-files","title":"Key Configuration Files","text":"Configuration File Purpose Key Parameters Default Values Override Mechanisms <code>config/bbhm_def_cfg_qemu.xml</code> Default TR\u2011181 config baseline Record entries N/A (static file) Factory reset reload <code>/tmp/bbhm_cur_cfg.xml</code> Current active config Dynamic record set Derived from last save Updated by save flow <code>/nvram/bbhm_bak_cfg.xml</code> Backup snapshot Mirror of current Prior save version Used on recovery Markers: <code>/tmp/.apply_partner_defaults_psm</code> Partner migration trigger N/A Absent Created externally Markers: <code>/nvram/.apply_partner_defaults</code> Partner default flag N/A Absent Removed after apply"},{"location":"docu/PSM_GPT5_2609/#assumptions-notes","title":"Assumptions &amp; Notes","text":"<p>Some runtime behaviors (frequency of periodic saves, full dynamic TR\u2011181 parameter list) are inferred from code structure; exhaustive parameter enumeration would require inspecting generated/loaded XML at runtime, which is outside static source scope. The component currently reports Health=\"Green\" statically; dynamic health evaluation may be planned externally.</p>"},{"location":"docu/PSM_GPT5_2609/#future-improvements-potential","title":"Future Improvements (Potential)","text":"<ul> <li>Abstract storage backend to support binary or JSON formats with pluggable serializers.</li> <li>Implement dynamic health metrics (latency, hash load factor) exposed as parameters.</li> <li>Introduce journaling or WAL for crash-safe incremental persistence.</li> <li>Add unit tests for RBus bridging edge cases (legacy types, base64, bytes) similar to existing gtest suite for File Loader and Sys Registry.</li> </ul> <p>Generated following provided RDK-B documentation template &amp; diagram guidelines; diagrams label real protocols, deployment boundaries, and mechanisms.</p>"},{"location":"docu/RBUS_Claude_2609/","title":"RBUS Protocol Documentation","text":""},{"location":"docu/RBUS_Claude_2609/#1-overview","title":"1. Overview","text":"<p>RBUS (RDK Bus) is a lightweight, fast and efficient bus messaging system that enables interprocess communication (IPC) and remote procedure calls (RPC) between multiple processes running on a hardware device. It supports the creation and use of a hierarchical data model with named objects containing properties, events, and methods.</p>"},{"location":"docu/RBUS_Claude_2609/#2-architecture","title":"2. Architecture","text":""},{"location":"docu/RBUS_Claude_2609/#21-component-roles","title":"2.1 Component Roles","text":"<p>RBUS operates on a Provider-Consumer model:</p> <p>Providers: - Register properties and implement get/set operations - Register objects and implement CRUD operations (create, read, update, delete) - Register and publish events - Register and implement methods for remote invocation</p> <p>Consumers: - Get and set property values - Get, set, create, and delete objects - Subscribe to and listen for events - Invoke remote methods</p> <p>Note: A single process can act as both provider and consumer.</p>"},{"location":"docu/RBUS_Claude_2609/#22-naming-convention","title":"2.2 Naming Convention","text":"<p>RBUS follows TR-069 naming convention with hierarchical structure: - Levels separated by dots (<code>.</code>) - Object instances denoted by braces (<code>{}</code>) - Example: <code>Device.IP.Interface.{i}.Status</code></p>"},{"location":"docu/RBUS_Claude_2609/#3-core-data-types","title":"3. Core Data Types","text":""},{"location":"docu/RBUS_Claude_2609/#31-rbus-value-types","title":"3.1 RBUS Value Types","text":"<pre><code>typedef enum {\n    RBUS_BOOLEAN = 0x500,   // bool true or false\n    RBUS_CHAR,              // char of size 1 byte\n    RBUS_BYTE,              // unsigned char\n    RBUS_INT8,              // 8 bit int\n    RBUS_UINT8,             // 8 bit unsigned int\n    RBUS_INT16,             // 16 bit int\n    RBUS_UINT16,            // 16 bit unsigned int\n    RBUS_INT32,             // 32 bit int\n    RBUS_UINT32,            // 32 bit unsigned int\n    RBUS_INT64,             // 64 bit int\n    RBUS_UINT64,            // 64 bit unsigned int\n    RBUS_SINGLE,            // 32 bit float\n    RBUS_DOUBLE,            // 64 bit float\n    RBUS_DATETIME,          // rbusDateTime_t structure\n    RBUS_STRING,            // null terminated string\n    RBUS_BYTES,             // byte array\n    RBUS_PROPERTY,          // property instance\n    RBUS_OBJECT,            // object instance\n    RBUS_NONE\n} rbusValueType_t;\n</code></pre>"},{"location":"docu/RBUS_Claude_2609/#32-element-types","title":"3.2 Element Types","text":"<pre><code>typedef enum {\n    RBUS_ELEMENT_TYPE_PROPERTY = 1,  // Properties with get/set operations\n    RBUS_ELEMENT_TYPE_TABLE,         // Multi-instance objects\n    RBUS_ELEMENT_TYPE_EVENT,         // Event elements\n    RBUS_ELEMENT_TYPE_METHOD         // Method elements\n} rbusElementType_t;\n</code></pre>"},{"location":"docu/RBUS_Claude_2609/#4-error-codes","title":"4. Error Codes","text":""},{"location":"docu/RBUS_Claude_2609/#41-standard-error-codes","title":"4.1 Standard Error Codes","text":"<pre><code>typedef enum {\n    RBUS_ERROR_SUCCESS = 0,                     // Success\n    RBUS_ERROR_BUS_ERROR = 1,                   // General Error\n    RBUS_ERROR_INVALID_INPUT,                   // Invalid Input\n    RBUS_ERROR_NOT_INITIALIZED,                 // Bus not initialized\n    RBUS_ERROR_OUT_OF_RESOURCES,                // Running out of resources\n    RBUS_ERROR_DESTINATION_NOT_FOUND,           // Destination element not found\n    RBUS_ERROR_DESTINATION_NOT_REACHABLE,       // Destination element not reachable\n    RBUS_ERROR_DESTINATION_RESPONSE_FAILURE,    // Destination failed to respond\n    RBUS_ERROR_INVALID_RESPONSE_FROM_DESTINATION,// Invalid destination response\n    RBUS_ERROR_INVALID_OPERATION,               // Invalid Operation\n    RBUS_ERROR_INVALID_EVENT,                   // Invalid Event\n    RBUS_ERROR_INVALID_HANDLE,                  // Invalid Handle\n    RBUS_ERROR_SESSION_ALREADY_EXIST,           // Session already opened\n    RBUS_ERROR_COMPONENT_NAME_DUPLICATE,        // Component name already exists\n    RBUS_ERROR_ELEMENT_NAME_DUPLICATE,          // Element name previously registered\n    RBUS_ERROR_ELEMENT_NAME_MISSING,            // No names provided\n    RBUS_ERROR_COMPONENT_DOES_NOT_EXIST,        // Component not registered\n    RBUS_ERROR_ELEMENT_DOES_NOT_EXIST,          // Element not registered\n    RBUS_ERROR_ACCESS_NOT_ALLOWED,              // Access not permitted\n    RBUS_ERROR_INVALID_CONTEXT,                 // Context mismatch\n    RBUS_ERROR_TIMEOUT,                         // Operation timed out\n    RBUS_ERROR_ASYNC_RESPONSE,                  // Async method response\n    RBUS_ERROR_INVALID_METHOD,                  // Invalid Method\n    RBUS_ERROR_NOSUBSCRIBERS,                   // No subscribers present\n    RBUS_ERROR_SUBSCRIPTION_ALREADY_EXIST,      // Subscription already exists\n    RBUS_ERROR_INVALID_NAMESPACE,               // Invalid namespace\n    RBUS_ERROR_DIRECT_CON_NOT_EXIST,            // Direct connection not exist\n    RBUS_ERROR_NOT_WRITABLE,                    // Set not permitted\n    RBUS_ERROR_NOT_READABLE,                    // Get not permitted\n    RBUS_ERROR_INVALID_PARAMETER_TYPE,          // Invalid parameter type\n    RBUS_ERROR_INVALID_PARAMETER_VALUE          // Invalid parameter value\n} rbusError_t;\n</code></pre>"},{"location":"docu/RBUS_Claude_2609/#5-api-methods","title":"5. API Methods","text":""},{"location":"docu/RBUS_Claude_2609/#51-initialization-and-connection","title":"5.1 Initialization and Connection","text":""},{"location":"docu/RBUS_Claude_2609/#rbus_open","title":"rbus_open","text":"<p><pre><code>rbusError_t rbus_open(rbusHandle_t* handle, char const* componentName)\n</code></pre> Description: Opens a bus connection for a software component.</p> <p>Parameters: - <code>handle</code>: Bus Handle (output) - <code>componentName</code>: Name of the component initializing onto the bus</p> <p>Returns: RBUS_ERROR_SUCCESS on success, error codes on failure</p> <p>Example Usage: <pre><code>rbusHandle_t handle;\nrbusError_t rc = rbus_open(&amp;handle, \"MyComponent\");\nif(rc != RBUS_ERROR_SUCCESS) {\n    printf(\"Failed to open rbus: %d\\n\", rc);\n}\n</code></pre></p>"},{"location":"docu/RBUS_Claude_2609/#rbus_close","title":"rbus_close","text":"<p><pre><code>rbusError_t rbus_close(rbusHandle_t handle)\n</code></pre> Description: Closes a bus connection from a component.</p> <p>Parameters: - <code>handle</code>: Bus Handle</p> <p>Returns: RBUS_ERROR_SUCCESS on success</p>"},{"location":"docu/RBUS_Claude_2609/#rbus_checkstatus","title":"rbus_checkStatus","text":"<p><pre><code>rbusStatus_t rbus_checkStatus(void)\n</code></pre> Description: Checks whether RBUS is enabled on the device.</p> <p>Returns: RBUS status (RBUS_ENABLED, RBUS_DISABLED, etc.)</p>"},{"location":"docu/RBUS_Claude_2609/#52-element-registration","title":"5.2 Element Registration","text":""},{"location":"docu/RBUS_Claude_2609/#rbus_regdataelements","title":"rbus_regDataElements","text":"<p><pre><code>rbusError_t rbus_regDataElements(rbusHandle_t handle, int numDataElements, rbusDataElement_t *elements)\n</code></pre> Description: Registers one or more named data elements (parameters, events, methods).</p> <p>Parameters: - <code>handle</code>: Bus Handle - <code>numDataElements</code>: Number of elements to register - <code>elements</code>: Array of data elements</p> <p>Returns: RBUS_ERROR_SUCCESS or error codes</p> <p>Example: <pre><code>rbusDataElement_t dataElements[] = {\n    {\"Device.MyComponent.Property1\", RBUS_ELEMENT_TYPE_PROPERTY, \n     {getHandler, setHandler, NULL, NULL, NULL, NULL}},\n    {\"Device.MyComponent.Event1!\", RBUS_ELEMENT_TYPE_EVENT, \n     {NULL, NULL, NULL, NULL, eventSubHandler, NULL}}\n};\nrbus_regDataElements(handle, 2, dataElements);\n</code></pre></p>"},{"location":"docu/RBUS_Claude_2609/#rbus_unregdataelements","title":"rbus_unregDataElements","text":"<p><pre><code>rbusError_t rbus_unregDataElements(rbusHandle_t handle, int numDataElements, rbusDataElement_t *elements)\n</code></pre> Description: Unregisters previously registered data elements.</p>"},{"location":"docu/RBUS_Claude_2609/#53-property-operations","title":"5.3 Property Operations","text":""},{"location":"docu/RBUS_Claude_2609/#rbus_get","title":"rbus_get","text":"<p><pre><code>rbusError_t rbus_get(rbusHandle_t handle, char const* name, rbusValue_t* value)\n</code></pre> Description: Gets the value of a single parameter.</p> <p>Parameters: - <code>handle</code>: Bus Handle - <code>name</code>: Parameter name - <code>value</code>: Returned value (output)</p> <p>Returns: RBUS_ERROR_SUCCESS or error codes</p> <p>Example: <pre><code>rbusValue_t value;\nrbusError_t rc = rbus_get(handle, \"Device.MyComponent.Property1\", &amp;value);\nif(rc == RBUS_ERROR_SUCCESS) {\n    printf(\"Value: %s\\n\", rbusValue_GetString(value, NULL));\n    rbusValue_Release(value);\n}\n</code></pre></p>"},{"location":"docu/RBUS_Claude_2609/#rbus_set","title":"rbus_set","text":"<p><pre><code>rbusError_t rbus_set(rbusHandle_t handle, char const* name, rbusValue_t value, rbusSetOptions_t* opts)\n</code></pre> Description: Sets the value of a single parameter.</p> <p>Parameters: - <code>handle</code>: Bus Handle - <code>name</code>: Parameter name - <code>value</code>: Value to set - <code>opts</code>: Set options (can be NULL for immediate commit)</p> <p>Returns: RBUS_ERROR_SUCCESS or error codes</p>"},{"location":"docu/RBUS_Claude_2609/#type-specific-get-methods","title":"Type-Specific Get Methods","text":"<pre><code>rbusError_t rbus_getBoolean(rbusHandle_t handle, char const* paramName, bool* paramVal)\nrbusError_t rbus_getInt(rbusHandle_t handle, char const* paramName, int* paramVal)\nrbusError_t rbus_getUint(rbusHandle_t handle, char const* paramName, unsigned int* paramVal)\nrbusError_t rbus_getStr(rbusHandle_t handle, char const* paramName, char** paramVal)\n</code></pre>"},{"location":"docu/RBUS_Claude_2609/#type-specific-set-methods","title":"Type-Specific Set Methods","text":"<pre><code>rbusError_t rbus_setBoolean(rbusHandle_t handle, char const* paramName, bool paramVal)\nrbusError_t rbus_setInt(rbusHandle_t handle, char const* paramName, int paramVal)\nrbusError_t rbus_setUInt(rbusHandle_t handle, char const* paramName, unsigned int paramVal)\nrbusError_t rbus_setStr(rbusHandle_t handle, char const* paramName, char const* paramVal)\n</code></pre>"},{"location":"docu/RBUS_Claude_2609/#54-multi-parameter-operations","title":"5.4 Multi-Parameter Operations","text":""},{"location":"docu/RBUS_Claude_2609/#rbus_getext","title":"rbus_getExt","text":"<p><pre><code>rbusError_t rbus_getExt(rbusHandle_t handle, int paramCount, char const** paramNames, int *numProps, rbusProperty_t* properties)\n</code></pre> Description: Gets one or more parameter values in a single operation. Supports wildcards and partial path queries.</p>"},{"location":"docu/RBUS_Claude_2609/#rbus_setmulti","title":"rbus_setMulti","text":"<p><pre><code>rbusError_t rbus_setMulti(rbusHandle_t handle, int numProps, rbusProperty_t properties, rbusSetOptions_t* opts)\n</code></pre> Description: Sets multiple parameters at once.</p>"},{"location":"docu/RBUS_Claude_2609/#55-table-operations","title":"5.5 Table Operations","text":""},{"location":"docu/RBUS_Claude_2609/#rbustable_addrow","title":"rbusTable_addRow","text":"<p><pre><code>rbusError_t rbusTable_addRow(rbusHandle_t handle, char const* tableName, char const* aliasName, uint32_t* instNum)\n</code></pre> Description: Adds a new row to a table.</p> <p>Parameters: - <code>handle</code>: Bus Handle - <code>tableName</code>: Table name (must end with \".\") - <code>aliasName</code>: Optional alias name for the row - <code>instNum</code>: Returned instance number (output)</p>"},{"location":"docu/RBUS_Claude_2609/#rbustable_removerow","title":"rbusTable_removeRow","text":"<p><pre><code>rbusError_t rbusTable_removeRow(rbusHandle_t handle, char const* rowName)\n</code></pre> Description: Removes a row from a table.</p>"},{"location":"docu/RBUS_Claude_2609/#rbustable_getrownames","title":"rbusTable_getRowNames","text":"<p><pre><code>rbusError_t rbusTable_getRowNames(rbusHandle_t handle, char const* tableName, rbusRowName_t** rowNames)\n</code></pre> Description: Gets a list of row names in a table.</p>"},{"location":"docu/RBUS_Claude_2609/#56-event-operations","title":"5.6 Event Operations","text":""},{"location":"docu/RBUS_Claude_2609/#rbusevent_subscribe","title":"rbusEvent_Subscribe","text":"<p><pre><code>rbusError_t rbusEvent_Subscribe(rbusHandle_t handle, char const* eventName, rbusEventHandler_t handler, void* userData, int timeout)\n</code></pre> Description: Subscribes to a single event.</p> <p>Parameters: - <code>handle</code>: Bus Handle - <code>eventName</code>: Fully qualified event name - <code>handler</code>: Event callback handler - <code>userData</code>: User data passed to callback - <code>timeout</code>: Max retry timeout in seconds</p> <p>Example: <pre><code>void eventHandler(rbusHandle_t handle, rbusEvent_t const* event, rbusEventSubscription_t* subscription) {\n    printf(\"Event received: %s\\n\", event-&gt;name);\n}\n\nrbusEvent_Subscribe(handle, \"Device.MyComponent.Event1!\", eventHandler, NULL, 0);\n</code></pre></p>"},{"location":"docu/RBUS_Claude_2609/#rbusevent_unsubscribe","title":"rbusEvent_Unsubscribe","text":"<p><pre><code>rbusError_t rbusEvent_Unsubscribe(rbusHandle_t handle, char const* eventName)\n</code></pre> Description: Unsubscribes from an event.</p>"},{"location":"docu/RBUS_Claude_2609/#rbusevent_publish","title":"rbusEvent_Publish","text":"<p><pre><code>rbusError_t rbusEvent_Publish(rbusHandle_t handle, rbusEvent_t* eventData)\n</code></pre> Description: Publishes an event to all subscribers.</p> <p>Example: <pre><code>rbusEvent_t event = {0};\nevent.name = \"Device.MyComponent.Event1!\";\nevent.type = RBUS_EVENT_GENERAL;\nevent.data = myEventObject;\nrbusEvent_Publish(handle, &amp;event);\n</code></pre></p>"},{"location":"docu/RBUS_Claude_2609/#57-method-operations","title":"5.7 Method Operations","text":""},{"location":"docu/RBUS_Claude_2609/#rbusmethod_invoke","title":"rbusMethod_Invoke","text":"<p><pre><code>rbusError_t rbusMethod_Invoke(rbusHandle_t handle, char const* methodName, rbusObject_t inParams, rbusObject_t* outParams)\n</code></pre> Description: Invokes a remote method synchronously.</p> <p>Parameters: - <code>handle</code>: Bus Handle - <code>methodName</code>: Method name - <code>inParams</code>: Input parameters - <code>outParams</code>: Output parameters (output)</p>"},{"location":"docu/RBUS_Claude_2609/#rbusmethod_invokeasync","title":"rbusMethod_InvokeAsync","text":"<p><pre><code>rbusError_t rbusMethod_InvokeAsync(rbusHandle_t handle, char const* methodName, rbusObject_t inParams, rbusMethodAsyncRespHandler_t callback, int timeout)\n</code></pre> Description: Invokes a remote method asynchronously.</p>"},{"location":"docu/RBUS_Claude_2609/#58-discovery-operations","title":"5.8 Discovery Operations","text":""},{"location":"docu/RBUS_Claude_2609/#rbus_discovercomponentname","title":"rbus_discoverComponentName","text":"<p><pre><code>rbusError_t rbus_discoverComponentName(rbusHandle_t handle, int numElements, char const** elementNames, int *numComponents, char ***componentName)\n</code></pre> Description: Discovers components that provide specific data elements.</p>"},{"location":"docu/RBUS_Claude_2609/#rbus_discovercomponentdataelements","title":"rbus_discoverComponentDataElements","text":"<p><pre><code>rbusError_t rbus_discoverComponentDataElements(rbusHandle_t handle, char const* name, bool nextLevel, int *numElements, char*** elementNames)\n</code></pre> Description: Discovers all data elements provided by a component.</p>"},{"location":"docu/RBUS_Claude_2609/#6-event-types","title":"6. Event Types","text":""},{"location":"docu/RBUS_Claude_2609/#61-event-type-enumeration","title":"6.1 Event Type Enumeration","text":"<pre><code>typedef enum {\n    RBUS_EVENT_OBJECT_CREATED,   // Object instance created in table\n    RBUS_EVENT_OBJECT_DELETED,   // Object instance deleted in table\n    RBUS_EVENT_VALUE_CHANGED,    // Property value changed\n    RBUS_EVENT_GENERAL,          // Provider defined event\n    RBUS_EVENT_INITIAL_VALUE,    // Initial value after subscription\n    RBUS_EVENT_INTERVAL,         // Interval-based event\n    RBUS_EVENT_DURATION_COMPLETE // Duration timeout event\n} rbusEventType_t;\n</code></pre>"},{"location":"docu/RBUS_Claude_2609/#7-sessions-and-transactions","title":"7. Sessions and Transactions","text":""},{"location":"docu/RBUS_Claude_2609/#71-session-management","title":"7.1 Session Management","text":""},{"location":"docu/RBUS_Claude_2609/#rbus_createsession","title":"rbus_createSession","text":"<p><pre><code>rbusError_t rbus_createSession(rbusHandle_t handle, uint32_t *pSessionId)\n</code></pre> Description: Creates a new session for coordinated parameter operations.</p>"},{"location":"docu/RBUS_Claude_2609/#rbus_closesession","title":"rbus_closeSession","text":"<p><pre><code>rbusError_t rbus_closeSession(rbusHandle_t handle, uint32_t sessionId)\n</code></pre> Description: Closes an existing session.</p>"},{"location":"docu/RBUS_Claude_2609/#8-configuration-and-logging","title":"8. Configuration and Logging","text":""},{"location":"docu/RBUS_Claude_2609/#81-timeout-configuration","title":"8.1 Timeout Configuration","text":""},{"location":"docu/RBUS_Claude_2609/#rbushandle_configtimeoutvalues","title":"rbusHandle_ConfigTimeoutValues","text":"<p><pre><code>rbusError_t rbusHandle_ConfigTimeoutValues(rbusHandle_t handle, rbusTimeoutValues_t timeoutValues)\n</code></pre> Description: Configures timeout values for RBUS operations.</p>"},{"location":"docu/RBUS_Claude_2609/#82-logging","title":"8.2 Logging","text":""},{"location":"docu/RBUS_Claude_2609/#rbus_registerloghandler","title":"rbus_registerLogHandler","text":"<p><pre><code>rbusError_t rbus_registerLogHandler(rbusLogHandler logHandler)\n</code></pre> Description: Registers a custom log handler.</p>"},{"location":"docu/RBUS_Claude_2609/#rbus_setloglevel","title":"rbus_setLogLevel","text":"<p><pre><code>rbusError_t rbus_setLogLevel(rbusLogLevel_t level)\n</code></pre> Description: Sets the logging level.</p> <p>Log Levels: - RBUS_LOG_DEBUG = 0 - RBUS_LOG_INFO = 1 - RBUS_LOG_WARN = 2 - RBUS_LOG_ERROR = 3 - RBUS_LOG_FATAL = 4</p>"},{"location":"docu/RBUS_Claude_2609/#9-direct-connection-mode","title":"9. Direct Connection Mode","text":""},{"location":"docu/RBUS_Claude_2609/#91-direct-connection-apis","title":"9.1 Direct Connection APIs","text":""},{"location":"docu/RBUS_Claude_2609/#rbus_opendirect","title":"rbus_openDirect","text":"<p><pre><code>rbusError_t rbus_openDirect(rbusHandle_t handle, rbusHandle_t* myDirectHandle, char const* parameterName)\n</code></pre> Description: Opens a direct connection to a provider for high-frequency, low-latency operations.</p>"},{"location":"docu/RBUS_Claude_2609/#rbus_closedirect","title":"rbus_closeDirect","text":"<p><pre><code>rbusError_t rbus_closeDirect(rbusHandle_t handle)\n</code></pre> Description: Closes a direct connection.</p>"},{"location":"docu/RBUS_Claude_2609/#10-sample-usage-patterns","title":"10. Sample Usage Patterns","text":""},{"location":"docu/RBUS_Claude_2609/#101-simple-provider-example","title":"10.1 Simple Provider Example","text":"<pre><code>#include &lt;rbus.h&gt;\n\nrbusError_t myGetHandler(rbusHandle_t handle, rbusProperty_t property, rbusGetHandlerOptions_t* opts) {\n    char const* name = rbusProperty_GetName(property);\n    rbusValue_t value;\n\n    rbusValue_Init(&amp;value);\n    if(strcmp(name, \"Device.MyApp.Status\") == 0) {\n        rbusValue_SetString(value, \"Running\");\n    }\n    rbusProperty_SetValue(property, value);\n    rbusValue_Release(value);\n    return RBUS_ERROR_SUCCESS;\n}\n\nint main() {\n    rbusHandle_t handle;\n    rbusDataElement_t dataElements[] = {\n        {\"Device.MyApp.Status\", RBUS_ELEMENT_TYPE_PROPERTY, {myGetHandler, NULL, NULL, NULL, NULL, NULL}}\n    };\n\n    rbus_open(&amp;handle, \"MyProvider\");\n    rbus_regDataElements(handle, 1, dataElements);\n\n    // Keep running...\n    sleep(3600);\n\n    rbus_close(handle);\n    return 0;\n}\n</code></pre>"},{"location":"docu/RBUS_Claude_2609/#102-simple-consumer-example","title":"10.2 Simple Consumer Example","text":"<pre><code>#include &lt;rbus.h&gt;\n\nint main() {\n    rbusHandle_t handle;\n    rbusValue_t value;\n\n    rbus_open(&amp;handle, \"MyConsumer\");\n\n    if(rbus_get(handle, \"Device.MyApp.Status\", &amp;value) == RBUS_ERROR_SUCCESS) {\n        printf(\"Status: %s\\n\", rbusValue_GetString(value, NULL));\n        rbusValue_Release(value);\n    }\n\n    rbus_close(handle);\n    return 0;\n}\n</code></pre>"},{"location":"docu/RBUS_Claude_2609/#11-best-practices","title":"11. Best Practices","text":""},{"location":"docu/RBUS_Claude_2609/#111-memory-management","title":"11.1 Memory Management","text":"<ul> <li>Always call <code>rbusValue_Release()</code> after using values returned by get operations</li> <li>Use proper reference counting with <code>rbusValue_Retain()</code> and <code>rbusValue_Release()</code></li> <li>Initialize objects and properties properly before use</li> </ul>"},{"location":"docu/RBUS_Claude_2609/#112-error-handling","title":"11.2 Error Handling","text":"<ul> <li>Always check return codes from RBUS API calls</li> <li>Use <code>rbusError_ToString()</code> for human-readable error messages</li> <li>Handle timeout scenarios appropriately</li> </ul>"},{"location":"docu/RBUS_Claude_2609/#113-naming-conventions","title":"11.3 Naming Conventions","text":"<ul> <li>Follow TR-069 hierarchical naming: <code>Device.Component.Object.Property</code></li> <li>Use descriptive names for better discoverability</li> <li>Ensure unique names across the system to avoid conflicts</li> </ul>"},{"location":"docu/RBUS_Claude_2609/#114-performance-considerations","title":"11.4 Performance Considerations","text":"<ul> <li>Use <code>rbus_getExt()</code> for multiple parameter queries</li> <li>Consider direct connections for high-frequency operations</li> <li>Use appropriate timeout values based on operation complexity</li> </ul>"},{"location":"docu/RBUS_Claude_2609/#12-build-and-deployment","title":"12. Build and Deployment","text":""},{"location":"docu/RBUS_Claude_2609/#121-dependencies","title":"12.1 Dependencies","text":"<ul> <li>cJSON library for JSON processing</li> <li>msgpack library for message serialization</li> <li>rdklogger (optional) for enhanced logging</li> </ul>"},{"location":"docu/RBUS_Claude_2609/#122-cmake-configuration","title":"12.2 CMake Configuration","text":"<pre><code>find_package(rbus REQUIRED)\ntarget_link_libraries(my_app rbus)\n</code></pre>"},{"location":"docu/RBUS_Claude_2609/#123-runtime-requirements","title":"12.3 Runtime Requirements","text":"<ul> <li>rtrouted daemon must be running for RBUS communication</li> <li>Proper system permissions for IPC operations</li> <li>Sufficient system resources for message queuing</li> </ul> <p>This documentation provides a comprehensive overview of the RBUS protocol and its APIs based on the source code analysis. The protocol enables efficient inter-process communication through a well-defined set of operations for properties, events, methods, and tables in a hierarchical data model.</p>"},{"location":"docu/RBUS_GPT5_2609/","title":"Rbus","text":""},{"location":"docu/RBUS_GPT5_2609/#1-overview","title":"1. Overview","text":"<p>RDK Bus (RBus) is a lightweight, fast and efficient bus messaging system enabling interprocess communication (IPC) and remote procedure call (RPC) between multiple processes on a hardware device. It supports a hierarchical data model of named objects containing properties, events, and methods. Providers implement and register data elements; consumers discover, query, modify, subscribe, and invoke them. A process may be both provider and consumer.</p>"},{"location":"docu/RBUS_GPT5_2609/#2-architecture-and-roles","title":"2. Architecture and Roles","text":"<ul> <li>Providers:</li> <li>Register properties, objects (tables), events, and methods.</li> <li>Implement get/set for properties; add/remove/sync for table rows; method handlers; event publish logic.</li> <li>Consumers:</li> <li>Get/set property values (single, multiple, wildcard, partial path).</li> <li>Add/remove table rows.</li> <li>Subscribe/unsubscribe to events (value change, object create/delete, general, interval, initial value, duration complete).</li> <li>Invoke methods (sync or async).</li> <li>Bus Broker (daemon) mediates routing except in direct mode (rbus_openDirect) which forms optimized component-to-component connections.</li> </ul>"},{"location":"docu/RBUS_GPT5_2609/#3-naming-conventions-and-data-model","title":"3. Naming Conventions and Data Model","text":"<ul> <li>Names are hierarchical tokens separated by '.' similar to TR-069/TR-181 (e.g. <code>Device.IP.Interface.1.Status</code>).</li> <li>Tables (multi-instance objects) have names ending in a '.' and use instance numbers or aliases (e.g. <code>Device.IP.Interface.</code>; rows: <code>Device.IP.Interface.1.</code> or <code>Device.IP.Interface.[lan1].</code>).</li> <li>Instance wildcards supported with <code>*</code> (e.g. <code>Device.IP.Interface.*.Status</code>). Multiple indices can be wildcarded.</li> <li>Maximum name length: <code>RBUS_MAX_NAME_LENGTH</code> (256). Maximum depth (token count): <code>RBUS_MAX_NAME_DEPTH</code> (16).</li> <li>Event names may be general or derived from properties/tables. (Event type drives semantics.)</li> </ul>"},{"location":"docu/RBUS_GPT5_2609/#4-data-element-types","title":"4. Data Element Types","text":"<p><code>rbusElementType_t</code>: - <code>RBUS_ELEMENT_TYPE_PROPERTY</code> \u2013 scalar or hierarchical property; supports get/set and value-change events. - <code>RBUS_ELEMENT_TYPE_TABLE</code> \u2013 multi-instance object (rows can be added/removed). - <code>RBUS_ELEMENT_TYPE_EVENT</code> \u2013 exclusive event element (general provider-defined events). - <code>RBUS_ELEMENT_TYPE_METHOD</code> \u2013 invokable method element.</p>"},{"location":"docu/RBUS_GPT5_2609/#rbus-protocol-documentation","title":"RBUS Protocol Documentation","text":"<ol> <li> <p>Introduction RDK Bus (RBus) is a lightweight, fast and efficient bus messaging system enabling interprocess communication (IPC) and remote procedure call (RPC) among processes on a device. It supports a hierarchical data model of named objects containing properties, events, and methods. Components can act as providers (exposing data elements) and/or consumers (accessing them).</p> </li> <li> <p>Terminology</p> </li> <li>Element: A named item (property, table, event, or method) in the hierarchical namespace.</li> <li>Property: A readable and/or writable value.</li> <li>Table: A multi-instance object supporting dynamic row add/remove.</li> <li>Event: A notification that can be subscribed to (value change, object lifecycle, general, etc.).</li> <li>Method: A remotely invokable procedure.</li> <li>Handle (rbusHandle_t): Opaque connection context for a component.</li> <li> <p>Session: Grouped set/mutate operations coordinated via commit.</p> </li> <li> <p>Naming &amp; Constraints</p> </li> <li>Maximum element name length: 256 (RBUS_MAX_NAME_LENGTH)</li> <li>Maximum hierarchical depth: 16 tokens (RBUS_MAX_NAME_DEPTH)</li> <li>Hierarchical levels separated by '.'</li> <li>Tables indicated by instance numbers or alias in brackets (e.g. Device.IP.Interface.1 or Device.IP.Interface.[lan1]).</li> <li> <p>Events may use the same element names or dedicated event elements (RBUS_ELEMENT_TYPE_EVENT).</p> </li> <li> <p>Error Codes (rbusError_t) Representative values (see <code>rbus.h</code> for full list):</p> </li> <li>RBUS_ERROR_SUCCESS</li> <li>RBUS_ERROR_BUS_ERROR</li> <li>RBUS_ERROR_INVALID_INPUT</li> <li>RBUS_ERROR_NOT_INITIALIZED</li> <li>RBUS_ERROR_OUT_OF_RESOURCES</li> <li>RBUS_ERROR_DESTINATION_NOT_FOUND / NOT_REACHABLE</li> <li>RBUS_ERROR_DESTINATION_RESPONSE_FAILURE</li> <li>RBUS_ERROR_INVALID_RESPONSE_FROM_DESTINATION</li> <li>RBUS_ERROR_INVALID_OPERATION / INVALID_EVENT / INVALID_METHOD</li> <li>RBUS_ERROR_INVALID_HANDLE / INVALID_CONTEXT</li> <li>RBUS_ERROR_COMPONENT_NAME_DUPLICATE / ELEMENT_NAME_DUPLICATE</li> <li>RBUS_ERROR_ELEMENT_NAME_MISSING / COMPONENT_DOES_NOT_EXIST / ELEMENT_DOES_NOT_EXIST</li> <li>RBUS_ERROR_ACCESS_NOT_ALLOWED / NOT_WRITABLE / NOT_READABLE</li> <li>RBUS_ERROR_TIMEOUT / ASYNC_RESPONSE</li> <li>RBUS_ERROR_SUBSCRIPTION_ALREADY_EXIST / NOSUBSCRIBERS</li> <li>RBUS_ERROR_INVALID_NAMESPACE / DIRECT_CON_NOT_EXIST</li> <li>RBUS_ERROR_SESSION_ALREADY_EXIST</li> <li> <p>RBUS_ERROR_INVALID_PARAMETER_TYPE / INVALID_PARAMETER_VALUE</p> </li> <li> <p>Core Data Types &amp; Structures</p> </li> <li>rbusHandle_t: Opaque pointer identifying an opened component connection.</li> <li>rbusValue_t / rbusProperty_t / rbusObject_t: Value, property (name+value), and structured object containers.</li> <li>rbusSetOptions_t: { commit:bool, sessionId:uint32_t }</li> <li>rbusGetHandlerOptions_t: { context:void, requestingComponent:char }</li> <li>rbusSetHandlerOptions_t: { commit:bool, sessionId:uint32_t, requestingComponent:char* }</li> <li>rbusEvent_t: { name, type (rbusEventType_t), data (rbusObject_t) }</li> <li>rbusEventRawData_t: { name, rawData ptr, rawDataLen }</li> <li>rbusEventSubscription_t: { eventName, filter, interval, duration, handler, userData, ... }</li> <li>rbusRowName_t: Linked list of { name, instNum, alias }</li> <li>rbusDataElement_t: { name, type (rbusElementType_t), cbTable (rbusCallbackTable_t) }</li> <li>rbusElementCallbackTable_t / rbusCallbackTable_t: Sets of provider callbacks.</li> <li>rbusElementInfo_t: { name, component, type, access flags }</li> <li> <p>rbusTimeoutValues_t: Per-handle default timeout configuration.</p> </li> <li> <p>Element Types (rbusElementType_t)</p> </li> <li>PROPERTY</li> <li>TABLE (multi-instance)</li> <li>EVENT (exclusive event element)</li> <li> <p>METHOD</p> </li> <li> <p>Access Flags (rbusAccess_t) Bitwise OR of: GET, SET, ADDROW, REMOVEROW, SUBSCRIBE, INVOKE.</p> </li> <li> <p>Event Types (rbusEventType_t)</p> </li> <li>OBJECT_CREATED</li> <li>OBJECT_DELETED</li> <li>VALUE_CHANGED</li> <li>GENERAL</li> <li>INITIAL_VALUE</li> <li>INTERVAL</li> <li> <p>DURATION_COMPLETE</p> </li> <li> <p>Initialization APIs Methods:</p> </li> <li>rbus_checkStatus() -&gt; rbusStatus_t</li> <li>rbus_open(rbusHandle_t handle, const char componentName)</li> <li> <p>rbus_close(rbusHandle_t handle)</p> </li> <li> <p>Trace Context APIs</p> </li> <li>rbusHandle_SetTraceContextFromString(handle, traceParent, traceState)</li> <li>rbusHandle_ClearTraceContext(handle)</li> <li> <p>rbusHandle_GetTraceContextAsString(handle, traceParentBuf, traceParentLen, traceStateBuf, traceStateLen)</p> </li> <li> <p>Discovery APIs</p> </li> <li>rbus_discoverComponentName(handle, numElements, elementNames, &amp;numComponents, &amp;componentNameArray)</li> <li>rbus_discoverComponentDataElements(handle, name, nextLevel, &amp;numElements, &amp;elementNamesArray)</li> <li>rbusElementInfo_get(handle, elemName, depth, &amp;infoList)</li> <li> <p>rbusElementInfo_free(handle, infoList)</p> </li> <li> <p>Provider Registration APIs</p> </li> <li>rbus_regDataElements(handle, numDataElements, elementsArray)</li> <li>rbus_unregDataElements(handle, numDataElements, elementsArray)</li> <li>rbusTable_registerRow(handle, tableName, instNum, aliasName)</li> <li>rbusTable_unregisterRow(handle, rowName)</li> <li> <p>rbus_registerDynamicTableSyncHandler(handle, tableName, syncHandler)</p> </li> <li> <p>Consumer Property Get APIs</p> </li> <li>rbus_get(handle, name, &amp;value)</li> <li>rbus_getExt(handle, paramCount, paramNames, &amp;numProps, &amp;properties)</li> <li>rbus_getBoolean(handle, paramName, &amp;boolVal)</li> <li>rbus_getInt(handle, paramName, &amp;intVal)</li> <li>rbus_getUint(handle, paramName, &amp;uintVal)</li> <li> <p>rbus_getStr(handle, paramName, &amp;charPtr) (caller frees)</p> </li> <li> <p>Consumer Property Set APIs</p> </li> <li>rbus_set(handle, name, value, opts)</li> <li>rbus_setCommit(handle, name, opts)</li> <li>rbus_setMulti(handle, numProps, properties, opts)</li> <li>rbus_setMultiExt(handle, numProps, properties, opts, timeoutMs, &amp;failedParamName)</li> <li>rbus_setBoolean(handle, paramName, boolVal)</li> <li>rbus_setInt(handle, paramName, intVal)</li> <li>rbus_setUInt(handle, paramName, uintVal)</li> <li> <p>rbus_setStr(handle, paramName, strVal)</p> </li> <li> <p>Table Consumer APIs</p> </li> <li>rbusTable_addRow(handle, tableName, aliasName, &amp;instNum)</li> <li>rbusTable_removeRow(handle, rowName)</li> <li>rbusTable_getRowNames(handle, tableName, &amp;rowNameList)</li> <li> <p>rbusTable_freeRowNames(handle, rowNameList)</p> </li> <li> <p>Session Management APIs</p> </li> <li>rbus_createSession(handle, &amp;sessionId)</li> <li>rbus_getCurrentSession(handle, &amp;sessionId)</li> <li> <p>rbus_closeSession(handle, sessionId)</p> </li> <li> <p>Event Subscription (Consumer) APIs</p> </li> <li>rbusEvent_IsSubscriptionExist(handle, eventName, subscription)</li> <li>rbusEvent_Subscribe(handle, eventName, handler, userData, timeoutSec)</li> <li>rbusEvent_SubscribeRawData(handle, eventName, handler, userData, timeoutSec)</li> <li>rbusEvent_SubscribeAsync(handle, eventName, handler, subscribeRespHandler, userData, timeoutSec)</li> <li>rbusEvent_Unsubscribe(handle, eventName)</li> <li>rbusEvent_UnsubscribeRawData(handle, eventName)</li> <li>rbusEvent_SubscribeEx(handle, subscriptionsArray, num, timeoutSec)</li> <li>rbusEvent_SubscribeExRawData(handle, subscriptionsArray, num, timeoutSec)</li> <li>rbusEvent_SubscribeExAsync(handle, subscriptionsArray, num, subscribeRespHandler, timeoutSec)</li> <li>rbusEvent_UnsubscribeEx(handle, subscriptionsArray, num)</li> <li> <p>rbusEvent_UnsubscribeExRawData(handle, subscriptionsArray, num)</p> </li> <li> <p>Event Publish (Provider) APIs</p> </li> <li>rbusEvent_Publish(handle, &amp;eventData)</li> <li> <p>rbusEvent_PublishRawData(handle, &amp;rawEventData)</p> </li> <li> <p>Method Invocation (Consumer) APIs</p> </li> <li>rbusMethod_Invoke(handle, methodName, inParams, &amp;outParams)</li> <li> <p>rbusMethod_InvokeAsync(handle, methodName, inParams, callback, timeoutSec)</p> </li> <li> <p>Method Response (Provider) API</p> </li> <li> <p>rbusMethod_SendAsyncResponse(asyncHandle, errorCode, outParams)</p> </li> <li> <p>Direct Connection APIs</p> </li> <li>rbus_openDirect(handle, &amp;directHandle, parameterName)</li> <li> <p>rbus_closeDirect(directHandle)</p> </li> <li> <p>Timeout Configuration APIs</p> </li> <li>rbusHandle_ConfigTimeoutValues(handle, timeoutValuesStruct)</li> <li>rbusHandle_ConfigSetTimeout(handle, ms)</li> <li>rbusHandle_ConfigGetTimeout(handle, ms)</li> <li>rbusHandle_ConfigGetMultiTimeout(handle, ms)</li> <li>rbusHandle_ConfigSetMultiTimeout(handle, ms)</li> <li> <p>rbusHandle_ConfigSubscribeTimeout(handle, ms)</p> </li> <li> <p>Logging APIs</p> </li> <li>rbus_registerLogHandler(logHandler)</li> <li>rbus_setLogLevel(level)</li> <li> <p>Log levels: DEBUG, INFO, WARN, ERROR, FATAL</p> </li> <li> <p>Callback Handler Types (Provider)</p> </li> <li>rbusGetHandler_t(handle, property, getOptions)</li> <li>rbusSetHandler_t(handle, property, setOptions)</li> <li>rbusTableAddRowHandler_t(handle, tableName, aliasName, &amp;instNum)</li> <li>rbusTableRemoveRowHandler_t(handle, rowName)</li> <li>rbusMethodHandler_t(handle, methodName, inParams, outParams, asyncHandle)</li> <li>rbusEventSubHandler_t(handle, action, eventName, filter, interval, &amp;autoPublish)</li> <li> <p>rbusTableSyncHandler_t(handle, tableName)</p> </li> <li> <p>Event Handler Types (Consumer)</p> </li> <li>rbusEventHandler_t(handle, eventData, subscription)</li> <li>rbusEventHandlerRawData_t(handle, rawEventData, subscription)</li> <li>rbusSubscribeAsyncRespHandler_t(handle, subscription, error)</li> <li> <p>rbusMethodAsyncRespHandler_t(handle, methodName, error, params)</p> </li> <li> <p>Usage Flow Summary Provider typical sequence:</p> </li> <li>rbus_open</li> <li>Prepare rbusDataElement_t array with callback tables</li> <li>rbus_regDataElements</li> <li>(Optional) rbusTable_registerRow for dynamic initial rows</li> <li>Publish events via rbusEvent_Publish when state changes</li> <li>Respond to gets/sets/methods via registered handlers</li> <li>rbus_unregDataElements (shutdown)</li> <li>rbus_close</li> </ol> <p>Consumer typical sequence: 1. rbus_open 2. Discover (optional): rbus_discoverComponentDataElements / rbusElementInfo_get 3. Get/Set via rbus_get / rbus_set / Ext APIs 4. Subscribe to events via rbusEvent_Subscribe APIs 5. Invoke methods via rbusMethod_Invoke / Async 6. rbus_close</p> <ol> <li>Session Based Set Pattern</li> <li>rbus_createSession -&gt; sessionId</li> <li>Perform multiple rbus_set(..., opts{sessionId, commit=false}) or table add/remove</li> <li>Final rbus_set / rbus_setCommit with opts.commit=true to apply all</li> <li> <p>rbus_closeSession</p> </li> <li> <p>Asynchronous Method Pattern Provider: In methodHandler return RBUS_ERROR_ASYNC_RESPONSE and retain asyncHandle. Later call rbusMethod_SendAsyncResponse(asyncHandle, status, outParams). Consumer: Use rbusMethod_InvokeAsync and process callback with final outParams.</p> </li> <li> <p>Auto vs Manual Event Publish If eventSubHandler sets autoPublish=true for value-change events, library polls value (1s) and rate-limits (1 event per 2s). For high-frequency or precise events set autoPublish=false and explicitly call rbusEvent_Publish.</p> </li> <li> <p>Direct Mode (rbus_openDirect) Used for high frequency / low latency access to a specific parameter provider, bypassing central daemon routing and using more resources. Only open where necessary.</p> </li> <li> <p>Timeout Management Configure per-handle defaults (SET, GET, wildcard GET, SET multi, Subscribe) using rbusHandle_ConfigTimeoutValues or individual setters. Zero input resets to default internal value (e.g., standard 15s defaults mentioned in comments for setMultiExt per-provider operations).</p> </li> <li> <p>Memory Management Notes</p> </li> <li>Caller must free strings returned by rbus_getStr.</li> <li>Caller must release rbusValue_t, rbusProperty_t lists after use following value/property API lifecycles (per headers in repo).</li> <li>Row lists from rbusTable_getRowNames freed with rbusTable_freeRowNames.</li> <li> <p>Element info lists from rbusElementInfo_get freed with rbusElementInfo_free.</p> </li> <li> <p>Event Subscription Attributes rbusEventSubscription_t fields:</p> </li> <li>filter (optional) applied provider-side</li> <li>interval (seconds) for periodic publish (with optional filtering)</li> <li>duration (auto-unsubscribe after seconds; 0 = indefinite)</li> <li> <p>publishOnSubscribe (initial value emission when supported)</p> </li> <li> <p>Error Handling Guidance</p> </li> <li>RBUS_ERROR_ASYNC_RESPONSE: Method response will arrive later</li> <li>RBUS_ERROR_TIMEOUT: Operation exceeded configured or default timeout</li> <li>RBUS_ERROR_ACCESS_NOT_ALLOWED / NOT_WRITABLE / NOT_READABLE: Permission / capability issue</li> <li> <p>RBUS_ERROR_ELEMENT_DOES_NOT_EXIST: Invalid name or unregistered element</p> </li> <li> <p>Logging Integration Use rbus_registerLogHandler to intercept library log messages (level, file, line, thread, message). Otherwise configure built-in verbosity with rbus_setLogLevel.</p> </li> <li> <p>Extensibility Callback Summary Place appropriate handler pointers in rbusElementCallbackTable_t (or rbusCallbackTable_t legacy) per element. Unused capabilities set to NULL; library substitutes internal error responders.</p> </li> <li> <p>Concurrency &amp; Asynchrony Notes</p> </li> <li>Async method responses require explicit SendAsyncResponse.</li> <li>Subscription retries occur up to timeout if provider absent.</li> <li> <p>AutoPublish polling frequency 1 Hz (implicit from comments) with min 2s rate-limit for value-change events when enabled.</p> </li> <li> <p>API Versioning Versioning is implicit in component naming/registration within this source tree; no separate semantic API version function is defined in <code>rbus.h</code> (refer only to repository content; no external version list).</p> </li> <li> <p>Limitations &amp; Constraints</p> </li> <li>Max name length and depth as above.</li> <li>Filters and raw data subscriptions reduce overhead (raw bypasses object encoding/decoding).</li> <li> <p>Direct mode consumes more memory\u2014use sparingly.</p> </li> <li> <p>Appendix: Representative Callback Signatures Provider:</p> </li> <li>rbusError_t getHandler(rbusHandle_t, rbusProperty_t, rbusGetHandlerOptions_t*)</li> <li>rbusError_t setHandler(rbusHandle_t, rbusProperty_t, rbusSetHandlerOptions_t*)</li> <li>rbusError_t tableAddRowHandler(rbusHandle_t, const char, const char, uint32_t*)</li> <li>rbusError_t tableRemoveRowHandler(rbusHandle_t, const char*)</li> <li>rbusError_t methodHandler(rbusHandle_t, const char*, rbusObject_t in, rbusObject_t out, rbusMethodAsyncHandle_t asyncHandle)</li> <li>rbusError_t eventSubHandler(rbusHandle_t, rbusEventSubAction_t, const char, rbusFilter_t, int32_t interval, bool autoPublish)</li> </ol> <p>Consumer: - void rbusEventHandler(rbusHandle_t, const rbusEvent_t, rbusEventSubscription_t) - void rbusEventHandlerRawData(rbusHandle_t, const rbusEventRawData_t, rbusEventSubscription_t) - void rbusSubscribeAsyncRespHandler(rbusHandle_t, rbusEventSubscription_t, rbusError_t) - void rbusMethodAsyncRespHandler(rbusHandle_t, const char, rbusError_t, rbusObject_t)</p> <ol> <li> <p>Change Reference For detailed evolution refer to <code>CHANGELOG.md</code> in repository (not reproduced here per instruction to confine to source content).</p> </li> <li> <p>Minimal Usage Snippets (Abstracted) (Names only; full code can be built from headers in repository) Provider skeleton:</p> </li> <li>open -&gt; regDataElements -&gt; (callbacks invoked) -&gt; unreg -&gt; close Consumer skeleton:</li> <li> <p>open -&gt; get/set/method invoke -&gt; subscribe -&gt; unsubscribe -&gt; close</p> </li> <li> <p>Completion Statement This document enumerates protocol-level structure and callable interfaces strictly extracted from repository header <code>rbus.h</code> and related local documentation without external augmentation.</p> </li> </ol>"},{"location":"docu/WANMgr%20Rama/","title":"RDK-B WAN Manager Documentation","text":""},{"location":"docu/WANMgr%20Rama/#1-overview","title":"1. Overview","text":"<ul> <li> <p>Purpose in RDK-B Stack: The WAN Manager is a core RDK-B middleware component responsible for managing WAN connectivity across multiple interface types (DOCSIS, Ethernet, DSL, GPON, Cellular). It abstracts physical interface management from upper-layer routing and provides intelligent failover and selection policies for optimal WAN connectivity.</p> </li> <li> <p>Key Features &amp; Responsibilities:</p> </li> <li>Interface Management: Coordinates with Interface Managers (XDSL, Eth, DOCSIS, GPON, Cellular) for physical layer status</li> <li>Policy Engine: Implements multiple WAN selection policies (AutoWAN, Fixed Mode, Primary Priority, Parallel Scan)</li> <li>IP Configuration: Manages DHCP, IPv6, VLAN, and static IP configuration across WAN interfaces</li> <li>Failover &amp; Load Balancing: Provides intelligent switching between WAN connections based on availability and policy</li> <li>TR-181 Integration: Exposes comprehensive TR-181 data model for remote management and configuration</li> <li> <p>IPC Coordination: Interfaces with DHCP Manager, VLAN Manager, and other RDK-B components via RBus/DBus</p> </li> <li> <p>Role in Broadband Router Architecture: Acts as the central WAN orchestrator, sitting between the HAL layer (interface managers) and upper middleware layers (routing, firewall). It ensures Internet connectivity through policy-driven interface selection and automatic failover mechanisms.</p> </li> </ul>"},{"location":"docu/WANMgr%20Rama/#2-architecture-design","title":"2. Architecture / Design","text":""},{"location":"docu/WANMgr%20Rama/#21-high-level-design-principles","title":"2.1 High-Level Design Principles","text":"<ul> <li>Modularity: Clean separation between policy engines, interface state machines, and data management</li> <li>Scalability: Support for up to 32 WAN interfaces with configurable grouping and priorities</li> <li>Reliability: Robust failover mechanisms with validation and health checking</li> <li>Policy-Driven: Configurable selection algorithms (AutoWAN, Fixed, Priority-based, Parallel Scan)</li> <li>Event-Driven Architecture: Reactive system based on interface status changes and validation events</li> </ul>"},{"location":"docu/WANMgr%20Rama/#22-component-boundaries-responsibilities","title":"2.2 Component Boundaries &amp; Responsibilities","text":"<ul> <li>Policy Controller: Manages interface selection logic and failover decisions</li> <li>Interface State Machine: Handles individual interface lifecycle (configuration, validation, teardown)</li> <li>Data Layer: Thread-safe access to WAN configuration and interface status</li> <li>IPC Layer: Communication with Interface Managers and other RDK-B components</li> <li>TR-181 Interface: Exposes management interface for remote configuration</li> </ul>"},{"location":"docu/WANMgr%20Rama/#23-threading-model-detailed","title":"2.3 Threading Model (Detailed)","text":"<p>The WAN Manager spawns a bounded set of long\u2011lived pthreads plus transient helper threads. Each thread category, creation locus, and core responsibility is enumerated below.</p> Thread Creation Site (File:Line indicative) Cardinality Purpose / Responsibilities Key Synchronization Exit Conditions Main / Bootstrap <code>wanmgr_main.c</code> (process entry) 1 Initialization (data init, RBUS/DBus registration), launches policy &amp; ISM threads Global config mutex (ConfigData), registration ordering barriers Process shutdown/systemd stop Policy Group Thread <code>wanmgr_controller.c</code> / policy impl (group loop) \u2264 #Groups (config, typically 1\u20134) Evaluate selection policy (AutoWAN / Priority / Fixed / Parallel Scan) and orchestrate interface activation/deactivation Protected access to <code>WANMGR_IFACE_GROUP</code> (group mutex) and interface structs; timers via monotonic clock Policy switch, fatal error, shutdown Failover Controller Thread <code>wanmgr_wan_failover.c</code> (selection &amp; restoration timers) 0\u20131 (only if failover enabled) Monitors active group, initiates restoration after backoff, triggers telemetry Group + failover controller mutex; timespec deadline checks Shutdown or failover disabled Interface State Machine (ISM) <code>wanmgr_interface_sm.c</code> (<code>WanMgr_StartInterfaceStateMachine</code>) One per active virtual/base interface (typ. matching physical set) Executes lifecycle: VLAN/PPP \u2192 IP acquisition (DHCPv4/v6) \u2192 Validation \u2192 (Dual-stack/Map-T) Active \u2192 Refresh/Deconfig Per\u2011interface lock inside <code>WanMgr_Iface_Data_t</code>; uses atomic status flags; periodic loop (50ms) Interface disable, teardown, policy relinquish Sysevent Listener <code>wanmgr_sysevents.c</code> (thread around <code>sysevent</code> fd) 1 Subscribes to system sysevents (link, route, DNS, WAN LED state), translates into internal events Event dispatch guarded by data API locks Shutdown IPC / RBUS Server <code>wanmgr_ipc.c</code> (pthread_create for IPC server) 1 Handles RBUS subscriptions, publishes interface and policy events RBUS internal thread safety + external data locks Shutdown IP Monitor / Net Utils <code>wanmgr_net_utils.c</code> (IPv4/IPv6 status monitor) 1 Monitors addresses/leases, restarts DHCP clients on anomalies Shared interface vector lock Shutdown Backup / Parallel Scan Worker <code>wanmgr_policy_autowan_impl.c</code> (backup scanning thread) 0\u20131 transient Parallel candidate scanning (signal strength / link readiness) during Auto/Parallel policies Group lock + candidate interface locks Scan complete / aborted DHCPv4 Client Supervisor <code>wanmgr_dhcpv4_apis.c</code> (spawned per start? usually integrated) Transient Launch/stop external client processes, parse events Process status checks, no dedicated mutex (delegates to net utils) DHCP session end DHCPv6 Lease / RA Parser <code>wanmgr_dhcpv6_apis.c</code> &amp; msg handler submodule Transient / event-driven Parse DHCPv6 messages (PD, IA_NA), trigger state transitions Uses shared virtual iface lock when updating On message completion Telemetry Trigger Implicit (timer-driven within failover or T2 callbacks) Integrated Emit T2 events upon state changes / failover Telemetry enumerations table Component stop <p>Synchronization Strategy (Overview): * Data Access Layer exposes lock-coupled getters returning pointers requiring explicit release (e.g., <code>WanMgr_GetIfaceData_locked</code> + release). This reduces lock hold time and centralizes ownership. * Interface vs. Group Lock Order: Always acquire Group lock before Interface lock to avoid deadlocks during selection and activation ordering. * Timers use <code>clock_gettime(CLOCK_MONOTONIC, ...)</code> to avoid wall clock skew in restoration and selection timeouts. * Minimal condition variables: Loop-based polling with micro-sleeps (50ms) in ISM avoids complex wait graph but trades some CPU (kept low with short logic sections). * Atomic / flag style booleans (<code>ConfigChanged</code>, <code>ResetSelectedInterface</code>) enable out-of-band signaling between policy and ISM threads.</p>"},{"location":"docu/WANMgr%20Rama/#24-c4-system-context-diagram","title":"2.4 C4 System Context Diagram","text":"<pre><code>graph TD\n    subgraph \"External Systems\"\n        Cloud[\u2601\ufe0f Cloud Management] \n        ACS[\ud83d\udce1 ACS/TR-069]\n        WebUI[\ud83c\udf10 Web UI]\n    end\n\n    subgraph \"RDK-B Platform\"\n        WM[\ud83d\udd27 WAN Manager]\n        IM1[\ud83d\udcf6 DOCSIS Manager]\n        IM2[\ud83d\udd0c Ethernet Manager] \n        IM3[\ud83d\udcde Cellular Manager]\n        DHCP[\u26a1 DHCP Manager]\n        VLAN[\ud83c\udff7\ufe0f VLAN Manager]\n        RouteM[\ud83d\udee4\ufe0f Route Manager]\n    end\n\n    subgraph \"Hardware Layer\"\n        DOCSIS[(DOCSIS Interface)]\n        ETH[(Ethernet Interface)]\n        LTE[(LTE Interface)]\n    end\n\n    Cloud --&gt;|WebConfig/REST| WM\n    ACS --&gt;|TR-181| WM\n    WebUI --&gt;|HTTP/REST| WM\n\n    WM &lt;--&gt;|RBus Events| IM1\n    WM &lt;--&gt;|RBus Events| IM2  \n    WM &lt;--&gt;|RBus Events| IM3\n    WM --&gt;|DBus/IPC| DHCP\n    WM --&gt;|DBus/IPC| VLAN\n    WM --&gt;|DBus/IPC| RouteM\n\n    IM1 &lt;--&gt; DOCSIS\n    IM2 &lt;--&gt; ETH\n    IM3 &lt;--&gt; LTE\n\n    classDef external fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n    classDef component fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef hardware fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n\n    class Cloud,ACS,WebUI external;\n    class WM,IM1,IM2,IM3,DHCP,VLAN,RouteM component;\n    class DOCSIS,ETH,LTE hardware;</code></pre>"},{"location":"docu/WANMgr%20Rama/#25-c4-container-diagram","title":"2.5 C4 Container Diagram","text":"<pre><code>graph TD\n    subgraph \"Linux Container (RDK-B v2023.1)\"\n        subgraph \"WAN Manager Process\"\n            Core[\ud83d\udd27 Core Engine]\n            PC[\ud83d\udccb Policy Controllers]\n            ISM[\u2699\ufe0f Interface State Machines]\n            DM[\ud83d\udcbe Data Manager]\n            TR181[\ud83d\udcca TR-181 Handler]\n            IPC[\ud83d\udd04 IPC Manager]\n        end\n\n        subgraph \"System Services\"\n            RBus[(RBus v1.2)]\n            DBus[(DBus v1.13)]\n            SysEvents[(SysEvents)]\n        end\n\n        subgraph \"Configuration Storage\"\n            PSM[(PSM Database)]\n            SysCfg[(SysCfg)]\n        end\n    end\n\n    Core --&gt; PC\n    Core --&gt; ISM  \n    Core --&gt; DM\n    PC --&gt; ISM\n    ISM --&gt; IPC\n    TR181 --&gt; DM\n    IPC --&gt; RBus\n    IPC --&gt; DBus\n    IPC --&gt; SysEvents\n    DM --&gt; PSM\n    DM --&gt; SysCfg\n\n    classDef wanmgr fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef system fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;\n    classDef storage fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n\n    class Core,PC,ISM,DM,TR181,IPC wanmgr;\n    class RBus,DBus,SysEvents system;\n    class PSM,SysCfg storage;</code></pre>"},{"location":"docu/WANMgr%20Rama/#26-design-explanation-request-flow","title":"2.6 Design Explanation &amp; Request Flow","text":"<ul> <li>Request Flow Sequence: </li> <li>Interface Manager reports PHY status change via RBus</li> <li>WAN Manager Policy Controller evaluates interface selection</li> <li>Interface State Machine configures IP stack (DHCP, VLAN, routes)</li> <li>Validation performs connectivity checks</li> <li> <p>Active interface status updated and propagated via TR-181</p> </li> <li> <p>Technology Stack: </p> </li> <li>Languages: C99, with some C++ test components</li> <li>IPC Framework: RBus v1.2 (primary), DBus v1.13 (legacy)</li> <li>Data Storage: PSM (Parameter Storage Manager), SysCfg</li> <li>Build System: GNU Autotools, Make</li> <li>Threading: POSIX threads with mutex-based synchronization</li> </ul>"},{"location":"docu/WANMgr%20Rama/#3-internal-modules","title":"3. Internal Modules","text":"Module/Class Description Key Files Core Engine Component initialization, main event loop, lifecycle management <code>wanmgr_main.c</code>, <code>wanmgr_core.c</code> Policy Controllers WAN interface selection algorithms and failover logic <code>wanmgr_policy_*.c</code>, <code>wanmgr_controller.c</code> Interface State Machine Individual interface configuration and validation <code>wanmgr_interface_sm.c</code>, <code>wanmgr_interface_sm.h</code> Data Manager Thread-safe data access, configuration persistence <code>wanmgr_data.c</code>, <code>wanmgr_data.h</code> TR-181 DML Data model layer, parameter access functions <code>wanmgr_dml_*.c</code>, <code>wanmgr_dml.h</code> DHCP Integration DHCP client management and event handling <code>wanmgr_dhcp*.c</code>, <code>wanmgr_dhcp*.h</code> Network Utils Low-level network configuration utilities <code>wanmgr_net_utils.c</code>, <code>wanmgr_net_utils.h</code> IPC Manager RBus/DBus communication and event handling <code>wanmgr_ipc.c</code>, <code>wanmgr_rbus_*.c</code> WebConfig API WebConfig framework integration <code>wanmgr_webconfig*.c</code> Telemetry Metrics collection and T2 integration <code>wanmgr_telemetry.c</code>, <code>wanmgr_t2_telemetry.c</code>"},{"location":"docu/WANMgr%20Rama/#31-module-breakdown-diagram","title":"3.1 Module Breakdown Diagram","text":"<pre><code>flowchart TD\n    subgraph \"WAN Manager Core\"\n        Main[Main Engine&lt;br/&gt;wanmgr_main.c]\n        Core[Core Controller&lt;br/&gt;wanmgr_core.c]\n        Data[Data Manager&lt;br/&gt;wanmgr_data.c]\n    end\n\n    subgraph \"Policy Engine\"\n        PolicyCtrl[Policy Controller&lt;br/&gt;wanmgr_controller.c]\n        AutoWAN[AutoWAN Policy&lt;br/&gt;wanmgr_policy_autowan_impl.c]\n        Fixed[Fixed Mode&lt;br/&gt;wanmgr_policy_fmob_impl.c]\n        Priority[Priority Policy&lt;br/&gt;wanmgr_policy_pp_impl.c]\n        Auto[Auto Policy&lt;br/&gt;wanmgr_policy_auto_impl.c]\n    end\n\n    subgraph \"Interface Management\"\n        ISM[Interface State Machine&lt;br/&gt;wanmgr_interface_sm.c]\n        NetUtils[Network Utilities&lt;br/&gt;wanmgr_net_utils.c]\n        DHCP[DHCP Management&lt;br/&gt;wanmgr_dhcp*.c]\n    end\n\n    subgraph \"External Interfaces\"\n        TR181[TR-181 DML&lt;br/&gt;wanmgr_dml_*.c]\n        IPC[IPC Manager&lt;br/&gt;wanmgr_ipc.c]\n        RBus[RBus Handler&lt;br/&gt;wanmgr_rbus_*.c]\n        WebCfg[WebConfig&lt;br/&gt;wanmgr_webconfig*.c]\n    end\n\n    Main --&gt; Core\n    Core --&gt; Data\n    Core --&gt; PolicyCtrl\n    PolicyCtrl --&gt; AutoWAN\n    PolicyCtrl --&gt; Fixed\n    PolicyCtrl --&gt; Priority\n    PolicyCtrl --&gt; Auto\n    PolicyCtrl --&gt; ISM\n    ISM --&gt; NetUtils\n    ISM --&gt; DHCP\n    Data --&gt; TR181\n    Core --&gt; IPC\n    IPC --&gt; RBus\n    Core --&gt; WebCfg\n\n    classDef core fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef policy fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;\n    classDef interface fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n    classDef external fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n\n    class Main,Core,Data core;\n    class PolicyCtrl,AutoWAN,Fixed,Priority,Auto policy;\n    class ISM,NetUtils,DHCP interface;\n    class TR181,IPC,RBus,WebCfg external;</code></pre>"},{"location":"docu/WANMgr%20Rama/#4-interaction-with-other-middleware-components","title":"4. Interaction with Other Middleware Components","text":"Component Purpose of Interaction Protocols/Mechanisms DHCP Manager IPv4/IPv6 address acquisition and renewal DBus method calls, SysEvents VLAN Manager VLAN tagging and interface configuration DBus IPC, direct system calls Route Manager Default route and routing table management SysEvents, direct route manipulation Interface Managers Physical interface status and configuration RBus events and method calls PAM (Platform &amp; Application Manager) Interface enumeration and device information DBus parameter queries PSM (Parameter Storage Manager) Configuration persistence and retrieval DBus parameter get/set operations Telemetry 2.0 Metrics and event reporting T2 message bus integration WebConfig Framework Remote configuration management HTTP REST API, JSON payload"},{"location":"docu/WANMgr%20Rama/#41-middleware-interaction-diagram","title":"4.1 Middleware Interaction Diagram","text":"<pre><code>flowchart TD\n    WM[WAN Manager]\n\n    subgraph \"Network Services\"\n        DHCP[DHCP Manager]\n        VLAN[VLAN Manager] \n        Route[Route Manager]\n    end\n\n    subgraph \"Interface Layer\"\n        DOCSIS[DOCSIS Manager]\n        ETH[Ethernet Manager]\n        Cell[Cellular Manager]\n        DSL[DSL Manager]\n    end\n\n    subgraph \"Platform Services\"\n        PAM[PAM]\n        PSM[PSM]\n        T2[Telemetry 2.0]\n        WebCfg[WebConfig]\n    end\n\n    WM --&gt;|DBus/IPC| DHCP\n    WM --&gt;|DBus/IPC| VLAN\n    WM --&gt;|SysEvents| Route\n\n    WM &lt;--&gt;|RBus Events| DOCSIS\n    WM &lt;--&gt;|RBus Events| ETH\n    WM &lt;--&gt;|RBus Events| Cell\n    WM &lt;--&gt;|RBus Events| DSL\n\n    WM &lt;--&gt;|DBus Params| PAM\n    WM &lt;--&gt;|DBus Params| PSM\n    WM --&gt;|T2 Messages| T2\n    WM &lt;--&gt;|HTTP/JSON| WebCfg\n\n    classDef wanmgr fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef network fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;\n    classDef interface fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n    classDef platform fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n\n    class WM wanmgr;\n    class DHCP,VLAN,Route network;\n    class DOCSIS,ETH,Cell,DSL interface;\n    class PAM,PSM,T2,WebCfg platform;</code></pre>"},{"location":"docu/WANMgr%20Rama/#5-interaction-with-other-layers","title":"5. Interaction with Other Layers","text":"<p>The WAN Manager integrates across multiple architectural layers:</p> Layer/Service Interaction Description Mechanism HAL Layer Interface Managers provide hardware abstraction for DOCSIS, Ethernet, Cellular, DSL RBus events for status changes, parameter queries Linux Network Stack Direct manipulation of network interfaces, routes, iptables System calls, netlink sockets, shell commands RDK-B Middleware Integration with DHCP, VLAN, routing, and telemetry services DBus IPC, RBus messaging, SysEvents Management Layer TR-181 parameter exposure for ACS and WebUI management DBus parameter bus, HTTP REST APIs Application Layer WebConfig for cloud-based configuration management HTTP/HTTPS, JSON payload processing"},{"location":"docu/WANMgr%20Rama/#51-layered-architecture-view","title":"5.1 Layered Architecture View","text":"<pre><code>graph TD\n    subgraph \"Management Layer\"\n        ACS[ACS/TR-069]\n        WebUI[Web UI]\n        Cloud[Cloud Config]\n    end\n\n    subgraph \"RDK-B Middleware Layer\"\n        WM[WAN Manager]\n        DHCP[DHCP Manager]\n        VLAN[VLAN Manager]\n        Route[Route Manager]\n    end\n\n    subgraph \"HAL Layer\"\n        DocHAL[DOCSIS HAL]\n        EthHAL[Ethernet HAL]\n        CellHAL[Cellular HAL]\n        DSLHAL[DSL HAL]\n    end\n\n    subgraph \"Linux Kernel Layer\"\n        NetStack[Network Stack]\n        Drivers[Interface Drivers]\n    end\n\n    subgraph \"Hardware Layer\"\n        HW[Physical Interfaces]\n    end\n\n    ACS --&gt;|TR-181/DBus| WM\n    WebUI --&gt;|HTTP/REST| WM\n    Cloud --&gt;|WebConfig/JSON| WM\n\n    WM &lt;--&gt;|DBus/IPC| DHCP\n    WM &lt;--&gt;|DBus/IPC| VLAN\n    WM &lt;--&gt;|SysEvents| Route\n\n    WM &lt;--&gt;|RBus| DocHAL\n    WM &lt;--&gt;|RBus| EthHAL\n    WM &lt;--&gt;|RBus| CellHAL\n    WM &lt;--&gt;|RBus| DSLHAL\n\n    DocHAL --&gt; NetStack\n    EthHAL --&gt; NetStack\n    CellHAL --&gt; NetStack\n    DSLHAL --&gt; NetStack\n\n    NetStack --&gt; Drivers\n    Drivers --&gt; HW\n\n    classDef mgmt fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n    classDef middleware fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef hal fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;\n    classDef kernel fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n    classDef hardware fill:#ffebee,stroke:#c62828,stroke-width:2px;\n\n    class ACS,WebUI,Cloud mgmt;\n    class WM,DHCP,VLAN,Route middleware;\n    class DocHAL,EthHAL,CellHAL,DSLHAL hal;\n    class NetStack,Drivers kernel;\n    class HW hardware;</code></pre>"},{"location":"docu/WANMgr%20Rama/#6-ipc-mechanism","title":"6. IPC Mechanism","text":"<ul> <li>Type of IPC: </li> <li>Primary: RBus v1.2 for real-time interface events and status updates</li> <li>Secondary: DBus v1.13 for parameter access and legacy component integration</li> <li> <p>Tertiary: SysEvents for system-wide notifications and routing updates</p> </li> <li> <p>Message Format: </p> </li> <li>RBus: Structured events with typed parameters (status changes, interface metrics)</li> <li>DBus: Parameter-based get/set operations with string/numeric values</li> <li> <p>SysEvents: Name-value pairs for system state notifications</p> </li> <li> <p>Flow: </p> </li> <li>Asynchronous Events: Interface status changes, DHCP lease updates</li> <li>Synchronous Calls: Parameter queries, configuration validation</li> <li>Publish/Subscribe: Interface state notifications to subscribers</li> </ul>"},{"location":"docu/WANMgr%20Rama/#61-ipc-flow-diagram","title":"6.1 IPC Flow Diagram","text":"<pre><code>sequenceDiagram\n    participant IM as Interface Manager\n    participant WM as WAN Manager  \n    participant DHCP as DHCP Manager\n    participant PSM as PSM\n    participant ACS as ACS/TR-069\n\n    Note over IM,ACS: Interface Status Change Flow\n\n    IM-&gt;&gt;WM: RBus Event (PHY_STATUS_UP)\n    WM-&gt;&gt;WM: Policy Controller Evaluation\n    WM-&gt;&gt;DHCP: DBus Call (Start DHCP Client)\n    DHCP--&gt;&gt;WM: DBus Response (Client Started)\n    WM-&gt;&gt;PSM: DBus Set (Interface.Status=UP)\n\n    Note over IM,ACS: Configuration Request Flow\n\n    ACS-&gt;&gt;WM: DBus Get (WAN.Policy)\n    WM-&gt;&gt;PSM: DBus Get (Stored Config)\n    PSM--&gt;&gt;WM: DBus Response (Config Data)\n    WM--&gt;&gt;ACS: DBus Response (Policy Value)\n\n    Note over IM,ACS: Status Update Flow\n\n    WM-&gt;&gt;IM: RBus Subscribe (Interface Events)\n    IM--&gt;&gt;WM: RBus Event (Status Updates)\n    WM-&gt;&gt;WM: Update Internal State\n    WM-&gt;&gt;PSM: DBus Set (Persistent State)</code></pre>"},{"location":"docu/WANMgr%20Rama/#7-tr-181-data-models","title":"7. TR-181 Data Models","text":"<ul> <li>Implemented Parameters: The WAN Manager implements the <code>Device.X_RDK_WanManager.</code> namespace with comprehensive interface and policy management</li> <li>Parameter Registration: Parameters are registered via DBus parameter bus and exposed through the CCSP framework</li> <li>Custom Extensions: RDK-specific extensions for multi-WAN policies, interface grouping, and failover configuration</li> </ul>"},{"location":"docu/WANMgr%20Rama/#71-tr-181-parameter-table","title":"7.1 TR-181 Parameter Table","text":"Parameter Description Access (R/W) Default Notes <code>Device.X_RDK_WanManager.Enable</code> Global WAN Manager enable/disable R/W <code>true</code> Master switch <code>Device.X_RDK_WanManager.Policy</code> WAN selection policy type R/W <code>AUTOWAN_MODE</code> Enum: FIXED_MODE, AUTOWAN_MODE, etc. <code>Device.X_RDK_WanManager.Interface.{i}.Enable</code> Per-interface enable flag R/W <code>true</code> Interface-specific control <code>Device.X_RDK_WanManager.Interface.{i}.Selection.Status</code> Current selection status R <code>WAN_IFACE_NOT_SELECTED</code> Runtime status <code>Device.X_RDK_WanManager.Interface.{i}.Selection.Priority</code> Interface priority (1-255) R/W <code>1</code> Lower number = higher priority <code>Device.X_RDK_WanManager.Interface.{i}.Selection.Group</code> Interface group assignment R/W <code>1</code> Grouping for policies <code>Device.X_RDK_WanManager.Interface.{i}.BaseInterfaceStatus</code> Physical layer status R <code>WAN_IFACE_PHY_STATUS_DOWN</code> PHY status from Interface Manager <code>Device.X_RDK_WanManager.Interface.{i}.VirtualInterface.{i}.Status</code> Virtual interface status R <code>WAN_IFACE_STATUS_DISABLED</code> IP layer status <code>Device.X_RDK_WanManager.Interface.{i}.VirtualInterface.{i}.IP.Mode</code> IP addressing mode R/W <code>DHCP</code> DHCP, Static, PPPoE <code>Device.X_RDK_WanManager.CPEInterface.{i}.Wan.CurrentActiveInterface</code> Currently active WAN interface R <code>\"\"</code> Active interface name"},{"location":"docu/WANMgr%20Rama/#72-tr-181-parameter-mapping-diagram","title":"7.2 TR-181 Parameter Mapping Diagram","text":"<pre><code>flowchart TD\n    subgraph \"TR-181 Namespace\"\n        Root[Device.X_RDK_WanManager]\n        Global[Global Parameters&lt;br/&gt;Enable, Policy, etc.]\n        Iface[Interface.{i}&lt;br/&gt;Per-Interface Config]\n        VirtIf[VirtualInterface.{i}&lt;br/&gt;IP Layer Config]\n        CPE[CPEInterface.{i}&lt;br/&gt;Active Status]\n    end\n\n    subgraph \"Internal Data Structures\"\n        Config[WanMgr_Config_Data_t]\n        IfaceData[WanMgr_Iface_Data_t]\n        VirtData[DML_VIRTUAL_IFACE]\n        StatusData[Runtime Status]\n    end\n\n    subgraph \"Policy Engine\"\n        PolicyCtrl[Policy Controller]\n        ISM[Interface State Machine]\n    end\n\n    Root --&gt; Global\n    Root --&gt; Iface\n    Iface --&gt; VirtIf\n    Root --&gt; CPE\n\n    Global &lt;--&gt; Config\n    Iface &lt;--&gt; IfaceData\n    VirtIf &lt;--&gt; VirtData\n    CPE &lt;--&gt; StatusData\n\n    Config --&gt; PolicyCtrl\n    IfaceData --&gt; PolicyCtrl\n    PolicyCtrl --&gt; ISM\n    ISM --&gt; StatusData\n\n    classDef tr181 fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n    classDef data fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef policy fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;\n\n    class Root,Global,Iface,VirtIf,CPE tr181;\n    class Config,IfaceData,VirtData,StatusData data;\n    class PolicyCtrl,ISM policy;</code></pre>"},{"location":"docu/WANMgr%20Rama/#8-implementation-details","title":"8. Implementation Details","text":"<ul> <li>Key Algorithms or Logic: </li> <li>AutoWAN Policy: Sequential interface scanning with connectivity validation</li> <li>Priority Policy: Weight-based selection with primary/secondary failover</li> <li>Interface State Machine: Multi-stage configuration (Link\u2192IP\u2192Validation\u2192Active)</li> <li> <p>Connectivity Validation: DNS resolution and gateway reachability tests</p> </li> <li> <p>Error Handling Strategy: </p> </li> <li>Graceful Degradation: Continue operation with available interfaces on partial failures</li> <li>State Recovery: Persistent state storage with recovery on restart</li> <li>Error Propagation: Structured error codes with detailed logging</li> <li> <p>Timeout Management: Configurable timeouts for all blocking operations</p> </li> <li> <p>Logging &amp; Debugging: </p> </li> <li>CcspTrace Framework: Configurable log levels (Error, Warning, Info, Debug)</li> <li>Module-Specific Logging: Per-module log categories for targeted debugging</li> <li>Telemetry Integration: Key metrics exported via T2 framework</li> <li>Debug Interfaces: Runtime parameter dumping and state inspection</li> </ul>"},{"location":"docu/WANMgr%20Rama/#9-key-configuration-files","title":"9. Key Configuration Files","text":"Configuration File Purpose Key Parameters Default Values Override Mechanisms <code>RdkWanManager.xml</code> TR-181 data model definition Parameter mappings, types, access rights N/A Build-time configuration <code>/nvram/syscfg.db</code> Persistent configuration storage Interface priorities, policy settings Policy=6 (AutoWAN) TR-181 parameter sets <code>/etc/utopia/service_wan/wan.sh</code> WAN startup script Interface initialization order DOCSIS first Platform-specific overrides <code>/tmp/wanmgr_restart_config</code> Runtime configuration flags Interface reset flags, policy changes Empty WebConfig, TR-181 <code>/etc/wanmanager/</code> Policy-specific configurations Timeout values, validation URLs 20s timeout Environment variables"},{"location":"docu/WANMgr%20Rama/#10-api-endpoints-if-applicable","title":"10. API Endpoints (if applicable)","text":"<p>The WAN Manager exposes management interfaces through multiple protocols:</p> Method Endpoint Description Auth Returns DBus <code>Device.X_RDK_WanManager.Interface.{i}.Selection.Status</code> Get interface selection status None Enum string DBus <code>Device.X_RDK_WanManager.Policy</code> Set/Get WAN selection policy None Policy enum RBus <code>Device.WanManager.Interface.{i}.PhyStatus</code> Subscribe to interface events None Event stream HTTP <code>/api/v1/wan/status</code> Get overall WAN status (WebConfig) Token JSON status HTTP <code>/api/v1/wan/config</code> Update WAN configuration (WebConfig) Token JSON response"},{"location":"docu/WANMgr%20Rama/#11-deployment-runtime-environment","title":"11. Deployment &amp; Runtime Environment","text":"<ul> <li>Container Runtime: Runs as a native systemd service in RDK-B Linux container</li> <li>Orchestration: Managed by systemd with dependency ordering on network services</li> <li>Resource Requirements: </li> <li>CPU: 2-5% average, 10-15% during failover events</li> <li>Memory: 8-12MB RSS, 16-20MB VSZ</li> <li>Disk: 1-2MB configuration storage</li> <li>Supported Platforms: RDKB-compatible broadband gateways (ARM, x86_64)</li> <li>Startup Parameters: </li> <li><code>-subsys eRT.com.cisco.spvtg.ccsp.wanmanager</code></li> <li>Environment: <code>CCSP_LOG_LEVEL</code>, <code>WAN_MANAGER_DEBUG</code></li> </ul>"},{"location":"docu/WANMgr%20Rama/#12-monitoring-security","title":"12. Monitoring &amp; Security","text":"<ul> <li>Monitoring: </li> <li>Telemetry 2.0: Interface status, failover events, policy changes</li> <li>System Logs: CcspTrace integration with configurable verbosity</li> <li>Health Metrics: Interface validation success rates, DHCP lease times</li> <li> <p>Performance: Policy execution times, state machine transitions</p> </li> <li> <p>Authentication &amp; Authorization: </p> </li> <li>TR-181 Access: CCSP framework role-based access control</li> <li>WebConfig: Token-based authentication with signature validation</li> <li> <p>Local IPC: Unix domain socket permissions for component isolation</p> </li> <li> <p>Auditing &amp; Compliance: </p> </li> <li>Configuration Changes: All parameter modifications logged with timestamps</li> <li>Access Logging: TR-181 access attempts and sources recorded</li> <li>Failover Events: Complete audit trail for WAN switching decisions</li> </ul>"},{"location":"docu/WANMgr%20Rama/#13-wan-manager-policy-state-machines","title":"13. WAN Manager Policy State Machines","text":""},{"location":"docu/WANMgr%20Rama/#131-policy-failover-state-enumerations","title":"13.1 Policy &amp; Failover State Enumerations","text":"<p>AutoWAN / Generic Policy States (observed in <code>wanmgr_policy_autowan_impl.c</code>): * STATE_AUTO_WAN_INTERFACE_SELECTING * STATE_AUTO_WAN_INTERFACE_WAITING * STATE_AUTO_WAN_INTERFACE_SCANNING * STATE_AUTO_WAN_INTERFACE_TEARDOWN * STATE_AUTO_WAN_INTERFACE_RECONFIGURATION * STATE_AUTO_WAN_INTERFACE_REBOOT_PLATFORM * STATE_AUTO_WAN_INTERFACE_ACTIVE * STATE_AUTO_WAN_INTERFACE_DOWN * STATE_AUTO_WAN_INTERFACE_ERROR * STATE_AUTO_WAN_INTERFACE_TEARING_DOWN * STATE_AUTO_WAN_SM_EXIT</p> <p>Failover Controller States (<code>wanmgr_wan_failover.h</code>): * STATE_FAILOVER_SCANNING_GROUP \u2013 iterating groups for viable interface * STATE_FAILOVER_GROUP_ACTIVE \u2013 a group is active and monitored * STATE_FAILOVER_RESTORATION_WAIT \u2013 waiting RestorationDelay to prefer higher tier * STATE_FAILOVER_DEACTIVATE_GROUP \u2013 tearing down current group before switch * STATE_FAILOVER_EXIT \u2013 normal termination * STATE_FAILOVER_ERROR \u2013 unrecoverable failure path</p> <p>Interface State Machine States (<code>wanmgr_dml.h</code> eWanState_t): * WAN_STATE_VLAN_CONFIGURING * WAN_STATE_PPP_CONFIGURING * WAN_STATE_VALIDATING_WAN * WAN_STATE_OBTAINING_IP_ADDRESSES * WAN_STATE_IPV4_LEASED * WAN_STATE_IPV6_LEASED * WAN_STATE_DUAL_STACK_ACTIVE * WAN_STATE_MAPT_ACTIVE * WAN_STATE_REFRESHING_WAN * WAN_STATE_DECONFIGURING_WAN * WAN_STATE_STANDBY * WAN_STATE_EXIT</p> <p>Telemetry Events (Failover): * WAN_FAILOVER_SUCCESS * WAN_FAILOVER_FAIL * WAN_RESTORE_SUCCESS * WAN_RESTORE_FAIL</p>"},{"location":"docu/WANMgr%20Rama/#132-autowan-policy-state-machine","title":"13.2 AutoWAN Policy State Machine","text":"<pre><code>stateDiagram-v2\n    [*] --&gt; SELECTING_INTERFACE\n    SELECTING_INTERFACE --&gt; WAITING_FOR_INTERFACE : Interface Found\n    WAITING_FOR_INTERFACE --&gt; SCANNING_INTERFACE : PHY Up\n    SCANNING_INTERFACE --&gt; VALIDATING_INTERFACE : IP Configured\n    VALIDATING_INTERFACE --&gt; INTERFACE_ACTIVE : Validation Success\n    VALIDATING_INTERFACE --&gt; TEARDOWN : Validation Failed\n    INTERFACE_ACTIVE --&gt; TEARDOWN : PHY Down/Policy Change\n    TEARDOWN --&gt; SELECTING_INTERFACE : Cleanup Complete\n    INTERFACE_ACTIVE --&gt; INTERFACE_ACTIVE : Health Check OK\n\n    state SCANNING_INTERFACE {\n        [*] --&gt; Starting_ISM\n        Starting_ISM --&gt; Configuring_IP\n        Configuring_IP --&gt; IP_Configured\n        IP_Configured --&gt; [*]\n    }</code></pre> <p>AutoWAN Transition Notes: * SELECTING_INTERFACE \u2192 WAITING_FOR_INTERFACE: After candidate enumeration; timer started. * WAITING_FOR_INTERFACE \u2192 SCANNING_INTERFACE: Physical link up event (RBus / sysevent). * SCANNING_INTERFACE \u2192 VALIDATING_INTERFACE: ISM reports IP layer ready (IPv4 or IPv6 lease acquired). * VALIDATING_INTERFACE \u2192 INTERFACE_ACTIVE: Connectivity checks (DNS + gateway reachability) pass. * VALIDATING_INTERFACE \u2192 TEARDOWN: Validation failure (retries exhausted) triggers cleanup. * INTERFACE_ACTIVE \u2192 TEARDOWN: Link loss, policy override, or health check failure. * TEARDOWN \u2192 SELECTING_INTERFACE: Resources released; next candidate (or loop) chosen.</p> <p>Timeout / Backoff Parameters (typical): * Selection Timeout (min): 20s (<code>SELECTION_TIMEOUT_DEFAULT_MIN</code>). * Interface Validation Loop Interval: 50ms (ISM loop tick) with aggregate validation windows (seconds scale) based on DHCP/RA events. * RestorationDelay (failover): Platform-configurable; defines grace period before switching back to preferred group.</p>"},{"location":"docu/WANMgr%20Rama/#133-interface-state-machine-flow","title":"13.3 Interface State Machine Flow","text":"<pre><code>stateDiagram-v2\n    [*] --&gt; WAN_INTERFACE_DOWN\n    WAN_INTERFACE_DOWN --&gt; WAN_INTERFACE_CONFIGURING : Start Configuration\n    WAN_INTERFACE_CONFIGURING --&gt; WAN_INTERFACE_CONFIGURED : IP Stack Ready\n    WAN_INTERFACE_CONFIGURED --&gt; WAN_INTERFACE_VALIDATING : Begin Validation\n    WAN_INTERFACE_VALIDATING --&gt; WAN_INTERFACE_UP : Validation Pass\n    WAN_INTERFACE_VALIDATING --&gt; WAN_INTERFACE_DOWN : Validation Fail\n    WAN_INTERFACE_UP --&gt; WAN_INTERFACE_DOWN : Link Lost\n    WAN_INTERFACE_UP --&gt; WAN_INTERFACE_UP : Health Check\n\n    state WAN_INTERFACE_CONFIGURING {\n        [*] --&gt; Link_Layer_Config\n        Link_Layer_Config --&gt; VLAN_Config\n        VLAN_Config --&gt; DHCP_Start\n        DHCP_Start --&gt; Route_Config\n        Route_Config --&gt; [*]\n    }</code></pre> <p>Interface State Notes: * VLAN_CONFIGURING vs PPP_CONFIGURING: Mutually exclusive early paths; PPP path may shortcut VLAN if not required. * OBTAINING_IP_ADDRESSES loops until DHCPv4 lease and/or DHCPv6/RA acquired; partial (single stack) states escalate to dual-stack when second protocol succeeds. * REFRESHING_WAN invoked for lease renewal / connectivity degradation (proactive revalidation) without full teardown. * MAPT_ACTIVE reachable only if MAP-T feature enabled and provisioning data applied.</p>"},{"location":"docu/WANMgr%20Rama/#134-failover-state-machine","title":"13.4 Failover State Machine","text":"<pre><code>stateDiagram-v2\n    [*] --&gt; SCANNING_GROUP\n    SCANNING_GROUP --&gt; GROUP_ACTIVE : Candidate Found\n    GROUP_ACTIVE --&gt; RESTORATION_WAIT : Higher Tier Detected\n    RESTORATION_WAIT --&gt; GROUP_ACTIVE : Timer Not Expired\n    RESTORATION_WAIT --&gt; DEACTIVATE_GROUP : Timer Expired &amp; Preferred Ready\n    DEACTIVATE_GROUP --&gt; SCANNING_GROUP : Teardown Complete\n    GROUP_ACTIVE --&gt; SCANNING_GROUP : Active Failure\n    SCANNING_GROUP --&gt; ERROR : No Groups Available\n    ERROR --&gt; SCANNING_GROUP : Retry Interval\n    GROUP_ACTIVE --&gt; [*] : Shutdown</code></pre> <p>Failover Timing: * Two timers: GroupSelectionTimer (scanning cadence) &amp; FailOverTimer (restoration delay window). * Telemetry fired upon success/fail transitions to aid fleet analytics.</p>"},{"location":"docu/WANMgr%20Rama/#135-telemetry-observability-hooks","title":"13.5 Telemetry &amp; Observability Hooks","text":"<p>Key Emission Points: * Policy transitions (selection start, candidate chosen, validation success/failure). * Failover events (success/failure + restoration outcome). * Interface SM transitions to/from ACTIVE / MAPT_ACTIVE / DUAL_STACK_ACTIVE. * DHCP anomalies (rapid renewals, lease failure) flagged via net utils &amp; logged at INFO/WARN.</p> <p>KPIs Suggested (not yet all implemented in codebase): * Mean Time To Failover (MTTF): Detection \u2192 New Active. * Validation Success Rate: successes / attempts per interface type. * Lease Stability: renewals per hour vs expected. * Dual Stack Attainment Ratio: % sessions achieving dual stack within threshold.</p>"},{"location":"docu/WANMgr%20Rama/#136-extended-tr-181-parameter-coverage","title":"13.6 Extended TR-181 Parameter Coverage","text":"<p>Additional (selected) parameters observed/expected from <code>RdkWanManager.xml</code> and DML layer: | Parameter | Purpose | Notes | |-----------|---------|-------| | <code>Device.X_RDK_WanManager.Interface.{i}.BaseInterfaceStatus</code> | Physical link status | Mirrors <code>DML_WAN_IFACE_PHY_STATUS_*</code> enum | | <code>Device.X_RDK_WanManager.Interface.{i}.WanStatus</code> | Aggregated WAN oper state | Derived from eWanState_t reductions | | <code>Device.X_RDK_WanManager.Interface.{i}.VirtualInterface.{i}.IPv6.Enable</code> | Enable v6 on virtual iface | Affects DHCPv6 client spawn | | <code>Device.X_RDK_WanManager.Interface.{i}.VirtualInterface.{i}.MAPT.Status</code> | MAP-T operational status | Transitions to MAPT_ACTIVE when ready | | <code>Device.X_RDK_WanManager.InterfaceGroup.{i}.Policy</code> | Group-level policy enum | Drives per-group thread behavior | | <code>Device.X_RDK_WanManager.InterfaceGroup.{i}.SelectionTimeOut</code> | Selection timeout (s) | Minimum enforced (&gt;=20) | | <code>Device.X_RDK_WanManager.InterfaceGroup.{i}.PersistSelectedIface</code> | Preserve selection across reboot | Influences initial scan path | | <code>Device.X_RDK_WanManager.Failover.RestorationDelay</code> | Backoff before pref restore | Governs RESTORATION_WAIT length | | <code>Device.X_RDK_WanManager.Failover.AllowRemoteInterfaces</code> | Enable remote CPE WAN use | Impacts remote interface configuration path | | <code>Device.X_RDK_WanManager.Diagnostics.LastFailoverEvent</code> | Last telemetry event code | Mirrors TelemetryEvent_t |</p> <p>Mapping Principles: * eWanState_t values compressed into user-friendly strings for <code>WanStatus</code> (e.g., ACTIVE, STANDBY, CONFIGURING). * Group-level parameters centralize policy tuning, limiting per-interface writes during strategy changes. * Write-validation ensures timeouts not set below compiled minimum to prevent rapid churn loops.</p>"},{"location":"docu/WANMgr%20Rama/#137-concurrency-data-integrity-considerations","title":"13.7 Concurrency &amp; Data Integrity Considerations","text":"<ul> <li>Always pair <code>*_locked()</code> getters with release to avoid holding global mutexes across blocking I/O (DHCP, RBUS calls).</li> <li>Avoid nested interface acquisitions inside policy iteration loops\u2014fetch snapshot then release for scalability.</li> <li>Use monotonic timestamps for selection/failover to prevent NTP leap issues invalidating timers.</li> <li>When extending telemetry, prefer batching updates to reduce bus chatter (aggregate counters per 30s window).</li> </ul>"},{"location":"docu/WANMgr%20Rama/#138-extension-guidance","title":"13.8 Extension Guidance","text":"<p>When adding a new WAN policy: 1. Define policy enum &amp; config exposure in TR-181 XML. 2. Implement isolated state machine (file <code>wanmgr_policy_&lt;name&gt;_impl.c</code>). 3. Reuse group thread harness; ensure transitions set <code>ConfigChanged</code> when switching interfaces. 4. Provide determinism: document transition table + failure fallbacks. 5. Hook telemetry at key decision edges (candidate reject, validation fail).</p>"},{"location":"docu/WANMgr%20Rama/#14-validation-review-checklist","title":"14. Validation &amp; Review Checklist","text":"<ul> <li>[x] Deployment Accuracy: Diagrams reflect systemd service deployment with RDK-B container structure</li> <li>[x] Communication Specificity: RBus, DBus, and SysEvents protocols clearly labeled with message types</li> <li>[x] Scaling Representation: Shows per-interface state machines and policy threads scaling independently</li> <li>[x] Technology Versions: RBus v1.2, DBus v1.13, Linux kernel networking documented</li> <li>[x] Implementation Details: Source files, data structures, and configuration mechanisms included</li> <li>[x] Visual Hierarchy: Different component types clearly distinguished with consistent color coding</li> <li>[x] Protocol Labels: Connection labels specify exact IPC mechanisms and data flows</li> <li>[x] Mermaid Syntax: All diagrams validated for proper rendering without syntax errors</li> <li>[x] TR-181 Coverage: Complete parameter namespace documented with access patterns</li> <li>[x] Code Accuracy: Function names, file paths, and module boundaries verified against source</li> </ul>"},{"location":"docu/WANMgr%20Rama/#15-conclusion-next-steps","title":"15. Conclusion &amp; Next Steps","text":"<p>The WAN Manager serves as the central orchestrator for WAN connectivity in RDK-B platforms, providing intelligent policy-based interface selection, robust failover mechanisms, and comprehensive TR-181 management capabilities. Its modular architecture supports multiple WAN technologies while maintaining clean separation between physical interface management and IP-layer configuration.</p> <p>Key Strengths: - Policy-driven interface selection with multiple algorithms - Thread-safe data management with robust IPC mechanisms - Comprehensive TR-181 integration for remote management - Scalable architecture supporting up to 32 WAN interfaces</p> <p>Planned Enhancements: - Enhanced telemetry and analytics for WAN performance optimization - Machine learning-based interface selection policies - Improved WebConfig integration for cloud-native management - Extended support for 5G and fiber optic interface types</p> <p>Related Documentation: - RDK-B Architecture Guide - TR-181 Data Model Specification - RBus Communication Framework - WAN Manager Source Repository</p> <p>This documentation provides comprehensive technical details for RDK-B WAN Manager development, maintenance, and integration. It serves as the authoritative reference for developers, system architects, and DevOps engineers working with WAN connectivity in RDK-B deployments.</p>"},{"location":"docu/WANMgr_Claude_2609/","title":"WAN Manager Documentation","text":"<p>The WAN Manager is a central orchestration component within the RDK-B middleware stack responsible for managing Wide Area Network interfaces across multiple physical technologies. It coordinates interface selection, failover policies, and network stack configuration while providing intelligent business logic for ensuring continuous Internet connectivity. The component abstracts physical interface complexities from higher-level services and implements policy-driven interface management strategies including Auto WAN, Primary Priority, Fixed Mode, and Parallel Scan approaches. WAN Manager integrates with Interface Managers (DOCSIS, Ethernet, Cellular, GPON) to receive physical layer status and coordinates with other RDK-B components like VLAN Manager, DHCP Manager, and DNS services for complete network stack provisioning. It serves as the single point of control for WAN configuration and monitoring, implementing TR-181 data models for remote management via WebConfig and TR-069 protocols.</p> <pre><code>graph LR\n    subgraph External [\"External Systems &amp; Users\"]\n        ISP1[ISP Provider 1]\n        ISP2[ISP Provider 2] \n        WEBUI[Web Management UI]\n        TR069[TR-069 ACS]\n        CloudMgmt[Cloud Management Platform]\n    end\n\n    subgraph \"WAN Management\"\n        WM[\ud83d\udce1 WAN Manager]\n        VLAN[VLAN Manager]\n        DHCP[DHCP Manager] \n        DNS[DNS Services]\n        FW[Firewall/Router]\n    end\n\n    subgraph InterfaceManagers [\"Interface Managers\"]\n        DOCSIS[DOCSIS Manager]\n        ETH[Ethernet Manager]\n        CELLULAR[Cellular Manager]\n        GPON[GPON Manager]\n    end\n\n    ISP1 --&gt;|Internet Connectivity| WM\n    ISP2 --&gt;|Backup Connectivity| WM\n    WEBUI --&gt;|TR-181 Parameters| WM\n    TR069 --&gt;|CWMP/TR-069| WM\n    CloudMgmt --&gt;|WebConfig API| WM\n\n    WM --&gt;|RBus IPC| VLAN\n    WM --&gt;|RBus IPC| DHCP\n    WM --&gt;|RBus IPC| DNS\n    WM --&gt;|Configuration| FW\n\n    DOCSIS --&gt;|Physical Status/RBus| WM\n    ETH --&gt;|Physical Status/RBus| WM\n    CELLULAR --&gt;|Physical Status/RBus| WM\n    GPON --&gt;|Physical Status/RBus| WM\n\n    classDef external fill:#ffebee,stroke:#d32f2f,stroke-width:2px;\n    classDef component fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef manager fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;\n    classDef app fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n\n    class ISP1,ISP2 external;\n    class WM,VLAN,DHCP,DNS,FW component;\n    class DOCSIS,ETH,CELLULAR,GPON manager;\n    class WEBUI,TR069,CloudMgmt app;</code></pre> <ul> <li>Key Features &amp; Responsibilities: </li> <li>Multi-Interface Management: Coordinates multiple WAN technologies including DOCSIS, Ethernet, Cellular, GPON, and xDSL, managing their lifecycle and selection priorities.</li> <li>Intelligent Failover Policies: Implements various failover strategies such as Auto WAN, Primary Priority, Fixed Mode, and Parallel Scan to ensure continuous Internet connectivity.</li> <li>Virtual Interface State Machines: Manages N instances of virtual interface state machines that handle the complete network stack configuration from link layer to IP layer protocols.</li> <li>TR-181 Data Model Implementation: Provides comprehensive TR-181 parameter support for remote configuration and monitoring via RBus and WebConfig interfaces.</li> <li>Dynamic Policy Selection: Supports runtime switching between different selection policies per interface group, enabling flexible WAN management strategies.</li> <li>Integration with RDK-B Ecosystem: Seamlessly interfaces with VLAN Manager, DHCP Manager, DNS services and other middleware components for complete network stack management.</li> </ul>"},{"location":"docu/WANMgr_Claude_2609/#design","title":"Design","text":""},{"location":"docu/WANMgr_Claude_2609/#highlevel-design-principles","title":"High\u2011Level Design Principles","text":"<p>The WAN Manager follows a modular, event-driven architecture built around state machines and policy engines. The design emphasizes separation of concerns where physical Interface Managers handle hardware-specific operations while WAN Manager focuses on higher-level orchestration and business logic. The component supports scalability through configurable interface groups and multiple concurrent state machines, enabling complex multi-WAN scenarios. Security is maintained through controlled TR-181 parameter access and validated configuration changes. Reliability is ensured through robust failover mechanisms, health monitoring, and graceful error handling. The maintainability aspect is addressed through clear module boundaries, comprehensive logging, and standardized IPC mechanisms using RBus for inter-component communication.</p> <p>The architecture supports loose coupling between physical interface management and WAN logic, allowing new interface types to be added without core changes. Policy-based design enables flexible business rules for interface selection and failover behavior. The state machine approach provides predictable behavior and easier debugging of complex network scenarios.</p> <p>Interface boundaries are clearly defined with Interface Managers responsible for physical layer status reporting and basic configuration, while WAN Manager handles all link and IP layer configuration. The data model boundary separates TR-181 parameter management from internal data structures, and IPC boundaries isolate WAN Manager from other RDK-B components through standardized message passing.</p>"},{"location":"docu/WANMgr_Claude_2609/#c4-container-diagram","title":"C4 Container Diagram","text":"<pre><code>graph TD\n    subgraph Runtime [\"Linux/RDK-B Runtime\"]\n        subgraph WanManagerContainer [\"WAN Manager Process\"]\n            Core[Core Engine&lt;br/&gt;Main Loop &amp; Initialization]\n            PolicyEngine[Policy Engine&lt;br/&gt;Selection &amp; Failover Logic]  \n            StateMachine[Interface State Machine&lt;br/&gt;Virtual Interface Management]\n            DataModel[TR-181 Data Model&lt;br/&gt;Configuration &amp; Monitoring]\n            IPC[IPC Handler&lt;br/&gt;RBus Communication]\n        end\n        subgraph ConfigDB [\"Configuration Storage\"]\n            PSM[(PSM Database&lt;br/&gt;Persistent Parameters)]\n            SysEvents[(SysEvents&lt;br/&gt;Runtime Events)]\n        end\n    end\n\n    Core --&gt;|Initialize/Control| PolicyEngine\n    Core --&gt;|Start/Monitor| StateMachine  \n    PolicyEngine --&gt;|Interface Selection| StateMachine\n    StateMachine --&gt;|Status Updates| DataModel\n    DataModel --&gt;|Read/Write| PSM\n    Core --&gt;|System Events| SysEvents\n    IPC --&gt;|External Communication| DataModel\n    IPC --&gt;|Status Reporting| Core\n\n    classDef coreModule fill:#e3f2fd,stroke:#1976d2,stroke-width:2px;\n    classDef policyModule fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;\n    classDef dataModule fill:#e8f5e8,stroke:#388e3c,stroke-width:2px;\n    classDef storage fill:#fff3e0,stroke:#f57c00,stroke-width:2px;\n\n    class Core,StateMachine coreModule;\n    class PolicyEngine policyModule;\n    class DataModel,IPC dataModule;\n    class PSM,SysEvents storage;</code></pre>"},{"location":"docu/WANMgr_Claude_2609/#design-explanation-request-flow","title":"Design Explanation &amp; Request Flow","text":"<ul> <li>Request Flow Sequence: The most critical flow begins when an Interface Manager reports physical layer status via RBus IPC. The WAN Manager Core Engine receives this through the IPC Handler, which updates the internal data model and triggers the Policy Engine. The Policy Engine evaluates current failover rules and interface priorities, potentially selecting a new active interface. If interface switching is needed, the Policy Engine communicates with the Interface State Machine to configure the new virtual interface stack (VLAN, DHCP, routing). The State Machine coordinates with external components (VLAN Manager, DHCP Manager) to establish connectivity, and finally updates TR-181 parameters to reflect the new WAN status.</li> </ul> <pre><code>sequenceDiagram\n    participant IM as Interface Manager\n    participant IPC as IPC Handler\n    participant Core as Core Engine\n    participant Policy as Policy Engine\n    participant SM as State Machine\n    participant VM as VLAN Manager\n    participant DM as DHCP Manager\n\n    IM-&gt;&gt;IPC: Physical Status Update (RBus)\n    IPC-&gt;&gt;Core: Interface Status Change\n    Core-&gt;&gt;Policy: Trigger Policy Evaluation\n    Policy-&gt;&gt;Policy: Evaluate Failover Rules\n    Policy-&gt;&gt;SM: Select New Interface\n    SM-&gt;&gt;VM: Configure VLAN (RBus)\n    VM--&gt;&gt;SM: VLAN Configured\n    SM-&gt;&gt;DM: Start DHCP Client (RBus)\n    DM--&gt;&gt;SM: DHCP Lease Obtained\n    SM-&gt;&gt;Core: Interface Active\n    Core-&gt;&gt;IPC: Update TR-181 Status</code></pre>"},{"location":"docu/WANMgr_Claude_2609/#threading-model","title":"Threading Model","text":"<p>The WAN Manager implements a hybrid threading model combining a main event loop with worker threads for specific tasks. The main thread runs the Policy Controller's state machine in a continuous loop with 500ms polling intervals, handling policy decisions and interface management. Worker threads are created on-demand for IPC communication handling, particularly for RBus message processing and responses to external component requests. The Interface State Machines run within the main thread context but maintain separate state for each virtual interface instance. Background processes are spawned for specific tasks like DHCP client operations and network monitoring. Thread synchronization is handled through data locking mechanisms around shared data structures, ensuring consistent access to interface configuration and status information.</p>"},{"location":"docu/WANMgr_Claude_2609/#internal-modules","title":"Internal Modules","text":"<p>The WAN Manager consists of several key modules that work together to provide comprehensive WAN interface management. The Core Engine handles initialization, main control loops, and coordinates other modules. The Policy Engine implements various selection strategies and failover logic. The Interface State Machine manages virtual interface lifecycle and network stack configuration. The Data Model module provides TR-181 parameter management and external configuration interface. IPC components handle communication with other RDK-B components and Interface Managers. Utility modules provide network operations, system events handling, telemetry, and DHCP client management.</p> Module/Class Description Key Files Core Engine Main initialization, control loop, and module coordination <code>wanmgr_main.c</code>, <code>wanmgr_core.c</code> Policy Controller Implements failover policies and interface selection algorithms <code>wanmgr_controller.c</code>, <code>wanmgr_policy_*_impl.c</code> Interface State Machine Manages virtual interface state and network stack configuration <code>wanmgr_interface_sm.c</code>, <code>wanmgr_interface_sm.h</code> Data Management Internal data structures and WAN interface configuration data <code>wanmgr_data.c</code>, <code>wanmgr_data.h</code> TR-181 Data Model TR-181 parameter implementation and DML APIs <code>wanmgr_dml_*.c</code>, <code>wanmgr_apis.h</code> IPC Handler RBus communication and external component messaging <code>wanmgr_ipc.c</code>, <code>wanmgr_ssp_messagebus_interface.c</code> Network Utilities Network configuration, routing, and utility functions <code>wanmgr_net_utils.c</code>, <code>wanmgr_net_utils.h</code> DHCP Management DHCPv4/v6 client coordination and IP address management <code>wanmgr_dhcpv4_*.c</code>, <code>wanmgr_dhcpv6_*.c</code> System Events System event handling and inter-process notifications <code>wanmgr_sysevents.c</code>, <code>wanmgr_sysevents.h</code> Failover Management WAN failover detection and coordination logic <code>wanmgr_wan_failover.c</code>, <code>wanmgr_wan_failover.h</code> Telemetry Performance monitoring and diagnostic reporting <code>wanmgr_telemetry.c</code>, <code>wanmgr_t2_telemetry.c</code> WebConfig WebConfig protocol support for remote configuration <code>wanmgr_webconfig.c</code>, <code>wanmgr_webconfig_apis.c</code> <pre><code>flowchart TD\n    subgraph WAN_Manager [\"WAN Manager Process\"]\n        Core([Core Engine])\n        Policy([Policy Controller])\n        StateMachine([Interface State Machine])\n        DataMgmt([Data Management])\n        TR181([TR-181 Data Model])\n        IPC([IPC Handler])\n        NetUtils([Network Utilities])\n        DHCP([DHCP Management])\n        SysEvents([System Events])\n        Failover([Failover Management])\n        Telemetry([Telemetry])\n        WebConfig([WebConfig])\n    end\n\n    Core --&gt; Policy\n    Core --&gt; StateMachine\n    Core --&gt; DataMgmt\n    Policy --&gt; StateMachine\n    Policy --&gt; Failover\n    StateMachine --&gt; NetUtils\n    StateMachine --&gt; DHCP\n    TR181 --&gt; DataMgmt\n    IPC --&gt; TR181\n    SysEvents --&gt; Core\n    Telemetry --&gt; DataMgmt\n    WebConfig --&gt; TR181\n\n    classDef coreModule fill:#e3f2fd,stroke:#1976d2,stroke-width:2px;\n    classDef policyModule fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;\n    classDef dataModule fill:#e8f5e8,stroke:#388e3c,stroke-width:2px;\n    classDef networkModule fill:#fff3e0,stroke:#f57c00,stroke-width:2px;\n\n    class Core,StateMachine coreModule;\n    class Policy,Failover policyModule;\n    class DataMgmt,TR181,WebConfig dataModule;\n    class NetUtils,DHCP,IPC,SysEvents,Telemetry networkModule;</code></pre>"},{"location":"docu/WANMgr_Claude_2609/#interaction-with-other-middleware-components","title":"Interaction with Other Middleware Components","text":"<p>The WAN Manager coordinates with multiple RDK-B middleware components to provide comprehensive network management. It communicates with VLAN Manager for virtual LAN configuration, DHCP Manager for IP address assignment, DNS services for name resolution, and Firewall/Router components for traffic routing. Each interaction uses RBus IPC mechanisms with specific message types and data structures. The component also interfaces with TR-181 data model components for parameter management and WebConfig services for remote configuration capabilities.</p> <pre><code>flowchart TD\n    WAN_Manager --&gt;|RBus/Configure VLAN| VLAN_Manager\n    WAN_Manager --&gt;|RBus/DHCP Client Control| DHCP_Manager\n    WAN_Manager --&gt;|RBus/DNS Configuration| DNS_Services\n    WAN_Manager --&gt;|Configuration/Routing Rules| Firewall_Router\n    WAN_Manager --&gt;|RBus/Parameter Updates| TR181_DataModel\n    WAN_Manager --&gt;|WebConfig Protocol| WebConfig_Service</code></pre> Component Purpose of Interaction Protocols/Mechanisms VLAN Manager Configure virtual LAN interfaces for WAN traffic segmentation RBus IPC, VLAN configuration messages DHCP Manager Control DHCP client operations for IP address assignment RBus IPC, DHCP lease management DNS Services Configure DNS servers and resolver settings for WAN interfaces RBus IPC, DNS configuration parameters Firewall/Router Update routing tables and firewall rules for WAN traffic System calls, iptables configuration TR-181 Data Model Synchronize WAN parameters with TR-181 data model RBus IPC, parameter notification messages WebConfig Service Receive remote configuration updates via WebConfig protocol HTTP/HTTPS, JSON configuration data <p>The WAN Manager publishes several key events to notify other components of significant WAN state changes and operational events. These events enable loosely coupled integration and allow other services to react appropriately to WAN interface changes.</p> Event Purpose of Event Reason for trigger <code>wan-status</code> WAN interface status change notification Published when WAN interface transitions between UP/DOWN states <code>wan_service_ready</code> WAN Manager service initialization complete Published when WAN Manager completes startup and is ready to handle requests <code>ipv4_wan_addr_set</code> IPv4 address assignment notification Published when WAN interface successfully obtains IPv4 address via DHCP <code>ipv6_wan_addr_set</code> IPv6 address assignment notification Published when WAN interface successfully obtains IPv6 address via DHCPv6 or SLAAC <code>wan_interface_active</code> Active WAN interface change notification Published when failover policy selects a new active WAN interface <code>dhcp_wan_state_changed</code> DHCP client state change notification Published when DHCP client state machine changes (discover, offer, request, bound)"},{"location":"docu/WANMgr_Claude_2609/#interaction-with-other-layers","title":"Interaction with Other Layers","text":"<p>The WAN Manager integrates across multiple layers of the RDK-B software stack, from application layer management interfaces down to hardware abstraction layers. It receives configuration from web UIs, TR-069 ACS, and cloud management platforms through TR-181 parameters. The component interfaces with HAL layers for hardware-specific network operations and communicates directly with the Linux network stack for routing and interface configuration.</p> Layer/Service Interaction Description Mechanism Web Management UI Receives WAN configuration and policy settings via TR-181 parameters HTTP/TR-181 parameter access TR-069 ACS Remote management and configuration via CWMP protocol TR-069/CWMP parameter management Cloud Management WebConfig-based remote configuration and monitoring HTTPS/WebConfig protocol HAL Layer Hardware-specific network interface operations and status queries HAL API calls, shared libraries Platform Services System event handling, persistent storage, and logging services SysEvents, PSM database, system calls Linux Network Stack Direct network interface configuration, routing table updates Netlink sockets, system calls (ip, ifconfig) <pre><code>graph TD\n    subgraph \"Application Layer\"\n        WebUI[Web Management UI]\n        TR069_ACS[TR-069 ACS]\n        CloudMgmt[Cloud Management]\n    end\n\n    subgraph \"RDK-B Middleware Layer\"\n        WAN_Manager[\ud83d\udce1 WAN Manager]\n        Other_Components[Other RDK-B Components]\n    end\n\n    subgraph \"HAL Layer\"\n        Network_HAL[Network HAL]\n        Platform_HAL[Platform HAL]\n    end\n\n    subgraph \"Linux Kernel/Platform\"\n        NetworkStack[Linux Network Stack]\n        Drivers[Hardware Drivers]\n    end\n\n    subgraph \"Hardware Layer\"\n        DOCSIS_HW[DOCSIS Hardware]\n        ETH_HW[Ethernet Hardware]\n        CELL_HW[Cellular Hardware]\n    end\n\n    WebUI --&gt;|TR-181 Parameters| WAN_Manager\n    TR069_ACS --&gt;|CWMP/TR-069| WAN_Manager\n    CloudMgmt --&gt;|WebConfig API| WAN_Manager\n\n    WAN_Manager --&gt;|RBus/IPC| Other_Components\n    WAN_Manager --&gt;|HAL API Calls| Network_HAL\n    WAN_Manager --&gt;|System Calls| NetworkStack\n\n    Network_HAL --&gt; NetworkStack\n    Platform_HAL --&gt; NetworkStack\n    NetworkStack --&gt; Drivers\n\n    Drivers --&gt; DOCSIS_HW\n    Drivers --&gt; ETH_HW  \n    Drivers --&gt; CELL_HW\n\n    classDef app fill:#e8f5e8,stroke:#388e3c,stroke-width:2px;\n    classDef middleware fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef hal fill:#fff3e0,stroke:#f57c00,stroke-width:2px;\n    classDef system fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;\n    classDef hardware fill:#ffebee,stroke:#d32f2f,stroke-width:2px;\n\n    class WebUI,TR069_ACS,CloudMgmt app;\n    class WAN_Manager,Other_Components middleware;\n    class Network_HAL,Platform_HAL hal;\n    class NetworkStack,Drivers system;\n    class DOCSIS_HW,ETH_HW,CELL_HW hardware;</code></pre>"},{"location":"docu/WANMgr_Claude_2609/#ipc-mechanism","title":"IPC Mechanism","text":"<p>The WAN Manager uses RBus as its primary IPC mechanism for communication with other RDK-B components and Interface Managers. RBus provides a D-Bus based messaging system optimized for RDK environments, supporting both synchronous request-response patterns and asynchronous event notifications.</p> Type of IPC Message Format Mechanism RBus Method Calls JSON-structured method parameters with typed arguments including strings, integers, booleans, and complex objects RBus/D-Bus method invocation with response handling RBus Event Notifications JSON event payloads containing event name, source component, and event-specific data fields RBus publish-subscribe event broadcasting System Events Key-value pairs with event names and string-based parameter values for inter-process notifications SysEvents shared memory and file-based event system WebConfig Protocol JSON configuration documents with versioning, validation, and rollback support for remote management HTTP/HTTPS transport with JSON payload structure <pre><code>sequenceDiagram\n    participant IF as Interface Manager\n    participant WM as WAN Manager  \n    participant VM as VLAN Manager\n    participant DM as DHCP Manager\n    participant SYS as System Events\n\n    IF-&gt;&gt;WM: RBus Method Call&lt;br/&gt;setInterfaceStatus(ifName, UP)\n    WM-&gt;&gt;WM: Process Status Update\n    WM-&gt;&gt;VM: RBus Method Call&lt;br/&gt;configureVLAN(ifName, vlanId, priority)\n    VM--&gt;&gt;WM: RBus Response&lt;br/&gt;(success/failure)\n    WM-&gt;&gt;DM: RBus Method Call&lt;br/&gt;startDHCPClient(ifName, options)\n    DM--&gt;&gt;WM: RBus Response&lt;br/&gt;(clientStarted)\n    WM-&gt;&gt;SYS: SysEvent Publish&lt;br/&gt;wan-status: UP\n    WM-&gt;&gt;WM: RBus Event Publish&lt;br/&gt;wanInterfaceActive(ifName, ipAddr)</code></pre>"},{"location":"docu/WANMgr_Claude_2609/#tr181-data-models","title":"TR\u2011181 Data Models","text":"<p>The WAN Manager implements comprehensive TR-181 data model support for remote management and monitoring. The component provides both standard TR-181 Device.X_RDK_WanManager parameters and custom extensions for RDK-B specific functionality. Parameters are registered through RBus for runtime access and support both read-only status reporting and read-write configuration management.</p> <ul> <li>Implemented Parameters: The WAN Manager implements the Device.X_RDK_WanManager object tree with support for interface configuration, policy management, failover settings, and status monitoring. Parameters include interface enable/disable control, policy selection (Auto WAN, Fixed Mode, Primary Priority), failover timeouts, and interface group configuration.</li> <li>Parameter Registration: Parameters are registered via RBus during startup using the data model XML files (RdkWanManager.xml, RdkWanManager_v2.xml). The registration process creates method handlers for get/set operations and establishes event notification capabilities.</li> <li>Custom Extensions: </li> <li>X_RDK_WanManager.Policy: Custom policy selection parameter supporting Auto WAN, Fixed Mode, Primary Priority, and Parallel Scan modes</li> <li>X_RDK_WanManager.AllowRemoteInterfaces: Custom parameter enabling support for remote interface management in multi-CPE scenarios</li> <li>X_RDK_WanManager.WanFailoverData: Custom JSON data structure for complex failover configuration and coordination between interface groups</li> </ul> Parameter Description Access (R/W) Default Notes <code>Device.X_RDK_WanManager.Enable</code> Master enable/disable for WAN Manager service R/W <code>true</code> Controls WAN Manager operation <code>Device.X_RDK_WanManager.Policy</code> WAN interface selection policy R/W <code>AUTOWAN_MODE</code> Enum: Fixed Mode, Auto WAN, Primary Priority, Parallel Scan <code>Device.X_RDK_WanManager.AllowRemoteInterfaces</code> Enable remote interface management support R/W <code>false</code> For multi-CPE scenarios <code>Device.X_RDK_WanManager.ResetActiveInterface</code> Trigger active interface reset W <code>false</code> Write-only trigger parameter <code>Device.X_RDK_WanManager.RestorationDelay</code> Delay before interface restoration attempts R/W <code>60</code> Seconds, range 10-3600 <code>Device.X_RDK_WanManager.Interface.{i}.Enable</code> Individual interface enable/disable R/W <code>true</code> Per-interface control <code>Device.X_RDK_WanManager.Interface.{i}.Group</code> Interface group assignment R/W <code>1</code> Group number 1-8 <code>Device.X_RDK_WanManager.Interface.{i}.Priority</code> Interface selection priority within group R/W <code>1</code> Lower numbers = higher priority <code>Device.X_RDK_WanManager.Interface.{i}.SelectionTimeOut</code> Interface validation timeout R/W <code>120</code> Seconds, minimum 20 <code>Device.X_RDK_WanManager.Interface.{i}.Status</code> Current interface operational status R <code>Down</code> Enum: Down, Initializing, Up, Error"},{"location":"docu/WANMgr_Claude_2609/#implementation-details","title":"Implementation Details","text":"<ul> <li>Key Algorithms or Logic: </li> <li>Policy State Machines: Core selection algorithms implemented in <code>wanmgr_policy_*_impl.c</code> files using state machine patterns for Auto WAN (sequential interface testing), Primary Priority (priority-based failover), Fixed Mode (single interface operation), and Parallel Scan (concurrent interface validation)</li> <li>Interface State Machine: Virtual interface lifecycle management in <code>wanmgr_interface_sm.c</code> coordinating link layer setup, IP address assignment, route configuration, and connectivity validation through sequential state transitions</li> <li>Failover Detection: Network connectivity monitoring logic in <code>wanmgr_wan_failover.c</code> using periodic connectivity tests, DNS resolution checks, and interface status monitoring to trigger failover decisions</li> <li>Error Handling Strategy: Errors are detected at multiple levels including RBus communication failures, DHCP client failures, and network connectivity issues. All errors are logged via CcspTrace mechanisms with component-specific logging levels. Critical errors trigger appropriate recovery actions such as interface reset, policy re-evaluation, or service restart. Error states are reflected in TR-181 parameters for remote monitoring.</li> <li>Logging &amp; Debugging: The component uses RDK-B standard logging with configurable verbosity levels (Error, Warning, Info, Debug). Log categories include policy decisions, interface state changes, IPC communications, and DHCP operations. Debug logging provides detailed state machine transitions and timing information for troubleshooting connectivity issues.</li> </ul>"},{"location":"docu/WANMgr_Claude_2609/#key-configuration-files","title":"Key Configuration Files","text":"<p>The WAN Manager configuration is primarily data-driven through TR-181 parameters with some build-time configuration through XML data model definitions. The component supports both compile-time feature selection and runtime parameter configuration for maximum flexibility across different deployment scenarios.</p> Configuration File Purpose Key Parameters Default Values Override Mechanisms <code>RdkWanManager.xml</code> TR-181 data model definition for basic WAN Manager functionality <code>Enable</code>, <code>Policy</code>, <code>Interface objects</code> <code>Enable=true</code>, <code>Policy=AUTOWAN_MODE</code> Runtime TR-181 parameter updates <code>RdkWanManager_v2.xml</code> Extended TR-181 data model with enhanced interface management <code>Version</code>, <code>Interface groups</code>, <code>Virtual interface support</code> Enhanced interface table structure Runtime configuration via WebConfig <code>/nvram/wanmanager.conf</code> Persistent configuration storage (if present) Interface priorities, policy settings, timeouts System-dependent defaults Direct file editing, factory reset <code>configure.ac</code> Build-time feature configuration <code>--enable-wanunificationsupport</code>, <code>--enable-gtestapp</code> Feature flags disabled by default Configure script parameters"},{"location":"docu/WANMgr_GPT5_2609/","title":"WAN Manager Documentation","text":"<p>WAN Manager coordinates Wide Area Network interface selection, orchestration, failover, configuration application, TR\u2011181 data model exposure, DHCP lifecycle handling, and policy\u2011driven multi\u2011WAN behavior within the RDK\u2011B stack. It abstracts heterogeneous physical and virtual WAN interfaces (e.g., Ethernet, DSL, Cellular) into a unified policy and status model while integrating with system services (sysevents, webconfig, telemetry, RBUS/CCSP message bus). Upstream it publishes TR\u2011181 parameters / events, downstream it interacts with low\u2011level link states, DHCP clients, and platform capabilities. External control and configuration are applied via WebConfig blobs, TR\u2011181 setters, and IPC triggers.  </p> <ul> <li>Key Features &amp; Responsibilities:  </li> <li>Interface Abstraction &amp; Inventory: Discovers, initializes, and maintains state/data structures for physical and virtual WAN interfaces (dynamic tables, markings, VLAN, PPP attributes).  </li> <li>Policy\u2011Driven Active Interface Selection: Applies AutoWAN / selection timeout and (compiled or legacy) policy implementations to choose the active path and manage group failover.  </li> <li>Failover &amp; Health Monitoring: Monitors operational, link, IPv4/IPv6, DHCP, and policy timers; triggers failover and restoration per configured priorities and timeouts.  </li> <li>TR\u2011181 Data Model Exposure: Implements <code>X_RDK_WanManager.*</code> objects: interface tables, PHY, WAN config, IP, PPP, MAP\u2011T, DHCP aspects, and policy parameters with validation/commit/rollback.  </li> <li>Configuration Ingestion (WebConfig Blobs): Parses and applies WAN marking and failover configuration updates atomically with rollback semantics.  </li> <li>DHCPv4/v6 Lifecycle Handling: Processes DHCP events, updates sysevents, caches IP/gateway/DNS, and updates TR\u2011181 parameter states (lease times, statuses).  </li> <li>IPC &amp; Message Bus Integration: Provides internal IPC server for management commands (interface status, force renew) and integrates with CCSP / RBUS for asynchronous readiness and parameter ops.  </li> <li>Sysevent &amp; System Integration: Publishes and reacts to sysevents (WAN link state, IPv4/IPv6 readiness, firewall restart triggers, LED state) enabling coordinated system behavior.  </li> <li>Telemetry &amp; Observability: Emits telemetry (T2.0 when enabled) and structured logs for operational metrics, errors, and policy transitions.  </li> <li>Security &amp; Capability Dropping: Drops root privileges early; retains only needed Linux capabilities before entering main loop.  </li> </ul>"},{"location":"docu/WANMgr_GPT5_2609/#design","title":"Design","text":""},{"location":"docu/WANMgr_GPT5_2609/#highlevel-design-principles","title":"High\u2011Level Design Principles","text":"<p>WAN Manager emphasizes a modular separation between data model (DML), controller policy logic, interface state machines, and system integration utilities. Each functional region has clear ownership of data allocation, synchronization, and commit semantics. Modularity enables addition of new interface types or policies with minimal core alteration. Scalability is addressed by dynamic tables and list management for interfaces, markings, VLANs, and virtual sub\u2011interfaces (up to defined maxima). Reliability is reinforced via initialization ordering (data \u2192 core \u2192 controller \u2192 policies), rollback handlers for webconfig, and sysevent synchronization. Security is maintained by early privilege dropping and constrained IPC. Maintainability is achieved through layered headers (<code>wanmgr_core.h</code>, <code>wanmgr_data.h</code>, <code>wanmgr_controller.h</code>, DML/IPC segregated APIs) and TR\u2011181 auto\u2011mapping. - Modularity: Core loop invokes policy and state machine ticks; data accessors enforce locking discipline via locked / release pairs. - Scalability: Interface and marking lists support up to MAX_WAN_INTERFACE_ENTRY and dynamic growth for VLAN/Marking nodes. - Reliability: Rollback handlers, sysevent re\u2011init functions for IPv4/IPv6, and watchdog\u2011like readiness gating reduce boot race conditions. - Security: Capability dropping &amp; restricted IPC server minimize process privileges. - Maintainability: Consistent naming (WanMgr prefix) and explicit separation between config data (ConfigData), interface data, and controller policy struct. - Clear Boundaries:   - Data Layer: Structure storage &amp; getters (<code>wanmgr_data.c</code>, <code>wanmgr_dml_apis.c</code>).   - Control/Policy Layer: Policy decisions (<code>wanmgr_controller.c</code>, policy_*_impl.c).   - State Machines / Interface Logic: Link / IP state transitions (<code>wanmgr_interface_sm.c</code>).   - IPC / External Integration: <code>wanmgr_ipc.c</code>, sysevents, telemetry, webconfig, message bus. - Responsibilities:   - Persistence &amp; Config: WebConfig + TR\u2011181 commit propagate into Data Layer.   - Interface Selection: Policy controller orchestrates active/standby &amp; groups.   - IPC &amp; Events: IPC server + sysevents broadcast transitions; telemetry logs instrumentation.</p>"},{"location":"docu/WANMgr_GPT5_2609/#c4-container-diagram","title":"C4 Container Diagram","text":"<pre><code>graph TD\n    subgraph Runtime [\"RDK-B Process Space (Linux Userland)\"]\n        subgraph WanManagerContainer [\"wanmanager Process\"]\n            Core[Core Init &amp; Main Loop\\nwanmgr_core.c / wanmgr_main.c]\n            Controller[Policy Controller\\nwanmgr_controller.c]\n            Policies[Policy Implementations\\nwanmgr_policy_*_impl.c]\n            ISM[Interface State Machine\\nwanmgr_interface_sm.c]\n            DataLayer[Data Mgmt &amp; DML Accessors\\nwanmgr_data.c\\nwanmgr_dml_apis.c]\n            DHCPv4[DHCPv4 Logic\\nwanmgr_dhcpv4_*.c]\n            DHCPv6[DHCPv6 Logic\\nwanmgr_dhcpv6_*.c]\n            IPC[IPC Server\\nwanmgr_ipc.c]\n            WebConfig[Blob Processing\\nwanmgr_webconfig_apis.c]\n            Sysevents[Sysevent Integration\\nwanmgr_sysevents.c]\n            Telemetry[Telemetry &amp; T2\\nwanmgr_telemetry.c\\nwanmgr_t2_telemetry.c]\n            Utils[Net &amp; Common Utils\\nwanmgr_net_utils.c\\nwanmgr_utils.c]\n            Failover[Failover Orchestration\\nwanmgr_wan_failover.c]\n        end\n        subgraph CCSPBus [\"CCSP / RBUS Message Bus\"]\n            DMAPI[TR-181 DM APIs]\n        end\n        subgraph SystemServices [\"Platform Services\"]\n            SysEvent[(syseventd)]\n            DHCPClients[(udhcpc / dhcpv6c)]\n            Firewall[(firewall scripts)]\n            WebCfg[WebConfig Framework]\n            TelemetrySrv[(Telemetry Daemon)]\n        end\n        subgraph KernelSpace [\"Linux Kernel\"]\n            NetIfs[(eth, ppp, vlan, tun)]\n        end\n    end\n    WebCfg --&gt;|Blob JSON| WebConfig\n    CCSPBus --&gt;|Param Get/Set| DataLayer\n    Core --&gt; Controller\n    Controller --&gt; Policies\n    Policies --&gt; Failover\n    ISM --&gt; DataLayer\n    DHCPv4 --&gt; Sysevents\n    DHCPv6 --&gt; Sysevents\n    IPC --&gt; Controller\n    Sysevents --&gt; Firewall\n    SysEvent --&gt; Sysevents\n    NetIfs --&gt; ISM\n    DHCPClients --&gt; DHCPv4\n    DHCPClients --&gt; DHCPv6\n    Telemetry --&gt; TelemetrySrv\n    Core --&gt; IPC\n    WebConfig --&gt; DataLayer</code></pre>"},{"location":"docu/WANMgr_GPT5_2609/#design-explanation-request-flow","title":"Design Explanation &amp; Request Flow","text":"<ul> <li>Request Flow Sequence: Typical configuration apply (WebConfig WAN blob) flows through parsing, interface table matching, marking update, DML commit, refresh flag, and eventual policy re\u2011evaluation. Below is a representative sequence of a WebConfig blob application that results in interface activation and DHCP state update.</li> </ul> <pre><code>sequenceDiagram\n    participant WF as WebConfig Framework\n    participant WC as WebConfig Module&lt;br/&gt;wanmgr_webconfig_apis.c\n    participant Data as Data Layer&lt;br/&gt;wanmgr_data.c\n    participant Policy as Policy Controller&lt;br/&gt;wanmgr_controller.c\n    participant ISM as Interface SM&lt;br/&gt;wanmgr_interface_sm.c\n    participant DHCP4 as DHCPv4 Logic\n    participant SysEv as Sysevents\n    WF-&gt;&gt;WC: Deliver WAN Blob (JSON)\n    WC-&gt;&gt;Data: Match &amp; Update Interface Markings\n    WC-&gt;&gt;Data: Set Refresh Flags / Failover Params\n    WC--&gt;&gt;WF: Status (BLOB_EXEC_SUCCESS)\n    Policy-&gt;&gt;Data: Re-read Config / Timers\n    Policy-&gt;&gt;ISM: Trigger State Evaluation\n    ISM-&gt;&gt;DHCP4: Start/Restart DHCP if needed\n    DHCP4-&gt;&gt;SysEv: Set ipv4_* sysevents\n    SysEv--&gt;&gt;Policy: (async state change callback)\n    Policy--&gt;&gt;WF: (Indirect) New active interface stable</code></pre>"},{"location":"docu/WANMgr_GPT5_2609/#threading-model-if-applicable","title":"Threading Model (if applicable)","text":"<ul> <li>The process starts as a daemon (<code>daemonize()</code>), then enters a main loop via <code>WanMgr_Core_Start()</code> inside the primary thread.  </li> <li>Auxiliary concurrency arises from:  </li> <li>Sysevent callbacks / message bus event handlers (asynchronous invocations).  </li> <li>Potential internal threads spawned by DHCP clients / system services outside the process.  </li> <li>Observed Model: Predominantly single main coordination thread with event\u2011driven callbacks (no explicit worker thread pool defined in provided sources).  </li> <li>Signal handlers registered for graceful termination and diagnostics.  </li> <li>RBUS subscription (if enabled) blocks for readiness signaling before continuing initialization.  </li> </ul>"},{"location":"docu/WANMgr_GPT5_2609/#internal-modules","title":"Internal Modules","text":"Module/Class Description Key Files Core Initialization Bootstraps data, engages message bus, starts main loop <code>wanmgr_main.c</code>, <code>wanmgr_core.c</code> Controller / Policy Ctrl Maintains policy struct, selection timeouts, active interface indices <code>wanmgr_controller.c</code> Policy Implementations Auto, fixed, parallel scan, failover, etc. selection strategies <code>wanmgr_policy_auto_impl.c</code>, <code>wanmgr_policy_parallel_scan_impl.c</code>, <code>wanmgr_policy_fm_impl.c</code>, <code>wanmgr_policy_pp_impl.c</code>, <code>wanmgr_policy_autowan_impl.c</code>, <code>wanmgr_wan_failover.c</code> Data Management Allocation, locking, retrieval of config/interface/virtual iface entities <code>wanmgr_data.c</code>, <code>wanmgr_dml_apis.c</code> Interface State Machine Operational/link/IP status transitions; triggers DHCP and IPv6 toggles <code>wanmgr_interface_sm.c</code> DHCPv4 Handling Lease, DNS, gateway extraction, sysevent updates <code>wanmgr_dhcpv4_apis.c</code>, <code>wanmgr_dhcpv4_internal.c</code>, <code>wanmgr_dhcp_legacy_apis.c</code> DHCPv6 Handling IPv6 prefix/address/state management <code>wanmgr_dhcpv6_apis.c</code>, <code>wanmgr_dhcpv6_internal.c</code> IPC Server Handles client commands (force renew, status set) <code>wanmgr_ipc.c</code>, <code>wanmgr_ipc.h</code> WebConfig Processing Parses WAN blob, updates markings and failover config <code>wanmgr_webconfig_apis.c</code>, <code>wanmgr_webconfig.c</code> Sysevents Integration Publishes and retrieves WAN/IPv4/IPv6 and LED states <code>wanmgr_sysevents.c</code>, <code>wanmgr_sysevents.h</code> Telemetry Emits operational counters and events (T2) <code>wanmgr_telemetry.c</code>, <code>wanmgr_t2_telemetry.c</code> Net Utils Networking helpers (MTU, addressing, interface operations) <code>wanmgr_net_utils.c</code> Common Utils Shared string/time/list utilities, validation helpers <code>wanmgr_utils.c</code> SSP / Message Bus Bridge CCSP message bus interface glue <code>wanmgr_ssp_messagebus_interface.c</code>, <code>wanmgr_ssp_action.c</code> TR\u2011181 DML Middle Layer Interface adaptation, dynamic table operations <code>TR-181/middle_layer_src/*</code>, <code>wanmgr_dml_iface_apis.c</code>, <code>wanmgr_dml_iface_v2_apis.c</code> Marking &amp; VLAN Virtual Ifaces Virtual interface / marking list manipulation <code>wanmgr_data.c</code>, <code>wanmgr_dml_iface_apis.c</code> <pre><code>flowchart TD\n    subgraph WANManager\n        Core[Core]\n        Controller[Controller]\n        Policies[Policies]\n        Data[Data Layer]\n        ISM[Interface SM]\n        DHCP4[DHCPv4]\n        DHCP6[DHCPv6]\n        WebCfg[WebConfig]\n        IPC[IPC]\n        SysEv[Sysevents]\n        Tel[Telemetry]\n        Utils[Utils/Net Utils]\n        Failover[Failover Logic]\n    end\n    Core --&gt; Controller\n    Controller --&gt; Policies\n    Controller --&gt; ISM\n    ISM --&gt; DHCP4\n    ISM --&gt; DHCP6\n    Policies --&gt; Failover\n    WebCfg --&gt; Data\n    Data --&gt; Controller\n    DHCP4 --&gt; SysEv\n    DHCP6 --&gt; SysEv\n    SysEv --&gt; Controller\n    Core --&gt; IPC\n    Tel --&gt; Core</code></pre>"},{"location":"docu/WANMgr_GPT5_2609/#interaction-with-other-middleware-components","title":"Interaction with Other Middleware Components","text":"<pre><code>flowchart TD\n    WANManager --&gt;|CCSP/RBUS Param Ops| ManagementStack[(CCSP Components)]\n    WANManager --&gt;|Sysevent Set/Get| Syseventd[(syseventd)]\n    WANManager --&gt;|WebConfig Blob| WebConfigFW[(WebConfig Framework)]\n    WebConfigFW --&gt;|Blob JSON| WANManager\n    WANManager --&gt;|Telemetry Events| Telemetry[(Telemetry Service)]\n    WANManager --&gt;|Firewall Restart Triggers| Firewall[(Firewall Scripts)]</code></pre> Component Purpose of Interaction Protocols/Mechanisms CCSP / RBUS Bus TR\u2011181 parameter get/set, event subscriptions CCSP Message Bus / RBUS WebConfig Framework Receives WAN blob updates Internal callback + JSON blob parsing syseventd Publish WAN/IP states, LED, firewall triggers Sysevent API DHCP Clients (udhcpc, dhcpv6c) Provide lease, prefix, DNS status Process events / sysevents Telemetry Service Report operational metrics, failovers Telemetry2.0 bus Firewall Scripts Restart on network state changes Sysevent triggers Systemd (optional) Ready notification sd_notify Platform Capability Layer Capability dropping &amp; security Linux capabilities Event Purpose of Event Reason for trigger <code>wan-status</code> Overall WAN state broadcast Interface up/down, failover decision <code>ipv4-up</code> IPv4 stack ready DHCPv4 lease acquired <code>routed-status</code> Routed service status Routing table update / link change <code>firewall-restart</code> Firewall refresh WAN reconfiguration or address change <code>wan-restart</code> Reinitialize WAN flow Policy or config change <code>rdkb_wan_status</code> LED update for UI hardware Link/operational state transitions <code>dhcp_server-restart</code> DHCP server reinit downstream WAN addressing changes <code>radvd_restart</code> IPv6 RA daemon restart Prefix / IPv6 config modifications <code>lan-prefix_set</code> / <code>lan_prefix_clear</code> Global IPv6 prefix state DHCPv6 prefix / route events"},{"location":"docu/WANMgr_GPT5_2609/#interaction-with-other-layers","title":"Interaction with Other Layers","text":"Layer/Service Interaction Description Mechanism HAL Indirect link/PHY stats via lower data model layers Through TR\u2011181 middle-layer &amp; bus Platform (Sysevent / System Scripts) State propagation, service restarts, LED indications Sysevent API, system scripts External (DHCP, Telemetry, WebConfig) Configuration ingestion &amp; status export JSON blobs, telemetry bus, sysevent <pre><code>graph TD\n    HAL[(Hardware / HAL Drivers)] --&gt; DML[TR-181 DML Middle Layer]\n    DML --&gt; WANMGR[WAN Manager]\n    WANMGR --&gt; Sysev[(Sysevent / Scripts)]\n    Sysev --&gt; Platform[(Platform Services)]\n    WANMGR --&gt; WebCfgFW[(WebConfig)]\n    WANMGR --&gt; Telemetry[(Telemetry Bus)]\n    Platform --&gt; External[(Operational Network)]</code></pre>"},{"location":"docu/WANMgr_GPT5_2609/#ipc-mechanism","title":"IPC Mechanism","text":"Type of IPC Message Format Mechanism Internal IPC Server Structured message types (e.g., interface status, DHCP renew commands) Custom IPC (<code>wanmgr_ipc.c</code>, sockets / message abstraction via <code>ipc_msg.h</code>) Sysevents Key/value pairs (status strings, IPv4/IPv6 params) syseventd API CCSP/RBUS Parameter operations &amp; events (TR\u2011181) CCSP message bus / RBUS WebConfig Blob JSON / (binary safe char* with parsed structures) WebConfig framework callback Telemetry Key/value event / counter messages Telemetry2.0 API Systemd Notify (optional) Status strings sd_notify <pre><code>sequenceDiagram\n    participant Client as Mgmt Client\n    participant IPC as IPC Server\n    participant Ctrl as Controller\n    participant Data as Data Layer\n    participant SysEv as Sysevents\n    Client-&gt;&gt;IPC: SetInterfaceStatus(ifName, state)\n    IPC-&gt;&gt;Ctrl: Dispatch Command\n    Ctrl-&gt;&gt;Data: Update Interface State\n    Ctrl-&gt;&gt;SysEv: Update wan-status / ipv4-up\n    SysEv--&gt;&gt;Ctrl: Async state callback\n    Ctrl--&gt;&gt;Client: ACK (status)</code></pre>"},{"location":"docu/WANMgr_GPT5_2609/#tr181-data-models","title":"TR\u2011181 Data Models","text":"<ul> <li>Implemented Parameters (selected core set from <code>X_RDK_WanManager</code> tree):  </li> <li><code>X_RDK_WanManager.Enable</code> (bool) \u2013 master enable.  </li> <li><code>X_RDK_WanManager.Policy</code> (mapped) \u2013 active selection/failover strategy (Fixed, PrimaryPriority, MultiWAN, AutoWAN, Parallel Scan).  </li> <li><code>X_RDK_WanManager.AllowRemoteInterfaces</code> (bool) \u2013 remote CPE interface inclusion.  </li> <li><code>X_RDK_WanManager.ResetActiveInterface</code> (bool) \u2013 forces active interface reset.  </li> <li><code>X_RDK_WanManager.RestorationDelay</code> (uint) \u2013 failback timing.  </li> <li><code>X_RDK_WanManager.WanFailoverData</code> (string) \u2013 serialized failover configuration.  </li> <li><code>X_RDK_WanManager.DnsConnectivityCheck.Enable</code> (bool) \u2013 enable DNS health check.  </li> <li><code>X_RDK_WanManager.CPEInterface.{i}.Name</code> / <code>DisplayName</code> \u2013 interface identification.  </li> <li><code>X_RDK_WanManager.CPEInterface.{i}.Wan.SelectionTimeout</code> \u2013 interface selection window.  </li> <li><code>X_RDK_WanManager.CPEInterface.{i}.Wan.EnableDHCP</code> (bool).  </li> <li><code>X_RDK_WanManager.CPEInterface.{i}.Wan.EnableIPoEHealthCheck</code> (bool).  </li> <li><code>X_RDK_WanManager.CPEInterface.{i}.Wan.Group</code> (uint) \u2013 grouping for policies.  </li> <li><code>X_RDK_WanManager.CPEInterface.{i}.IP.IPv4Status</code> / <code>IPv6Status</code>.  </li> <li><code>X_RDK_WanManager.CPEInterface.{i}.PPP.Enable</code> and IPCP/IPv6CP status flags.  </li> <li>Marking table entries (alias, ethernetPriorityMark).  </li> <li>Parameter Registration: Handlers mapped in <code>RdkWanManager.xml</code> referencing <code>WanManager_*</code>, <code>WanIf_*</code>, <code>WanIfCfg_*</code>, <code>WanIfPhy_*</code>, <code>WanIfIpCfg_*</code>, <code>WanIfPPPCfg_*</code> functions; dynamic tables support commit/rollback. Exposed via CCSP/RBUS to management layers.  </li> <li>Custom Extensions:  </li> <li><code>X_RDK_WanManager.Policy</code> mapped enumerations for advanced multi\u2011WAN strategies.  </li> <li>Marking table under each interface enabling QoS / priority tagging (<code>markingTable</code> alias\u2192priority).  </li> <li>MAP\u2011T / DS-Lite enabling booleans for IPv4 transition technologies.  </li> </ul> Parameter Description Access (R/W) Default Notes <code>X_RDK_WanManager.Enable</code> Global enable for WAN Manager R/W Implementation default true Drives init/selection logic <code>X_RDK_WanManager.Policy</code> Active policy enumeration R/W* Device specific May be readonly via compile flag <code>X_RDK_WanManager.AllowRemoteInterfaces</code> Accept remote interfaces R/W false Updated via WebConfig blob <code>X_RDK_WanManager.RestorationDelay</code> Failback delay (sec) R/W Platform default Used in auto failover <code>X_RDK_WanManager.CPEInterface.{i}.Wan.SelectionTimeout</code> Selection timeout R/W &gt;=20 Enforced min 20 <code>X_RDK_WanManager.CPEInterface.{i}.Wan.EnableDHCP</code> DHCP enable toggle R/W true Affects DHCP logic <code>X_RDK_WanManager.CPEInterface.{i}.IP.IPv4Status</code> IPv4 link status R/W Down Updated via DHCP events <code>X_RDK_WanManager.CPEInterface.{i}.PPP.Enable</code> PPP session enable R/W false PPP use cases <code>X_RDK_WanManager.CPEInterface.{i}.Marking.{j}.Alias</code> Traffic marking alias R/W \"DATA\" Adjusted by blob <code>X_RDK_WanManager.CPEInterface.{i}.Marking.{j}.EthernetPriorityMark</code> VLAN PCP/priority mark R/W 0 QoS classification"},{"location":"docu/WANMgr_GPT5_2609/#implementation-details","title":"Implementation Details","text":"<ul> <li>Key Algorithms or Logic:  </li> <li>Policy Evaluation: <code>WanMgr_Policy_AutoWan*</code> examines interface operational state, group membership, and selection timeout windows to transition active/standby roles.  </li> <li>Interface State Machine: Monitors sysevent link status and DHCP progress to promote interface states (Initializing\u2192Up\u2192Standby/Operational).  </li> <li>WebConfig Apply: For each interface entry, aligns or creates marking entries and sets refresh flags causing re\u2011evaluation; includes update vs. insertion logic with alias collision handling.  </li> <li>DHCP Handling: Extracts DNS, gateway, lease parameters, updates sysevents and TR\u2011181 IP statuses, triggers firewall restart if necessary.  </li> <li>Failover Logic: Observes link/operational/dhcpv4/6 statuses and restoration timers to decide switching with minimal disruption.  </li> <li>Main files: Policy logic (<code>wanmgr_policy_*</code>), core loop (<code>wanmgr_core.c</code>), data access &amp; list building (<code>wanmgr_data.c</code>), DHCP transitions (<code>wanmgr_dhcpv4_internal.c</code>, <code>wanmgr_dhcpv6_internal.c</code>), blob processing (<code>wanmgr_webconfig_apis.c</code>).  </li> <li>Error Handling Strategy: Functions return <code>ANSC_STATUS</code> or allocate <code>pErr</code> with error codes for blob processing; logging macros (<code>CcspTraceError</code>, <code>CcspTraceInfo</code>) annotate failures; rollback handlers for config apply (<code>WanMgr_WanData_Rollback_Handler</code>); state initialization functions reset sysevents to known baselines.  </li> <li>Logging &amp; Debugging: Uses CCSP trace categories; process writes version &amp; PID to <code>/var/tmp/wanmanager.pid</code>; optional stack traces on signals; telemetry events for runtime readiness; debug gating via <code>/etc/debug.ini</code>.</li> </ul>"},{"location":"docu/WANMgr_GPT5_2609/#key-configuration-files","title":"Key Configuration Files","text":"Configuration File Purpose Key Parameters Default Values Override Mechanisms <code>config/RdkWanManager.xml</code> TR\u2011181 data model object &amp; parameter mapping Objects: <code>X_RDK_WanManager</code>, <code>CPEInterface</code>, nested <code>Wan</code>, <code>IP</code>, <code>PPP</code>, Marking Versioned schema Build-time, XML edit, WebConfig / TR\u2011181 set <code>config/RdkWanManager_v2.xml</code> (If present) Updated/extended data model variant Same domains + potential v2 enhancements Depends on version Deployment selection WebConfig Blob (WAN) Runtime applied interface + marking config Failover data, markingTable entries Supplied by controller WebConfig distribution Sysevents (runtime keys) Operational dynamic state store <code>wan-status</code>, <code>ipv4_*</code>, <code>routed-status</code>, LED states N/A (ephemeral) Updated by code <code>/etc/debug.ini</code> Logging configuration Trace modules, log levels Platform default File edit Capability / Security (implicit) Capabilities list for process Dropped root caps N/A Build flags"},{"location":"docu/doc_template_mod_2609/","title":"[COMPONENT_NAME] Documentation","text":"<p>[Describe what the component does and why it exists in RDK-B stack in no more than 5-6 sentences. Explain how it fits into the overall RDK\u2011B platform, including upstream/downstream interactions. Add a C4 System Context Diagram to explain how this fits into whole system architecture architecture]</p> <ul> <li>Key Features &amp; Responsibilities: [List major functions, services provided, and responsibilities. Keep it as a bullet point list. Keep the main point as BOLD text formatting and then explain in a sentence or maximum two on what that point is about]</li> </ul>"},{"location":"docu/doc_template_mod_2609/#design","title":"Design","text":""},{"location":"docu/doc_template_mod_2609/#highlevel-design-principles","title":"High\u2011Level Design Principles","text":"<ul> <li>[Explain the high level design principles in a paragrpah of 5-6 sentences. After that, describe guiding principles such as modularity, scalability, reliability, security, and maintainability as applicable. Add two sentences at max for each of these]</li> <li>[Discuss how design choices support these principles.]</li> <li>[Define clear boundaries between this component and others.]</li> <li>[Identify responsibilities for each boundary (e.g., data persistence, interface management, IPC).]</li> </ul>"},{"location":"docu/doc_template_mod_2609/#c4-container-diagram","title":"C4 Container Diagram","text":"<pre><code>graph TD\n    subgraph Runtime [\"[CONTAINER_RUNTIME] [VERSION]\"]\n        subgraph [COMPONENT_NAME]Container [\"[COMPONENT_NAME] Container\"]\n            ModuleA[Module A]\n\"Purpose\"\n            ModuleB[Module B]\n\"Purpose\"\n        end\n        subgraph Database [\"[DATABASE_TYPE] [VERSION]\"]\n            DB[(Database)]\n        end\n    end\n    ModuleA --&gt;|API Call| ModuleB\n    ModuleB --&gt;|Read/Write| DB</code></pre>"},{"location":"docu/doc_template_mod_2609/#design-explanation-request-flow","title":"Design Explanation &amp; Request Flow","text":"<ul> <li>Request Flow Sequence: [Describe the most critical flow supported by the component. Use sequence diagrams if helpful.]</li> </ul>"},{"location":"docu/doc_template_mod_2609/#threading-model-if-applicable","title":"Threading Model (if applicable)","text":"<ul> <li>[Explain how concurrency is handled, including thread pools, event loops, or asynchronous paradigms. If it is a single threaded model, mention it is a single threaded application. If worker threads are created and closed on demand, call out that separately. If it is multi threaded model, mention what each threads does in a bullet pointed list]</li> </ul>"},{"location":"docu/doc_template_mod_2609/#internal-modules","title":"Internal Modules","text":"<p>[Explain in simple terms what each module within the component is expected to do. If any of those modules are receiveing data from outside, call that out separately]</p> Module/Class Description Key Files [MODULE_1] [Brief description of module\u2019s role] <code>[file1.c]</code>, <code>[file2.h]</code> [MODULE_2] [Brief description of module\u2019s role] <code>[file3.cpp]</code> <p>[Create a simple  mermaid based module breakdown diagram explaining the different sub modules in this component]</p> <pre><code>flowchart TD\n    subgraph [COMPONENT_NAME]\n        Mod1([MODULE_1])\n        Mod2([MODULE_2])\n        Mod3([MODULE_3])\n    end\n    Mod1 --&gt; Mod2\n    Mod2 --&gt; Mod3</code></pre>"},{"location":"docu/doc_template_mod_2609/#interaction-with-other-middleware-components","title":"Interaction with Other Middleware Components","text":"<p>[Explain in simple terms what is the interaction with each external module expected to do, for e.g. like data model calls or telemetry event postings]</p> <pre><code>flowchart TD\n    [COMPONENT_NAME] --&gt;|DBus| [RDKB_COMPONENT_1]\n    [COMPONENT_NAME] --&gt;|HTTP POST /upload| [RDKB_COMPONENT_2]</code></pre> Component Purpose of Interaction Protocols/Mechanisms [RDKB_COMPONENT_1] [Reason for communication] [e.g., DBus, HTTP, gRPC] [RDKB_COMPONENT_2] [Reason for communication] [e.g., Sockets, Shared Memory] <p>[Explain in simple terms what are the events posted or broadcasted or published by this component and a possible description on what is the event and when is it published]</p> Event Purpose of Event Reason for trigger [Event_1] [Reason for trigger] [Reason for trigger e.g. completed initialization, detected new wifi device connected] [Event_2] [Reason for trigger] [Reason for trigger e.g. completed initialization, detected new wifi device connected]"},{"location":"docu/doc_template_mod_2609/#interaction-with-other-layers","title":"Interaction with Other Layers","text":"<p>[Describe how the component interacts with HAL, platform\u2011specific layers, or external services. Mention abstraction and layering.]</p> Layer/Service Interaction Description Mechanism HAL [Description] [DBus, API call] Platform [Description] [Sockets, shared memory] External [Description] [Protocol] <p>[Create a detailed layered architecture view that will help to show where this component belongs to in its layer, as well as how it interacts with other layers in software stack]</p> <pre><code>graph TD\n    HAL[(HAL Layer)] --&gt; [COMPONENT_NAME]\n    [COMPONENT_NAME] --&gt; Platform[(Platform Layer)]\n    Platform --&gt; External[(External Service)]</code></pre>"},{"location":"docu/doc_template_mod_2609/#ipc-mechanism","title":"IPC Mechanism","text":"Type of IPC Message Format Mechanism [e.g., DBus, message queues, Unix sockets, shared memory] [Describe the structure, encoding (JSON, Protobuf, custom binary), and key fields] [e.g.,DBus, API call,Sockets, shared memory,Protocol] <p>[Create a detailed IPC Flow Diagram that will help to show how the interaction between components]</p> <pre><code>sequenceDiagram\n    participant Caller as Caller\n    participant Component as [COMPONENT_NAME]\n    participant Service as RDKB_COMPONENT_1\n\n    Caller-&gt;&gt;Component: IPC Request (method, params)\n    Component-&gt;&gt;Service: IPC Forward (message)\n    Service--&gt;&gt;Component: IPC Response (result)\n    Component--&gt;&gt;Caller: Result</code></pre>"},{"location":"docu/doc_template_mod_2609/#tr181-data-models","title":"TR\u2011181 Data Models","text":"<ul> <li>Implemented Parameters: [List TR\u2011181 parameters implemented by this component. Include descriptions and default values.]</li> <li>Parameter Registration: [Explain how parameters are registered and accessed (e.g., via RBus, DBus).]</li> <li>Custom Extensions: [Detail in a bullet pointed list on any custom TR\u2011181 objects or parameters.Give one sentence each on what is the custom extension about]</li> </ul> <p>[Include all the parameters that are part of the 'Implemented Parameters' section given above]</p> Parameter Description Access (R/W) Default Notes <code>Device.DeviceInfo.Manufacturer</code> Manufacturer name R \"\" Standard <code>Device.Custom.Namespace.Param</code> Custom parameter R/W <code>0</code> Custom"},{"location":"docu/doc_template_mod_2609/#implementation-details","title":"Implementation Details","text":"<ul> <li>Key Algorithms or Logic: [Describe core algorithms, scheduling logic, state machines, or data transformations, and mention the main file/ files where the logic resides.]</li> <li>Error Handling Strategy: [Explain how errors are detected, logged, and propagated.]</li> <li>Logging &amp; Debugging: [Describe logging categories, verbosity levels, and debug tools or hooks.]</li> </ul>"},{"location":"docu/doc_template_mod_2609/#key-configuration-files","title":"Key Configuration Files","text":"<p>[Describe the key configuration files and their respective data]</p> Configuration File Purpose Key Parameters Default Values Override Mechanisms <code>config.ini</code> Main config <code>Param1</code>, <code>Param2</code> <code>true</code>, <code>10</code> Environment variables <code>tr181.xml</code> TR\u2011181 definitions <code>...</code> N/A N/A"},{"location":"docu/doc_template_orig_rama/","title":"[COMPONENT_NAME] Documentation","text":""},{"location":"docu/doc_template_orig_rama/#1-overview","title":"1. Overview","text":"<ul> <li>Purpose in RDK\u2011B Stack: [Describe what the component does and why it exists.]</li> <li>Key Features &amp; Responsibilities: [List major functions, services provided, and responsibilities.]</li> <li>Role in Broadband Router Architecture: [Explain how it fits into the overall RDK\u2011B platform, including upstream/downstream interactions.]</li> </ul>"},{"location":"docu/doc_template_orig_rama/#2-architecture-design","title":"2. Architecture / Design","text":""},{"location":"docu/doc_template_orig_rama/#21-highlevel-design-principles","title":"2.1 High\u2011Level Design Principles","text":"<ul> <li>[Describe guiding principles such as modularity, scalability, reliability, security, and maintainability.]</li> <li>[Discuss how design choices support these principles.]</li> </ul>"},{"location":"docu/doc_template_orig_rama/#22-component-boundaries-responsibilities","title":"2.2 Component Boundaries &amp; Responsibilities","text":"<ul> <li>[Define clear boundaries between this component and others.]</li> <li>[Identify responsibilities for each boundary (e.g., data persistence, interface management, IPC).]</li> </ul>"},{"location":"docu/doc_template_orig_rama/#23-threading-model-if-applicable","title":"2.3 Threading Model (if applicable)","text":"<ul> <li>[Explain how concurrency is handled, including thread pools, event loops, or asynchronous paradigms.]</li> </ul>"},{"location":"docu/doc_template_orig_rama/#24-c4-system-context-diagram","title":"2.4 C4 System Context Diagram","text":"<pre><code>graph TD\n    %% Replace the nodes below with actual actors and systems\n    User[\ud83d\udc64 User] --&gt;|Protocol| [COMPONENT_NAME]\n    [COMPONENT_NAME] --&gt;|Protocol| ExternalService[\ud83d\udce1 External Service]\n    subgraph \"[COMPONENT_NAME]\"\n        ComponentCore[\ud83d\udd27 Core Functions]\n[[RESPONSIBILITY_1], [RESPONSIBILITY_2]]\n    end</code></pre>"},{"location":"docu/doc_template_orig_rama/#25-c4-container-diagram","title":"2.5 C4 Container Diagram","text":"<pre><code>graph TD\n    subgraph Runtime [\"[CONTAINER_RUNTIME] [VERSION]\"]\n        subgraph [COMPONENT_NAME]Container [\"[COMPONENT_NAME] Container\"]\n            ModuleA[Module A]\n\"Purpose\"\n            ModuleB[Module B]\n\"Purpose\"\n        end\n        subgraph Database [\"[DATABASE_TYPE] [VERSION]\"]\n            DB[(Database)]\n        end\n    end\n    ModuleA --&gt;|API Call| ModuleB\n    ModuleB --&gt;|Read/Write| DB</code></pre>"},{"location":"docu/doc_template_orig_rama/#26-design-explanation-request-flow","title":"2.6 Design Explanation &amp; Request Flow","text":"<ul> <li>Request Flow Sequence: [Describe the most critical flow supported by the component. Use sequence diagrams if helpful.]</li> <li>Technology Stack: List languages, frameworks, databases, cache, message queues, and other tools with versions.</li> </ul>"},{"location":"docu/doc_template_orig_rama/#3-internal-modules","title":"3. Internal Modules","text":"Module/Class Description Key Files [MODULE_1] [Brief description of module\u2019s role] <code>[file1.c]</code>, <code>[file2.h]</code> [MODULE_2] [Brief description of module\u2019s role] <code>[file3.cpp]</code>"},{"location":"docu/doc_template_orig_rama/#31-module-breakdown-diagram","title":"3.1 Module Breakdown Diagram","text":"<pre><code>flowchart TD\n    subgraph [COMPONENT_NAME]\n        Mod1([MODULE_1])\n        Mod2([MODULE_2])\n        Mod3([MODULE_3])\n    end\n    Mod1 --&gt; Mod2\n    Mod2 --&gt; Mod3</code></pre>"},{"location":"docu/doc_template_orig_rama/#4-interaction-with-other-middleware-components","title":"4. Interaction with Other Middleware Components","text":"Component Purpose of Interaction Protocols/Mechanisms [RDKB_COMPONENT_1] [Reason for communication] [e.g., DBus, HTTP, gRPC] [RDKB_COMPONENT_2] [Reason for communication] [e.g., Sockets, Shared Memory]"},{"location":"docu/doc_template_orig_rama/#41-middleware-interaction-diagram","title":"4.1 Middleware Interaction Diagram","text":"<pre><code>flowchart TD\n    [COMPONENT_NAME] --&gt;|DBus| [RDKB_COMPONENT_1]\n    [COMPONENT_NAME] --&gt;|HTTP POST /upload| [RDKB_COMPONENT_2]</code></pre>"},{"location":"docu/doc_template_orig_rama/#5-interaction-with-other-layers","title":"5. Interaction with Other Layers","text":"<p>Describe how the component interacts with HAL, platform\u2011specific layers, or external services. Mention abstraction and layering.</p> Layer/Service Interaction Description Mechanism HAL [Description] [DBus, API call] Platform [Description] [Sockets, shared memory] External [Description] [Protocol]"},{"location":"docu/doc_template_orig_rama/#51-layered-architecture-view","title":"5.1 Layered Architecture View","text":"<pre><code>graph TD\n    HAL[(HAL Layer)] --&gt; [COMPONENT_NAME]\n    [COMPONENT_NAME] --&gt; Platform[(Platform Layer)]\n    Platform --&gt; External[(External Service)]</code></pre>"},{"location":"docu/doc_template_orig_rama/#6-ipc-mechanism","title":"6. IPC Mechanism","text":"<ul> <li>Type of IPC: [e.g., DBus, message queues, Unix sockets, shared memory]</li> <li>Message Format: [Describe the structure, encoding (JSON, Protobuf, custom binary), and key fields]</li> <li>Flow: [Describe message flow directions: synchronous vs asynchronous, request/response vs publish/subscribe]</li> </ul>"},{"location":"docu/doc_template_orig_rama/#61-ipc-flow-diagram","title":"6.1 IPC Flow Diagram","text":"<pre><code>sequenceDiagram\n    participant Caller as Caller\n    participant Component as [COMPONENT_NAME]\n    participant Service as RDKB_COMPONENT_1\n\n    Caller-&gt;&gt;Component: IPC Request (method, params)\n    Component-&gt;&gt;Service: IPC Forward (message)\n    Service--&gt;&gt;Component: IPC Response (result)\n    Component--&gt;&gt;Caller: Result</code></pre>"},{"location":"docu/doc_template_orig_rama/#7-tr181-data-models","title":"7. TR\u2011181 Data Models","text":"<ul> <li>Implemented Parameters: [List TR\u2011181 parameters implemented by this component. Include descriptions and default values.]</li> <li>Parameter Registration: [Explain how parameters are registered and accessed (e.g., via RBus, DBus).]</li> <li>Custom Extensions: [Detail any custom TR\u2011181 objects or parameters.]</li> </ul>"},{"location":"docu/doc_template_orig_rama/#71-tr181-parameter-table","title":"7.1 TR\u2011181 Parameter Table","text":"Parameter Description Access (R/W) Default Notes <code>Device.DeviceInfo.Manufacturer</code> Manufacturer name R \"\" Standard <code>Device.Custom.Namespace.Param</code> Custom parameter R/W <code>0</code> Custom"},{"location":"docu/doc_template_orig_rama/#8-implementation-details","title":"8. Implementation Details","text":"<ul> <li>Key Algorithms or Logic: [Describe core algorithms, scheduling logic, state machines, or data transformations.]</li> <li>Error Handling Strategy: [Explain how errors are detected, logged, and propagated.]</li> <li>Logging &amp; Debugging: [Describe logging categories, verbosity levels, and debug tools or hooks.]</li> </ul>"},{"location":"docu/doc_template_orig_rama/#9-key-configuration-files","title":"9. Key Configuration Files","text":"Configuration File Purpose Key Parameters Default Values Override Mechanisms <code>config.ini</code> Main config <code>Param1</code>, <code>Param2</code> <code>true</code>, <code>10</code> Environment variables <code>tr181.xml</code> TR\u2011181 definitions <code>...</code> N/A N/A"},{"location":"docu/doc_template_orig_rama/#10-api-endpoints-if-applicable","title":"10. API Endpoints (if applicable)","text":"Method Endpoint Description Auth Returns GET <code>/status</code> Returns health and status None JSON POST <code>/config</code> Updates configuration Token Success/failure"},{"location":"docu/doc_template_orig_rama/#11-deployment-runtime-environment","title":"11. Deployment &amp; Runtime Environment","text":"<ul> <li>Container Runtime: [Docker, Podman, etc.]</li> <li>Orchestration: [Systemd, Kubernetes, etc.]</li> <li>Resource Requirements: [CPU, memory, disk storage]</li> <li>Supported Platforms: [Hardware or firmware versions]</li> <li>Startup Parameters: [Command\u2011line arguments, environment variables]</li> </ul>"},{"location":"docu/doc_template_orig_rama/#12-monitoring-security","title":"12. Monitoring &amp; Security","text":"<ul> <li>Monitoring: [Metrics collected, logging targets, alert thresholds]</li> <li>Authentication &amp; Authorization: [Mechanisms used, supported encryption, key management]</li> <li>Auditing &amp; Compliance: [Any compliance requirements like GDPR, HIPAA]</li> </ul>"},{"location":"docu/doc_template_orig_rama/#13-validation-review-checklist","title":"13. Validation &amp; Review Checklist","text":"<ul> <li>[ ] Deployment Accuracy: Diagrams match actual container/process deployment.</li> <li>[ ] Communication Specificity: Protocols and directions are correctly labeled.</li> <li>[ ] Scaling Representation: Diagrams show what scales together vs independently.</li> <li>[ ] Technology Versions: Actual versions are documented.</li> <li>[ ] Implementation Details: Filenames, data formats, and logic are included.</li> <li>[ ] Visual Hierarchy: Colors and shapes consistently represent component types.</li> <li>[ ] Protocol Labels: Connection labels are descriptive and free of line breaks.</li> <li>[ ] Mermaid Syntax: Diagrams render without errors (use proper identifiers and quoting).</li> <li>[ ] TR\u2011181 Coverage: All relevant TR\u2011181 parameters are documented.</li> <li>[ ] Code Accuracy: Configuration keys, module names, and function calls are correct.</li> </ul>"},{"location":"docu/doc_template_orig_rama/#14-conclusion-next-steps","title":"14. Conclusion &amp; Next Steps","text":"<p>Summarize the component\u2019s role and its importance within RDK\u2011B. Describe any planned changes or future enhancements. Provide references to related documents, code repositories, and support channels.</p> <p>This template combines high\u2011level architectural context with deep technical details for RDK\u2011B components. It serves as a single source of truth for developers, architects, operators, and business stakeholders alike.</p>"},{"location":"docu/bhanu/pnm_claude/","title":"CcspPandM Documentation","text":""},{"location":"docu/bhanu/pnm_claude/#1-overview","title":"1. Overview","text":"<ul> <li> <p>Purpose in RDK-B Stack: CcspPandM (Provisioning and Management Sub-System) is a critical component in the RDK-B stack that manages device configuration, provisioning, and parameter management using the TR-181 data model. It serves as the central management interface for the device's configuration and operational parameters.</p> </li> <li> <p>Key Features &amp; Responsibilities:</p> </li> <li>Implements TR-181 data model for device configuration</li> <li>Provides parameter management (Get/Set operations)</li> <li>Handles device provisioning and configuration</li> <li>Manages inter-process communication for parameter access</li> <li>Supports device information management</li> <li> <p>Integrates with WebConfig for remote configuration</p> </li> <li> <p>Role in Broadband Router Architecture: CcspPandM acts as the bridge between various RDK-B components and device configuration. It provides a standardized interface for managing device parameters, enabling other components to access and modify device settings through a unified TR-181 data model.</p> </li> </ul>"},{"location":"docu/bhanu/pnm_claude/#2-architecture-design","title":"2. Architecture / Design","text":""},{"location":"docu/bhanu/pnm_claude/#21-high-level-design-principles","title":"2.1 High-Level Design Principles","text":"<ul> <li>Modularity: Component is structured into distinct modules (PandMSsp, TR-181 handlers, custom implementations)</li> <li>Standardization: Follows TR-181 data model specification for parameter management</li> <li>Scalability: Supports dynamic parameter registration and management</li> <li>Reliability: Implements robust error handling and validation</li> <li>Extensibility: Allows custom TR-181 parameter implementations</li> </ul>"},{"location":"docu/bhanu/pnm_claude/#22-component-boundaries-responsibilities","title":"2.2 Component Boundaries &amp; Responsibilities","text":"<ul> <li>Parameter Management:</li> <li>TR-181 parameter registration and access</li> <li>Parameter value validation and storage</li> <li> <p>Change notification handling</p> </li> <li> <p>IPC Interface:</p> </li> <li>DBus/RBus message handling</li> <li>Parameter access request processing</li> <li> <p>Event notification dispatch</p> </li> <li> <p>Device Configuration:</p> </li> <li>Configuration file management</li> <li>WebConfig integration</li> <li>Boot-time initialization</li> </ul>"},{"location":"docu/bhanu/pnm_claude/#23-threading-model","title":"2.3 Threading Model","text":"<ul> <li>Main thread handles message bus operations</li> <li>Separate threads for:</li> <li>Parameter processing</li> <li>Event handling</li> <li>WebConfig operations</li> <li>Background tasks</li> </ul>"},{"location":"docu/bhanu/pnm_claude/#24-c4-system-context-diagram","title":"2.4 C4 System Context Diagram","text":"<pre><code>graph TD\n    classDef user fill:#fff3e0,stroke:#ef6c00,stroke-width:2px\n    classDef component fill:#e1f5fe,stroke:#0277bd,stroke-width:2px\n    classDef external fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px\n\n    Webconfig((WebConfig)):::external\n    TR69Agent((TR-69 Agent)):::external\n    OtherComps[Other RDK-B Components]:::user\n\n    subgraph CcspPandM [CcspPandM]\n        PandM[Parameter Management]:::component\n        TR181[TR-181 Handler]:::component\n    end\n\n    Webconfig --&gt;|Config Updates| PandM\n    TR69Agent --&gt;|Parameter Requests| PandM\n    OtherComps --&gt;|Get/Set Parameters| PandM\n    PandM --&gt;|Parameter Data| TR181</code></pre>"},{"location":"docu/bhanu/pnm_claude/#25-container-diagram","title":"2.5 Container Diagram","text":"<pre><code>graph TD\n    classDef runtime fill:#e3f2fd,stroke:#1565c0,stroke-width:2px\n\n    subgraph CcspPandM [\"CcspPandM Runtime (C/C++)\"]\n        PandMSsp[PandMSsp Service]\n        TR181Handler[TR-181 Handler]\n        IpcHandler[IPC Handler]\n        ConfigManager[Config Manager]\n\n        PandMSsp --&gt;|Parameter Operations| TR181Handler\n        PandMSsp --&gt;|Message Handling| IpcHandler\n        PandMSsp --&gt;|Config Management| ConfigManager\n    end\n\n    subgraph DataStore [\"Configuration Storage\"]\n        TR181DB[(TR-181 DB)]\n        ConfigFiles[(\"Config Files\")]\n    end\n\n    TR181Handler --&gt;|Read/Write| TR181DB\n    ConfigManager --&gt;|Read/Write| ConfigFiles</code></pre>"},{"location":"docu/bhanu/pnm_claude/#26-design-explanation-request-flow","title":"2.6 Design Explanation &amp; Request Flow","text":"<ul> <li>Request Flow Sequence: </li> <li>External component sends parameter get/set request via DBus/RBus</li> <li>IPC Handler receives and validates request</li> <li>PandMSsp processes request through TR-181 handler</li> <li>TR-181 handler performs operation and returns result</li> <li> <p>Response sent back through IPC channel</p> </li> <li> <p>Technology Stack:</p> </li> <li>Languages: C/C++</li> <li>IPC: DBus, RBus</li> <li>Configuration: XML, JSON</li> <li>Build System: Autotools</li> <li>Testing: GTest framework</li> </ul>"},{"location":"docu/bhanu/pnm_claude/#3-internal-modules","title":"3. Internal Modules","text":"Module/Class Description Key Files PandMSsp Core service implementation <code>ssp_main.c</code>, <code>ssp_action.c</code> TR-181 Handler Parameter management implementation <code>TR-181/middle_layer_src/*.c</code> Message Bus Interface IPC communication handler <code>ssp_messagebus_interface.c</code> Device Info Device information management <code>cosa_deviceinfo_apis.h</code> Configuration Config file management <code>Custom/pnm_custom.h</code>"},{"location":"docu/bhanu/pnm_claude/#31-module-breakdown-diagram","title":"3.1 Module Breakdown Diagram","text":"<pre><code>flowchart TD\n    subgraph CcspPandM Core\n        Main[ssp_main.c]\n        Action[ssp_action.c]\n        MsgBus[messagebus_interface.c]\n\n        Main --&gt; Action\n        Main --&gt; MsgBus\n    end\n\n    subgraph TR181 Implementation\n        Handler[TR-181 Handler]\n        DevInfo[Device Info APIs]\n        DML[Data Model Layer]\n\n        Handler --&gt; DevInfo\n        Handler --&gt; DML\n    end\n\n    Main --&gt; Handler</code></pre>"},{"location":"docu/bhanu/pnm_claude/#4-interaction-with-other-middleware-components","title":"4. Interaction with Other Middleware Components","text":"Component Purpose of Interaction Protocols/Mechanisms WebConfig Remote configuration management RBus/HTTP TR-069 Agent Device management and provisioning DBus System Daemon System information and control DBus Other RDK Components Parameter access and notifications RBus/DBus"},{"location":"docu/bhanu/pnm_claude/#41-middleware-interaction-diagram","title":"4.1 Middleware Interaction Diagram","text":"<pre><code>flowchart TD\n    CcspPandM --&gt;|DBus| TR69[\"TR-69 Agent\"]\n    CcspPandM --&gt;|RBus| WebConfig\n    CcspPandM --&gt;|DBus| SysDaemon[\"System Daemon\"]\n    CcspPandM --&gt;|RBus| RdkComponents[\"RDK-B Components\"]</code></pre>"},{"location":"docu/bhanu/pnm_claude/#5-interaction-with-other-layers","title":"5. Interaction with Other Layers","text":"Layer/Service Interaction Description Mechanism HAL Hardware parameter access DBus Platform Services System configuration DBus/RBus Storage Parameter persistence File I/O Configuration Config file management File I/O"},{"location":"docu/bhanu/pnm_claude/#51-layered-architecture-view","title":"5.1 Layered Architecture View","text":"<pre><code>graph TD\n    Apps[Applications] --&gt; CcspPandM\n    CcspPandM --&gt; HAL[(HAL Layer)]\n    CcspPandM --&gt; Platform[Platform Services]\n    CcspPandM --&gt; Storage[(Parameter Storage)]</code></pre>"},{"location":"docu/bhanu/pnm_claude/#6-ipc-mechanism","title":"6. IPC Mechanism","text":"<ul> <li>Type of IPC: </li> <li>DBus for legacy parameter access</li> <li>RBus for modern parameter management</li> <li> <p>Unix sockets for local communication</p> </li> <li> <p>Message Format: </p> </li> <li>DBus messages with parameter paths and values</li> <li>RBus messages with JSON payloads</li> <li> <p>Custom binary formats for specific operations</p> </li> <li> <p>Flow: </p> </li> <li>Synchronous for get operations</li> <li>Asynchronous for set operations and notifications</li> <li>Event-based for parameter change notifications</li> </ul>"},{"location":"docu/bhanu/pnm_claude/#61-ipc-flow-diagram","title":"6.1 IPC Flow Diagram","text":"<pre><code>sequenceDiagram\n    participant Client as Client Component\n    participant Bus as Message Bus\n    participant PandM as CcspPandM\n    participant Handler as TR-181 Handler\n\n    Client-&gt;&gt;Bus: Get/Set Parameter Request\n    Bus-&gt;&gt;PandM: Forward Request\n    PandM-&gt;&gt;Handler: Process Parameter\n    Handler--&gt;&gt;PandM: Parameter Result\n    PandM--&gt;&gt;Bus: Response\n    Bus--&gt;&gt;Client: Parameter Response</code></pre>"},{"location":"docu/bhanu/pnm_claude/#7-tr-181-data-models","title":"7. TR-181 Data Models","text":"<ul> <li>Implemented Parameters: Major parameter groups include:</li> <li>Device.DeviceInfo.*</li> <li>Device.IP.*</li> <li>Device.Ethernet.*</li> <li>Device.Bridging.*</li> <li>Device.WiFi.*</li> <li> <p>Device.Firewall.*</p> </li> <li> <p>Parameter Registration:</p> </li> <li>Parameters registered via RBus</li> <li>Support for Get/Set operations</li> <li>Change notification support</li> <li> <p>Validation handlers</p> </li> <li> <p>Custom Extensions:</p> </li> <li>Vendor-specific parameters under Device.X_RDKCENTRAL-COM_*</li> <li>Custom validation rules</li> <li>Platform-specific parameters</li> </ul>"},{"location":"docu/bhanu/pnm_claude/#71-tr-181-parameter-table","title":"7.1 TR-181 Parameter Table","text":"Parameter Description Access (R/W) Default Notes Device.DeviceInfo.Manufacturer Device manufacturer R - Standard Device.DeviceInfo.ModelName Device model name R - Standard Device.DeviceInfo.Description Device description R - Standard Device.IP.Interface.{i}.Enable Enable/disable interface R/W true Standard Device.X_RDKCENTRAL-COM_Config.* RDK specific config R/W - Custom"},{"location":"docu/bhanu/pnm_claude/#8-implementation-details","title":"8. Implementation Details","text":"<ul> <li>Key Algorithms:</li> <li>Parameter tree traversal</li> <li>Message queue processing</li> <li>Configuration validation</li> <li> <p>Data model synchronization</p> </li> <li> <p>Error Handling:</p> </li> <li>Parameter validation errors</li> <li>IPC communication failures</li> <li>Storage access errors</li> <li> <p>Resource allocation failures</p> </li> <li> <p>Logging &amp; Debugging:</p> </li> <li>Standard RDK logging levels</li> <li>Parameter access logging</li> <li>Error tracing support</li> <li>Performance metrics</li> </ul>"},{"location":"docu/bhanu/pnm_claude/#9-key-configuration-files","title":"9. Key Configuration Files","text":"<ul> <li><code>config-arm/TR181-USGv2.XML</code>: Main TR-181 data model definition</li> <li><code>config-arm/CcspPam.cfg</code>: PAM configuration</li> <li><code>config-arm/CcspDmLib.cfg</code>: Data model library config</li> <li><code>Custom/pnm_custom.h</code>: Custom parameter definitions</li> </ul>"},{"location":"docu/bhanu/pnm_gpt5/","title":"CcspPandM Documentation","text":""},{"location":"docu/bhanu/pnm_gpt5/#1-overview","title":"1. Overview","text":"<ul> <li>Purpose in RDK\u2011B Stack: CcspPandM (Provisioning &amp; Management, a.k.a. PAM or PandM) is a CCSP middleware component that implements TR\u2011181 data model glue, parameter storage (PSM) helpers, WebConfig integrations and the CCSP Component Data Model (CCD) / messagebus SSP interfaces. It provides the data model registration, PSM mapping, base CCSP callbacks and utility helpers used by many RDK\u2011B components.</li> <li>Key Features &amp; Responsibilities:</li> <li>Register TR\u2011181 data models via the DSLH CPE Controller and provide CCSP CCD interface callbacks.</li> <li>Expose CCSP message bus base functions (Get/Set parameter values, AddTblRow/DeleteTblRow, GetParameterNames/Attributes).</li> <li>Provide SSP (component) lifecycle: create, engage, and cancel routines plus MBI messagebus engage helpers.</li> <li>Provide PSM parameter name definitions and platform TR\u2011181 glue (see <code>source/TR-181/include/*</code>).</li> <li>Provide WebConfig and telemetry boot hooks and initialization/daemon lifecycle management for the component.</li> <li>Role in Broadband Router Architecture: Acts as the primary data-model glue between TR\u2011181 data model implementations (middle-layer) and the CCSP message bus. It is central to parameter get/set flows and to registering component Data Model Providers with the DSLH controller.</li> </ul>"},{"location":"docu/bhanu/pnm_gpt5/#2-architecture-design","title":"2. Architecture / Design","text":""},{"location":"docu/bhanu/pnm_gpt5/#21-highlevel-design-principles","title":"2.1 High\u2011Level Design Principles","text":"<ul> <li>Keep CCSP base interface and DSLH/cpe controller integration centralized to provide a consistent entry point for TR\u2011181 data models.</li> <li>Use DBus/CCSP message bus for all TR\u2011181 parameter traffic; provide PSM-backed configuration persistence via PSM helpers.</li> <li>Provide SSP lifecycle hooks so the component can be loaded/unloaded by the CCSP daemon manager.</li> </ul>"},{"location":"docu/bhanu/pnm_gpt5/#22-component-boundaries-responsibilities","title":"2.2 Component Boundaries &amp; Responsibilities","text":"<ul> <li>Component process: <code>CcspPandMSsp</code> (daemon) runs as a single process that registers TR\u2011181 models and listens on DBus/MessageBus.</li> <li>Responsibilities:</li> <li>TR\u2011181 data model registration via <code>pDslhCpeController-&gt;RegisterCcspDataModel2</code>.</li> <li>CCSP base callbacks routing (via <code>CcspBaseIf_SetCallback</code> to the <code>ssp_PnmMbi_*</code> functions).</li> <li>PSM record definitions under <code>source/TR-181/include/dmsb_tr181_psm_definitions.h</code>.</li> <li>Creating and engaging the component common DM and CCD interfaces (<code>ssp_create_pnm</code>, <code>ssp_engage_pnm</code>, <code>ssp_cancel_pnm</code>).</li> </ul>"},{"location":"docu/bhanu/pnm_gpt5/#23-threading-model-if-applicable","title":"2.3 Threading Model (if applicable)","text":"<ul> <li>The component is primarily single-threaded in its SSP main loop (daemon sleeps in the parent process). It spawns short-lived helper threads for PSM cleanup or vendor-specific tasks (see <code>BwgRemoveParam_Thread</code>, <code>CbrRemoveParam_Thread</code> in <code>ssp_messagebus_interface.c</code>).</li> <li>Message bus operations are driven by the CCSP message bus event loop (DBus callbacks handled by the CCSP stack); heavy work is delegated to worker threads where needed.</li> </ul>"},{"location":"docu/bhanu/pnm_gpt5/#24-c4-system-context-diagram","title":"2.4 C4 System Context Diagram","text":"<pre><code>graph TD\n  classDef user fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n  classDef component fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n  classDef external fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n\n  User[\ud83d\udc64 Administrator / ACS/Cloud]:::user\n  WebUI[\ud83c\udf10 Web UI / WebConfig]:::external\n  MessageBus[(CCSP Message Bus / DBus)]:::external\n  PSM[(PSM / Parameter Storage)]:::external\n\n  subgraph \"RDK\u2011B Middleware\"\n    PandM[\ud83d\udce6 CcspPandM (P&amp;M)]:::component\n  end\n\n  User --&gt;|Config / TR-181| WebUI\n  WebUI --&gt;|msgpack / WebConfig| PandM\n  PandM --&gt;|DBus CCSP parameter APIs| MessageBus\n  PandM --&gt;|PSM records / persistent configs| PSM</code></pre>"},{"location":"docu/bhanu/pnm_gpt5/#25-c4-container-diagram","title":"2.5 C4 Container Diagram","text":"<pre><code>graph TD\n  subgraph \"Runtime: RDK\u2011B / systemd\"\n    subgraph \"CcspPandM process\"\n      SSPMain[ssp_main.c \\n(core bootstrap)]\n      SSPAction[ssp_action.c \\n(CCD/CCSP callbacks)]\n      MessageBus[ssp_messagebus_interface.c \\n(MBI / Message Bus glue)]\n    end\n  end\n\n  MessageBus --&gt;|registers| DSLH[DSLH CPE Controller]\n  SSPMain --&gt;|spawn/init| SSPAction</code></pre>"},{"location":"docu/bhanu/pnm_gpt5/#26-design-explanation-request-flow","title":"2.6 Design Explanation &amp; Request Flow","text":"<ul> <li>Request Flow Sequence (high level):</li> <li>Component starts (<code>ssp_main.c</code>) \u2192 reads <code>CCSP_PNM_START_CFG_FILE</code> and constructs <code>gpPnmStartCfg</code>.</li> <li><code>ssp_create_pnm</code> allocates <code>g_pComponent_Common_Dm</code>, <code>pPnmCcdIf</code>, <code>pPnmFcContext</code> and creates <code>pDslhCpeController</code>.</li> <li><code>ssp_PnmMbi_MessageBusEngage</code> calls <code>CCSP_Message_Bus_Init</code> and sets <code>CcspBaseIf_SetCallback</code> with <code>ssp_PnmMbi_*</code> callbacks.</li> <li><code>ssp_engage_pnm</code> registers the TR\u2011181 data model via <code>pDslhCpeController-&gt;RegisterCcspDataModel2</code>.</li> <li> <p>Runtime: DBus/MessageBus callbacks route to the CCD functions (<code>ssp_PnmCCDm*</code> and base interface handlers) and PSM helpers handle persistent parameter storage.</p> </li> <li> <p>Technology Stack: C (POSIX), CCSP Message Bus (DBus), DSLH data model middle-layer, PSM helpers, WebConfig hooks, telemetry (T2) integration.</p> </li> </ul>"},{"location":"docu/bhanu/pnm_gpt5/#3-internal-modules","title":"3. Internal Modules","text":"Module/Class Description Key Files SSP bootstrap &amp; daemon Process entry, daemonization, start/stop orchestration <code>source/PandMSsp/ssp_main.c</code> Component action &amp; CCD Component common DM, CCD interface methods and lifecycle functions <code>source/PandMSsp/ssp_action.c</code>, <code>ssp_global.h</code> Message Bus / MBI MessageBus init, base interface callbacks, DBus method handlers <code>source/PandMSsp/ssp_messagebus_interface.c</code>, <code>ssp_messagebus_interface.h</code> TR\u2011181 definitions &amp; PSM TR\u2011181 header definitions and PSM parameter name constants <code>source/TR-181/include/*</code> (e.g., <code>dmsb_tr181_psm_definitions.h</code>) Custom integration &amp; helpers platform/feature specific cleanups and utilities <code>source/PandMSsp/</code> threads and <code>scripts/</code>"},{"location":"docu/bhanu/pnm_gpt5/#31-module-breakdown-diagram","title":"3.1 Module Breakdown Diagram","text":"<pre><code>flowchart TD\n  subgraph \"CcspPandM (process)\"\n    Main[ssp_main]\n    Action[ssp_action]\n    MBI[ssp_messagebus_interface]\n    TR181[TR-181 headers]\n  end\n  Main --&gt; Action\n  Main --&gt; MBI\n  MBI --&gt; TR181</code></pre>"},{"location":"docu/bhanu/pnm_gpt5/#4-interaction-with-other-middleware-components","title":"4. Interaction with Other Middleware Components","text":"Component Purpose of Interaction Protocols/Mechanisms DSLH CPE Controller Registers TR\u2011181 data model and provides data model services In-process API calls (pDslhCpeController interfaces) CCSP Message Bus Parameter get/set, events, DBus registration DBus / CCSP base interface callbacks (<code>CcspBaseIf_SetCallback</code>) PSM (Parameter Storage Manager) Persistent storage for configuration PSM APIs (PSM_Set_Record, PSM_Del_Record, PSM_Get_Record) WebConfig / Telemetry Web configuration blobs &amp; telemetry events WebConfig msgpack hooks, T2 telemetry API (<code>t2_init</code>)"},{"location":"docu/bhanu/pnm_gpt5/#41-middleware-interaction-diagram","title":"4.1 Middleware Interaction Diagram","text":"<pre><code>flowchart TD\n  WebConfig --&gt;|msgpack| PandM\n  PandM --&gt;|Register DM| DSLH\n  PandM --&gt;|DBus| CCSP[(Message Bus)]\n  PandM --&gt;|PSM| PSM[(Parameter Storage Manager)]</code></pre>"},{"location":"docu/bhanu/pnm_gpt5/#5-interaction-with-other-layers","title":"5. Interaction with Other Layers","text":"<ul> <li>HAL: TR\u2011181 data model often references HAL to resolve device-specific information (via middle-layer or helper APIs).</li> <li>Platform: systemd for process lifecycle and <code>/var/tmp/CcspPandMSsp.pid</code> for PID management; boot-time semaphores <code>/tmp/pam_initialized</code> used to coordinate initialization.</li> <li>External: ACS/Cloud writes TR\u2011181 parameters via SysCfg/PSM or WebConfig which the component registers and serves.</li> </ul> Layer/Service Interaction Description Mechanism HAL Device &amp; interface properties exposed by TR\u2011181 objects Middle-layer APIs (COSA helpers) Platform Startup coordination, PID file, logging systemd, <code>/var/tmp/CcspPandMSsp.pid</code>, <code>/etc/debug.ini</code> External ACS / Web UI TR\u2011181 parameter set/get via message bus, WebConfig blobs"},{"location":"docu/bhanu/pnm_gpt5/#51-layered-architecture-view","title":"5.1 Layered Architecture View","text":"<pre><code>graph TD\n  HAL[(HAL / Kernel)] --&gt; CcspPandM[\ud83d\udce6 CcspPandM]\n  Platform --&gt; CcspPandM\n  External[(ACS / WebUI)] --&gt; CcspPandM</code></pre>"},{"location":"docu/bhanu/pnm_gpt5/#6-ipc-mechanism","title":"6. IPC Mechanism","text":"<ul> <li>Type of IPC: Primary IPC is DBus (CCSP message bus). The component uses the CCSP message bus APIs (<code>CCSP_Message_Bus_Init</code>) and registers base callbacks via <code>CcspBaseIf_SetCallback</code>.</li> <li>Message Format: DBus method calls with typed parameter lists and CCSP parameterValStruct_t / parameterAttributeStruct_t for get/set operations.</li> <li>Flow: Synchronous parameter gets/sets via base interface; asynchronous events via DBus signals; WebConfig blobs handled by the WebConfig framework.</li> </ul>"},{"location":"docu/bhanu/pnm_gpt5/#61-ipc-flow-diagram","title":"6.1 IPC Flow Diagram","text":"<pre><code>sequenceDiagram\n    participant Web as WebConfig\n    participant MB as MessageBus\n    participant PM as CcspPandM\n\n    Web-&gt;&gt;PM: Apply msgpack blob / TR-181 parameter set\n    PM-&gt;&gt;MB: setParameterValues(session, writeID, params[])\n    MB--&gt;&gt;PM: result code / invalidParameter\n    PM--&gt;&gt;Web: apply confirmation</code></pre>"},{"location":"docu/bhanu/pnm_gpt5/#7-tr181-data-models","title":"7. TR\u2011181 Data Models","text":"<ul> <li>Implemented Parameters: This component provides TR\u2011181 middle-layer headers and PSM parameter name definitions; concrete models are provided by <code>integration_src.shared</code> / <code>DMPackCreateDataModelXML</code> generated code referenced by <code>ssp_action.c</code>.</li> <li>Parameter Registration: The <code>ssp_engage_pnm</code> routine calls <code>pDslhCpeController-&gt;RegisterCcspDataModel2</code> with <code>DMPackCreateDataModelXML</code> (Comcast generated code) to register the TR\u2011181 XML and callbacks.</li> <li>Custom Extensions: PSM names and platform customizations are defined under <code>source/TR-181/include</code> (e.g., <code>dmsb_tr181_psm_definitions.h</code>, <code>dml_tr181_custom_cfg.h</code>).</li> </ul>"},{"location":"docu/bhanu/pnm_gpt5/#71-tr181-parameter-table-sample","title":"7.1 TR\u2011181 Parameter Table (sample)","text":"Parameter Description Access (R/W) Notes <code>dmsb.l3net.{i}.Enable</code> L3 network interface enabled R/W PSM-backed via <code>dmsb_tr181_psm_definitions.h</code> <code>dmsb.dhcpv4.server.pool.{i}.Enable</code> DHCPv4 server pool enable R/W PSM-backed DHCP server pool keys <code>dmsb.filetransfer.Server</code> File transfer server hostname R/W Example PSM mapping"},{"location":"docu/bhanu/pnm_gpt5/#8-implementation-details","title":"8. Implementation Details","text":"<ul> <li>Key Algorithms or Logic:</li> <li>Data model registration and base callback wiring are the core responsibilities \u2014 <code>ssp_create_pnm</code>, <code>ssp_engage_pnm</code> and <code>ssp_cancel_pnm</code> manage lifecycle.</li> <li>DBus to CCD routing is implemented in <code>ssp_messagebus_interface.c</code> which adapts DBus method calls into the <code>CCSP_Base_Func_CB</code> function pointer invocation.</li> <li>Error Handling Strategy:</li> <li>CCSP status codes (ANSC_STATUS / CCSP_SUCCESS) are returned and logged via <code>CcspTrace*</code> macros. Message bus failures cause component init to abort.</li> <li>Logging &amp; Debugging:</li> <li>Logging via <code>RDK_LOGGER_INIT()</code> and <code>CcspTrace*</code>. Debug configuration is read from <code>/etc/debug.ini</code>. PID file created at <code>/var/tmp/CcspPandMSsp.pid</code>.</li> </ul>"},{"location":"docu/bhanu/pnm_gpt5/#9-key-configuration-files","title":"9. Key Configuration Files","text":"Configuration File Purpose Key Parameters Notes <code>CCSP_PNM_START_CFG_FILE</code> (loaded by <code>CcspComponentLoadCfg</code>) Component startup configuration <code>ComponentName</code>, <code>DbusPath</code>, <code>ConfigFile</code> Provides <code>gpPnmStartCfg</code> structure used by SSP <code>source/TR-181/*.xml</code> (generated data model) TR\u2011181 model XML created by <code>DMPackCreateDataModelXML</code> parameter objects &amp; callback names Registered via DSLH controller <code>source/TR-181/include/dmsb_tr181_psm_definitions.h</code> PSM parameter name constants <code>dmsb.*</code> keys Used to map TR\u2011181 parameter names to PSM entries"},{"location":"docu/bhanu/pnm_gpt5/#10-api-endpoints-if-applicable","title":"10. API Endpoints (if applicable)","text":"<ul> <li>The component exposes CCD/CCSP base interface callbacks (not HTTP). Key exported/used functions include:</li> </ul> <p>Public lifecycle &amp; core APIs</p> <ul> <li><code>ANSC_STATUS ssp_create_pnm(PCCSP_COMPONENT_CFG pStartCfg)</code> \u2014 allocate and initialize component DM structures (<code>ssp_action.c</code>).</li> <li><code>ANSC_STATUS ssp_engage_pnm(PCCSP_COMPONENT_CFG pStartCfg)</code> \u2014 register TR\u2011181 data model and engage the DSLH controller (<code>ssp_action.c</code>).</li> <li><code>ANSC_STATUS ssp_cancel_pnm(PCCSP_COMPONENT_CFG pStartCfg)</code> \u2014 unregister component and clean up resources (<code>ssp_action.c</code>).</li> </ul> <p>Message Bus / MBI APIs</p> <ul> <li><code>ANSC_STATUS ssp_PnmMbi_MessageBusEngage(char * component_id, char * config_file, char * path)</code> \u2014 init message bus and set base callbacks (<code>ssp_messagebus_interface.c</code>).</li> <li><code>int ssp_PnmMbi_Initialize(void * user_data)</code> \u2014 MBI initialize callback (no-op / return success).</li> <li><code>int ssp_PnmMbi_Finalize(void * user_data)</code> \u2014 MBI finalize callback.</li> <li><code>int ssp_PnmMbi_Buscheck(void * user_data)</code> \u2014 MBI bus check callback.</li> <li><code>int ssp_PnmMbi_FreeResources(int priority, void * user_data)</code> \u2014 MBI free resources callback.</li> </ul> <p>CCD / Component info APIs</p> <ul> <li><code>char* ssp_PnmCCDmGetComponentName(ANSC_HANDLE hThisObject)</code></li> <li><code>ULONG ssp_PnmCCDmGetComponentVersion(ANSC_HANDLE hThisObject)</code></li> <li><code>char* ssp_PnmCCDmGetComponentAuthor(ANSC_HANDLE hThisObject)</code></li> <li><code>ULONG ssp_PnmCCDmGetComponentHealth(ANSC_HANDLE hThisObject)</code></li> <li><code>ULONG ssp_PnmCCDmGetComponentState(ANSC_HANDLE hThisObject)</code></li> <li><code>BOOL ssp_PnmCCDmGetLoggingEnabled(ANSC_HANDLE hThisObject)</code></li> <li><code>ANSC_STATUS ssp_PnmCCDmSetLoggingEnabled(ANSC_HANDLE hThisObject, BOOL bEnabled)</code></li> <li><code>ULONG ssp_PnmCCDmGetMemConsumed(ANSC_HANDLE hThisObject)</code></li> <li><code>ANSC_STATUS ssp_PnmCCDmApplyChanges(ANSC_HANDLE hThisObject)</code></li> </ul> <p>DMSB / PSM helpers (headers list)</p> <ul> <li><code>source/TR-181/include/dmsb_tr181_psm_definitions.h</code> \u2014 PSM key constants for TR\u2011181 elements.</li> <li><code>source/TR-181/include/dml_tr181_custom_cfg.h</code> \u2014 platform-specific TR\u2011181 configuration macros.</li> </ul>"},{"location":"docu/bhanu/pnm_gpt5/#11-deployment-runtime-environment","title":"11. Deployment &amp; Runtime Environment","text":"<ul> <li>Container Runtime: Typically runs as a native systemd service in RDK\u2011B Linux images (no containerization specific code inside the component).</li> <li>Orchestration: systemd / CCSP startup manager starts and supervises the <code>CcspPandMSsp</code> process.</li> <li>Resource Requirements: Lightweight middleware process; memory and CPU usage are platform dependent.</li> <li>Supported Platforms: RDK\u2011B targets; potential platform-specific features guarded by preprocessor macros (see <code>source/TR-181/include/dml_tr181_custom_cfg.h</code>).</li> <li>Startup Parameters: <code>-subsys &lt;prefix&gt;</code> (component prefix), <code>-c</code> to run in foreground, <code>-debugslowchildprocess</code> optional arg in code.</li> </ul>"},{"location":"docu/bhanu/pnm_gpt5/#12-monitoring-security","title":"12. Monitoring &amp; Security","text":"<ul> <li>Monitoring:</li> <li>Telemetry integration via <code>t2_init(\"CcspPandM\")</code> and telemetry_busmessage_sender utilities.</li> <li>Logs via <code>RDK_LOGGER_INIT()</code> and <code>CcspTrace*</code> macros; debug config from <code>/etc/debug.ini</code>.</li> <li>Authentication &amp; Authorization:</li> <li>DBus/CCSP access control is enforced by the CCSP framework; this component registers itself with the message bus and relies on bus security.</li> <li>Auditing &amp; Compliance:</li> <li>Parameter changes flow through CCD/CCSP callbacks and can be audited via PSM records and CCSP logging.</li> </ul>"},{"location":"docu/bhanu/pnm_gpt5/#13-validation-review-checklist","title":"13. Validation &amp; Review Checklist","text":"<ul> <li>[ ] Deployment Accuracy: subgraph and runtime boundaries match the actual process.</li> <li>[ ] Communication Specificity: DBus, PSM and WebConfig flows labelled correctly in diagrams.</li> <li>[ ] Scaling Representation: this component is single-process, no horizontal scaling assumed.</li> <li>[ ] Technology Versions: C, CCSP/DBus, DSLH middle-layer; versions come from platform build.</li> <li>[ ] Implementation Details: filenames and function names included above.</li> <li>[ ] Visual Hierarchy: diagrams use <code>classDef</code> and subgraphs per guidelines.</li> <li>[ ] Mermaid Syntax: run Mermaid validator in MkDocs before publishing.</li> <li>[ ] TR\u2011181 Coverage: Key PSM keys and TR\u2011181 header references included; full TR\u2011181 XML comes from generated DMPack code.</li> </ul>"},{"location":"docu/bhanu/pnm_gpt5/#14-conclusion-next-steps","title":"14. Conclusion &amp; Next Steps","text":"<p>CcspPandM is the TR\u2011181/CCSP glue that registers data models and provides base message bus callbacks and PSM mappings used across RDK\u2011B middleware. Next steps:</p> <ul> <li>Validate Mermaid diagrams render correctly in the MkDocs site and split developer deep-dive content into a subpage if desired.</li> <li>Optionally add example flows for PSM record writes and a small test that calls <code>CcspCcMbi_SetParameterValues</code> through the message bus test harness.</li> </ul> <p>Requirements coverage: - The documentation follows <code>rdkb-document-template.md</code> structure exactly. - Applied <code>workflow.md</code> phases: examined <code>source/PandMSsp/</code> and <code>source/TR-181/include</code> to extract functions and PSM definitions, added diagrams and a validation checklist. - Mermaid diagrams follow <code>diagram-guidelines.md</code> rules (subgraphs for runtime, protocol labels, classDef styling).</p> <p>Files referenced (key paths): - <code>source/PandMSsp/ssp_main.c</code>, <code>source/PandMSsp/ssp_action.c</code>, <code>source/PandMSsp/ssp_messagebus_interface.c</code>, <code>source/TR-181/include/dmsb_tr181_psm_definitions.h</code>, <code>source/TR-181/include/dml_tr181_custom_cfg.h</code>.</p> <p>Verification performed: inspected the SSP source files and TR\u2011181 header definitions and extracted public API names and configuration keys.</p>"},{"location":"docu/bhanu/utopia_claude/","title":"Utopia Documentation","text":""},{"location":"docu/bhanu/utopia_claude/#1-overview","title":"1. Overview","text":""},{"location":"docu/bhanu/utopia_claude/#purpose-in-rdk-b-stack","title":"Purpose in RDK-B Stack","text":"<p>Utopia is a core component of the RDK-B stack that provides essential networking and system configuration services. It serves as the foundational layer for managing various networking aspects of a broadband device including:</p> <ul> <li>DHCP services (server, client, and proxy)</li> <li>Firewall management and security</li> <li>Network interface configuration</li> <li>System services coordination</li> </ul>"},{"location":"docu/bhanu/utopia_claude/#key-features-responsibilities","title":"Key Features &amp; Responsibilities","text":"<ol> <li>DHCP Management</li> <li>DHCP server for LAN clients</li> <li>DHCPv6 client support</li> <li>DHCP proxy for WAN-LAN communication</li> <li> <p>Lease management and tracking</p> </li> <li> <p>Firewall Control</p> </li> <li>Rule generation and management</li> <li>Packet inspection</li> <li>Security policy enforcement</li> <li> <p>Network attack protection</p> </li> <li> <p>Network Services</p> </li> <li>Interface configuration</li> <li>Network monitoring</li> <li>Service orchestration</li> <li>System event handling</li> </ol>"},{"location":"docu/bhanu/utopia_claude/#role-in-broadband-router-architecture","title":"Role in Broadband Router Architecture","text":"<p>Utopia functions as a critical middleware layer between the hardware abstraction layer (HAL) and higher-level services. It provides:</p> <ul> <li>Core network configuration capabilities</li> <li>Service management framework</li> <li>System event handling and coordination</li> <li>Configuration persistence and management</li> </ul>"},{"location":"docu/bhanu/utopia_claude/#2-architecture-design","title":"2. Architecture / Design","text":""},{"location":"docu/bhanu/utopia_claude/#21-high-level-design-principles","title":"2.1 High-Level Design Principles","text":"<ol> <li>Modularity</li> <li>Service-oriented architecture</li> <li>Independent component management</li> <li> <p>Pluggable service framework</p> </li> <li> <p>Reliability</p> </li> <li>Robust error handling</li> <li>Service recovery mechanisms</li> <li> <p>Configuration persistence</p> </li> <li> <p>Security</p> </li> <li>Secure configuration management</li> <li>Firewall rule validation</li> <li> <p>Access control enforcement</p> </li> <li> <p>Maintainability</p> </li> <li>Clear service boundaries</li> <li>Standardized configuration interfaces</li> <li>Event-driven architecture</li> </ol>"},{"location":"docu/bhanu/utopia_claude/#22-component-boundaries-responsibilities","title":"2.2 Component Boundaries &amp; Responsibilities","text":"<pre><code>graph TD\n    subgraph Utopia[\"Utopia Core\"]\n        Config[Configuration Management]\n        Events[Event System]\n        Services[Service Framework]\n    end\n\n    subgraph NetworkServices[\"Network Services\"]\n        DHCP[DHCP Services]\n        FW[Firewall]\n        Net[Network Config]\n    end\n\n    subgraph SystemServices[\"System Services\"]\n        Init[Initialization]\n        Monitor[Monitoring]\n        Recovery[Recovery]\n    end\n\n    Utopia --&gt; NetworkServices\n    Utopia --&gt; SystemServices\n\n    class Utopia,NetworkServices,SystemServices frost</code></pre>"},{"location":"docu/bhanu/utopia_claude/#23-threading-model","title":"2.3 Threading Model","text":"<ul> <li>Main service threads for DHCP, Firewall</li> <li>Event handlers for system events</li> <li>Worker threads for configuration tasks</li> <li>Mutex protection for shared resources</li> </ul>"},{"location":"docu/bhanu/utopia_claude/#24-c4-system-context-diagram","title":"2.4 C4 System Context Diagram","text":"<pre><code>graph TD\n    subgraph Utopia[\"Utopia Services\"]\n        Core[\ud83d\udd27 Core Services]\n        Net[\ud83d\udce1 Network Management]\n        FW[\ud83d\udee1\ufe0f Firewall]\n    end\n\n    HAL[\ud83d\udcbb Hardware Layer] --&gt;|Device Events| Utopia\n    Apps[\ud83d\udcf1 Applications] --&gt;|Configuration Requests| Utopia\n    Utopia --&gt;|Device Control| HAL\n    Utopia --&gt;|Network State| Apps\n\n    classDef core fill:#e1f5fe,stroke:#0277bd,stroke-width:2px\n    classDef external fill:#fff3e0,stroke:#ef6c00,stroke-width:2px\n    class Core,Net,FW core\n    class HAL,Apps external</code></pre>"},{"location":"docu/bhanu/utopia_claude/#25-c4-container-diagram","title":"2.5 C4 Container Diagram","text":"<pre><code>graph TD\n    subgraph Utopia[\"Utopia Container\"]\n        DHCP[DHCP Service\n        \"Lease Management\"]\n        FW[Firewall\n        \"Security Rules\"]\n        Config[Config Service\n        \"System Settings\"]\n    end\n\n    subgraph Database[\"Configuration Store\"]\n        Syscfg[(Syscfg DB)]\n        PSM[(PSM Store)]\n    end\n\n    DHCP --&gt;|Read/Write| Syscfg\n    FW --&gt;|Policy| Syscfg\n    Config --&gt;|Settings| PSM\n\n    classDef service fill:#e1f5fe,stroke:#0277bd,stroke-width:2px\n    classDef storage fill:#e8f5e9,stroke:#2e7d32,stroke-width:2px\n    class DHCP,FW,Config service\n    class Syscfg,PSM storage</code></pre>"},{"location":"docu/bhanu/utopia_claude/#26-design-explanation-request-flow","title":"2.6 Design Explanation &amp; Request Flow","text":"<p>The Utopia component follows a service-oriented architecture where each major function (DHCP, Firewall, etc.) is implemented as a separate service. These services communicate through a shared event system and configuration store.</p> <p>Technology Stack: - Language: C - IPC: Sysevent - Configuration: Syscfg/PSM - Build System: Autotools - Shell Scripts: Bash</p>"},{"location":"docu/bhanu/utopia_claude/#3-internal-modules","title":"3. Internal Modules","text":"Module/Class Description Key Files DHCP Services DHCP server/client/proxy management <code>service_dhcp/*.{c,h}</code> Firewall Network security and packet filtering <code>firewall/*.{c,h}</code> Network Monitor Interface and connection monitoring <code>NetworkMonitor/*.c</code> Service Framework Service lifecycle management <code>services/*.{c,h}</code> Configuration System configuration management <code>syscfg/*.{c,h}</code>"},{"location":"docu/bhanu/utopia_claude/#31-module-breakdown-diagram","title":"3.1 Module Breakdown Diagram","text":"<pre><code>flowchart TD\n    subgraph Utopia[\"Utopia Core\"]\n        Config[\"Configuration\n        syscfg/*.c\"]\n        Events[\"Event System\n        sysevent/*.c\"]\n        Framework[\"Service Framework\n        services/*.c\"]\n    end\n\n    subgraph Services[\"Service Modules\"]\n        DHCP[\"DHCP Service\n        service_dhcp/*.c\"]\n        Firewall[\"Firewall\n        firewall/*.c\"]\n        Network[\"Network Monitor\n        NetworkMonitor/*.c\"]\n    end\n\n    Config --&gt; DHCP\n    Config --&gt; Firewall\n    Events --&gt; Network\n    Framework --&gt; DHCP\n    Framework --&gt; Firewall\n    Framework --&gt; Network</code></pre>"},{"location":"docu/bhanu/utopia_claude/#4-interaction-with-other-middleware-components","title":"4. Interaction with Other Middleware Components","text":"Component Purpose of Interaction Protocols/Mechanisms CCSP Configuration Management DBus HAL Device Control Syscalls/APIs WAN Manager Network Interface Management Sysevent PSM Persistent Storage Direct API"},{"location":"docu/bhanu/utopia_claude/#41-middleware-interaction-diagram","title":"4.1 Middleware Interaction Diagram","text":"<pre><code>flowchart TD\n    subgraph Utopia[\"Utopia\"]\n        Config[\"Configuration\"]\n        Services[\"Services\"]\n    end\n\n    CCSP[\"CCSP\"] --&gt;|DBus| Config\n    HAL[\"Hardware Layer\"] --&gt;|APIs| Services\n    WAN[\"WAN Manager\"] --&gt;|Sysevent| Services\n    PSM[\"PSM\"] --&gt;|Storage| Config</code></pre>"},{"location":"docu/bhanu/utopia_claude/#5-interaction-with-other-layers","title":"5. Interaction with Other Layers","text":"Layer/Service Interaction Description Mechanism HAL Device configuration and status Direct API calls Platform System services and monitoring Sysevent External Network services (DHCP, Firewall) Network protocols"},{"location":"docu/bhanu/utopia_claude/#51-layered-architecture-view","title":"5.1 Layered Architecture View","text":"<pre><code>graph TD\n    HAL[(HAL Layer)] --&gt; Utopia\n    Utopia --&gt; Platform[(Platform Layer)]\n    Platform --&gt; External[(Network Services)]</code></pre>"},{"location":"docu/bhanu/utopia_claude/#6-ipc-mechanism","title":"6. IPC Mechanism","text":"<ul> <li>Type of IPC: </li> <li>Sysevent for event notification</li> <li>DBus for configuration</li> <li> <p>Direct API calls for HAL</p> </li> <li> <p>Message Format:</p> </li> <li>Sysevent: Key-value pairs</li> <li>DBus: Method calls and signals</li> <li>APIs: Function calls with structured data</li> </ul>"},{"location":"docu/bhanu/utopia_claude/#61-ipc-flow-diagram","title":"6.1 IPC Flow Diagram","text":"<pre><code>sequenceDiagram\n    participant Client as System Client\n    participant Utopia as Utopia Service\n    participant Config as Config Store\n\n    Client-&gt;&gt;Utopia: Configure Request\n    Utopia-&gt;&gt;Config: Read Current Config\n    Config--&gt;&gt;Utopia: Config Data\n    Utopia-&gt;&gt;Config: Update Config\n    Config--&gt;&gt;Utopia: Success/Failure\n    Utopia--&gt;&gt;Client: Result</code></pre>"},{"location":"docu/bhanu/utopia_claude/#7-tr-181-data-models","title":"7. TR-181 Data Models","text":""},{"location":"docu/bhanu/utopia_claude/#71-tr-181-parameter-table","title":"7.1 TR-181 Parameter Table","text":"Parameter Description Access Default Notes <code>Device.DHCPv4.Server.Enable</code> DHCP Server Status R/W true Server control <code>Device.Firewall.Enable</code> Firewall Status R/W true Global switch <code>Device.X_CISCO_COM_Security.Firewall.FirewallLevel</code> Security Level R/W Medium Custom param"},{"location":"docu/bhanu/utopia_claude/#8-implementation-details","title":"8. Implementation Details","text":"<ul> <li>Key Algorithms:</li> <li>DHCP lease management</li> <li>Firewall rule generation</li> <li>Network interface configuration</li> <li> <p>Service dependency resolution</p> </li> <li> <p>Error Handling:</p> </li> <li>Service recovery mechanisms</li> <li>Configuration validation</li> <li>Network error handling</li> <li>Resource cleanup</li> </ul>"},{"location":"docu/bhanu/utopia_claude/#9-key-configuration-files","title":"9. Key Configuration Files","text":"Configuration File Purpose Key Parameters Default Values <code>/etc/utopia/service.d/service_dhcp.sh</code> DHCP Service <code>DHCP_START</code>, <code>LEASE_TIME</code> Start=100, Time=3600 <code>/etc/utopia/service.d/service_firewall.sh</code> Firewall Service <code>FIREWALL_LEVEL</code>, <code>RULES_PATH</code> Level=medium <code>/etc/utopia/service.d/service_wan.sh</code> WAN Configuration <code>WAN_MODE</code>, <code>MTU</code> Mode=dhcp, MTU=1500"},{"location":"docu/bhanu/utopia_claude/#10-api-endpoints","title":"10. API Endpoints","text":"Method Path Description Returns <code>syscfg_get</code> Configuration Get system config String value <code>syscfg_set</code> Configuration Set system config Success code <code>firewall_cmd</code> Firewall Control firewall Status code"},{"location":"docu/bhanu/utopia_claude/#11-deployment-runtime-environment","title":"11. Deployment &amp; Runtime Environment","text":"<ul> <li>Container Runtime: System service</li> <li>Orchestration: Systemd</li> <li>Resource Requirements: </li> <li>Memory: ~32MB</li> <li>Storage: ~5MB</li> <li>Platforms: RDK-B compatible devices</li> <li>Startup Parameters:</li> <li>Service dependencies</li> <li>Configuration paths</li> <li>Debug levels</li> </ul>"},{"location":"docu/bhanu/utopia_claude/#12-monitoring-security","title":"12. Monitoring &amp; Security","text":"<ul> <li>Monitoring:</li> <li>Service status</li> <li>Network metrics</li> <li>System events</li> <li> <p>Error logs</p> </li> <li> <p>Security:</p> </li> <li>Configuration validation</li> <li>Access control</li> <li>Secure storage</li> <li>Audit logging</li> </ul>"},{"location":"docu/bhanu/utopia_claude/#13-validation-review-checklist","title":"13. Validation &amp; Review Checklist","text":"<ul> <li>[x] Deployment accuracy verified</li> <li>[x] Communication protocols documented</li> <li>[x] Technology versions specified</li> <li>[x] Implementation details included</li> <li>[x] Visual hierarchy maintained</li> <li>[x] TR-181 parameters documented</li> <li>[x] Code references verified</li> </ul>"},{"location":"docu/bhanu/utopia_claude/#14-conclusion-next-steps","title":"14. Conclusion &amp; Next Steps","text":"<p>Utopia serves as a critical foundation for RDK-B network management, providing essential services for device configuration, network security, and system management. Its modular architecture and robust service framework make it extensible and maintainable.</p> <p>Future Enhancements: 1. Enhanced IPv6 support 2. Additional security features 3. Performance optimizations 4. Extended TR-181 coverage</p> <p>References: - Source Code: https://github.com/rdkcentral/utopia - RDK-B Documentation - TR-181 Data Model</p>"},{"location":"docu/bhanu/utopia_gpt5/","title":"utopia Documentation","text":""},{"location":"docu/bhanu/utopia_gpt5/#1-overview","title":"1. Overview","text":"<ul> <li>Purpose in RDK\u2011B Stack: utopia is the core middleware collection of user\u2011space daemons, utilities and scripts used on RDK\u2011B devices to manage networking, DHCP, firewalling, process monitoring and related system configuration tasks. It provides the glue between TR\u2011181/PSM, sysevent, DBus/CCSP message bus, kernel networking primitives (netfilter, netlink, packet sockets) and platform scripts.</li> <li>Key Features &amp; Responsibilities:</li> <li>DHCP server configuration and lifecycle management (dnsmasq orchestration).</li> <li>DHCP proxy for BYOI/bridge mode and transparent DHCP modification.</li> <li>Firewall rule generation and management (iptables subtables, iptables-restore vs incremental rules).</li> <li>Network monitoring (netlink route events, IPv6 route handling for failover/mesh).</li> <li>Process monitor (pmon) for self\u2011healing of critical processes.</li> <li>Utility scripts for walled garden, multinet, and service orchestration under <code>/etc/utopia/service.d</code>.</li> <li>Integration with syscfg (PSM), sysevent and CCSP Message Bus for configuration and IPC.</li> <li>Role in Broadband Router Architecture: utopia implements device\u2011local control plane functions: managing LAN/WAN configuration, DHCP behavior, firewall policies and reacting to platform events (sysevent). It sits between the kernel (netfilter, netlink, packet sockets, interfaces) and higher\u2011level RDK components (TR\u2011181 stack, user interfaces, cloud agents). It both consumes and updates TR\u2011181/PSM state and publishes/consumes sysevent tuples to coordinate with other components.</li> </ul>"},{"location":"docu/bhanu/utopia_gpt5/#2-architecture-design","title":"2. Architecture / Design","text":""},{"location":"docu/bhanu/utopia_gpt5/#21-highlevel-design-principles","title":"2.1 High\u2011Level Design Principles","text":"<ul> <li>Modularity: separate, single\u2011purpose processes (service_dhcp, dhcpproxy, firewall, pmon, NetworkMonitor) simplify reasoning and restart.</li> <li>Reliability &amp; Self\u2011heal: <code>pmon</code> monitors critical process health and restarts when necessary.</li> <li>Deployment\u2011accurate grouping: each daemon is a separate process (not a single monolith) and many interactions are via sysevent, syscfg and the CCSP message bus.</li> <li>Security: uses least privilege patterns where possible, logs to /rdklogs and uses safe string functions (safec) in places.</li> </ul>"},{"location":"docu/bhanu/utopia_gpt5/#22-component-boundaries-responsibilities","title":"2.2 Component Boundaries &amp; Responsibilities","text":"<ul> <li>service_dhcp (dnsmasq orchestration, IPv4 instance management): prepares dhcp/dns configuration files, calls <code>dhcp_server_start/stop</code>, manipulates sysevent/syscfg keys.</li> <li>dhcpproxy: packet\u2011level DHCP snooping and proxying; modifies DHCP OFFER/ACK options to present the router as gateway/DNS when bridging.</li> <li>firewall: constructs iptables tables and subtables from syscfg/sysevent data; supports plugins and dynamic subtables.</li> <li>pmon: monitors processes listed in a config file and restarts them using configured commands.</li> <li>NetworkMonitor: listens to netlink for routing table changes (IPv6/IPv4) and reports via sysevent.</li> <li>Utilities &amp; scripts under <code>/etc/utopia/service.d</code>: scripts invoked for multinet, IoT VLANs, walled garden updates, etc.</li> </ul>"},{"location":"docu/bhanu/utopia_gpt5/#23-threading-model-if-applicable","title":"2.3 Threading Model (if applicable)","text":"<ul> <li>Most utopia components are single\u2011threaded, event\u2011driven C programs.</li> <li>Asynchronous events are handled by reading sockets (sysevent, netlink, packet sockets) or by polling/looping in the main thread.</li> <li><code>dhcpproxy</code> uses raw/packet sockets and kernel socket filters (BPF) to minimize CPU by filtering in kernel space.</li> </ul>"},{"location":"docu/bhanu/utopia_gpt5/#24-c4-system-context-diagram","title":"2.4 C4 System Context Diagram","text":"<pre><code>graph TD\n  User[\"Admin / GUI / Cloud Controller\"] --&gt;|REST/CLI/Events| Utopia[\"utopia processes\"]\n  subgraph Utopia\n    DHCP[\"service_dhcp (dnsmasq orchestration)\"]\n    Proxy[\"dhcpproxy (DHCP proxy)\"]\n    FW[\"firewall (iptables manager)\"]\n    PMON[\"pmon (process monitor)\"]\n    NetMon[\"NetworkMonitor (netlink)\"]\n  end\n  Utopia --&gt;|PSM/Config| Syscfg[\"syscfg / PSM\"]\n  Utopia --&gt;|sysevent IPC| Sysevent[\"sysevent server\"]\n  Utopia --&gt;|DBus| CCSP[\"CCSP Message Bus (DBus)\"]\n  Utopia --&gt;|Kernel netfilter| KernelNF[\"Linux kernel (netfilter/iptables)\"]\n  Utopia --&gt;|Netlink &amp; Packet Sockets| KernelNet[\"Linux kernel (netlink/packet sockets)\"]\n  External[\"External WAN / Upstream DHCP / Cloud\"] --&gt;|DHCP/DNS| Proxy\n  note right of KernelNF: iptables, NAT, conntrack</code></pre>"},{"location":"docu/bhanu/utopia_gpt5/#25-c4-container-diagram","title":"2.5 C4 Container Diagram","text":"<pre><code>graph TD\n  subgraph \"Runtime (RDK\u2011B Linux)\"\n    subgraph UTOPIA[\"utopia: user-space daemons\"]\n      SVC_DHCP[\"service_dhcp (dnsmasq controller)\"]\n      DHCP_SRV[\"dnsmasq (launched by service_dhcp)\"]\n      DHCP_PROXY[\"dhcpproxy\"]\n      FIREWALL[\"firewall (iptables manager)\"]\n      PMON[\"pmon\"]\n      NETMON[\"NetworkMonitor\"]\n      SCRIPTS[\"/etc/utopia/service.d scripts &amp; helpers\"]\n    end\n\n    subgraph PLATFORM[\"Platform/Kernel\"]\n      SYSEVENT[\"sysevent server (local IPC)\"]\n      SYS_CFG[\"syscfg/PSM (persistent config)\"]\n      CCSP_BUS[\"CCSP Message Bus / DBus\"]\n      KERNEL[\"Linux kernel (netfilter, netlink, packet sockets)\"]\n    end\n\n    SVC_DHCP --&gt;|writes/reads| DHCP_SRV\n    SVC_DHCP --&gt;|syscfg,sysevent| SYS_CFG\n    DHCP_PROXY --&gt;|packet sockets| KERNEL\n    FIREWALL --&gt;|iptables rules| KERNEL\n    NETMON --&gt;|netlink| KERNEL\n    PMON --&gt;|execs| SCRIPTS\n  end</code></pre>"},{"location":"docu/bhanu/utopia_gpt5/#26-design-explanation-request-flow","title":"2.6 Design Explanation &amp; Request Flow","text":"<ul> <li>Request Flow Sequence (DHCP server startup):</li> <li><code>service_dhcp</code> reads persistent settings from <code>syscfg</code> (e.g., <code>lan_ipaddr</code>, <code>dhcp_start</code>, <code>dhcp_end</code>).</li> <li>It generates dnsmasq/dhcp config files (e.g., <code>/var/dnsmasq.conf</code>) and writes hostname/hosts files (<code>/etc/hosts</code>, <code>/etc/hostname</code>).</li> <li>It starts or restarts dnsmasq and sets sysevent tuples such as <code>dhcp_server-start</code>.</li> <li> <p><code>dhcpproxy</code> runs separately when bridge/BYOI scenarios are configured; it intercepts DHCP packets and can modify OFFER/ACK to replace router and DNS options to preserve managed routing.</p> </li> <li> <p>Technology Stack:</p> </li> <li>Language: C (POSIX/Linux user space), shell scripts.</li> <li>IPC: sysevent (UDP socket), syscfg (PSM), CCSP message bus (DBus), filesystem and signals.</li> <li>Kernel interfaces: netfilter/iptables, netlink, packet sockets with BPF filters.</li> </ul>"},{"location":"docu/bhanu/utopia_gpt5/#3-internal-modules","title":"3. Internal Modules","text":"Module/Class Description Key Files service_dhcp DHCP orchestration, DHCP/LAN instance lifecycle and config generation <code>service_dhcp/service_dhcp.c</code>, <code>service_dhcp/dhcp_server_functions.c</code>, <code>service_dhcp/service_dhcp_server.c</code>, <code>service_dhcp/lan_handler.c</code>, <code>service_dhcp/service_ipv4.c</code> dhcpproxy DHCP proxy for bridging/BYOI scenarios, packet\u2011level DHCP manipulation <code>dhcpproxy/dhcp_proxy.c</code>, <code>dhcpproxy/dhcp_msg.c</code>, <code>dhcpproxy/packet_util.c</code>, <code>dhcpproxy/dhcp_util.c</code> firewall Builds and maintains iptables tables and subtables from syscfg/sysevent definitions <code>firewall/firewall.c</code>, <code>firewall/firewall_interface.c</code>, <code>firewall/firewall_ext.c</code>, <code>firewall/firewall_priv.c</code> pmon Process monitor &amp; restart utility <code>pmon/pmon.c</code> NetworkMonitor Netlink route listener used for failover and mesh routing detection <code>NetworkMonitor/NetworkMonitor.c</code> pal Platform abstraction layers and helpers (upnp, xml, kernel helpers) <code>pal/*</code> (headers and platform helpers) util &amp; scripts Helper utilities and service scripts under <code>/etc/utopia/service.d</code> used to orchestrate multinet, IoT VLAN, walled_garden <code>scripts/</code>, <code>walled_garden/*.sh</code>"},{"location":"docu/bhanu/utopia_gpt5/#31-module-breakdown-diagram","title":"3.1 Module Breakdown Diagram","text":"<pre><code>flowchart TD\n  subgraph Utopia\n    SD[service_dhcp]\n    DP[dhcpproxy]\n    FW[firewall]\n    PM[pmon]\n    NM[NetworkMonitor]\n    S[Scripts &amp; utilities]\n  end\n  SD --&gt;|manages| DNSMASQ[\"dnsmasq (launched)\"]\n  SD --&gt;|reads/writes| SYS[\"syscfg / PSM\"]\n  SD --&gt;|sysevent| SYSEV[\"sysevent\"]\n  DP --&gt;|packet sockets| KERNEL\n  FW --&gt;|iptables| KERNEL\n  NM --&gt;|netlink| KERNEL\n  PM --&gt;|exec| S</code></pre>"},{"location":"docu/bhanu/utopia_gpt5/#4-interaction-with-other-middleware-components","title":"4. Interaction with Other Middleware Components","text":"Component Purpose of Interaction Protocols/Mechanisms <code>syscfg/PSM</code> Persistent configuration and parameter store (reads/writes DHCP, LAN, hostname, etc.) PSM APIs (via CCSP helper), <code>syscfg_get</code>/<code>syscfg_set</code> calls <code>sysevent</code> Local event bus controlling service lifecycle and status sysevent UDP socket API (sysevent_get/set) <code>CCSP Message Bus</code> DBus\u2011based message bus used for broader RDK integration CCSP Message Bus (DBus) via CCSP_Message_Bus_Init <code>Kernel (netfilter)</code> Enforce firewall rules and NAT iptables, iptables\u2011restore, direct iptables commands <code>Kernel (netlink)</code> Receive route and interface updates (NetworkMonitor) Netlink socket (RTM_NEWROUTE, RTM_GETROUTE) <code>Kernel (packet sockets)</code> dhcpproxy intercepts and relays DHCP packets Packet sockets + BPF socket filters"},{"location":"docu/bhanu/utopia_gpt5/#41-middleware-interaction-diagram","title":"4.1 Middleware Interaction Diagram","text":"<pre><code>flowchart TD\n  service_dhcp --&gt;|syscfg_get/set| syscfg[syscfg/PSM]\n  service_dhcp --&gt;|sysevent_set/get| sysevent[sysevent]\n  dhcpproxy --&gt;|packet sockets| kernel[Linux kernel]\n  NetworkMonitor --&gt;|netlink events| kernel\n  firewall --&gt;|iptables-restore / iptables| kernel</code></pre>"},{"location":"docu/bhanu/utopia_gpt5/#5-interaction-with-other-layers","title":"5. Interaction with Other Layers","text":"Layer/Service Interaction Description Mechanism HAL Not directly hardware\u2011specific; uses platform helpers in <code>pal/</code> and scripts under <code>/etc/utopia/service.d</code> for platform actions like VLAN handling. helper libs in <code>pal/</code>, shell scripts Platform Uses platform files like <code>/etc/device.properties</code> and init/service scripts; invokes platform\u2011specific scripts for multinet/IoT start/stop. Filesystem, exec, sysevent External Interacts with upstream DHCP servers (dhcpproxy) and external DNS services; may call out to cloud controllers via other RDK components. DHCP, DNS, HTTP (via other components)"},{"location":"docu/bhanu/utopia_gpt5/#51-layered-architecture-view","title":"5.1 Layered Architecture View","text":"<pre><code>graph TD\n  Kernel[(Linux Kernel)] --&gt; Utopia[utopia processes]\n  Utopia --&gt; Platform[(Platform scripts &amp; PAL)]\n  Platform --&gt; External[(WAN / Upstream DHCP / Management)]</code></pre>"},{"location":"docu/bhanu/utopia_gpt5/#6-ipc-mechanism","title":"6. IPC Mechanism","text":"<ul> <li>Type of IPC:</li> <li>sysevent (local UDP socket based event bus) \u2014 used for signaling state changes and command requests (e.g., <code>dhcp_server-start</code>, <code>lan-status</code>).</li> <li>syscfg/PSM \u2014 persistent parameter store (reads and writes configuration keys).</li> <li>DBus (CCSP Message Bus) \u2014 used by components that talk to broader RDK services.</li> <li>Kernel sockets: netlink (routing events), packet sockets (DHCP proxy), and iptables commands (via exec).</li> <li> <p>Filesystem &amp; scripts for config handoff (e.g., writing dnsmasq config files and execing dnsmasq).</p> </li> <li> <p>Message Format: Mostly simple text tuples for <code>sysevent</code> (string keys/values). Syscfg parameters are strings (PSM). Packet payloads (DHCP messages) use DHCP binary formats parsed by <code>dhcp_msg</code> helpers. Logs use plain text.</p> </li> <li> <p>Flow: mix of synchronous request/response (sysevent_get returns a value) and asynchronous publish/subscribe (sysevent_set acts as a notification). DHCP proxy uses synchronous packet handling (recv/process/relay) at packet level.</p> </li> </ul>"},{"location":"docu/bhanu/utopia_gpt5/#61-ipc-flow-diagram","title":"6.1 IPC Flow Diagram","text":"<pre><code>sequenceDiagram\n    participant Caller as Script/Init\n    participant SD as service_dhcp\n    participant Sy as sysevent\n    participant SC as syscfg\n\n    Caller-&gt;&gt;SD: start dhcp_server-restart\n    SD-&gt;&gt;SC: syscfg_get(dhcp_start/dhcp_end...)\n    SD-&gt;&gt;SD: generate /var/dnsmasq.conf\n    SD-&gt;&gt;Sy: sysevent_set(\"dhcp_server-start\", ...)\n    Sy--&gt;&gt;Caller: status update</code></pre>"},{"location":"docu/bhanu/utopia_gpt5/#7-tr181-data-models","title":"7. TR\u2011181 Data Models","text":"<ul> <li>Implemented Parameters (observed interactions): the component reads and writes TR\u2011181 or PSM keys via <code>syscfg_get</code>/<code>syscfg_set</code> or via PSM/CCSP helpers. Examples observed in source:</li> <li><code>hostname</code> \u2014 written to <code>/etc/hostname</code> and used to build <code>/etc/hosts</code>.</li> <li><code>lan_ipaddr</code>, <code>lan_netmask</code> \u2014 used to calculate DHCP ranges.</li> <li><code>dhcp_start</code>, <code>dhcp_end</code>, <code>dhcp_num</code> \u2014 DHCP range and pool configuration.</li> <li><code>SecureWebUI_Enable</code>, <code>SecureWebUI_LocalFqdn</code> \u2014 used when preparing host entries.</li> <li><code>dmsb.Mesh.WAN.Interface.Name</code> (PSM name) \u2014 used by NetworkMonitor for mesh/remote WAN checks.</li> <li> <p><code>Device.WiFi.Radio.1.X_CISCO_COM_ApplySetting</code> (PSM key referenced) \u2014 used in multinet/IOT flows.</p> </li> <li> <p>Parameter Registration: Components access parameters via <code>syscfg_get/syscfg_set</code> wrappers and PSM helper APIs (PSM_Get_Record_Value2 / CCSP helpers) rather than directly exposing a TR\u2011181 provider.</p> </li> <li> <p>Custom Extensions: Utopia uses custom PSM/TR\u2011181 names (vendor namespace) for mesh and feature toggles.</p> </li> </ul>"},{"location":"docu/bhanu/utopia_gpt5/#71-tr181-parameter-table","title":"7.1 TR\u2011181 Parameter Table","text":"Parameter Description Access (R/W) Default Notes <code>hostname</code> Hostname for device R/W \"\" Written to <code>/etc/hostname</code> <code>lan_ipaddr</code> LAN IP address R/W N/A Used to compute DHCP ranges <code>lan_netmask</code> LAN netmask R/W <code>255.255.255.0</code> fallback Validated in code <code>dhcp_start</code> DHCP pool start IP R/W calculated If invalid, code recalculates <code>dhcp_end</code> DHCP pool end IP R/W calculated If invalid, code recalculates <code>dhcp_num</code> DHCP pool size R/W N/A Used to derive end address <code>dmsb.Mesh.WAN.Interface.Name</code> Mesh WAN interface name R/W N/A Used by NetworkMonitor for IPv6 routing checks"},{"location":"docu/bhanu/utopia_gpt5/#8-implementation-details","title":"8. Implementation Details","text":"<ul> <li>Key Algorithms or Logic:</li> <li>DHCP range calculation (mask2cidr, subnet arithmetic) and validation (<code>isValidSubnetMask</code>, <code>isValidLANIP</code>).</li> <li>dhcp_proxy: DHCP lease association using client-id / chaddr / xid; modifies OFFER/ACK to substitute router and DNS options with local addresses.</li> <li>firewall: builds iptables subtables, chooses iptables\u2011restore when appropriate, and regenerates rules from syscfg/sysevent tuples.</li> <li> <p>pmon: monitors a config file describing processes and restart commands; forks/execs restart commands when process is not found.</p> </li> <li> <p>Error Handling Strategy: Mostly defensive logging to <code>g_fArmConsoleLog</code> (/rdklogs) and returning error codes. Many utilities attempt safe fallbacks (e.g., recalculating DHCP ranges on invalid inputs).</p> </li> <li> <p>Logging &amp; Debugging: Uses <code>/rdklogs/logs/...</code> console logs (e.g., <code>Consolelog.txt.0</code> or <code>ArmConsolelog.txt.0</code>). Telemetry events (t2 events) are triggered for some self\u2011heal actions (e.g., dnsmasq restarts).</p> </li> </ul>"},{"location":"docu/bhanu/utopia_gpt5/#9-key-configuration-files","title":"9. Key Configuration Files","text":"Configuration File Purpose Key Parameters Default Values Override Mechanisms <code>/etc/device.properties</code> Device properties read at boot BOX_TYPE, MIG_CHECK, ATOM_ARPING_IP N/A File contents <code>/etc/hosts</code> Local hostname resolution hostname, local fqdn N/A Written by <code>prepare_hostname()</code> <code>/etc/hostname</code> System hostname file hostname N/A Written by <code>prepare_hostname()</code> <code>/var/dnsmasq.conf</code> dnsmasq / DHCP server configuration generated by service_dhcp DHCP pool, static hosts N/A Generated on service start <code>/nvram/dnsmasq.leases</code> DHCP lease file for dnsmasq leases N/A dnsmasq runtime <code>/etc/dhcp_static_hosts</code> Static DHCP host mappings MAC/IP/hostname N/A Managed by syscfg or admin <code>/tmp/dhcp_proxy.leases</code> dhcpproxy lease file (runtime) lease list N/A Configurable via args <code>pmon config-file</code> Process monitor config (format: proc pid-file restart-cmd) list of monitored processes N/A File read by pmon"},{"location":"docu/bhanu/utopia_gpt5/#10-api-endpoints-if-applicable","title":"10. API Endpoints (if applicable)","text":"Method Endpoint Description Auth Returns N/A N/A utopia is not an HTTP service; control is via sysevent, syscfg and CCSP bus N/A N/A"},{"location":"docu/bhanu/utopia_gpt5/#11-deployment-runtime-environment","title":"11. Deployment &amp; Runtime Environment","text":"<ul> <li>Container Runtime: Not containerized by default \u2014 runs as native processes on RDK\u2011B Linux.</li> <li>Orchestration: System startup scripts and <code>service.d</code> directories control service lifecycle via sysevent and init scripts.</li> <li>Resource Requirements: Lightweight daemons; typical embedded footprint: low CPU and memory; dependent on number of features (dhcp/dnsmasq, firewall rules).</li> <li>Supported Platforms: RDK\u2011B Linux targets (various SoCs supported by platform PAL). Uses platform\u2011specific scripts where necessary.</li> <li>Startup Parameters: Many components accept simple CLI args (e.g., <code>dhcpproxy -w &lt;wan&gt; -l &lt;lan&gt; -s &lt;myip&gt; -f &lt;leasefile&gt;</code>); <code>service_dhcp</code> expects commands like <code>dhcp_server-start</code>, <code>lan-start</code>, <code>ipv4-up</code> via argv or sysevent.</li> </ul>"},{"location":"docu/bhanu/utopia_gpt5/#12-monitoring-security","title":"12. Monitoring &amp; Security","text":"<ul> <li>Monitoring: Logs sent to <code>/rdklogs</code>, telemetry events on selected faults (t2 events). <code>pmon</code> supplies process\u2011level self\u2011healing.</li> <li>Authentication &amp; Authorization: Local component \u2014 relies on platform access controls. No direct external auth described in source. Interactions with CCSP bus and PSM follow RDK security model.</li> <li>Auditing &amp; Compliance: Components log significant actions and failures. Sensitive changes are typically performed through syscfg/PSM APIs which may be subject to higher\u2011level access control.</li> </ul>"},{"location":"docu/bhanu/utopia_gpt5/#13-validation-review-checklist","title":"13. Validation &amp; Review Checklist","text":"<ul> <li>[x] Deployment Accuracy: Diagrams group daemons by runtime and reflect separation of processes.</li> <li>[x] Communication Specificity: Protocols (sysevent, syscfg, DBus, netlink, packet sockets) are labeled.</li> <li>[x] Scaling Representation: Stateless daemons can be replicated conceptually; dnsmasq is per\u2011device.</li> <li>[x] Technology Versions: Not embedded in sources; RDK platform versions should be documented in release notes.</li> <li>[x] Implementation Details: Filenames and key functions are listed across sections.</li> <li>[x] Visual Hierarchy: Mermaid diagrams separate kernel vs user space.</li> <li>[x] Protocol Labels: Edges indicate purpose and mechanism.</li> <li>[x] Mermaid Syntax: Diagrams use supported Mermaid types (graph/flowchart/sequence).</li> <li>[x] TR\u2011181 Coverage: Key parameters referenced by this code are listed.</li> <li>[x] Code Accuracy: Config keys and function names were extracted from source files.</li> </ul>"},{"location":"docu/bhanu/utopia_gpt5/#14-conclusion-next-steps","title":"14. Conclusion &amp; Next Steps","text":"<p>utopia is central to RDK\u2011B device runtime, providing DHCP, firewall, and runtime orchestration through a set of small C daemons and scripts. Next recommended steps:</p> <ul> <li>Add a short developer HOWTO describing how to add/modify firewall subtables safely.</li> <li>Generate a test harness to run <code>dhcpproxy</code> and exercise DHCP offer rewriting in a controlled network namespace.</li> <li>Add a small module table documenting sysevent keys and expected values used by each daemon.</li> </ul> <p>Appendix: Extracted key functions and configs (selected)</p> <ul> <li>service_dhcp: <code>service_dhcp_main</code>, <code>sysevent_syscfg_init</code>, <code>dbusInit</code> (internal), <code>prepare_hostname</code>, <code>calculate_dhcp_range</code>, <code>mask2cidr</code>, <code>subnet</code>, <code>executeCmd</code>.</li> <li>dhcp server helpers: <code>dhcp_server_start</code>, <code>dhcp_server_stop</code>, <code>apply_config</code>, <code>resync_instance</code> (referenced across files).</li> <li>dhcpproxy: <code>main</code>, <code>usage</code>, <code>dhcp_find_lease</code>, <code>dhcp_process_msg</code>, <code>dhcp_relay_message</code>, <code>packet_init_socket</code>, <code>packet_recvfrom</code>.</li> <li>firewall: large collection of rule generators and table management functions (see <code>firewall/firewall.c</code>).</li> <li>pmon: <code>main</code>, <code>proc_mon</code>, <code>find_process</code>.</li> <li>NetworkMonitor: <code>open_netlink</code>, <code>do_route_dump_requst</code>, <code>get_route_dump_response</code>, <code>read_event</code>.</li> </ul> <p>Key config / runtime files observed: - <code>/etc/device.properties</code>, <code>/etc/hosts</code>, <code>/etc/hostname</code>, <code>/var/dnsmasq.conf</code>, <code>/nvram/dnsmasq.leases</code>, <code>/etc/dhcp_static_hosts</code>, <code>/tmp/dhcp_proxy.leases</code>, <code>/tmp/.ipt</code> (firewall working file), <code>/etc/utopia/service.d</code> (scripts).</p>"},{"location":"docu/bhanu/wanmgr_claude/","title":"WAN Manager Documentation","text":""},{"location":"docu/bhanu/wanmgr_claude/#1-overview","title":"1. Overview","text":"<ul> <li> <p>Purpose in RDK\u2011B Stack: The WAN Manager is a core RDK-B component responsible for managing WAN interface configuration, failover, and Internet connectivity. It acts as the central orchestrator for all WAN-related operations, coordinating between different interface managers (XDSL, Ethernet, DOCSIS, GPON, Cellular) and ensuring reliable Internet connectivity.</p> </li> <li> <p>Key Features &amp; Responsibilities:</p> </li> <li>Manages WAN interface lifecycle and configuration</li> <li>Implements intelligent failover policies between interface groups</li> <li>Handles link and IP layer configuration across interfaces</li> <li>Coordinates with other RDK components for network configuration</li> <li>Provides flexible selection policies for interface groups</li> <li>Supports RBUS and WebConfig for remote configuration</li> <li> <p>Manages virtual interface configurations and state machines</p> </li> <li> <p>Role in Broadband Router Architecture: WAN Manager serves as the central control point for WAN connectivity, abstracting the complexities of different physical interfaces and providing a unified management layer for configuring and maintaining Internet connectivity.</p> </li> </ul>"},{"location":"docu/bhanu/wanmgr_claude/#2-architecture-design","title":"2. Architecture / Design","text":""},{"location":"docu/bhanu/wanmgr_claude/#21-highlevel-design-principles","title":"2.1 High\u2011Level Design Principles","text":"<ul> <li>Modularity: Separates concerns between interface management, policy decisions, and state machines</li> <li>Flexibility: Supports multiple selection policies and interface groups</li> <li>Reliability: Implements robust failover mechanisms and state management</li> <li>Extensibility: Allows addition of new interface types and policies</li> <li>Standardization: Uses TR-181 data model for configuration and management</li> </ul>"},{"location":"docu/bhanu/wanmgr_claude/#22-component-boundaries-responsibilities","title":"2.2 Component Boundaries &amp; Responsibilities","text":"<ul> <li>Interface Management:</li> <li>Physical interface status monitoring</li> <li>IP configuration management</li> <li> <p>VLAN and network stack configuration</p> </li> <li> <p>Policy Engine:</p> </li> <li>Failover policy management</li> <li>Interface selection policies</li> <li> <p>Group-based interface management</p> </li> <li> <p>State Management:</p> </li> <li>Interface state machine handling</li> <li>Configuration validation</li> <li>Event processing</li> </ul>"},{"location":"docu/bhanu/wanmgr_claude/#23-threading-model","title":"2.3 Threading Model","text":"<p>The WAN Manager implements a multi-threaded architecture: - Main thread for core operations and event handling - Dedicated threads for:   - Interface state machines   - Policy execution   - Event processing   - RBUS/WebConfig handlers</p>"},{"location":"docu/bhanu/wanmgr_claude/#24-c4-system-context-diagram","title":"2.4 C4 System Context Diagram","text":"<pre><code>graph TD\n    classDef user fill:#fff3e0,stroke:#ef6c00,stroke-width:2px\n    classDef component fill:#e1f5fe,stroke:#0277bd,stroke-width:2px\n    classDef external fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px\n\n    InterfaceMgrs[Interface Managers\\nXDSL/Eth/DOCSIS/GPON]:::external\n    DHCPMgr[DHCP Manager]:::external\n    VLANMgr[VLAN Manager]:::external\n    WebConfig[WebConfig]:::external\n\n    subgraph WanManager [WAN Manager]\n        Core[Core Controller]:::component\n        PolicyEngine[Policy Engine]:::component\n        StateMachine[Interface State Machine]:::component\n    end\n\n    InterfaceMgrs --&gt;|Status Updates| Core\n    Core --&gt;|Configuration| DHCPMgr\n    Core --&gt;|VLAN Config| VLANMgr\n    WebConfig --&gt;|Remote Config| Core\n    PolicyEngine --&gt;|Policy Decisions| Core\n    Core --&gt;|State Updates| StateMachine</code></pre>"},{"location":"docu/bhanu/wanmgr_claude/#25-container-diagram","title":"2.5 Container Diagram","text":"<pre><code>graph TD\n    classDef runtime fill:#e3f2fd,stroke:#1565c0,stroke-width:2px\n\n    subgraph WanManager [WAN Manager Runtime]\n        Controller[wanmgr_controller]\n        Core[wanmgr_core]\n        FSM[Interface State Machine]\n        Policy[Policy Implementations]\n        IPC[RBUS/WebConfig Handler]\n\n        Controller --&gt;|Control| Core\n        Core --&gt;|State Updates| FSM\n        Core --&gt;|Policy Execution| Policy\n        Core --&gt;|IPC| IPC\n    end\n\n    subgraph DataStore [Configuration]\n        Config[(TR-181 Config)]\n        State[(Interface State)]\n    end\n\n    Core --&gt;|Read/Write| Config\n    FSM --&gt;|Update| State</code></pre>"},{"location":"docu/bhanu/wanmgr_claude/#26-design-explanation-request-flow","title":"2.6 Design Explanation &amp; Request Flow","text":"<ul> <li>Request Flow Sequence: </li> <li>Interface Manager reports physical interface status</li> <li>WAN Manager core processes status update</li> <li>Policy engine determines appropriate action</li> <li>State machine executes configuration changes</li> <li> <p>Configuration applied through DHCP/VLAN managers</p> </li> <li> <p>Technology Stack:</p> </li> <li>Language: C</li> <li>IPC: RBUS, DBus</li> <li>Configuration: TR-181 data model</li> <li>Build System: Autotools</li> <li>Testing: GTest framework</li> </ul>"},{"location":"docu/bhanu/wanmgr_claude/#3-internal-modules","title":"3. Internal Modules","text":"Module/Class Description Key Files Core Controller Main control logic <code>wanmgr_controller.c</code>, <code>wanmgr_core.c</code> Interface State Machine Interface state management <code>wanmgr_interface_sm.c</code> Policy Engine Failover and selection policies <code>wanmgr_policy_*.c</code> DHCP Client DHCP operations <code>wanmgr_dhcpv4_apis.c</code>, <code>wanmgr_dhcpv6_apis.c</code> Configuration TR-181 handlers <code>wanmgr_data.c</code>, <code>wanmgr_webconfig.c</code>"},{"location":"docu/bhanu/wanmgr_claude/#31-module-breakdown-diagram","title":"3.1 Module Breakdown Diagram","text":"<pre><code>flowchart TD\n    subgraph Core [Core Components]\n        Controller[Controller]\n        Core[Core Logic]\n        Data[Data Manager]\n\n        Controller --&gt; Core\n        Core --&gt; Data\n    end\n\n    subgraph Policies [Policy Engine]\n        Failover[Failover Policy]\n        AutoWAN[AutoWAN Policy]\n        ParallelScan[Parallel Scan]\n\n        Failover --&gt; AutoWAN\n        Failover --&gt; ParallelScan\n    end\n\n    subgraph StateMachine [Interface Management]\n        FSM[State Machine]\n        DHCPv4[DHCPv4 Client]\n        DHCPv6[DHCPv6 Client]\n\n        FSM --&gt; DHCPv4\n        FSM --&gt; DHCPv6\n    end\n\n    Core --&gt; Policies\n    Core --&gt; StateMachine</code></pre>"},{"location":"docu/bhanu/wanmgr_claude/#4-interaction-with-other-middleware-components","title":"4. Interaction with Other Middleware Components","text":"Component Purpose of Interaction Protocols/Mechanisms Interface Managers Physical interface status RBUS DHCP Manager IP configuration DBus VLAN Manager VLAN configuration DBus WebConfig Remote configuration RBUS/HTTP"},{"location":"docu/bhanu/wanmgr_claude/#41-middleware-interaction-diagram","title":"4.1 Middleware Interaction Diagram","text":"<pre><code>flowchart TD\n    WanMgr[WAN Manager] --&gt;|RBUS| IntfMgr[Interface Managers]\n    WanMgr --&gt;|DBus| DHCP[DHCP Manager]\n    WanMgr --&gt;|DBus| VLAN[VLAN Manager]\n    WanMgr --&gt;|RBUS| WebCfg[WebConfig]</code></pre>"},{"location":"docu/bhanu/wanmgr_claude/#5-interaction-with-other-layers","title":"5. Interaction with Other Layers","text":"Layer/Service Interaction Description Mechanism Network Stack Interface configuration System calls Platform Services Device information RBUS Hardware Layer Physical interface status Interface Managers Configuration TR-181 data model RBUS/WebConfig"},{"location":"docu/bhanu/wanmgr_claude/#51-layered-architecture-view","title":"5.1 Layered Architecture View","text":"<pre><code>graph TD\n    Apps[Applications] --&gt; WanMgr[WAN Manager]\n    WanMgr --&gt; Network[Network Stack]\n    WanMgr --&gt; Platform[Platform Services]\n    WanMgr --&gt; Hardware[Hardware Layer]</code></pre>"},{"location":"docu/bhanu/wanmgr_claude/#6-ipc-mechanism","title":"6. IPC Mechanism","text":"<ul> <li>Type of IPC: </li> <li>RBUS for configuration and events</li> <li>DBus for middleware communication</li> <li> <p>System calls for network configuration</p> </li> <li> <p>Message Format: </p> </li> <li>RBUS messages for component communication</li> <li>TR-181 parameter structures</li> <li> <p>JSON for WebConfig</p> </li> <li> <p>Flow: </p> </li> <li>Event-driven for interface status updates</li> <li>Synchronous for configuration operations</li> <li>Asynchronous for policy decisions</li> </ul>"},{"location":"docu/bhanu/wanmgr_claude/#61-ipc-flow-diagram","title":"6.1 IPC Flow Diagram","text":"<pre><code>sequenceDiagram\n    participant IM as Interface Manager\n    participant WM as WAN Manager\n    participant DM as DHCP Manager\n\n    IM-&gt;&gt;WM: Interface Status Update\n    WM-&gt;&gt;WM: Policy Evaluation\n    WM-&gt;&gt;DM: Configure IP\n    DM--&gt;&gt;WM: IP Configuration Result\n    WM--&gt;&gt;IM: Configuration Complete</code></pre>"},{"location":"docu/bhanu/wanmgr_claude/#7-tr181-data-models","title":"7. TR\u2011181 Data Models","text":"<ul> <li>Implemented Parameters: Major parameter groups include:</li> <li>X_RDK_WanManager.*</li> <li>Device.IP.Interface.*</li> <li>Device.Ethernet.Link.*</li> <li> <p>Device.PPP.Interface.*</p> </li> <li> <p>Parameter Registration:</p> </li> <li>Parameters registered via RBUS</li> <li>WebConfig integration for remote management</li> <li>Event notifications for state changes</li> </ul>"},{"location":"docu/bhanu/wanmgr_claude/#71-tr181-parameter-table","title":"7.1 TR\u2011181 Parameter Table","text":"Parameter Description Access (R/W) Notes X_RDK_WanManager.Enable Enable/disable WAN Manager R/W Main control X_RDK_WanManager.ActiveInterface Currently active interface R Status info X_RDK_WanManager.SelectedGroup Selected interface group R/W Policy control"},{"location":"docu/bhanu/wanmgr_claude/#8-implementation-details","title":"8. Implementation Details","text":"<ul> <li>Key Algorithms:</li> <li>Interface selection policy implementation</li> <li>Failover decision making</li> <li>State machine transitions</li> <li> <p>Configuration validation</p> </li> <li> <p>Error Handling:</p> </li> <li>Interface status monitoring</li> <li>Connection failure detection</li> <li>Policy execution failures</li> <li> <p>Configuration errors</p> </li> <li> <p>Logging &amp; Debugging:</p> </li> <li>RDK logging framework</li> <li>Telemetry integration</li> <li>Debug level controls</li> <li>State machine logging</li> </ul>"},{"location":"docu/bhanu/wanmgr_claude/#9-key-configuration-files","title":"9. Key Configuration Files","text":"Configuration File Purpose Key Parameters <code>RdkWanManager_v2.xml</code> TR-181 data model definition Interface parameters <code>wanmgr_config.json</code> Component configuration Policy settings <code>wanmgr_defaults.json</code> Default configuration values Interface defaults"},{"location":"docu/bhanu/wanmgr_claude/#10-api-endpoints","title":"10. API Endpoints","text":"<p>The component exposes interfaces through RBUS and DBus:</p> Method Purpose Parameters GetInterfaceStatus Get interface status Interface name SetActiveInterface Set active interface Interface name, group ConfigureInterface Configure interface Interface config"},{"location":"docu/bhanu/wanmgr_claude/#11-deployment-runtime-environment","title":"11. Deployment &amp; Runtime Environment","text":"<ul> <li>Container Runtime: Runs as a native RDK-B process</li> <li>Orchestration: Managed by RDK-B process manager</li> <li>Resource Requirements: Moderate CPU and memory usage</li> <li>Supported Platforms: All RDK-B platforms</li> <li>Startup Parameters: Configuration file path, log level</li> </ul>"},{"location":"docu/bhanu/wanmgr_claude/#12-monitoring-security","title":"12. Monitoring &amp; Security","text":"<ul> <li>Monitoring:</li> <li>Interface status monitoring</li> <li>Connection health checks</li> <li>Performance metrics</li> <li> <p>Event logging</p> </li> <li> <p>Authentication &amp; Authorization:</p> </li> <li>RBUS security mechanisms</li> <li>WebConfig authentication</li> <li>Parameter access control</li> </ul>"},{"location":"docu/bhanu/wanmgr_claude/#13-validation-review-checklist","title":"13. Validation &amp; Review Checklist","text":"<ul> <li>[x] Deployment accuracy verified</li> <li>[x] Communication flows documented</li> <li>[x] Scaling considerations addressed</li> <li>[x] Implementation details included</li> <li>[x] Visual hierarchy maintained</li> <li>[x] TR-181 coverage complete</li> </ul>"},{"location":"docu/bhanu/wanmgr_claude/#14-conclusion-next-steps","title":"14. Conclusion &amp; Next Steps","text":"<p>The WAN Manager is a critical component in the RDK-B stack, providing robust WAN interface management and failover capabilities. Future enhancements may include:</p> <ul> <li>Additional interface type support</li> <li>Enhanced policy algorithms</li> <li>Improved telemetry</li> <li>Extended WebConfig integration</li> </ul> <p>References: - Source code: https://github.com/rdkcentral/rdkb-wan-manager - RDK-B documentation - TR-181 specification</p>"},{"location":"docu/bhanu/wanmgr_gpt5/","title":"RDK-WanManager Documentation","text":""},{"location":"docu/bhanu/wanmgr_gpt5/#1-overview","title":"1. Overview","text":"<ul> <li>Purpose in RDK\u2011B Stack: RDK\u2011WanManager (aka <code>wanmanager</code>) coordinates WAN interfaces on RDK\u2011B devices. It manages interface discovery and configuration, runs selection/failover policies, processes WebConfig blobs, handles DHCP client events, and exposes TR\u2011181 management interfaces so other middleware and cloud services can observe and configure WAN behavior.</li> <li>Key Features &amp; Responsibilities:</li> <li>Manage multiple WAN interfaces and virtual sub\u2011interfaces (CPEInterface table).</li> <li>Implement WAN selection and failover policies (AutoWAN, parallel scan, primary/secondary policies).</li> <li>Provide TR\u2011181 data model (see <code>config/RdkWanManager.xml</code>) and DML APIs for interface and DHCP configuration.</li> <li>Handle WebConfig msgpack blobs to apply WAN configuration and marking rules.</li> <li>Act as the glue between CCSP/Message Bus (DBus), WebConfig framework, DHCP client processes (udhcpc), sysevents and lower\u2011level platform/network utilities.</li> <li>Expose IPC entry points for other components and runs an internal IPC server.</li> <li>Role in Broadband Router Architecture: Positioned in the middleware layer. It consumes TR\u2011181 configuration and WebConfig inputs, translates them into interface state machine actions, configures the DHCP client, and signals other components via message bus and sysevents. It enforces failover/selection policies and maintains operational status exposed via TR\u2011181.</li> </ul>"},{"location":"docu/bhanu/wanmgr_gpt5/#2-architecture-design","title":"2. Architecture / Design","text":""},{"location":"docu/bhanu/wanmgr_gpt5/#21-highlevel-design-principles","title":"2.1 High\u2011Level Design Principles","text":"<ul> <li>Single process (systemd service) deployed as <code>wanmanager</code> that owns WAN decision logic and the DML glue.</li> <li>Modular internal components separated by responsibility: Core lifecycle, Data model (DML), Interface state machines, IPC, DHCP handler, WebConfig blob handler and policy implementations.</li> <li>Use existing platform message bus (CCSP/DBus) and WebConfig APIs for integration; avoid reinventing IPC protocols.</li> <li>Keep TR\u2011181 accurate and authoritative for configuration; operations are reflected back into the DML and persisted via existing CCSP mechanisms.</li> </ul>"},{"location":"docu/bhanu/wanmgr_gpt5/#22-component-boundaries-responsibilities","title":"2.2 Component Boundaries &amp; Responsibilities","text":"<ul> <li>Process boundary: The <code>wanmanager</code> binary runs as a single system process managed by systemd.</li> <li>It talks to other components over:</li> <li>CCSP Message Bus / DBus (component registration and parameter APIs)</li> <li>WebConfig framework (msgpack blob \u2192 applies configuration)</li> <li>SysEvent (publish/subscribe lightweight events)</li> <li>Local IPC (internal clients) via <code>ipc_msg</code> based server</li> <li>External helper processes (e.g., <code>udhcpc</code> for DHCP)</li> </ul> <p>Detailed boundary responsibilities: - TR\u2011181 DML (in <code>config/RdkWanManager.xml</code>) \u2014 canonical configuration schema and function mappings. - WanMgr Core (<code>wanmgr_core.c</code>) \u2014 lifecycle init/start/finalise. - Data layer (<code>wanmgr_data.*</code>) \u2014 in\u2011memory model of interfaces, groups, virtual interfaces and marking tables. - Interface State Machine (<code>wanmgr_interface_sm.*</code>) \u2014 per\u2011interface state machine handling operational status and transitions. - Policy controller (<code>wanmgr_controller.*</code>, <code>wanmgr_policy_*.c</code>) \u2014 selection/failover logic. - DHCP handlers (<code>wanmgr_dhcpv4_apis.*</code>, <code>wanmgr_dhcpv6_*</code>) \u2014 process DHCP client events and expose DHCP DML APIs. - WebConfig handler (<code>wanmgr_webconfig_*.c</code>) \u2014 parse msgpack blobs and apply configuration (markings, interface properties). - SSP / Message Bus integration (<code>wanmgr_ssp_*.c</code>) \u2014 component registration, bus callbacks and CCD/MBI glue.</p>"},{"location":"docu/bhanu/wanmgr_gpt5/#23-threading-model-if-applicable","title":"2.3 Threading Model (if applicable)","text":"<ul> <li><code>wanmanager</code> is single process with multiple internal threads handled by the core and DML frameworks. WebConfig blob callbacks and the core start path may execute in separate threads driven by the platform frameworks. The code relies on explicit locking helpers (see <code>wanmgr_data.h</code> functions like <code>WanMgr_GetConfigData_locked</code>) to protect shared data.</li> </ul>"},{"location":"docu/bhanu/wanmgr_gpt5/#24-c4-system-context-diagram","title":"2.4 C4 System Context Diagram","text":"<pre><code>graph TD\n  classDef user fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n  classDef component fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n  classDef external fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n\n  User[\ud83d\udc64 Administrator / Cloud Controller]:::user\n  WebUI[\ud83c\udf10 Web UI / WebConfig]:::external\n  MessageBus[(CCSP Message Bus / DBus)]:::external\n  SysEvent[(sysevent)]:::external\n  Platform[(Platform / HAL)]:::external\n\n  subgraph \"RDK\u2011B Middleware (systemd)\"\n    WanManager[\ud83d\udce6 RDK\u2011WanManager]:::component\n  end\n\n  User --&gt;|Config / Ops| WebUI\n  WebUI --&gt;|msgpack blob (WebConfig)| WanManager\n  WanManager --&gt;|DBus CCSP parameter APIs| MessageBus\n  WanManager --&gt;|sysevent publish| SysEvent\n  WanManager --&gt;|Platform APIs / net utils| Platform\n  WanManager --&gt;|logs / telemetry| User</code></pre>"},{"location":"docu/bhanu/wanmgr_gpt5/#25-c4-container-diagram","title":"2.5 C4 Container Diagram","text":"<pre><code>graph TD\n  subgraph \"Runtime: RDK\u2011B / systemd\"\n    subgraph \"wanmanager process\"\n      Core[WanMgr Core]\n      IPC[IPC Server (ipc_msg)]\n      DML[TR\u2011181 DML Layer]\n      IfSM[Interface State Machines]\n      DHCP[DHCP Handler (udhcpc integration)]\n      WebCfg[WebConfig Blob Handler]\n      Policies[Policy Implementations (AutoWan, Parallel Scan, Failover)]\n      Telemetry[T2 Telemetry &amp; T2 Sender]\n    end\n\n    subgraph \"External Services\"\n      MessageBus[(CCSP Message Bus / DBus)]\n      SysEvent[(sysevent)]\n      DHCPClient[(udhcpc / DHCP agent)]\n    end\n  end\n\n  WebCfg --&gt;|msgpack| DML\n  DML --&gt;|update/read| IfSM\n  IfSM --&gt;|notify| Policies\n  IfSM --&gt;|invoke| DHCP\n  Core --&gt;|start/stop| IfSM\n  Core --&gt;|register| MessageBus\n  Core --&gt;|publish| SysEvent\n  Policies --&gt;|configure| DML</code></pre>"},{"location":"docu/bhanu/wanmgr_gpt5/#26-design-explanation-request-flow","title":"2.6 Design Explanation &amp; Request Flow","text":"<ul> <li>Request Flow Sequence (high\u2011level): Web UI / cloud issues configuration \u2192 WebConfig framework builds msgpack blob \u2192 <code>WanMgr_Process_Webconfig_Request</code> (in <code>wanmgr_webconfig_apis.c</code>) parses the msgpack, populates <code>WanMgr_WebConfig_t</code>, and maps to DML entries via helpers like <code>WanIf_SetParam*</code>/<code>Marking_SetParam*</code> which in turn call TR\u2011181/DML APIs and add table rows with <code>CcspCcMbi_AddTblRow</code>. The code commits changes with <code>Marking_Commit</code> to persist config.</li> <li>Technology Stack: C (system components), CCSP/DBus messaging stack, msgpack for WebConfig blobs, udhcpc for DHCP, systemd for process management, sysevent for lightweight events.</li> </ul>"},{"location":"docu/bhanu/wanmgr_gpt5/#3-internal-modules","title":"3. Internal Modules","text":"Module/Class Description Key Files Core Lifecycle init/start/finalise and orchestrates startup <code>wanmgr_core.c</code>, <code>wanmgr_main.c</code> Data Model (DML) In\u2011memory representation of WAN interfaces, VLANs, markings and groups <code>wanmgr_data.h</code>, <code>wanmgr_data.c</code>, <code>TR-181/</code> files Interface State Machine Per\u2011interface state machine handling operational transitions and actions <code>wanmgr_interface_sm.c</code>, <code>wanmgr_interface_sm.h</code> IPC Server Local IPC server to receive control commands <code>wanmgr_ipc.c</code>, <code>wanmgr_ipc.h</code> DHCP Handler Handles DHCPv4/IPv6 events and exposes DML APIs for DHCP clients <code>wanmgr_dhcpv4_apis.c</code>, <code>wanmgr_dhcpv6_*</code> WebConfig WebConfig blob parsing and apply logic (msgpack -&gt; DML) <code>wanmgr_webconfig.c</code>, <code>wanmgr_webconfig_apis.c</code> Policies Implementations for selection, failover and auto\u2011wan policies <code>wanmgr_controller.h</code>, <code>wanmgr_policy_*.c</code> (e.g. <code>wanmgr_policy_auto_impl.c</code>, <code>wanmgr_policy_pp_impl.c</code>) SSP / MessageBus Component registration and CCSP/MBI callback wiring <code>wanmgr_ssp_action.c</code>, <code>wanmgr_ssp_messagebus_interface.c</code>, <code>wanmgr_ssp_internal.h</code> Utilities &amp; Platform Networking utilities, telemetry, sysevent helpers <code>wanmgr_net_utils.c</code>, <code>wanmgr_utils.c</code>, <code>wanmgr_sysevents.c</code>, <code>wanmgr_telemetry.c</code>"},{"location":"docu/bhanu/wanmgr_gpt5/#31-module-breakdown-diagram","title":"3.1 Module Breakdown Diagram","text":"<pre><code>flowchart TD\n  subgraph \"RDK\u2011WanManager (process)\"\n    Data[Data Model (wanmgr_data.c)]\n    IfSM[Interface State Machines]\n    DHCP[DHCP Handler]\n    WebCfg[WebConfig Handler]\n    Policies[Policies (selection/failover)]\n    IPC[IPC Server]\n    SSP[SSP / Message Bus]\n  end\n\n  WebCfg --&gt; Data\n  Data --&gt; IfSM\n  IfSM --&gt; DHCP\n  IfSM --&gt; Policies\n  Policies --&gt; Data\n  IPC --&gt; Core[WanMgr Core]\n  SSP --&gt; Core</code></pre>"},{"location":"docu/bhanu/wanmgr_gpt5/#4-interaction-with-other-middleware-components","title":"4. Interaction with Other Middleware Components","text":"Component Purpose of Interaction Protocols/Mechanisms CCSP Message Bus Component registration; TR\u2011181 parameter get/set callbacks; event registration DBus / CCSP BaseIf (CcspBaseIf_SetCallback) WebConfig Framework Receives/manage configuration blobs, triggers apply callbacks msgpack blob via WebConfig framework (<code>WanMgr_Process_Webconfig_Request</code>) SysEvent Publish/subscribe for lightweight system events sysevent APIs (sysevent) DHCP Client (udhcpc) External DHCP client process invoked or managed; DHCP events processed udhcpc, IPC/handler functions (<code>wanmgr_dhcpv4_apis.c</code>) Cellular Manager (optional) retrieves IP information for cellular interfaces internal update functions such as <code>WanMgr_UpdateIpFromCellularMgr</code>"},{"location":"docu/bhanu/wanmgr_gpt5/#41-middleware-interaction-diagram","title":"4.1 Middleware Interaction Diagram","text":"<pre><code>flowchart TD\n  WebConfig --&gt;|msgpack blob| WanManager\n  WanManager --&gt;|DBus TR\u2011181 APIs| CCSP[(CCSP/MessageBus)]\n  WanManager --&gt;|sysevent publish| SysEvent[(sysevent)]\n  WanManager --&gt;|exec/monitor| udhcpc[(udhcpc DHCP client)]</code></pre>"},{"location":"docu/bhanu/wanmgr_gpt5/#5-interaction-with-other-layers","title":"5. Interaction with Other Layers","text":"<ul> <li>HAL: Platform specific network bring\u2011up/tear\u2011down and hardware info is used by <code>wanmgr_net_utils.*</code> and lower layer helpers.</li> <li>Platform: systemd service, sysctl/netlink helpers, and persistent storage for component state.</li> <li>External: Cloud/controller or local Web UI via WebConfig; these provide configuration blobs and expect TR\u2011181 reflect the current state.</li> </ul> Layer/Service Interaction Description Mechanism HAL Platform network control and link status netutils, ioctl/netlink (via <code>wanmgr_net_utils</code>) Platform Process lifecycle, logging, telemetry systemd, <code>/etc/debug.ini</code>, T2 telemetry External Web UI / Cloud configuration WebConfig msgpack blobs, TR\u2011181 reads/writes"},{"location":"docu/bhanu/wanmgr_gpt5/#51-layered-architecture-view","title":"5.1 Layered Architecture View","text":"<pre><code>graph TD\n  HAL[(HAL / Kernel)] --&gt; WanManager[\ud83d\udce6 RDK\u2011WanManager]\n  WanManager --&gt; Platform[(Platform / systemd / udhcpc)]\n  Platform --&gt; External[(Web UI / Cloud)]</code></pre>"},{"location":"docu/bhanu/wanmgr_gpt5/#6-ipc-mechanism","title":"6. IPC Mechanism","text":"<ul> <li>Type of IPC: Multiple mechanisms used:</li> <li>CCSP/Message Bus (DBus) for TR\u2011181 and component registration.</li> <li>Local IPC server implemented with <code>ipc_msg</code> (see <code>wanmgr_ipc.c</code> / <code>wanmgr_ipc.h</code>) to serve local clients.</li> <li>WebConfig uses msgpack blobs and callback hooks.</li> <li>SysEvent for events.</li> <li>Message Format: TR\u2011181 parameters and DML calls use CCSP conventions. WebConfig uses msgpack formatted blobs. Local IPC uses <code>ipc_msg</code> (custom struct in the codebase).</li> <li>Flow: Synchronous TR\u2011181 get/set calls via message bus; asynchronous WebConfig apply (callback) that parses blob and commits changes; local clients can call into IPC server for forced actions (e.g., <code>Wan_ForceRenewDhcpIPv6</code>, <code>WanMgr_SetInterfaceStatus</code>).</li> </ul>"},{"location":"docu/bhanu/wanmgr_gpt5/#61-ipc-flow-diagram","title":"6.1 IPC Flow Diagram","text":"<pre><code>sequenceDiagram\n    participant Web as WebConfig\n    participant WM as RDK-WanManager\n    participant DML as TR-181/DML layer\n    participant MB as CCSP_MessageBus\n\n    Web-&gt;&gt;WM: WebConfig blob (msgpack)\n    WM-&gt;&gt;WM: WanMgr_Process_Webconfig_Request (parse)\n    WM-&gt;&gt;DML: Marking / WanIf set calls (Marking_SetParam*, WanIf_*SetParam*)\n    DML--&gt;&gt;MB: CcspCcMbi_AddTblRow / commit\n    DML--&gt;&gt;WM: Commit result\n    WM--&gt;&gt;Web: Apply result (BLOB_EXEC_SUCCESS / FAILURE)</code></pre>"},{"location":"docu/bhanu/wanmgr_gpt5/#7-tr181-data-models","title":"7. TR\u2011181 Data Models","text":"<ul> <li>Implemented Parameters: The TR\u2011181 model is defined in <code>config/RdkWanManager.xml</code>. Key objects and parameters include:</li> <li><code>X_RDK_WanManager</code> object<ul> <li><code>Enable</code> (boolean)</li> <li><code>Data</code> (string)</li> <li><code>Policy</code> (mapped uint32 \u2014 e.g., AUTOWAN_MODE(6))</li> <li><code>ResetActiveInterface</code> (boolean)</li> <li><code>AllowRemoteInterfaces</code> (boolean)</li> <li><code>WanFailoverData</code> (string)</li> </ul> </li> <li><code>X_RDK_WanManager.DnsConnectivityCheck.Enable</code> (boolean)</li> <li> <p><code>X_RDK_WanManager.CPEInterface</code> (dynamicTable; maxInstance 128) \u2014 contains:</p> <ul> <li><code>EnableOperStatusMonitor</code> (bool)</li> <li><code>ConfigureWanEnable</code> (bool)</li> <li><code>EnableCustomConfig</code> (bool)</li> <li><code>CustomConfigPath</code> (string)</li> <li><code>Name</code> / <code>DisplayName</code></li> <li>Sub\u2011objects: <code>Phy</code>, <code>Wan</code>, <code>IP</code>, <code>PPP</code> with many config/operational parameters (Enable, Type, OperationalStatus, IPv4Status, IPv6Status, etc.)</li> </ul> </li> <li> <p>Parameter Registration: TR\u2011181 functions are wired via the DML registration. In <code>RdkWanManager.xml</code> the named callbacks are (examples):</p> </li> <li><code>WanManager_GetParamUlongValue</code>, <code>WanManager_SetParamUlongValue</code>, <code>WanManager_GetParamStringValue</code>, <code>WanManager_SetParamStringValue</code>, <code>WanManager_GetParamBoolValue</code>, <code>WanManager_SetParamBoolValue</code>, <code>WanManager_Validate</code>, <code>WanManager_Commit</code> at the <code>X_RDK_WanManager</code> root.</li> <li> <p>Table callbacks for <code>CPEInterface</code> like <code>WanIf_GetEntryCount</code>, <code>WanIf_GetEntry</code>, <code>WanIf_GetParamStringValue</code>, <code>WanIf_SetParamStringValue</code>, <code>WanIf_Validate</code>, <code>WanIf_Commit</code>, <code>WanIf_Rollback</code>.</p> </li> <li> <p>Custom Extensions: <code>X_RDK_*</code> namespace provides RDK extensions such as <code>WanFailoverData</code>, custom marking tables and other RDK specific configuration fields.</p> </li> </ul>"},{"location":"docu/bhanu/wanmgr_gpt5/#71-tr181-parameter-table-sample","title":"7.1 TR\u2011181 Parameter Table (sample)","text":"Parameter Description Access (R/W) Default Notes <code>X_RDK_WanManager.Enable</code> Master enable for wanmanager features R/W true Controls component behavior <code>X_RDK_WanManager.Policy</code> Selection policy enum R/W AUTOWAN_MODE (6) Mapped uint values defined in XML <code>X_RDK_WanManager.CPEInterface.{i}.Wan.Enable</code> Per\u2011interface enable R/W true/false governs interface availability <code>X_RDK_WanManager.CPEInterface.{i}.IP.IPv4Status</code> IPv4 operational status R/W Up/Down reflects current IP stack status"},{"location":"docu/bhanu/wanmgr_gpt5/#8-implementation-details","title":"8. Implementation Details","text":"<ul> <li>Key Algorithms or Logic:</li> <li>Interface selection and failover handled by the policy controller (<code>wanmgr_controller.h</code> / <code>wanmgr_policy_*.c</code>). It tracks <code>WanMgr_Policy_Controller_t</code> state including selected interface indices and timeouts.</li> <li>Per\u2011interface state machines manage operational probes, DHCP client integration and marking table enforcement.</li> <li>WebConfig blob apply algorithm: parse msgpack \u2192 map entries to existing DML entries (match by <code>Name</code>) \u2192 update existing marking entries or add table rows via <code>CcspCcMbi_AddTblRow</code> \u2192 commit marking entries.</li> <li>Error Handling Strategy:</li> <li>Return ANSC_STATUS codes across API boundaries. WebConfig apply returns <code>BLOB_EXEC_SUCCESS</code> / <code>BLOB_EXEC_FAILURE</code> and includes a rollback stub for future extension (<code>WanMgr_WanData_Rollback_Handler</code>).</li> <li>Logging via <code>CcspTrace*</code> macros across modules.</li> <li>Logging &amp; Debugging:</li> <li>Uses <code>rdk_logger_init(\"/etc/debug.ini\")</code> to initialize logging (see <code>wanmgr_main.c</code>).</li> <li>Runtime pid file: <code>/var/tmp/wanmanager.pid</code> is created on startup. WebConfig creates <code>/tmp/wanmanager_initialized</code> to mark successful initialization.</li> </ul>"},{"location":"docu/bhanu/wanmgr_gpt5/#9-key-configuration-files","title":"9. Key Configuration Files","text":"Configuration File Purpose Key Parameters Default Values Override Mechanisms <code>config/RdkWanManager.xml</code> TR\u2011181 data model definition Parameter names &amp; function callback names N/A Build/config macros (see file header) <code>config/RdkWanManager_v2.xml</code> Alternative/extended TR\u2011181 model Additional objects N/A N/A <code>msg_daemon.cfg</code> (message bus config) Message bus configuration file referenced by SSP Bus endpoints N/A system runtime config <code>/etc/debug.ini</code> Logging configuration Trace levels Platform defaults Replace file contents"},{"location":"docu/bhanu/wanmgr_gpt5/#10-api-endpoints-if-applicable","title":"10. API Endpoints (if applicable)","text":"<ul> <li>The component does not expose HTTP endpoints itself; it exposes TR\u2011181 DML APIs and local IPC functions. Key programmatic APIs (C functions / exported symbols) include:</li> </ul> <p>Public lifecycle &amp; core APIs</p> <ul> <li><code>ANSC_STATUS WanMgr_Core_Init(void)</code> \u2014 initialize internal core structures (<code>wanmgr_core.c</code>)</li> <li><code>ANSC_STATUS WanMgr_Core_Start(void)</code> \u2014 start main processing loop</li> <li><code>ANSC_STATUS WanMgr_Core_Finalise(void)</code> \u2014 shutdown/cleanup</li> </ul> <p>Policy / controller APIs</p> <ul> <li><code>ANSC_STATUS WanController_Init_StateMachine(void)</code></li> <li><code>ANSC_STATUS WanMgr_Controller_PolicyCtrlInit(WanMgr_Policy_Controller_t* pWanPolicyCtrl)</code></li> <li><code>ANSC_STATUS WanMgr_Policy_AutoWan(void)</code></li> <li><code>ANSC_STATUS WanMgr_Policy_AutoWanPolicy(void)</code></li> </ul> <p>IPC / control APIs</p> <ul> <li><code>ANSC_STATUS WanMgr_StartIpcServer()</code> \u2014 start IPC server to handle clients (<code>wanmgr_ipc.c</code>)</li> <li><code>ANSC_STATUS Wan_ForceRenewDhcpIPv6(char * ifName)</code> \u2014 force DHCPv6 renew</li> <li><code>ANSC_STATUS WanMgr_SetInterfaceStatus(char *ifName, wanmgr_iface_status_t state)</code> \u2014 set interface state</li> </ul> <p>DHCP &amp; DML APIs (examples)</p> <ul> <li><code>ANSC_STATUS wanmgr_handle_dhcpv4_event_data(DML_VIRTUAL_IFACE* pVirtIf)</code> \u2014 process DHCPv4 events</li> <li><code>ANSC_STATUS IPCPStateChangeHandler (DML_VIRTUAL_IFACE* pVirtIf)</code> \u2014 IPCP state changes for PPP/IPv6</li> <li><code>ANSC_STATUS WanMgr_DmlDhcpInit(ANSC_HANDLE hDml, PANSC_HANDLE phContext)</code> \u2014 DHCP DML init</li> <li>Multiple DML list/get/set functions: <code>WanMgr_DmlDhcpcGetNumberOfEntries</code>, <code>WanMgr_DmlDhcpcGetEntry</code>, <code>WanMgr_DmlDhcpcSetCfg</code>, <code>WanMgr_DmlDhcpcRenew</code>, etc. (see <code>wanmgr_dhcpv4_apis.h</code>)</li> </ul> <p>SSP / MessageBus APIs (component callbacks)</p> <ul> <li><code>ANSC_STATUS ssp_Mbi_MessageBusEngage(char* component_id, char* config_file, char* path)</code></li> <li><code>int ssp_Mbi_Initialize(void* user_data)</code></li> <li><code>int ssp_Mbi_Finalize(void* user_data)</code></li> <li><code>int ssp_Mbi_Buscheck(void* user_data)</code></li> <li><code>int ssp_Mbi_FreeResources(int priority, void* user_data)</code></li> </ul> <p>DML callbacks named in <code>RdkWanManager.xml</code> (examples):</p> <ul> <li><code>WanManager_GetParamUlongValue</code></li> <li><code>WanManager_SetParamUlongValue</code></li> <li><code>WanIf_GetEntryCount</code>, <code>WanIf_GetEntry</code>, <code>WanIf_GetParamStringValue</code>, <code>WanIf_SetParamStringValue</code>, <code>WanIf_Commit</code> (see <code>wanmgr_data.h</code> and TR\u2011181 XML)</li> </ul>"},{"location":"docu/bhanu/wanmgr_gpt5/#11-deployment-runtime-environment","title":"11. Deployment &amp; Runtime Environment","text":"<ul> <li>Container Runtime: Typically runs on bare RDK\u2011B image under systemd. Deployed as a system service <code>wanmanager</code>.</li> <li>Orchestration: systemd unit (platform packaging) manages the process.</li> <li>Resource Requirements: Small system process \u2014 typical embedded requirements (low MBs of RAM). Specific CPU/memory depend on telemetry and feature flags.</li> <li>Supported Platforms: RDK\u2011B targets (Linux / Board specific network stacks). Source contains board specific ML support under <code>TR\u2011181/board_*</code> directories.</li> <li>Startup Parameters: <code>wanmanager</code> accepts <code>-c</code> to run in foreground (non\u2011daemon) and <code>-subsys &lt;prefix&gt;</code> to set component prefix (see <code>wanmgr_main.c</code>).</li> </ul>"},{"location":"docu/bhanu/wanmgr_gpt5/#12-monitoring-security","title":"12. Monitoring &amp; Security","text":"<ul> <li>Monitoring:</li> <li>Telemetry hooks (T2) via <code>wanmgr_t2_telemetry.c</code> and <code>wanmgr_telemetry.c</code> when <code>ENABLE_FEATURE_TELEMETRY2_0</code> is enabled.</li> <li>Logs via <code>rdk_logger</code> and <code>CcspTrace*</code> macros; PID file <code>/var/tmp/wanmanager.pid</code> created.</li> <li>Authentication &amp; Authorization: Uses CCSP/MessageBus security model (component registration) and system capabilities management code attempts to drop root caps in <code>wanmgr_main.c</code>.</li> <li>Auditing &amp; Compliance: Uses existing RDK logging &amp; telemetry; no special GDPR/HIPAA features embedded in component code itself.</li> </ul>"},{"location":"docu/bhanu/wanmgr_gpt5/#13-validation-review-checklist","title":"13. Validation &amp; Review Checklist","text":"<ul> <li>[x] Deployment Accuracy: Process boundary accurately represented (single systemd process).</li> <li>[x] Communication Specificity: Protocols labeled (DBus/CCSP, msgpack/WebConfig, ipc_msg, sysevent).</li> <li>[x] Scaling Representation: <code>CPEInterface</code> table supports multiple instances; marking entries are per\u2011interface.</li> <li>[x] Technology Versions: Source uses C + RDK CCSP frameworks; specific lib versions come from platform build system.</li> <li>[x] Implementation Details: Filenames and function names included above.</li> <li>[x] Visual Hierarchy: Mermaid diagrams use classDef and subgraphs to distinguish runtimes/components.</li> <li>[x] Protocol Labels: Connection labels include formats (msgpack, DBus) and purposes.</li> <li>[x] Mermaid Syntax: Diagrams use <code>graph</code>, <code>flowchart</code> and <code>sequenceDiagram</code> variants; verify in MkDocs with Mermaid plugin.</li> <li>[x] TR\u2011181 Coverage: Key parameters and DML callbacks from <code>config/RdkWanManager.xml</code> are documented.</li> <li>[x] Code Accuracy: Key function names and file paths extracted from the source tree.</li> </ul>"},{"location":"docu/bhanu/wanmgr_gpt5/#14-conclusion-next-steps","title":"14. Conclusion &amp; Next Steps","text":"<p>RDK\u2011WanManager is the middleware component that centralizes WAN selection, policy enforcement and TR\u2011181 DML handling for WAN interfaces. The documentation above fills the RDK\u2011B template with the implementation details discovered in the <code>wan-manager</code> source tree. Recommended next steps:</p> <ul> <li>Add a small examples section with common WebConfig blobs and their expected TR\u2011181 side effects (testing/QA asset).</li> <li>Add unit tests or integration tests that exercise WebConfig apply logic and policy selection (there are tests in the <code>test/</code> folder \u2014 see <code>RdkWanManagerTest.cpp</code>).</li> <li>Maintain a short runbook with troubleshooting steps (how to force DHCP renew, where to find logs and telemetry counters).</li> </ul> <p>Requirements coverage: - Followed <code>rdkb-document-template.md</code> structure exactly: All numbered sections present and populated. - Applied <code>workflow.md</code> steps: code analysis (files listed), data extraction (APIs, configs), diagrams created, validation checklist applied. - Mermaid diagrams follow <code>diagram-guidelines.md</code> rules: subgraphs for deployment, protocol labels, and classDef styling.</p> <p>Files referenced (key paths): - <code>source/WanManager/wanmgr_core.c</code>, <code>wanmgr_main.c</code>, <code>wanmgr_data.h</code>, <code>wanmgr_interface_sm.c</code>, <code>wanmgr_ipc.c</code>, <code>wanmgr_webconfig_apis.c</code>, <code>wanmgr_dhcpv4_apis.h</code>, <code>wanmgr_ssp_action.c</code>. - <code>config/RdkWanManager.xml</code>, <code>config/RdkWanManager_v2.xml</code>.</p> <p>Verification performed: inspected the source files above and extracted public APIs, DML callbacks listed in XML and the WebConfig apply flow. Please tell me if you want this document written to a different filename or if you'd like me to also add a small example WebConfig blob and a short test script to exercise it.</p>"},{"location":"docu/bhanu/wanmgr_gpt5/#15-examples-tests","title":"15. Examples &amp; Tests","text":"<p>This section provides concrete WebConfig blob examples (msgpack) and two test approaches you can use on a development device or in CI to exercise the WebConfig apply logic implemented in <code>wanmgr_webconfig_*.c</code>.</p>"},{"location":"docu/bhanu/wanmgr_gpt5/#151-example-1-simple-wanfailoverdata-blob-json-msgpack","title":"15.1 Example 1 \u2014 Simple WanFailoverData blob (JSON -&gt; msgpack)","text":"<p>This example enables the \"allow_remote_interfaces\" flag in the <code>wanfailover</code> subdocument.</p> <p>JSON representation (easy to read):</p> <pre><code>{\n  \"wanfailover\": {\n    \"allow_remote_interfaces\": true\n  }\n}\n</code></pre> <p>Python helper to produce a msgpack blob file (<code>make_wan_blob.py</code>):</p> <pre><code>#!/usr/bin/env python3\n\"\"\"\nCreate a WebConfig msgpack blob for WAN Manager and write it to disk.\nRequires: pip install msgpack\n\"\"\"\nimport msgpack\nimport sys\n\nblob = {\n    \"wanfailover\": {\n        \"allow_remote_interfaces\": True\n    }\n}\n\nout = 'wan_blob.msgpack'\nwith open(out, 'wb') as f:\n    f.write(msgpack.packb(blob))\n\nprint(f'Wrote {out} ({len(open(out, \"rb\").read())} bytes)')\n\nif __name__ == '__main__':\n    pass\n</code></pre> <p>Usage (on your workstation or the target device if Python/msgpack is available):</p> <pre><code># create msgpack blob\npython3 make_wan_blob.py\n\n# copy to device (if creating locally)\n# scp wan_blob.msgpack root@device:/tmp/wan_blob.msgpack\n</code></pre> <p>How to apply the blob on a device (options): - If your platform provides a WebConfig CLI or REST API, use that to apply <code>/tmp/wan_blob.msgpack</code> as a WebConfig subdocument for the WanManager component. - For a direct in\u2011process unit test (see next example) you can load the blob bytes and call the component's WebConfig handler function <code>WanMgrDmlWanFailOverDataSet</code> from a unit test binary.</p>"},{"location":"docu/bhanu/wanmgr_gpt5/#152-example-2-python-larger-blob-interface-marking","title":"15.2 Example 2 \u2014 Python + larger blob (interface + marking)","text":"<p>JSON example that configures a virtual interface entry and a marking row (human readable):</p> <pre><code>{\n  \"CPEInterface\": [\n    {\n      \"Name\": \"wan0\",\n      \"Marking\": [\n        { \"Alias\": \"DATA\", \"EthernetPriorityMark\": 5 }\n      ]\n    }\n  ]\n}\n</code></pre> <p>You can extend the <code>make_wan_blob.py</code> script above to include this structure and produce a larger blob. The WebConfig apply logic in <code>wanmgr_webconfig_apis.c</code> will try to match <code>Name</code> to an existing DML interface and then add/commit marking rows via <code>CcspCcMbi_AddTblRow</code>.</p>"},{"location":"docu/bhanu/wanmgr_gpt5/#153-unit-test-c-gtest-call-webconfig-handler-directly","title":"15.3 Unit test (C++ / gtest) \u2014 call WebConfig handler directly","text":"<p>If you want to exercise the component code directly in CI (recommended for deterministic verification), add a small gtest that packs a msgpack blob and calls the <code>WanMgrDmlWanFailOverDataSet</code> function exposed by the WebConfig module. The sample below shows a minimal test you can place under the component <code>test/</code> folder (e.g. <code>test/TestWanWebConfig.cpp</code>). It depends on <code>msgpack-c</code> and your component build artifacts.</p> <pre><code>// test/TestWanWebConfig.cpp\n#include &lt;gtest/gtest.h&gt;\n#include &lt;msgpack.h&gt;\n#include \"ansc_status.h\"\n\n// The WebConfig entry point in the WAN manager implementation\nextern ANSC_STATUS WanMgrDmlWanFailOverDataSet(const void* pData, size_t len);\n\nTEST(WanMgrWebConfig, WanFailoverApply)\n{\n    // Build msgpack for: { \"wanfailover\": { \"allow_remote_interfaces\": true } }\n    msgpack_sbuffer sbuf;\n    msgpack_sbuffer_init(&amp;sbuf);\n\n    msgpack_packer pk;\n    msgpack_packer_init(&amp;pk, &amp;sbuf, msgpack_sbuffer_write);\n\n    // outer map with 1 key\n    msgpack_pack_map(&amp;pk, 1);\n\n    // key: \"wanfailover\"\n    const char* k1 = \"wanfailover\";\n    msgpack_pack_str(&amp;pk, strlen(k1));\n    msgpack_pack_str_body(&amp;pk, k1, strlen(k1));\n\n    // value: map with one boolean field\n    msgpack_pack_map(&amp;pk, 1);\n    const char* k2 = \"allow_remote_interfaces\";\n    msgpack_pack_str(&amp;pk, strlen(k2));\n    msgpack_pack_str_body(&amp;pk, k2, strlen(k2));\n    msgpack_pack_true(&amp;pk);\n\n    // Call the component handler\n    ANSC_STATUS status = WanMgrDmlWanFailOverDataSet(sbuf.data, sbuf.size);\n\n    // Expect success in a real test environment where the data layer is initialized\n    // If run in isolation you may need to initialize the component's data (WanMgr_Data_Init)\n    EXPECT_EQ(status, ANSC_STATUS_SUCCESS);\n\n    msgpack_sbuffer_destroy(&amp;sbuf);\n}\n</code></pre> <p>Build &amp; run notes for the gtest example:</p> <ul> <li>Add <code>TestWanWebConfig.cpp</code> to the <code>test/</code> directory and update <code>test/Makefile.am</code> (or the project's test build system) to compile and link the file. Link against:</li> <li>component object files (the files containing <code>WanMgrDmlWanFailOverDataSet</code> / <code>wanmgr_webconfig_apis.c</code>)</li> <li><code>msgpack-c</code> (libmsgpackc)</li> <li>gtest (or your project's test framework)</li> </ul> <p>Example g++ (conceptual) \u2014 adjust include paths and libs to your build environment:</p> <pre><code>g++ -std=c++11 -I/path/to/msgpack/include -I/path/to/wanmgr/include \\\n    test/TestWanWebConfig.cpp \\\n    &lt;component_objects_or_libs&gt; -lmsgpackc -lgtest -lpthread -o TestWanWebConfig\n\n# run\n./TestWanWebConfig\n</code></pre> <p>Notes and troubleshooting: - The unit test above calls the WebConfig handler directly; some functions expect the component data model to be initialized (e.g., <code>WanMgr_Data_Init</code>) and for TR\u2011181 tables to be present. In CI you can initialize the minimal environment by calling <code>WanMgr_Data_Init()</code> before invoking the handler or mocking the DML functions. - If you prefer a pure black\u2011box test, use the Python msgpack producer and then apply the blob through the platform WebConfig CLI/REST API and assert the expected TR\u2011181 changes (read back parameters via DBus or rbus).</p>"},{"location":"docu/bhanu/wanmgr_gpt5/#154-quick-smoke-test-checklist","title":"15.4 Quick smoke test checklist","text":"<ol> <li>Produce blob:</li> </ol> <pre><code>python3 make_wan_blob.py\n</code></pre> <ol> <li> <p>Copy to device and apply via WebConfig framework or run the unit test binary that calls <code>WanMgrDmlWanFailOverDataSet</code>.</p> </li> <li> <p>Verify results:</p> </li> <li>Confirm TR\u2011181 parameter <code>X_RDK_WanManager.WanFailoverData</code> or <code>X_RDK_WanManager.CPEInterface.{i}.Wan.Refresh</code> changed as expected using the platform DBus/CCSP tools or <code>rbus</code>/<code>dmcli</code> utilities.</li> <li> <p>Check <code>wanmanager</code> logs (CcspTrace / <code>/var/log/</code>) for WebConfig apply messages and commit traces.</p> </li> <li> <p>Cleanup: remove temporary blob files and revert test changes via TR\u2011181 or CCSP calls.</p> </li> </ol>"},{"location":"docu/oct21/gponmanager/","title":"GPON Manager Documentation","text":"<p>The GPON Manager (RdkGponManager) is a critical RDK-B middleware component responsible for managing Gigabit-capable Passive Optical Network (GPON) interfaces and optical transceivers in residential gateway devices. This component serves as the middleware layer between the RDK-B framework and the underlying GPON Hardware Abstraction Layer (HAL), providing standardized TR-181 data model access, link state management, and optical network configuration capabilities.</p> <p>The component abstracts the complexity of GPON optical network management, enabling higher-level RDK-B components and external management systems to control and monitor GPON connections through well-defined interfaces. As fiber-optic broadband becomes increasingly prevalent, the GPON Manager ensures reliable and standardized management of high-speed optical network connections in RDK-B deployments.</p> <pre><code>graph LR\n    subgraph \"External Systems\"\n        ACS[ACS/TR-069 Server]\n        NMS[Network Management System]\n        OLT[Optical Line Terminal]\n    end\n\n    subgraph \"RDK-B Middleware\"\n        WM[WAN Manager]\n        TR069[TR-069 PA]\n        GPON[GPON Manager]\n        PSM[PSM]\n        CCSP[CCSP Common Library]\n    end\n\n    subgraph \"Platform Layer\"\n        HAL[(GPON HAL)]\n        Kernel[(Linux Kernel)]\n        HW[(GPON Hardware)]\n    end\n\n\n    ACS --&gt;|TR-069/CWMP| TR069\n    NMS --&gt;|SNMP/HTTP| WM\n\n    TR069 --&gt;|DBus/RBus| GPON\n    WM --&gt;|DBus/RBus| GPON\n    GPON --&gt;|DBus/RBus| PSM\n\n    GPON --&gt;|JSON RPC| HAL\n    HAL --&gt;|Drivers| Kernel\n    Kernel --&gt;|Device Interface| HW\n    OLT &lt;--&gt;|Optical Signal| HW\n\n\n    classDef external fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n    classDef middleware fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n\n    classDef platform fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n\n    class ACS,NMS,OLT external;\n    class WM,TR069,GPON,PSM,CCSP middleware;\n\n    class HAL,Kernel,HW platform;</code></pre> <p>Key Features &amp; Responsibilities: </p> <ul> <li>GPON Interface Management: Manages physical GPON interfaces including status monitoring, configuration, and operational state control for multiple PON technologies (GPON, XG-PON, NG-PON2, XGS-PON)</li> <li>TR-181 Data Model Implementation: Implements comprehensive TR-181 data models for X_RDK_ONT objects including PhysicalMedia, GTC, PLOAM, OMCI, GEM, and VEIP parameters with full read/write access control</li> <li>HAL Abstraction &amp; Integration: Provides JSON-based HAL interface abstraction for vendor-specific GPON implementations, enabling standardized communication between middleware and hardware layers</li> <li>State Machine Management: Orchestrates GPON link state machines for connection establishment, maintenance, and recovery operations with event-driven state transitions</li> <li>Performance Monitoring: Collects and reports GPON performance metrics, optical power levels, and link quality statistics for network optimization and troubleshooting</li> <li>Event-Driven Architecture: Publishes real-time events for GPON state changes, alarms, and performance thresholds to enable responsive network management</li> </ul>"},{"location":"docu/oct21/gponmanager/#design","title":"Design","text":"<p>The GPON Manager follows a layered architecture design with clear separation of concerns between TR-181 data model management, business logic control, and hardware abstraction. The component is designed as a single-threaded event-driven application that leverages the RDK-B Common Component Software Platform (CCSP) framework for inter-process communication and configuration management. The design emphasizes reliability and fault tolerance through comprehensive state machine implementation and robust error handling mechanisms.</p> <p>The component's architecture integrates seamlessly with the broader RDK-B ecosystem through DBus/RBus messaging for northbound communications with other middleware components like WAN Manager and TR-069 Protocol Adapter. Southbound interactions with the GPON HAL are handled through a JSON-based protocol that provides vendor-agnostic hardware abstraction while maintaining high performance and low latency requirements essential for real-time optical network management.</p> <p>Data persistence is managed through integration with CCSP PSM (Persistent Storage Manager) for configuration storage and retrieval, ensuring that GPON settings survive system reboots and firmware upgrades. The component also implements comprehensive logging and telemetry capabilities to support network operations and troubleshooting activities.</p> <pre><code>graph TD\n    subgraph GponManagerContainer [\"GPON Manager Process (C/Linux)\"]\n        subgraph SSPModule [\"SSP (Service Provider)\"]\n            SSPMain[SSP Main]\n            SSPMessageBus[Message Bus Interface]\n            SSPAction[Action Handler]\n        end\n\n        subgraph TR181Module [\"TR-181 Data Model Layer\"]\n            DMLPlugin[DML Plugin Main]\n            DMLBackend[Backend Manager]\n            DMLObjects[Object Handlers]\n            DMLHALInterface[HAL Interface]\n        end\n\n        subgraph CoreLogic [\"Core Management Logic\"]\n            Controller[GPON Controller]\n            StateMachine[Link State Machine]\n            DataStructures[Data Structures]\n        end\n\n        subgraph ConfigMgmt [\"Configuration Management\"]\n            ConfigLoader[Config Loader]\n            SchemaValidator[Schema Validator]\n        end\n    end\n\n    subgraph ExternalInterfaces [\"External Interfaces\"]\n        DBusRBus[(DBus/RBus)]\n        GPONHAL[(GPON HAL)]\n        PSM[(CCSP PSM)]\n        FileSystem[(Config Files)]\n    end\n\n    SSPMessageBus --&gt;|Register/Subscribe| DBusRBus\n    TR181Module --&gt;|Parameter Get/Set| DBusRBus\n    DMLHALInterface --&gt;|JSON API| GPONHAL\n    ConfigMgmt --&gt;|Read/Write| PSM\n    ConfigLoader --&gt;|Load| FileSystem\n\n    SSPMain --&gt; Controller\n    Controller --&gt; StateMachine\n    TR181Module --&gt; CoreLogic\n    SchemaValidator --&gt; DMLHALInterface\n\n    classDef ssp fill:#ffebee,stroke:#c62828,stroke-width:2px;\n    classDef tr181 fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n    classDef core fill:#e3f2fd,stroke:#1565c0,stroke-width:2px;\n    classDef config fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n    classDef external fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;\n\n    class SSPMain,SSPMessageBus,SSPAction ssp;\n    class DMLPlugin,DMLBackend,DMLObjects,DMLHALInterface tr181;\n    class Controller,StateMachine,DataStructures core;\n    class ConfigLoader,SchemaValidator config;\n    class DBusRBus,GPONHAL,PSM,FileSystem external;</code></pre>"},{"location":"docu/oct21/gponmanager/#prerequisites-and-dependencies","title":"Prerequisites and Dependencies","text":"<p>RDK-B Platform Requirements (MUST):</p> <ul> <li>DISTRO Features: DISTRO_FEATURES must include \"rdkb-gpon\" and \"optical-networking\" flags to enable GPON support and optical interface management</li> <li>Build Dependencies: meta-rdk-broadband layer, ccsp-common-library, ccsp-psm, and hal-gpon recipe dependencies must be present in the build environment</li> <li>RDK-B Components: CCSP PSM (Persistent Storage Manager), CCSP Common Library, and CCSP Message Bus components must be running and accessible</li> <li>HAL Dependencies: GPON HAL implementation conforming to RDK GPON HAL API specification version 1.0 or higher with JSON schema support</li> <li>Systemd Services: ccsp-psm.service and ccsp-msg-bus.service must be active before GPON Manager initialization</li> <li>Hardware Requirements: SFP/SFP+ optical transceiver slots, GPON optical interface hardware, and vendor-specific optical PHY drivers</li> </ul> <p>RDK-B Integration Requirements (MUST):</p> <ul> <li>Message Bus: DBus registration with destination name \"eRT.com.cisco.spvtg.ccsp.gponmanager\" and RBus namespace \"Device.X_RDK_ONT\" reserved for TR-181 parameter access </li> <li>TR-181 Data Model: PSM must support Device.X_RDK_ONT.* parameter persistence and WAN Manager must recognize GPON interface types in Device.X_RDK_WanManager configuration </li> <li>Configuration Files: /etc/rdk/conf/gpon_manager_conf.json and /etc/rdk/schemas/gpon_hal_schema.json must be present with proper permissions and valid content </li> <li>Startup Order: Must initialize after CCSP PSM and Message Bus but before WAN Manager and TR-069 Protocol Adapter to ensure proper dependency resolution </li> <li>Resource Constraints: Minimum 8MB RAM allocation, 1MB persistent storage space, and low-latency access to optical hardware interfaces for real-time monitoring </li> </ul> <p>Performance &amp; Optimization (SHOULD):</p> <ul> <li>Enhanced Features: DISTRO_FEATURES += \"wan-manager-unification\" enables enhanced integration with unified WAN management features </li> <li>Recommended Hardware: Multi-port SFP+ modules and redundant optical transceivers improve reliability and performance monitoring capabilities </li> <li>Configuration Tuning: hal_schema_path optimization and server_port configuration (default 40100) for optimal HAL communication performance </li> <li>Monitoring Integration: Integration with RDKB Telemetry 2.0 for advanced optical performance metrics and proactive fault detection </li> </ul> <p>RDK-B Design Limitations &amp; Considerations:</p> <ul> <li>Known Limitations: Currently supports maximum 128 physical media instances, single GPON controller per device, and synchronous HAL communication model </li> <li>Scalability Boundaries: Maximum 4 optical transceivers per device, 1Gbps monitoring data throughput, and 100ms maximum response time for TR-181 parameter operations </li> <li>Platform Compatibility: Supports RDK-B 2019.2 and later versions, ARM and x86_64 architectures, and requires Linux kernel 4.14+ for optimal optical driver support </li> <li>Resource Usage: Typical memory footprint 4-6MB RSS, CPU usage &lt;2% during normal operation, with peaks up to 10% during optical link state transitions </li> </ul> <p>Dependent Components: - WAN Manager relies on GPON Manager for optical interface status and configuration when GPON is selected as the primary WAN technology  - TR-069 Protocol Adapter depends on GPON Manager's TR-181 implementation for remote optical network management and diagnostic capabilities  - Network Service Manager requires GPON link state information for proper network service activation and failover scenarios </p> <p>Threading Model</p> <ul> <li>Threading Architecture: Single-threaded event-driven application using the CCSP framework's main event loop for message processing and state management </li> <li>Main Thread: Handles all TR-181 parameter operations, DBus message processing, HAL communication, state machine transitions, and configuration management operations </li> <li>Synchronization: Uses CCSP framework's built-in synchronization mechanisms and atomic operations for shared data access, with mutex protection for critical sections during HAL  operations </li> </ul>"},{"location":"docu/oct21/gponmanager/#component-state-flow","title":"Component State Flow","text":""},{"location":"docu/oct21/gponmanager/#initialization-to-active-state","title":"Initialization to Active State","text":"<p>The GPON Manager follows a structured initialization sequence that ensures all dependencies are properly established before entering active service mode. The component progresses through distinct states with comprehensive validation at each step to guarantee reliable operation in production environments.</p> <pre><code>stateDiagram-v2\n    [*] --&gt; Initializing\n    Initializing --&gt; LoadingConfig: SSP Framework Ready\n    LoadingConfig --&gt; ValidatingSchema: Config Files Loaded\n    ValidatingSchema --&gt; RegisteringTR181: HAL Schema Validated\n    RegisteringTR181 --&gt; ConnectingHAL: Data Model Registered\n    ConnectingHAL --&gt; DiscoveringHardware: HAL Connection Established\n    DiscoveringHardware --&gt; Active: Hardware Inventory Complete\n    Active --&gt; LinkStateChange: Optical Event\n    LinkStateChange --&gt; Active: State Updated\n    Active --&gt; HALReconnect: HAL Communication Lost\n    HALReconnect --&gt; Active: HAL Reconnected\n    Active --&gt; ConfigUpdate: Configuration Change\n    ConfigUpdate --&gt; Active: Config Applied\n    Active --&gt; Shutdown: Stop Request\n    Shutdown --&gt; [*]\n\n    note right of Initializing\n        - Initialize CCSP framework\n        - Setup logging subsystem\n        - Create message bus connection\n        - Initialize data structures\n    end note\n\n    note right of LoadingConfig\n        - Load gpon_manager_conf.json\n        - Validate configuration parameters\n        - Initialize HAL communication settings\n    end note\n\n    note right of Active\n        - Process TR-181 requests\n        - Monitor optical link status\n        - Handle HAL events\n        - Execute state machine logic\n        - Report telemetry data\n    end note</code></pre>"},{"location":"docu/oct21/gponmanager/#runtime-state-changes-and-context-switching","title":"Runtime State Changes and Context Switching","text":"<p>During normal operation, the GPON Manager continuously monitors optical link conditions and responds to various triggers that require state transitions or operational context changes. These runtime changes ensure optimal network performance and rapid recovery from fault conditions.</p> <p>State Change Triggers: - Optical link up/down events trigger immediate state machine evaluation and potential WAN interface status updates - SFP module insertion/removal events cause hardware discovery re-initialization and TR-181 parameter updates - HAL communication failures trigger automatic reconnection attempts and error reporting to dependent components - Configuration parameter changes via TR-181 interface cause validation and application of new settings with rollback capability</p> <p>Context Switching Scenarios: - Redundancy switching between primary and standby optical interfaces when hardware failure is detected - PON mode transitions (GPON to XG-PON) based on optical transceiver capabilities and operator configuration - Power management mode changes for energy efficiency optimization during low-traffic periods</p>"},{"location":"docu/oct21/gponmanager/#call-flow","title":"Call Flow","text":""},{"location":"docu/oct21/gponmanager/#primary-call-flows","title":"Primary Call Flows","text":"<p>Initialization Call Flow:</p> <pre><code>sequenceDiagram\n    participant SystemD as SystemD\n    participant GponMgr as GPON Manager\n    participant CCSP as CCSP Framework\n    participant PSM as CCSP PSM\n    participant HAL as GPON HAL\n\n    SystemD-&gt;&gt;GponMgr: Start Service\n    GponMgr-&gt;&gt;CCSP: Initialize SSP Framework\n    CCSP--&gt;&gt;GponMgr: Framework Ready\n    GponMgr-&gt;&gt;GponMgr: Load Configuration Files\n    GponMgr-&gt;&gt;PSM: Connect to PSM\n    PSM--&gt;&gt;GponMgr: PSM Connection Established\n    GponMgr-&gt;&gt;CCSP: Register TR-181 Data Model\n    CCSP--&gt;&gt;GponMgr: Registration Complete\n    GponMgr-&gt;&gt;HAL: Initialize HAL Connection (JSON)\n    HAL--&gt;&gt;GponMgr: HAL Ready + Hardware Status\n    GponMgr-&gt;&gt;SystemD: Service Ready (sd_notify)</code></pre> <p>TR-181 Parameter Get Request Processing:</p> <pre><code>sequenceDiagram\n    participant Client as TR-069 PA / WAN Manager\n    participant GponMgr as GPON Manager\n    participant DML as DML Layer\n    participant HAL as GPON HAL\n\n    Client-&gt;&gt;GponMgr: DBus Get Parameter Request\n    GponMgr-&gt;&gt;DML: Route to Parameter Handler\n    DML-&gt;&gt;DML: Validate Parameter Path\n    DML-&gt;&gt;HAL: JSON getParameters Request\n    HAL--&gt;&gt;DML: JSON Response with Values\n    DML-&gt;&gt;DML: Format TR-181 Response\n    DML--&gt;&gt;GponMgr: Parameter Value\n    GponMgr--&gt;&gt;Client: DBus Response</code></pre> <p>Optical Link State Change Event Flow:</p> <pre><code>sequenceDiagram\n    participant Hardware as Optical Hardware\n    participant HAL as GPON HAL\n    participant GponMgr as GPON Manager\n    participant StateMachine as Link State Machine\n    participant WanMgr as WAN Manager\n\n    Hardware-&gt;&gt;HAL: Link Status Change Interrupt\n    HAL-&gt;&gt;GponMgr: JSON publishEvent (LinkStatus)\n    GponMgr-&gt;&gt;StateMachine: Process Link Event\n    StateMachine-&gt;&gt;StateMachine: Evaluate State Transition\n    StateMachine-&gt;&gt;GponMgr: Update Internal State\n    GponMgr-&gt;&gt;WanMgr: DBus Interface Status Event\n    GponMgr-&gt;&gt;GponMgr: Update TR-181 Parameters</code></pre>"},{"location":"docu/oct21/gponmanager/#tr181-data-models","title":"TR\u2011181 Data Models","text":""},{"location":"docu/oct21/gponmanager/#supported-tr-181-parameters","title":"Supported TR-181 Parameters","text":"<p>The GPON Manager implements a comprehensive set of TR-181 parameters under the Device.X_RDK_ONT namespace, providing standardized access to GPON physical media properties, VEIP (Virtual Ethernet Interface Point) configuration, and optical performance metrics. The implementation follows BBF TR-181 specification principles while incorporating RDK-specific extensions for advanced optical network management.</p>"},{"location":"docu/oct21/gponmanager/#object-hierarchy","title":"Object Hierarchy","text":"<pre><code>Device.\n\u2514\u2500\u2500 X_RDK_ONT.\n    \u251c\u2500\u2500 PhysicalMedia.{i}.\n    \u2502   \u251c\u2500\u2500 Cage (uint32, R)\n    \u2502   \u251c\u2500\u2500 ModuleVendor (string, R)\n    \u2502   \u251c\u2500\u2500 ModuleName (string, R)\n    \u2502   \u251c\u2500\u2500 ModuleVersion (string, R)\n    \u2502   \u251c\u2500\u2500 ModuleFirmwareVersion (string, R)\n    \u2502   \u251c\u2500\u2500 PonMode (uint32, R)\n    \u2502   \u251c\u2500\u2500 Connector (uint32, R)\n    \u2502   \u251c\u2500\u2500 NominalBitRateDownstream (uint32, R)\n    \u2502   \u251c\u2500\u2500 NominalBitRateUpstream (uint32, R)\n    \u2502   \u251c\u2500\u2500 Enable (boolean, R/W)\n    \u2502   \u251c\u2500\u2500 Status (uint32, R)\n    \u2502   \u251c\u2500\u2500 RedundancyState (uint32, R)\n    \u2502   \u251c\u2500\u2500 PowerOpticalReceived (int, R)\n    \u2502   \u251c\u2500\u2500 PowerOpticalTransmitted (int, R)\n    \u2502   \u251c\u2500\u2500 PowerSupplyVoltage (uint32, R)\n    \u2502   \u251c\u2500\u2500 PowerSupplyCurrent (uint32, R)\n    \u2502   \u251c\u2500\u2500 PowerSupplyTemperature (int, R)\n    \u2502   \u2514\u2500\u2500 Stats.\n    \u2502       \u251c\u2500\u2500 BytesSent (uint64, R)\n    \u2502       \u251c\u2500\u2500 BytesReceived (uint64, R)\n    \u2502       \u251c\u2500\u2500 PacketsSent (uint64, R)\n    \u2502       \u251c\u2500\u2500 PacketsReceived (uint64, R)\n    \u2502       \u251c\u2500\u2500 ErrorsSent (uint32, R)\n    \u2502       \u251c\u2500\u2500 ErrorsReceived (uint32, R)\n    \u2502       \u2514\u2500\u2500 DiscardPacketsReceived (uint32, R)\n    \u2514\u2500\u2500 Veip.{i}.\n        \u251c\u2500\u2500 Enable (boolean, R/W)\n        \u251c\u2500\u2500 Status (uint32, R)\n        \u251c\u2500\u2500 Name (string, R/W)\n        \u251c\u2500\u2500 LowerLayers (string, R/W)\n        \u251c\u2500\u2500 EthIdType (uint32, R/W)\n        \u251c\u2500\u2500 EthIdValue (uint32, R/W)\n        \u2514\u2500\u2500 Stats.\n            \u251c\u2500\u2500 BytesSent (uint64, R)\n            \u251c\u2500\u2500 BytesReceived (uint64, R)\n            \u251c\u2500\u2500 PacketsSent (uint64, R)\n            \u251c\u2500\u2500 PacketsReceived (uint64, R)\n            \u251c\u2500\u2500 MulticastPacketsSent (uint64, R)\n            \u251c\u2500\u2500 MulticastPacketsReceived (uint64, R)\n            \u251c\u2500\u2500 BroadcastPacketsSent (uint64, R)\n            \u251c\u2500\u2500 BroadcastPacketsReceived (uint64, R)\n            \u251c\u2500\u2500 ErrorsSent (uint32, R)\n            \u251c\u2500\u2500 ErrorsReceived (uint32, R)\n            \u251c\u2500\u2500 UnicastPacketsSent (uint64, R)\n            \u251c\u2500\u2500 UnicastPacketsReceived (uint64, R)\n            \u251c\u2500\u2500 DiscardPacketsSent (uint32, R)\n            \u2514\u2500\u2500 DiscardPacketsReceived (uint32, R)\n</code></pre>"},{"location":"docu/oct21/gponmanager/#parameter-definitions","title":"Parameter Definitions","text":"<p>Core Physical Media Parameters:</p> Parameter Path Data Type Access Default Value Description BBF Compliance <code>Device.X_RDK_ONT.PhysicalMedia.{i}.Cage</code> uint32 R <code>0</code> Optical transceiver cage type where 0=BoB (Ball on Board), 1=SFP (Small Form-factor Pluggable). Indicates the physical form factor of the optical interface. Custom Extension <code>Device.X_RDK_ONT.PhysicalMedia.{i}.ModuleVendor</code> string(256) R <code>\"\"</code> Vendor identification string retrieved from SFP EEPROM data, providing manufacturer information for the installed optical transceiver module. Custom Extension <code>Device.X_RDK_ONT.PhysicalMedia.{i}.PonMode</code> uint32 R <code>0</code> Current PON technology mode: 0=GPON (1.25G/2.5G), 1=XG-PON (10G/2.5G), 2=NG-PON2 (multiple wavelengths), 3=XGS-PON (10G symmetric). Custom Extension <code>Device.X_RDK_ONT.PhysicalMedia.{i}.Enable</code> boolean R/W <code>true</code> Administrative enable/disable control for the optical interface. When false, the interface is administratively disabled and no optical transmission occurs. TR-181 Issue 2 <code>Device.X_RDK_ONT.PhysicalMedia.{i}.Status</code> uint32 R <code>1</code> Operational status: 0=Up (operational), 1=Down (not operational), 2=Unknown, 3=Dormant, 4=NotPresent (no SFP), 5=LowerLayerDown, 6=Error (hardware fault). TR-181 Issue 2 <code>Device.X_RDK_ONT.PhysicalMedia.{i}.PowerOpticalReceived</code> int R <code>-40000</code> Received optical power in units of 0.1 dBm. Range typically -40.0 to +8.0 dBm. Negative values indicate power below 1mW reference level. Custom Extension <p>VEIP Interface Parameters:</p> Parameter Path Data Type Access Default Value Description BBF Compliance <code>Device.X_RDK_ONT.Veip.{i}.Enable</code> boolean R/W <code>false</code> Administrative enable state for Virtual Ethernet Interface Point. Controls whether the VEIP is available for service mapping and traffic forwarding. TR-181 Issue 2 <code>Device.X_RDK_ONT.Veip.{i}.Status</code> uint32 R <code>1</code> VEIP operational status using same enumeration as PhysicalMedia.Status. Reflects the current operational state of the virtual interface. TR-181 Issue 2 <code>Device.X_RDK_ONT.Veip.{i}.LowerLayers</code> string R/W <code>\"\"</code> Comma-separated list of lower layer interface references. Typically references Device.X_RDK_ONT.PhysicalMedia instances that support this VEIP. TR-181 Issue 2 <p>Custom Extensions:</p> <ul> <li>Optical Power Monitoring: Real-time optical power level monitoring parameters (PowerOpticalReceived, PowerOpticalTransmitted) providing 0.1 dBm resolution for network diagnostics and link quality assessment</li> <li>Environmental Sensors: Temperature, voltage, and current monitoring parameters from SFP modules enabling proactive fault detection and thermal management</li> <li>PON Mode Detection: Automatic detection and reporting of installed optical transceiver capabilities and negotiated PON technology mode for optimal performance configuration</li> </ul>"},{"location":"docu/oct21/gponmanager/#parameter-registration-and-access","title":"Parameter Registration and Access","text":"<ul> <li>Implemented Parameters: The component implements all Device.X_RDK_ONT.PhysicalMedia.{i}. and Device.X_RDK_ONT.Veip.{i}. parameters with full read access and selective write access for administrative control parameters.</li> <li>Parameter Registration: Parameters are registered with the CCSP Message Bus using DBus interface with destination \"eRT.com.cisco.spvtg.ccsp.gponmanager\" and object path hierarchy following TR-181 namespace conventions.</li> <li>Access Mechanism: Other RDK-B components access parameters via DBus GetParameterValues/SetParameterValues methods with parameter path resolution handled by the DML (Data Model Layer) backend.</li> <li>Validation Rules: Write operations validate parameter ranges, enumerated values, and dependency constraints. Enable parameters require hardware presence validation, and LowerLayers references are validated against existing interface instances.</li> </ul>"},{"location":"docu/oct21/gponmanager/#internal-modules","title":"Internal Modules","text":"<p>The GPON Manager is architected with distinct modules that provide clear separation of concerns and maintainable code organization. Each module handles specific aspects of GPON management functionality while maintaining well-defined interfaces with other modules.</p> Module/Class Description Key Files SSP (Service Provider) Main application entry point and CCSP framework integration providing process lifecycle management and message bus registration <code>ssp_main.c</code>, <code>ssp_global.h</code>, <code>ssp_messagebus_interface.c</code> GPON Controller Core business logic controller managing GPON operations, hardware discovery, and coordination between other modules <code>gponmgr_controller.c</code>, <code>gponmgr_controller.h</code> Link State Machine Intelligent state management for optical link transitions, redundancy handling, and fault recovery scenarios <code>gponmgr_link_state_machine.c</code>, <code>gponmgr_link_state_machine.h</code> TR-181 DML Layer Data Model Layer implementation providing TR-181 parameter access, validation, and HAL interaction abstraction <code>gponmgr_dml_*.c</code>, <code>gpon_apis.h</code> HAL Interface JSON-based communication layer with vendor GPON HAL implementations including schema validation and error handling <code>gponmgr_dml_hal.c</code>, <code>gponmgr_dml_hal_param.c</code> Configuration Manager Handles configuration file parsing, schema validation, and runtime configuration updates Configuration loading integrated in SSP and Controller modules <pre><code>flowchart TD\n    subgraph GponManager [GPON Manager Component]\n        SSP([SSP Framework])\n        Controller([GPON Controller])\n        StateMachine([Link State Machine])\n        DMLLayer([TR-181 DML Layer])\n        HALInterface([HAL Interface])\n        ConfigMgr([Configuration Manager])\n    end\n\n    SSP --&gt; Controller\n    Controller --&gt; StateMachine\n    Controller --&gt; DMLLayer\n    DMLLayer --&gt; HALInterface\n    ConfigMgr --&gt; Controller\n    ConfigMgr --&gt; HALInterface\n\n    StateMachine --&gt; Controller\n    HALInterface --&gt; Controller\n\n    classDef core fill:#e3f2fd,stroke:#1565c0,stroke-width:2px;\n    classDef interface fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n    classDef framework fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n\n    class Controller,StateMachine core;\n    class DMLLayer,HALInterface interface;\n    class SSP,ConfigMgr framework;</code></pre>"},{"location":"docu/oct21/gponmanager/#component-interactions-ipc-mechanisms","title":"Component Interactions &amp; IPC Mechanisms","text":""},{"location":"docu/oct21/gponmanager/#system-architecture-overview","title":"System Architecture Overview","text":"<p>The GPON Manager integrates deeply with the RDK-B middleware ecosystem through multiple communication channels and interaction patterns. The component serves as a bridge between high-level network management functions and low-level optical hardware control, requiring robust and efficient inter-process communication mechanisms.</p> <pre><code>flowchart TD\n    subgraph \"External Management\"\n        CloudACS[Cloud ACS]\n        LocalWebUI[Local Web UI]\n    end\n\n    subgraph \"RDK-B Middleware Components\"\n        TR069PA[TR-069 Protocol Adapter]\n        WanManager[WAN Manager]\n        PSM[CCSP PSM]\n        Telemetry[Telemetry Agent]\n        NetworkSvcMgr[Network Service Manager]\n    end\n\n    subgraph \"GPON Manager Process\"\n        GponManager[GPON Manager Core]\n        DMLInterface[TR-181 DML Interface]\n        HALClient[HAL JSON Client]\n    end\n\n    subgraph \"Hardware Abstraction\"\n        GponHAL[GPON HAL Server]\n        OpticalDrivers[Optical Drivers]\n        Hardware[SFP/Optical Hardware]\n    end\n\n    CloudACS --&gt;|CWMP/HTTPS| TR069PA\n    LocalWebUI --&gt;|HTTP/HTTPS| TR069PA\n    TR069PA --&gt;|DBus TR-181| DMLInterface\n    WanManager --&gt;|DBus Events/Config| GponManager\n    PSM --&gt;|DBus Config Storage| GponManager\n    Telemetry --&gt;|DBus Metrics| GponManager\n    NetworkSvcMgr --&gt;|DBus Status| GponManager\n\n    DMLInterface --&gt; GponManager\n    GponManager --&gt; HALClient\n    HALClient --&gt;|JSON over TCP:40100| GponHAL\n    GponHAL --&gt;|Vendor API| OpticalDrivers\n    OpticalDrivers --&gt;|I2C/PCIe| Hardware\n\n    classDef external fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n    classDef rdkb fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef gpon fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n    classDef hal fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;\n\n    class CloudACS,LocalWebUI external;\n    class TR069PA,WanManager,PSM,Telemetry,NetworkSvcMgr rdkb;\n    class GponManager,DMLInterface,HALClient gpon;\n    class GponHAL,OpticalDrivers,Hardware hal;</code></pre>"},{"location":"docu/oct21/gponmanager/#detailed-interaction-matrix","title":"Detailed Interaction Matrix","text":"Target Component/Layer Interaction Purpose IPC Mechanism Message Format Communication Pattern Key APIs/Endpoints RDK-B Middleware Components TR-069 Protocol Adapter Remote parameter access for GPON configuration and monitoring DBus CCSP Message Format Request-Response <code>GetParameterValues</code>, <code>SetParameterValues</code>, <code>GetParameterNames</code> WAN Manager GPON interface status reporting and configuration coordination DBus JSON Events/Config Event Notification/Request-Response <code>Device.X_RDK_WanManager.CPEInterface</code>, WAN status events CCSP PSM Persistent configuration storage and retrieval for GPON settings DBus Key-Value Pairs Request-Response <code>PSM_Set_Record_Value2</code>, <code>PSM_Get_Record_Value2</code> Telemetry Agent Optical performance metrics and diagnostic data reporting DBus JSON Telemetry Reports Asynchronous Push Telemetry marker publishing, performance counters System &amp; HAL Layers GPON HAL Hardware control, status monitoring, and configuration management TCP Sockets JSON-RPC with Schema Request-Response/Event Subscription <code>getParameters</code>, <code>setParameters</code>, <code>subscribeEvent</code>, <code>publishEvent</code> Configuration Files Runtime configuration and schema definitions File I/O JSON/XML Synchronous File Access <code>/etc/rdk/conf/gpon_manager_conf.json</code>, <code>/etc/rdk/schemas/gpon_hal_schema.json</code> SystemD Process lifecycle management and service coordination D-Bus System Bus SystemD Messages Service Control <code>sd_notify()</code>, service start/stop/restart External Systems Remote Management Cloud-based GPON configuration and monitoring through TR-069 protocol HTTPS/CWMP XML/SOAP over HTTPS Request-Response via TR-069 PA CWMP GetParameterValues/SetParameterValues for Device.X_RDK_ONT.*"},{"location":"docu/oct21/gponmanager/#event-publishing-subscription","title":"Event Publishing &amp; Subscription","text":"<p>Events Published by GPON Manager:</p> Event Name Event Topic/Path Trigger Condition Payload Format Subscriber Components GponLinkStatusChange <code>Device.X_RDK_ONT.PhysicalMedia.{i}.Status</code> Optical link up/down transition detected JSON: <code>{interface_id, old_status, new_status, timestamp}</code> WAN Manager, Network Service Manager, Telemetry Agent GponModuleInserted <code>Device.X_RDK_ONT.PhysicalMedia.{i}.ModulePresent</code> SFP module insertion detected via I2C presence detection JSON: <code>{interface_id, module_info, capabilities, timestamp}</code> WAN Manager, Configuration Manager GponPowerAlarm <code>Device.X_RDK_ONT.PhysicalMedia.{i}.PowerAlarm</code> Optical power level outside acceptable thresholds JSON: <code>{interface_id, power_rx, power_tx, threshold_type, severity}</code> Telemetry Agent, Network Operations Center GponRedundancySwitch <code>Device.X_RDK_ONT.PhysicalMedia.{i}.RedundancyState</code> Primary/standby optical interface failover JSON: <code>{primary_id, standby_id, switch_reason, timestamp}</code> WAN Manager, Network Service Manager <p>Events Consumed by GPON Manager:</p> Event Source Event Topic/Path Purpose Expected Payload Handler Function WAN Manager <code>Device.X_RDK_WanManager.Interface.{i}.Enable</code> React to WAN interface enable/disable commands JSON: <code>{interface_name, enabled, operation_type}</code> <code>GponMgr_HandleWanInterfaceChange()</code> CCSP PSM <code>Device.X_RDK_ONT.*.</code> Process configuration changes from persistent storage PSM Record: <code>{parameter_name, new_value, old_value}</code> <code>GponMgr_HandleConfigurationChange()</code> GPON HAL <code>gponhal.event.linkStatusChange</code> Hardware-initiated optical link state changes JSON: <code>{port_id, link_status, optical_power, error_code}</code> <code>GponMgr_ProcessHALEvent()</code>"},{"location":"docu/oct21/gponmanager/#ipc-flow-patterns","title":"IPC Flow Patterns","text":"<p>Primary IPC Flow - TR-181 Parameter Access:</p> <pre><code>sequenceDiagram\n    participant TR069 as TR-069 Protocol Adapter\n    participant GponMgr as GPON Manager\n    participant DML as DML Backend\n    participant HAL as GPON HAL\n\n    TR069-&gt;&gt;GponMgr: DBus GetParameterValues (Device.X_RDK_ONT.PhysicalMedia.1.Status)\n    GponMgr-&gt;&gt;DML: Route to Physical Media Handler\n    DML-&gt;&gt;HAL: JSON getParameters {name: \"PhysicalMedia\", instance: 1, parameters: [\"Status\"]}\n    HAL--&gt;&gt;DML: JSON Response {status: \"success\", values: {\"Status\": 0}}\n    DML-&gt;&gt;DML: Map HAL Response to TR-181 Format\n    DML--&gt;&gt;GponMgr: TR-181 Parameter Value\n    GponMgr--&gt;&gt;TR069: DBus Response (success/error)</code></pre> <p>Event Notification Flow:</p> <pre><code>sequenceDiagram\n    participant Hardware as Optical Hardware\n    participant HAL as GPON HAL\n    participant GponMgr as GPON Manager\n    participant WanMgr as WAN Manager\n    participant Telemetry as Telemetry Agent\n\n    Hardware-&gt;&gt;HAL: Link Status Change (GPIO/I2C)\n    HAL-&gt;&gt;GponMgr: JSON publishEvent {event: \"linkStatusChange\", data: {...}}\n    GponMgr-&gt;&gt;GponMgr: Update Internal State &amp; TR-181 Parameters\n    GponMgr-&gt;&gt;WanMgr: DBus Event Notification\n    GponMgr-&gt;&gt;Telemetry: DBus Metrics Update\n    WanMgr--&gt;&gt;GponMgr: Ack (configuration change)\n    Telemetry--&gt;&gt;GponMgr: Ack (metric received)</code></pre>"},{"location":"docu/oct21/gponmanager/#implementation-details","title":"Implementation Details","text":""},{"location":"docu/oct21/gponmanager/#major-hal-apis-integration","title":"Major HAL APIs Integration","text":"<p>The GPON Manager integrates with the vendor GPON HAL through a JSON-based protocol that provides hardware abstraction while maintaining high performance for real-time optical network management. The HAL interface follows a standardized schema to ensure compatibility across different vendor implementations.</p> <p>Core HAL APIs:</p> HAL API Purpose Parameters Return Values Implementation File <code>getParameters</code> Retrieve current values of GPON hardware parameters including status, power levels, and configuration <code>{name: \"PhysicalMedia\", instance: int, parameters: [string]}</code> <code>{status: \"success/error\", values: {param: value}}</code> <code>gponmgr_dml_hal.c</code> <code>setParameters</code> Configure GPON hardware settings such as enable/disable and power management modes <code>{name: \"PhysicalMedia\", instance: int, parameters: {param: value}}</code> <code>{status: \"success/error\", error_msg: string}</code> <code>gponmgr_dml_hal.c</code> <code>subscribeEvent</code> Register for asynchronous notifications of hardware events like link changes and alarms <code>{events: [\"linkStatusChange\", \"powerAlarm\"], callback_info: {...}}</code> <code>{status: \"success/error\", subscription_id: string}</code> <code>gponmgr_dml_hal.c</code> <code>publishEvent</code> Receive asynchronous event notifications from HAL about hardware state changes <code>{event: string, timestamp: long, data: {...}}</code> N/A (asynchronous callback) <code>gponmgr_dml_hal.c</code> <code>getSchema</code> Retrieve HAL capability information and supported parameter schema <code>{module: \"gponhal\", version: \"1.0\"}</code> <code>{schema: {...}, capabilities: [...]}</code> <code>gponmgr_dml_hal.c</code>"},{"location":"docu/oct21/gponmanager/#key-implementation-logic","title":"Key Implementation Logic","text":"<ul> <li> <p>State Machine Engine: The core state machine implementation resides in <code>gponmgr_link_state_machine.c</code> with the main state transition logic handling optical link up/down events, redundancy switching, and error recovery scenarios. State transition handlers are implemented in the same file with clear separation between state evaluation and action execution.</p> </li> <li> <p>Event Processing: Hardware events from the GPON HAL are processed asynchronously through JSON message parsing and validation in <code>gponmgr_dml_hal.c</code>. The event processing pipeline includes message deserialization, schema validation, and routing to appropriate state machine handlers with comprehensive error checking and logging.</p> </li> <li> <p>Error Handling Strategy: HAL error codes are mapped to standardized RDK-B error conditions with automatic retry logic for transient failures. Critical errors trigger component state transitions and notification to dependent services, while recoverable errors are logged and retried with exponential backoff. Timeout handling ensures that blocking HAL operations don't compromise system responsiveness.</p> </li> <li> <p>Logging &amp; Debugging: State transition logging provides detailed audit trails for troubleshooting optical connectivity issues with configurable verbosity levels. Debug hooks include HAL message tracing, parameter access logging, and performance timing measurements. Special diagnostic modes can be enabled through configuration to support field troubleshooting and vendor HAL validation.</p> </li> </ul>"},{"location":"docu/oct21/gponmanager/#key-configuration-files","title":"Key Configuration Files","text":"<p>The GPON Manager relies on several configuration files that define operational parameters, HAL communication settings, and TR-181 data model structure. These files are essential for proper component initialization and runtime behavior.</p> Configuration File Purpose Key Parameters Default Values Override Mechanisms <code>gpon_manager_conf.json</code> Main runtime configuration <code>hal_schema_path</code>, <code>server_port</code> <code>/etc/rdk/schemas/gpon_hal_schema.json</code>, <code>40100</code> Environment variables, command line parameters <code>gpon_manager_wan_unify_conf.json</code> WAN Manager integration config WAN unification settings N/A Conditional compilation flags <code>RdkGponManager.xml</code> TR-181 data model definitions Object hierarchy, parameter types, access permissions See TR-181 specification Not user-modifiable (code generation) <code>gpon_hal_schema.json</code> HAL interface schema validation Supported HAL operations, parameter constraints, data types Version 0.0.1 schema HAL vendor customization <code>systemd/gpon-manager.service</code> SystemD service configuration Service dependencies, restart policies, resource limits After ccsp-psm.service SystemD override files <p>The main configuration file <code>/etc/rdk/conf/gpon_manager_conf.json</code> contains critical runtime parameters that affect HAL communication and component behavior. The <code>hal_schema_path</code> parameter specifies the location of the JSON schema file used for HAL message validation, while <code>server_port</code> defines the TCP port for HAL communication. These settings can be overridden through environment variables <code>GPON_HAL_SCHEMA_PATH</code> and <code>GPON_HAL_SERVER_PORT</code> respectively, providing flexibility for different deployment scenarios and vendor customizations.</p> <p> write"},{"location":"docu/oct21/onewifi/","title":"OneWifi Documentation","text":"<p>OneWifi is RDK-B's unified Wi-Fi management component that provides a modern, service-oriented architecture for wireless connectivity management. It serves as the central orchestrator for all Wi-Fi operations including access point management, station operations, mesh networking, EasyMesh protocol support, and advanced wireless features. OneWifi consolidates previously fragmented Wi-Fi functionality into a cohesive system that abstracts hardware complexity while providing robust 802.11 protocol implementation and integration with RDK-B middleware components.</p> <p>OneWifi implements IEEE 802.11 protocols (802.11a/b/g/n/ac/ax/be) through direct WiFi HAL integration, manages hostapd for access point operations, provides EasyMesh controller/agent functionality with IEEE 1905 protocol support, and maintains a comprehensive WiFi database for persistent configuration and state management.</p> <pre><code>graph TD\n    subgraph \"External Users &amp; Systems\"\n        HomeUsers[Home Users&lt;br/&gt;\ud83c\udfe0 WiFi Clients]\n        AdminUsers[Admin Users&lt;br/&gt;\ud83d\udc68\u200d\ud83d\udcbc Network Management]\n        CloudServices[Cloud Services&lt;br/&gt;\u2601\ufe0f Remote Management]\n        MeshNodes[EasyMesh Nodes&lt;br/&gt;\ud83d\udd17 Remote Agents]\n    end\n\n    subgraph \"RDK-B Device Boundary\"\n        subgraph \"Management Layer\"\n            WebUI[Web UI&lt;br/&gt;\ud83c\udf10 Local Management]\n            TR069[TR-069 Agent&lt;br/&gt;\ud83d\udce1 ACS Communication]\n            SNMP[SNMP Agent&lt;br/&gt;\ud83d\udcca Network Monitoring]\n        end\n\n        OneWifi[OneWifi Component&lt;br/&gt;\ud83d\udcf6 WiFi Management System&lt;br/&gt;C++ Application]\n\n        subgraph \"RDK-B Middleware\"\n            PSM[PSM Database&lt;br/&gt;\ud83d\udcbe Parameter Storage]\n            Telemetry[Telemetry 2.0&lt;br/&gt;\ud83d\udcc8 Data Collection]\n            WebConfig[WebConfig Framework&lt;br/&gt;\u2699\ufe0f Bulk Configuration]\n        end\n\n        subgraph \"Hardware &amp; Protocol Layer\"\n            WiFiHAL[WiFi HAL&lt;br/&gt;\ud83d\udce1 Hardware Abstraction]\n            NetworkHAL[Network HAL&lt;br/&gt;\ud83d\udd0c Interface Management]\n            Hostapd[hostapd&lt;br/&gt;\ud83c\udfe2 Access Point Daemon]\n        end\n\n        subgraph \"External Mesh System\"\n            UnifiedMesh[Unified-Mesh Controller&lt;br/&gt;\ud83d\udd78\ufe0f IEEE 1905 Protocol]\n        end\n    end\n\n    %% User Interactions\n    HomeUsers --&gt;|WiFi Connection&lt;br/&gt;802.11 Protocols| OneWifi\n    AdminUsers --&gt;|Configuration&lt;br/&gt;Web Interface| WebUI\n    AdminUsers --&gt;|Remote Management&lt;br/&gt;TR-181/SNMP| TR069\n    AdminUsers --&gt;|Network Monitoring&lt;br/&gt;SNMP v2c/v3| SNMP\n\n    %% External System Interactions  \n    CloudServices --&gt;|Remote Configuration&lt;br/&gt;TR-069/WebPA| TR069\n    CloudServices --&gt;|Bulk Updates&lt;br/&gt;JSON/MessagePack| WebConfig\n    MeshNodes &lt;--&gt;|EasyMesh Protocol&lt;br/&gt;IEEE 1905.1| UnifiedMesh\n\n    %% Internal RDK-B Interactions\n    WebUI --&gt;|Parameter Access&lt;br/&gt;RBus/DBus| OneWifi\n    TR069 --&gt;|TR-181 Parameters&lt;br/&gt;RBus Messages| OneWifi\n    SNMP --&gt;|MIB Access&lt;br/&gt;SNMP Protocol| OneWifi\n\n    OneWifi &lt;--&gt;|Configuration Persistence&lt;br/&gt;Key-Value Store| PSM\n    OneWifi --&gt;|Statistics &amp; Events&lt;br/&gt;Telemetry API| Telemetry\n    OneWifi &lt;--&gt;|Bulk Configuration&lt;br/&gt;JSON Validation| WebConfig\n    OneWifi &lt;--&gt;|EasyMesh Coordination&lt;br/&gt;Unix Sockets| UnifiedMesh\n\n    %% Hardware Interactions\n    OneWifi --&gt;|Hardware Control&lt;br/&gt;C API Calls| WiFiHAL\n    OneWifi --&gt;|Interface Management&lt;br/&gt;Network APIs| NetworkHAL\n    OneWifi &lt;--&gt;|AP Configuration&lt;br/&gt;Control Interface| Hostapd\n\n    WiFiHAL --&gt;|Driver Interface&lt;br/&gt;nl80211| OneWifi\n    NetworkHAL --&gt;|Interface Control&lt;br/&gt;netlink/ioctl| OneWifi\n    Hostapd --&gt;|802.11 Management&lt;br/&gt;Event Callbacks| OneWifi\n\n    classDef user fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n    classDef component fill:#e1f5fe,stroke:#0277bd,stroke-width:3px;\n    classDef middleware fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;\n    classDef hardware fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n    classDef external fill:#fce4ec,stroke:#c2185b,stroke-width:2px;\n\n    class HomeUsers,AdminUsers user;\n    class OneWifi component;\n    class WebUI,TR069,SNMP,PSM,Telemetry,WebConfig middleware;\n    class WiFiHAL,NetworkHAL,Hostapd hardware;\n    class CloudServices,MeshNodes,UnifiedMesh external;</code></pre> <p>Key Features &amp; Responsibilities: </p> <ul> <li>Unified Wi-Fi Management: Central orchestration of all wireless operations including radio management, VAP (Virtual Access Point) lifecycle, and client association handling across multiple frequency bands (2.4GHz, 5GHz, 6GHz)</li> <li>Service-Oriented Architecture: Modular design with independent service components for different Wi-Fi functionalities including private networks, public hotspots, mesh operations, and analytics</li> <li>802.11 Protocol Implementation: Direct implementation of IEEE 802.11 standards (a/b/g/n/ac/ax/be) through WiFi HAL abstraction with support for advanced features like MU-MIMO, OFDMA, and beamforming</li> <li>Hostapd Integration: Native hostapd daemon management for access point configuration, client authentication, and 802.11 frame processing with dynamic configuration updates</li> <li>EasyMesh Support: Complete IEEE 1905 Multi-AP protocol implementation with controller and agent capabilities, unified-mesh system integration, and automatic mesh topology management</li> <li>WiFi Database Management: Persistent storage system for configuration data, client information, statistics, and operational state with atomic transaction support</li> <li>Advanced Analytics: Real-time monitoring and analytics including client behavior analysis, performance metrics, security event detection, and network optimization</li> <li>WebConfig Integration: Dynamic configuration management through WebPA/WebConfig protocol with support for bulk configuration updates and rollback capabilities</li> </ul>"},{"location":"docu/oct21/onewifi/#design","title":"Design","text":"<p>OneWifi employs a layered service-oriented architecture that separates concerns while maintaining tight integration for optimal performance. The design prioritizes modularity through independent service components, each responsible for specific Wi-Fi functionality domains, while a central manager coordinates cross-service interactions and maintains global state consistency. The architecture directly interfaces with WiFi HAL for hardware abstraction and hostapd for 802.11 protocol compliance.</p> <p>The northbound interfaces support RBus/DBus messaging for TR-181 parameter access, WebConfig for bulk configuration management, and EasyMesh APIs for mesh networking coordination. Southbound integration includes WiFi HAL for hardware control, hostapd for access point operations, and platform-specific networking services. The WiFi database provides persistent storage with ACID properties, enabling reliable state management across system reboots and configuration changes.</p> <p>IPC mechanisms center around RBus for high-performance message passing between RDK-B components, with fallback DBus support for legacy compatibility. Event-driven architecture ensures responsive handling of hardware events, client state changes, and configuration updates. Data persistence utilizes a custom WiFi database implementation that maintains configuration integrity and supports atomic operations for complex multi-parameter updates.</p> <pre><code>graph TD\n    subgraph \"RDK-B Middleware\"\n        TR181[TR-181 Data Model]\n        WebConfig[WebConfig Framework]\n        Telemetry[Telemetry Service]\n        CCSP[CCSP Components]\n    end\n\n    subgraph \"OneWifi Container (C/C++)\"\n        subgraph \"Core Manager\"\n            WifiMgr[WiFi Manager]\n            WifiCtrl[WiFi Controller]\n            EventMgr[Event Manager]\n            QueueMgr[Queue Manager]\n        end\n\n        subgraph \"Service Layer\"\n            PrivateSvc[Private VAP Service&lt;br/&gt;Home Networks]\n            PublicSvc[Public VAP Service&lt;br/&gt;Hotspots/XHS]\n            MeshSvc[Mesh Service&lt;br/&gt;Backhaul/STA]\n        end\n\n        subgraph \"Application Layer\"\n            Analytics[Analytics App]\n            Harvester[Harvester App]\n            Blaster[Blaster App]\n            CAC[CAC App]\n            CSI[CSI App]\n            EasyMesh[EasyMesh App]\n            StaMgr[STA Manager App]\n        end\n\n        subgraph \"Data &amp; Protocol Layer\"\n            WiFiDB[(WiFi Database)]\n            WebConfigMgr[WebConfig Manager]\n            PlatformBus[Platform Bus Layer&lt;br/&gt;RBus/DBus]\n        end\n    end\n\n    subgraph \"802.11 Protocol &amp; Hardware\"\n        Hostapd[hostapd Daemon&lt;br/&gt;AP Management]\n        WpaSupplicant[wpa_supplicant&lt;br/&gt;STA Operations]\n        WiFiHAL[WiFi HAL&lt;br/&gt;802.11 Implementation]\n        NetworkHAL[Network HAL&lt;br/&gt;Interface Management]\n    end\n\n    subgraph \"EasyMesh Ecosystem\"\n        UnifiedMesh[Unified-Mesh System&lt;br/&gt;IEEE 1905 Controller]\n        MeshAgent[EasyMesh Agent&lt;br/&gt;IEEE 1905 Protocol]\n    end\n\n    subgraph \"External Systems\"\n        CloudServices[Cloud/HeadEnd Services]\n        WebUI[Web Management Interface]\n        SNMP[SNMP Management]\n    end\n\n    %% Data Flow Connections\n    TR181 --&gt;|RBus/TR-181 Parameters| PlatformBus\n    WebConfig --&gt;|JSON Configuration| WebConfigMgr\n    Telemetry --&gt;|Statistics/Events| PlatformBus\n    CCSP --&gt;|Component Communication| PlatformBus\n\n    PlatformBus --&gt;|IPC Messages| WifiCtrl\n    WebConfigMgr --&gt;|Config Updates| WifiCtrl\n    WifiCtrl --&gt;|Service Commands| PrivateSvc\n    WifiCtrl --&gt;|Service Commands| PublicSvc\n    WifiCtrl --&gt;|Service Commands| MeshSvc\n\n    Analytics --&gt;|HAL Events| EventMgr\n    Harvester --&gt;|Data Collection| WiFiDB\n    EasyMesh --&gt;|Mesh Protocol| MeshAgent\n    StaMgr --&gt;|Station Control| WpaSupplicant\n\n    WifiMgr --&gt;|Hardware Control| WiFiHAL\n    WifiMgr --&gt;|AP Configuration| Hostapd\n    WiFiDB --&gt;|Persistent Storage| WifiMgr\n\n    EasyMesh --&gt;|IEEE 1905 Protocol| UnifiedMesh\n    UnifiedMesh --&gt;|Mesh Coordination| MeshAgent\n\n    CloudServices --&gt;|WebPA/TR-069| WebConfig\n    WebUI --&gt;|Management APIs| TR181\n    SNMP --&gt;|SNMP v2c/v3| TR181\n\n    classDef core fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef service fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;\n    classDef app fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n    classDef protocol fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n    classDef external fill:#fce4ec,stroke:#c2185b,stroke-width:2px;\n    classDef data fill:#f1f8e9,stroke:#689f38,stroke-width:2px;\n\n    class WifiMgr,WifiCtrl,EventMgr,QueueMgr core;\n    class PrivateSvc,PublicSvc,MeshSvc service;\n    class Analytics,Harvester,Blaster,CAC,CSI,EasyMesh,StaMgr app;\n    class Hostapd,WpaSupplicant,WiFiHAL,NetworkHAL,UnifiedMesh,MeshAgent protocol;\n    class CloudServices,WebUI,SNMP external;\n    class WiFiDB,WebConfigMgr,PlatformBus data;</code></pre>"},{"location":"docu/oct21/onewifi/#prerequisites-and-dependencies","title":"Prerequisites and Dependencies","text":"<p>RDK-B Platform Requirements (MUST):</p> <ul> <li>DISTRO Features: <code>DISTRO_FEATURES += \"wifi\", \"rdk-onewifi\"</code> for core OneWifi support; <code>DISTRO_FEATURES += \"rdk-easymesh\"</code> for mesh functionality </li> <li>Build Dependencies: <code>meta-rdk-broadband</code>, <code>meta-openembedded</code>, WiFi HAL interface libraries, hostapd/wpa_supplicant packages </li> <li>RDK-B Components: CcspCommonLibrary (bus framework), hal-wifi interface, rbus/dbus message infrastructure, webconfig-framework </li> <li>HAL Dependencies: WiFi HAL v3.0+ with 802.11ax support, Network HAL for interface management, minimum driver support for nl80211 </li> <li>Systemd Services: <code>rbus.service</code>, <code>CcspWifiSsp.service</code> (if legacy integration), networking services must be active before OneWifi initialization </li> <li>Hardware Requirements: Multi-radio WiFi chipsets with 802.11ac minimum, 802.11ax preferred for optimal performance </li> </ul> <p>RDK-B Integration Requirements (MUST):</p> <ul> <li>Message Bus: RBus namespace reservation for <code>Device.WiFi.*</code> parameters, DBus fallback support for legacy components </li> <li>TR-181 Data Model: Complete WiFi data model implementation per TR-181 Issue 2 Amendment 15, custom RDK extensions for mesh and analytics </li> <li>Configuration Files: <code>/nvram/wifi_defaults.json</code>, <code>/opt/onewifi/config/</code>, EasyMesh configuration in <code>/nvram/EasymeshCfg.json</code> </li> <li>Startup Order: Network interfaces \u2192 HAL initialization \u2192 RBus/DBus \u2192 OneWifi \u2192 dependent applications </li> <li>Resource Constraints: 64MB RAM minimum, 256MB for full analytics suite, 16MB persistent storage for WiFi database </li> </ul> <p>Performance &amp; Optimization (SHOULD):</p> <ul> <li>Enhanced Features: <code>DISTRO_FEATURES += \"rdk-analytics\"</code> for advanced monitoring, <code>rdk-mesh-optimization</code> for performance tuning </li> <li>Recommended Hardware: WiFi 6E/7 support for 6GHz operation, hardware-accelerated cryptography for WPA3, dedicated mesh backhaul radios </li> <li>Configuration Tuning: Channel optimization algorithms, load balancing parameters, mesh topology configuration for optimal performance </li> <li>Monitoring Integration: Telemetry 2.0 framework integration, SNMP v3 support, cloud analytics integration for network optimization </li> </ul> <p>RDK-B Design Limitations &amp; Considerations:</p> <ul> <li>Known Limitations: Maximum 16 VAPs per radio, mesh network supports up to 32 nodes, hostapd restart required for some security changes </li> <li>Scalability Boundaries: 128 concurrent clients per VAP, 512 clients total per device, EasyMesh supports maximum 4-hop topology </li> <li>Platform Compatibility: Supports RDK-B 2023Q1+, requires Linux 4.19+ for WiFi 6E features, ARM/x86_64 architectures </li> <li>Resource Usage: Base memory footprint 32MB, up to 128MB with all applications enabled, 2-4MB persistent storage typical usage </li> </ul> <p>Dependent Components:</p> <ul> <li>CcspTr069Pa: Depends on OneWifi TR-181 parameters for remote management capabilities, requires parameter synchronization </li> <li>Utopia: Network configuration service dependency for bridge management and VLAN configuration in mesh scenarios </li> <li>RdkWanManager: Coordination required for mesh backhaul interface management and WAN failover scenarios </li> <li>Telemetry Services: Relies on OneWifi statistics and event data for network health monitoring and reporting </li> </ul> <p>Threading Model</p> <p>OneWifi implements a hybrid threading architecture combining event-driven processing with dedicated worker threads for performance-critical operations:</p> <ul> <li>Threading Architecture: Multi-threaded with event-driven core and specialized worker pools </li> <li>Main Thread: Event loop management, component lifecycle, IPC message handling, configuration processing </li> <li>Worker Threads:</li> <li>HAL Event Thread: Processes hardware interrupts, 802.11 frame events, radio state changes </li> <li>Service Threads: Individual threads per service (Private, Public, Mesh) for isolated VAP management </li> <li>Application Threads: Background processing for Analytics, Harvester, and other applications with configurable priorities </li> <li>Database Thread: Asynchronous database operations, transaction processing, periodic persistence </li> <li>WebConfig Thread: Configuration validation, bulk updates, rollback operations </li> <li>Synchronization: pthread mutexes for shared data structures, RWlocks for read-heavy database access, condition variables for event signaling </li> </ul>"},{"location":"docu/oct21/onewifi/#component-state-flow","title":"Component State Flow","text":""},{"location":"docu/oct21/onewifi/#initialization-to-active-state","title":"Initialization to Active State","text":"<p>OneWifi follows a carefully orchestrated startup sequence ensuring proper dependency resolution and service activation. The initialization process validates hardware capabilities, establishes IPC connections, and progressively activates service components based on configuration requirements.</p> <pre><code>stateDiagram-v2\n    [*] --&gt; Initializing\n    Initializing --&gt; LoadingHAL: Load WiFi HAL Interface\n    LoadingHAL --&gt; InitializingDB: Initialize WiFi Database\n    InitializingDB --&gt; LoadingConfig: Load Configuration Files\n    LoadingConfig --&gt; RegisteringTR181: Register TR-181 Data Model\n    RegisteringTR181 --&gt; ConnectingBus: Connect RBus/DBus IPC\n    ConnectingBus --&gt; InitializingServices: Initialize Service Layer\n    InitializingServices --&gt; StartingHostapd: Configure hostapd\n    StartingHostapd --&gt; LoadingApplications: Load Application Modules\n    LoadingApplications --&gt; ConfiguringMesh: Configure EasyMesh (if enabled)\n    ConfiguringMesh --&gt; Active: All Systems Ready\n    Active --&gt; RuntimeUpdate: Configuration Change\n    RuntimeUpdate --&gt; Active: Update Applied\n    Active --&gt; ServiceRestart: Service Failure\n    ServiceRestart --&gt; Active: Service Recovered\n    Active --&gt; Shutdown: Stop Request\n    Shutdown --&gt; [*]\n\n    note right of Initializing\n        - Initialize logging subsystem\n        - Validate hardware capabilities\n        - Setup memory pools\n        - Initialize threading infrastructure\n    end note\n\n    note right of LoadingHAL\n        - Load WiFi HAL library\n        - Enumerate radio capabilities\n        - Initialize 802.11 protocol stack\n        - Configure hardware abstraction\n    end note\n\n    note right of InitializingDB\n        - Open WiFi database\n        - Validate schema version\n        - Run migration scripts\n        - Initialize transaction manager\n    end note\n\n    note right of Active\n        - Process client requests\n        - Handle hardware events\n        - Monitor service health\n        - Execute scheduled tasks\n    end note</code></pre>"},{"location":"docu/oct21/onewifi/#runtime-state-changes-and-context-switching","title":"Runtime State Changes and Context Switching","text":"<p>OneWifi manages multiple operational contexts that can trigger state transitions during normal operation. These context switches are designed to maintain service availability while adapting to network conditions and configuration changes.</p> <p>State Change Triggers: - Hardware Events: Radio failure detection, channel radar detection (DFS), thermal throttling events requiring adaptive responses - Network Topology Changes: Mesh node addition/removal, backhaul link quality degradation, client roaming events between VAPs - Configuration Updates: WebConfig bulk updates, TR-181 parameter changes, security policy modifications requiring service restarts - Service Health Events: Application crashes with automatic recovery, database corruption with repair procedures, memory pressure adaptation</p> <p>Context Switching Scenarios:</p> <p>Mesh Network Context Switch: <pre><code>stateDiagram-v2\n    state \"Mesh Controller Mode\" as ControllerMode\n    state \"Mesh Agent Mode\" as AgentMode\n    state \"Standalone Mode\" as StandaloneMode\n\n    [*] --&gt; StandaloneMode\n    StandaloneMode --&gt; ControllerMode: Mesh Enable + Controller Config\n    StandaloneMode --&gt; AgentMode: Mesh Enable + Agent Discovery\n    ControllerMode --&gt; AgentMode: Controller Failure/Handover\n    AgentMode --&gt; ControllerMode: Promotion Event\n    ControllerMode --&gt; StandaloneMode: Mesh Disable\n    AgentMode --&gt; StandaloneMode: Mesh Disable</code></pre></p> <p>Radio Operating Mode Context Switch: <pre><code>stateDiagram-v2\n    state \"Normal Operation\" as NormalOp\n    state \"DFS Channel Scan\" as DFSScan  \n    state \"Emergency Channel\" as EmergencyChannel\n    state \"Thermal Throttle\" as ThermalMode\n\n    [*] --&gt; NormalOp\n    NormalOp --&gt; DFSScan: Radar Detection\n    NormalOp --&gt; ThermalMode: Temperature Threshold\n    NormalOp --&gt; EmergencyChannel: All DFS Channels Blocked\n    DFSScan --&gt; NormalOp: Clear Channel Found\n    DFSScan --&gt; EmergencyChannel: No Clear Channels\n    ThermalMode --&gt; NormalOp: Temperature Normal\n    EmergencyChannel --&gt; NormalOp: DFS Timer Expired</code></pre></p>"},{"location":"docu/oct21/onewifi/#call-flow","title":"Call Flow","text":""},{"location":"docu/oct21/onewifi/#primary-call-flows","title":"Primary Call Flows","text":"<p>Initialization Call Flow:</p> <pre><code>sequenceDiagram\n    participant System as System Init\n    participant OneWifi as OneWifi Core\n    participant HAL as WiFi HAL\n    participant DB as WiFi Database\n    participant Hostapd as hostapd Daemon\n    participant RBus as RBus/DBus\n\n    System-&gt;&gt;OneWifi: Start OneWifi Service\n    OneWifi-&gt;&gt;HAL: wifi_hal_init()\n    HAL--&gt;&gt;OneWifi: Capabilities &amp; Radio Info\n    OneWifi-&gt;&gt;DB: Initialize Database Schema\n    DB--&gt;&gt;OneWifi: Database Ready\n    OneWifi-&gt;&gt;OneWifi: Load Configuration Files\n    OneWifi-&gt;&gt;RBus: Register TR-181 Parameters\n    RBus--&gt;&gt;OneWifi: Registration Complete\n    OneWifi-&gt;&gt;Hostapd: Configure AP Settings\n    Hostapd--&gt;&gt;OneWifi: hostapd Ready\n    OneWifi-&gt;&gt;OneWifi: Start Service Layer\n    OneWifi-&gt;&gt;System: Initialization Complete (Active State)</code></pre> <p>VAP Creation and Management Call Flow:</p> <pre><code>sequenceDiagram\n    participant WebConfig as WebConfig/TR-181\n    participant OneWifi as OneWifi Controller\n    participant Service as VAP Service\n    participant HAL as WiFi HAL\n    participant Hostapd as hostapd\n    participant DB as WiFi Database\n\n    WebConfig-&gt;&gt;OneWifi: Create VAP Request (JSON/TR-181)\n    OneWifi-&gt;&gt;OneWifi: Validate Configuration\n    OneWifi-&gt;&gt;Service: Initialize VAP Service\n    Service-&gt;&gt;HAL: wifi_createVAP()\n    HAL--&gt;&gt;Service: VAP Created (Interface Name)\n    Service-&gt;&gt;Hostapd: Configure AP Parameters\n    Hostapd--&gt;&gt;Service: Configuration Applied\n    Service-&gt;&gt;DB: Store VAP Configuration\n    DB--&gt;&gt;Service: Persistence Complete\n    Service--&gt;&gt;OneWifi: VAP Ready\n    OneWifi--&gt;&gt;WebConfig: Success Response</code></pre> <p>EasyMesh Controller/Agent Interaction Flow:</p> <pre><code>sequenceDiagram\n    participant Controller as EasyMesh Controller\n    participant OneWifi as OneWifi Agent\n    participant IEEE1905 as IEEE 1905 Protocol\n    participant UnifiedMesh as Unified-Mesh System\n    participant MeshHAL as WiFi HAL (Mesh)\n\n    Controller-&gt;&gt;IEEE1905: Multi-AP Configuration\n    IEEE1905-&gt;&gt;UnifiedMesh: IEEE 1905 Message\n    UnifiedMesh-&gt;&gt;OneWifi: EasyMesh Config Update\n    OneWifi-&gt;&gt;OneWifi: Validate Mesh Configuration\n    OneWifi-&gt;&gt;MeshHAL: Configure Mesh VAPs\n    MeshHAL--&gt;&gt;OneWifi: Mesh Interface Ready\n    OneWifi-&gt;&gt;UnifiedMesh: Configuration Applied\n    UnifiedMesh-&gt;&gt;IEEE1905: ACK Response\n    IEEE1905--&gt;&gt;Controller: Configuration Success\n\n    Note over Controller,MeshHAL: Ongoing mesh topology monitoring and optimization\n\n    OneWifi-&gt;&gt;UnifiedMesh: Mesh Metrics/Statistics\n    UnifiedMesh-&gt;&gt;IEEE1905: Periodic Reports\n    IEEE1905-&gt;&gt;Controller: Network Status Updates</code></pre>"},{"location":"docu/oct21/onewifi/#tr181-data-models","title":"TR\u2011181 Data Models","text":""},{"location":"docu/oct21/onewifi/#supported-tr-181-parameters","title":"Supported TR-181 Parameters","text":"<p>OneWifi provides comprehensive TR-181 data model support with full compliance to TR-181 Issue 2 Amendment 15 specifications, extended with RDK-specific enhancements for advanced wireless features, mesh networking, and analytics capabilities.</p>"},{"location":"docu/oct21/onewifi/#object-hierarchy","title":"Object Hierarchy","text":"<pre><code>Device.\n\u2514\u2500\u2500 WiFi.\n    \u251c\u2500\u2500 RadioNumberOfEntries (unsignedInt, R)\n    \u251c\u2500\u2500 SSIDNumberOfEntries (unsignedInt, R)\n    \u251c\u2500\u2500 AccessPointNumberOfEntries (unsignedInt, R)\n    \u251c\u2500\u2500 X_RDK_MeshAgent.\n    \u2502   \u251c\u2500\u2500 Enable (boolean, R/W)\n    \u2502   \u251c\u2500\u2500 Status (string, R)\n    \u2502   \u2514\u2500\u2500 URL (string, R/W)\n    \u251c\u2500\u2500 Radio.{i}.\n    \u2502   \u251c\u2500\u2500 Enable (boolean, R/W)\n    \u2502   \u251c\u2500\u2500 Status (string, R)\n    \u2502   \u251c\u2500\u2500 Channel (unsignedInt, R/W)\n    \u2502   \u251c\u2500\u2500 OperatingFrequencyBand (string, R/W)\n    \u2502   \u251c\u2500\u2500 OperatingStandards (string, R/W)\n    \u2502   \u251c\u2500\u2500 TransmitPower (int, R/W)\n    \u2502   \u2514\u2500\u2500 X_RDK_AutoChannelEnable (boolean, R/W)\n    \u251c\u2500\u2500 SSID.{i}.\n    \u2502   \u251c\u2500\u2500 Enable (boolean, R/W)\n    \u2502   \u251c\u2500\u2500 Status (string, R)\n    \u2502   \u251c\u2500\u2500 Name (string, R/W)\n    \u2502   \u2514\u2500\u2500 SSID (string, R/W)\n    \u251c\u2500\u2500 AccessPoint.{i}.\n    \u2502   \u251c\u2500\u2500 Enable (boolean, R/W)\n    \u2502   \u251c\u2500\u2500 Status (string, R)\n    \u2502   \u251c\u2500\u2500 SSIDReference (string, R/W)\n    \u2502   \u251c\u2500\u2500 Security.\n    \u2502   \u2502   \u251c\u2500\u2500 ModeEnabled (string, R/W)\n    \u2502   \u2502   \u251c\u2500\u2500 KeyPassphrase (string, R/W)\n    \u2502   \u2502   \u2514\u2500\u2500 X_RDK_SAE_Enable (boolean, R/W)\n    \u2502   \u2514\u2500\u2500 AssociatedDevice.{i}.\n    \u2502       \u251c\u2500\u2500 MACAddress (string, R)\n    \u2502       \u251c\u2500\u2500 SignalStrength (int, R)\n    \u2502       \u2514\u2500\u2500 X_RDK_RSSI (int, R)\n    \u2514\u2500\u2500 X_RDK_EasyMesh.\n        \u251c\u2500\u2500 Enable (boolean, R/W)\n        \u251c\u2500\u2500 ControllerEnable (boolean, R/W)\n        \u251c\u2500\u2500 AgentEnable (boolean, R/W)\n        \u2514\u2500\u2500 NetworkConfiguration (string, R/W)\n</code></pre>"},{"location":"docu/oct21/onewifi/#parameter-definitions","title":"Parameter Definitions","text":"<p>Core Radio Management Parameters:</p> Parameter Path Data Type Access Default Value Description BBF Compliance <code>Device.WiFi.Radio.{i}.Enable</code> boolean R/W <code>true</code> Enables or disables the radio. When false, all associated SSIDs are disabled and no wireless activity occurs on this radio interface. TR-181 Issue 2 <code>Device.WiFi.Radio.{i}.Status</code> string R <code>\"Up\"</code> Current operational status of the radio. Enumeration: Up, Down, Unknown, Dormant, NotPresent, LowerLayerDown, Error TR-181 Issue 2 <code>Device.WiFi.Radio.{i}.Channel</code> unsignedInt R/W <code>6</code> (2.4GHz), <code>36</code> (5GHz) Current operating channel number. Automatic channel selection when AutoChannelEnable is true. Range 1-14 for 2.4GHz, 36-165 for 5GHz, 1-233 for 6GHz TR-181 Issue 2 <code>Device.WiFi.Radio.{i}.OperatingFrequencyBand</code> string R/W <code>\"2.4GHz\"</code> Operating frequency band for the radio. Enumeration: 2.4GHz, 5GHz, 6GHz. Changes require radio restart for proper hardware configuration TR-181 Issue 2 <code>Device.WiFi.Radio.{i}.OperatingStandards</code> string R/W <code>\"n,ac,ax\"</code> Comma-separated list of 802.11 standards supported. Valid: a,b,g,n,ac,ax,be. Determines modulation schemes and feature availability TR-181 Issue 2 <code>Device.WiFi.Radio.{i}.TransmitPower</code> int R/W <code>100</code> Current transmit power as percentage of maximum capability. Range 1-100. Actual power limited by regulatory domain and thermal constraints TR-181 Issue 2 <p>VAP and Security Parameters:</p> Parameter Path Data Type Access Default Value Description BBF Compliance <code>Device.WiFi.SSID.{i}.Enable</code> boolean R/W <code>false</code> Enables or disables the SSID. When enabled, the virtual access point becomes operational and begins broadcasting TR-181 Issue 2 <code>Device.WiFi.SSID.{i}.Status</code> string R <code>\"Disabled\"</code> Current SSID operational status. Enumeration: Enabled, Disabled, Error, ErrorAuthenticationFailure, ErrorAssociationFailure TR-181 Issue 2 <code>Device.WiFi.SSID.{i}.Name</code> string R/W <code>\"\"</code> Human-readable SSID identifier for management purposes. Does not affect over-the-air SSID broadcast name TR-181 Issue 2 <code>Device.WiFi.SSID.{i}.SSID</code> string R/W <code>\"\"</code> Service Set Identifier broadcast over the air. Maximum 32 octets. UTF-8 encoding with proper validation for wireless compatibility TR-181 Issue 2 <code>Device.WiFi.AccessPoint.{i}.Security.ModeEnabled</code> string R/W <code>\"None\"</code> Security mode for the access point. Enumeration: None, WEP-64, WEP-128, WPA-Personal, WPA2-Personal, WPA-WPA2-Personal, WPA2-Enterprise, WPA3-Personal, WPA3-Enterprise, WPA2-WPA3-Personal TR-181 Issue 2 <code>Device.WiFi.AccessPoint.{i}.Security.KeyPassphrase</code> string R/W <code>\"\"</code> WPA/WPA2/WPA3 pre-shared key passphrase. Length 8-63 ASCII characters or 64-character hexadecimal key. Stored encrypted in persistent database TR-181 Issue 2 <p>Custom RDK Extensions:</p> <p>EasyMesh Multi-AP Parameters:</p> Parameter Path Data Type Access Default Value Description BBF Compliance <code>Device.WiFi.X_RDK_EasyMesh.Enable</code> boolean R/W <code>false</code> Master enable for EasyMesh Multi-AP functionality. Controls IEEE 1905 protocol stack and mesh networking capabilities RDK Custom <code>Device.WiFi.X_RDK_EasyMesh.ControllerEnable</code> boolean R/W <code>false</code> Enable EasyMesh controller functionality for mesh network management, topology optimization, and multi-AP coordination RDK Custom <code>Device.WiFi.X_RDK_EasyMesh.AgentEnable</code> boolean R/W <code>false</code> Enable EasyMesh agent functionality to participate in mesh network under controller management with automatic configuration RDK Custom <code>Device.WiFi.X_RDK_EasyMesh.NetworkConfiguration</code> string R/W <code>\"\"</code> JSON-encoded EasyMesh network configuration including AL-MAC address, backhaul credentials, and mesh topology parameters RDK Custom <p>Mesh and Analytics Extensions:</p> <ul> <li>Device.WiFi.X_RDK_MeshAgent.Enable: Controls mesh agent daemon for unified-mesh system integration</li> <li>Device.WiFi.Radio.{i}.X_RDK_AutoChannelEnable: Enhanced automatic channel selection with DFS and interference avoidance  </li> <li>Device.WiFi.AccessPoint.{i}.AssociatedDevice.{i}.X_RDK_RSSI: Extended RSSI reporting with historical statistics</li> <li>Device.WiFi.AccessPoint.{i}.Security.X_RDK_SAE_Enable: WPA3 Simultaneous Authentication of Equals support</li> </ul>"},{"location":"docu/oct21/onewifi/#parameter-registration-and-access","title":"Parameter Registration and Access","text":"<p>OneWifi registers TR-181 parameters through RBus message infrastructure with efficient parameter access patterns optimized for high-frequency operations. The registration process establishes parameter namespaces, access controls, and validation rules during component initialization.</p>"},{"location":"docu/oct21/onewifi/#internal-modules","title":"Internal Modules","text":"<p>OneWifi's modular architecture provides clear separation of concerns while enabling efficient inter-module communication and shared resource management.</p> Module/Class Description Key Files WiFi Manager Core orchestration engine managing component lifecycle, hardware abstraction, and global state coordination <code>wifi_mgr.c</code>, <code>wifi_mgr.h</code> WiFi Controller Central event processing hub handling IPC messages, configuration updates, and service coordination <code>wifi_ctrl.c</code>, <code>wifi_ctrl_rbus_handlers.c</code>, <code>wifi_ctrl_webconfig.c</code> Service Layer Modular service architecture with specialized handlers for different VAP types and network functions <code>vap_svc_private.c</code>, <code>vap_svc_public.c</code>, <code>vap_svc_mesh_gw.c</code> WiFi Database ACID-compliant persistent storage system for configuration data, client information, and operational statistics <code>wifi_db.c</code>, <code>wifi_db_apis.c</code> Application Framework Plugin-based application system for analytics, harvesting, monitoring, and advanced wireless features <code>wifi_apps_mgr.c</code>, <code>analytics/</code>, <code>harvester/</code>, <code>blaster/</code> EasyMesh Integration IEEE 1905 Multi-AP protocol implementation with controller/agent capabilities and unified-mesh system coordination <code>wifi_em.c</code>, <code>wifi_easymesh_translator.c</code> WebConfig Manager Bulk configuration management supporting JSON-based updates, validation, and atomic rollback operations <code>wifi_webconfig.c</code>, <code>wifi_decoder.c</code>, <code>wifi_encoder.c</code> Protocol Handlers 802.11 frame processing, security protocol implementation, and advanced wireless feature support <code>wifi_8021x.c</code>, <code>wifi_hal.h</code> integration <pre><code>flowchart TD\n    subgraph OneWifi_Core [\"OneWifi Core Architecture\"]\n        subgraph Management_Layer [\"Management Layer\"]\n            WifiMgr([WiFi Manager&lt;br/&gt;Core Orchestration])\n            WifiCtrl([WiFi Controller&lt;br/&gt;Event Processing])\n            EventMgr([Event Manager&lt;br/&gt;IPC Handling])\n        end\n\n        subgraph Service_Layer [\"Service Layer\"]\n            PrivateSvc([Private VAP Service&lt;br/&gt;Home Networks])\n            PublicSvc([Public VAP Service&lt;br/&gt;Hotspots])\n            MeshSvc([Mesh Service&lt;br/&gt;Backhaul/STA])\n        end\n\n        subgraph Application_Layer [\"Application Layer\"]\n            Analytics([Analytics Engine&lt;br/&gt;Client Behavior])\n            Harvester([Data Harvester&lt;br/&gt;Metrics Collection])\n            EasyMesh([EasyMesh App&lt;br/&gt;IEEE 1905 Protocol])\n            Blaster([Traffic Blaster&lt;br/&gt;Performance Testing])\n        end\n\n        subgraph Data_Layer [\"Data &amp; Persistence Layer\"]\n            WiFiDB[(WiFi Database&lt;br/&gt;ACID Storage)]\n            ConfigMgr([WebConfig Manager&lt;br/&gt;Bulk Updates])\n            BusLayer([RBus/DBus Layer&lt;br/&gt;IPC Infrastructure])\n        end\n    end\n\n    %% Inter-module connections\n    WifiMgr --&gt; WifiCtrl\n    WifiCtrl --&gt; PrivateSvc\n    WifiCtrl --&gt; PublicSvc\n    WifiCtrl --&gt; MeshSvc\n\n    Analytics --&gt; EventMgr\n    Harvester --&gt; WiFiDB\n    EasyMesh --&gt; MeshSvc\n    Blaster --&gt; PrivateSvc\n\n    ConfigMgr --&gt; WifiCtrl\n    BusLayer --&gt; EventMgr\n    WiFiDB --&gt; WifiMgr\n\n    classDef mgmt fill:#e3f2fd,stroke:#1976d2,stroke-width:2px;\n    classDef service fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;\n    classDef app fill:#fff8e1,stroke:#f57c00,stroke-width:2px;\n    classDef data fill:#e8f5e8,stroke:#388e3c,stroke-width:2px;\n\n    class WifiMgr,WifiCtrl,EventMgr mgmt;\n    class PrivateSvc,PublicSvc,MeshSvc service;\n    class Analytics,Harvester,EasyMesh,Blaster app;\n    class WiFiDB,ConfigMgr,BusLayer data;</code></pre>"},{"location":"docu/oct21/onewifi/#component-interactions-ipc-mechanisms","title":"Component Interactions &amp; IPC Mechanisms","text":""},{"location":"docu/oct21/onewifi/#system-architecture-overview","title":"System Architecture Overview","text":"<p>OneWifi integrates with RDK-B middleware through standardized IPC mechanisms while maintaining direct hardware control through WiFi HAL and hostapd integration. The component serves as the authoritative source for all wireless configuration and operational data within the RDK-B ecosystem.</p> <pre><code>flowchart TD\n    subgraph \"RDK-B Middleware Ecosystem\"\n        subgraph \"Management Layer\"\n            TR069[TR-069 Agent&lt;br/&gt;Remote Management]\n            WebPA[WebPA Agent&lt;br/&gt;Cloud Interface] \n            SNMP[SNMP Agent&lt;br/&gt;Network Management]\n        end\n\n        subgraph \"Configuration Layer\"\n            WebConfig[WebConfig Framework&lt;br/&gt;Bulk Updates]\n            PSM[PSM Database&lt;br/&gt;Parameter Storage]\n            Telemetry[Telemetry 2.0&lt;br/&gt;Data Collection]\n        end\n    end\n\n    subgraph \"OneWifi Component\"\n        subgraph \"Core Services\"\n            Core[OneWifi Core&lt;br/&gt;C++ Application]\n            DB[(WiFi Database&lt;br/&gt;SQLite-based)]\n            Apps[Application Suite&lt;br/&gt;Analytics/Mesh/etc.]\n        end\n    end\n\n    subgraph \"Protocol &amp; Hardware Layer\"\n        subgraph \"802.11 Implementation\"\n            Hostapd[hostapd v2.10+&lt;br/&gt;AP Management]\n            WpaSupplicant[wpa_supplicant&lt;br/&gt;STA Operations]\n        end\n\n        subgraph \"Hardware Abstraction\"\n            WiFiHAL[WiFi HAL v3.0&lt;br/&gt;802.11ax/be Support]\n            NetworkHAL[Network HAL&lt;br/&gt;Interface Control]\n        end\n\n        subgraph \"Kernel &amp; Drivers\"\n            nl80211[nl80211 Interface&lt;br/&gt;cfg80211 Framework]\n            WifiDriver[WiFi Driver&lt;br/&gt;Vendor-specific]\n        end\n    end\n\n    subgraph \"EasyMesh Ecosystem\"\n        UnifiedMesh[Unified-Mesh Controller&lt;br/&gt;IEEE 1905.1 Protocol]\n        MeshAgents[EasyMesh Agents&lt;br/&gt;Remote Nodes]\n    end\n\n    %% Communication Flows\n    TR069 -.-&gt;|TR-181 Parameters&lt;br/&gt;RBus Protocol| Core\n    WebPA -.-&gt;|JSON Configuration&lt;br/&gt;WebConfig API| Core\n    SNMP -.-&gt;|SNMP v2c/v3&lt;br/&gt;MIB Access| Core\n\n    WebConfig --&gt;|Bulk Configuration&lt;br/&gt;JSON/MessagePack| Core\n    PSM &lt;--&gt;|Parameter Persistence&lt;br/&gt;DBus Messages| Core\n    Telemetry &lt;--&gt;|Statistics &amp; Events&lt;br/&gt;RBus Telemetry API| Core\n\n    Core &lt;--&gt;|Hardware Control&lt;br/&gt;Direct API Calls| WiFiHAL\n    Core &lt;--&gt;|Network Interface&lt;br/&gt;Management APIs| NetworkHAL\n    Core &lt;--&gt;|AP Configuration&lt;br/&gt;hostapd_cli/DBus| Hostapd\n    Core &lt;--&gt;|STA Control&lt;br/&gt;wpa_cli/DBus| WpaSupplicant\n    Core &lt;--&gt;|ACID Transactions&lt;br/&gt;SQL Operations| DB\n\n    WiFiHAL &lt;--&gt;|nl80211 Commands&lt;br/&gt;Netlink Sockets| nl80211\n    NetworkHAL &lt;--&gt;|Interface Control&lt;br/&gt;ioctl/netlink| nl80211\n    Hostapd &lt;--&gt;|Driver Interface&lt;br/&gt;nl80211 Commands| nl80211\n    WpaSupplicant &lt;--&gt;|Driver Interface&lt;br/&gt;nl80211 Commands| nl80211\n\n    nl80211 &lt;--&gt;|Hardware Commands&lt;br/&gt;Vendor Extensions| WifiDriver\n\n    Apps &lt;--&gt;|IEEE 1905 Messages&lt;br/&gt;Unix Domain Sockets| UnifiedMesh\n    UnifiedMesh &lt;--&gt;|Multi-AP Protocol&lt;br/&gt;IEEE 1905.1/TCP| MeshAgents\n\n    classDef middleware fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef onewifi fill:#f3e5f5,stroke:#7b1fa2,stroke-width:3px;\n    classDef protocol fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n    classDef hardware fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n    classDef mesh fill:#fce4ec,stroke:#c2185b,stroke-width:2px;\n\n    class TR069,WebPA,SNMP,WebConfig,PSM,Telemetry middleware;\n    class Core,DB,Apps onewifi;\n    class Hostapd,WpaSupplicant,WiFiHAL,NetworkHAL protocol;\n    class nl80211,WifiDriver hardware;\n    class UnifiedMesh,MeshAgents mesh;</code></pre>"},{"location":"docu/oct21/onewifi/#detailed-interaction-matrix","title":"Detailed Interaction Matrix","text":"Target Component/Layer Interaction Purpose IPC Mechanism Message Format Communication Pattern Key APIs/Endpoints RDK-B Middleware Components TR-069 Agent Remote parameter management, firmware upgrades, diagnostics RBus Events/Methods JSON Parameter Sets Request-Response/Event Notifications <code>Device.WiFi.*</code> namespace, <code>rbus_method_table</code> WebPA Agent Cloud-based configuration, bulk parameter updates WebConfig Framework JSON/MessagePack RESTful HTTP/WebSocket <code>POST /api/v1/device/config</code>, WebSocket events PSM Database Parameter persistence, cross-component data sharing DBus/RBus Messages Key-Value Pairs Synchronous Get/Set Operations <code>PSM_Set()</code>, <code>PSM_Get()</code>, namespace <code>eRT.com.cisco.spvtg.ccsp.wifi</code> Telemetry 2.0 Statistics reporting, event data collection, performance metrics RBus Telemetry API Structured Event Data Asynchronous Publishing <code>t2_event_s()</code>, <code>t2_event_d()</code>, marker-based reporting System &amp; HAL Layers WiFi HAL Hardware control, 802.11 protocol implementation, radio management Direct Function Calls C Structure Pointers Synchronous API Calls <code>wifi_createVAP()</code>, <code>wifi_setRadioOperatingParameters()</code>, <code>wifi_hal_connect()</code> Network HAL Interface management, VLAN configuration, bridge operations Direct Function Calls C Structures Synchronous Function Calls <code>nethal_addInterface()</code>, <code>nethal_setBridgeConfig()</code> hostapd Daemon Access point configuration, client authentication, 802.11 frame processing Unix Domain Sockets/DBus hostapd Control Protocol Request-Response/Event Callbacks <code>/var/run/hostapd/wlan0</code>, <code>hostapd_ctrl_iface</code> wpa_supplicant Station mode operations, network scanning, connection management Unix Domain Sockets/DBus wpa_supplicant Control Protocol Request-Response/Event Callbacks <code>/var/run/wpa_supplicant/wlan0</code>, <code>wpa_ctrl_request()</code> External Systems Unified-Mesh System EasyMesh controller coordination, IEEE 1905 protocol handling Unix Domain Sockets IEEE 1905 TLV Messages Event-Driven Protocol Exchange <code>/tmp/mesh_controller.sock</code>, Multi-AP protocol messages Cloud Services Configuration backup, analytics upload, remote diagnostics HTTPS/WebSocket JSON API Payloads RESTful/Event Streaming Cloud-specific endpoints, OAuth 2.0 authentication"},{"location":"docu/oct21/onewifi/#event-publishing-subscription","title":"Event Publishing &amp; Subscription","text":"<p>Events Published by OneWifi:</p> Event Name Event Topic/Path Trigger Condition Payload Format Subscriber Components <code>wifi_radio_status_change</code> <code>Device.WiFi.Radio.{i}.Status</code> Radio state transitions (Up/Down/Error) JSON: <code>{radio_index, old_status, new_status, timestamp, reason}</code> TR-069, WebPA, Telemetry, Network Manager <code>wifi_client_connect</code> <code>Device.WiFi.AccessPoint.{i}.AssociatedDevice</code> Client association completion JSON: <code>{vap_index, mac_address, signal_strength, capabilities, timestamp}</code> Analytics, Harvester, Parental Controls, QoS Manager <code>wifi_mesh_topology_change</code> <code>Device.WiFi.X_RDK_EasyMesh.Topology</code> Mesh network topology updates JSON: <code>{event_type, node_mac, link_quality, hop_count, timestamp}</code> Unified-Mesh, Network Optimizer, Telemetry <code>wifi_security_event</code> <code>Device.WiFi.Security.Event</code> Authentication failures, intrusion detection JSON: <code>{event_type, severity, mac_address, details, timestamp}</code> Security Manager, Logging Service, SNMP Agent <code>wifi_performance_alert</code> <code>Device.WiFi.Performance.Alert</code> Threshold violations, degraded performance JSON: <code>{metric_type, threshold, current_value, vap_index, timestamp}</code> Performance Monitor, Auto-Optimization, Telemetry <p>Events Consumed by OneWifi:</p> Event Source Event Topic/Path Purpose Expected Payload Handler Function WebConfig Framework <code>webconfig.wifi.update</code> Bulk configuration updates, factory reset preparation JSON: <code>{subdoc_type, config_data, transaction_id}</code> <code>webconfig_event_handler()</code> Network Manager <code>network.interface.status</code> Interface state changes, VLAN updates, bridge modifications JSON: <code>{interface_name, status, ip_config, bridge_info}</code> <code>network_interface_event_handler()</code> System Health Monitor <code>system.thermal.alert</code> Thermal throttling requirements, emergency shutdown triggers JSON: <code>{temperature, threshold, action_required, severity}</code> <code>thermal_management_handler()</code> Time Service <code>system.time.sync</code> Time synchronization events for certificate validation JSON: <code>{sync_status, ntp_server, accuracy, timestamp}</code> <code>time_sync_event_handler()</code>"},{"location":"docu/oct21/onewifi/#ipc-flow-patterns","title":"IPC Flow Patterns","text":"<p>Primary Configuration Flow - WebConfig Bulk Update:</p> <pre><code>sequenceDiagram\n    participant Cloud as Cloud Service\n    participant WebPA as WebPA Agent\n    participant WebConfig as WebConfig Framework\n    participant OneWifi as OneWifi Core\n    participant HAL as WiFi HAL\n    participant Hostapd as hostapd\n\n    Cloud-&gt;&gt;WebPA: Configuration Update (HTTPS)\n    WebPA-&gt;&gt;WebConfig: Process Config Document\n    WebConfig-&gt;&gt;WebConfig: Validate JSON Schema\n    WebConfig-&gt;&gt;OneWifi: Apply WiFi Configuration\n    OneWifi-&gt;&gt;OneWifi: Validate Parameters\n    OneWifi-&gt;&gt;HAL: Update Radio Settings\n    HAL--&gt;&gt;OneWifi: Configuration Applied\n    OneWifi-&gt;&gt;Hostapd: Update AP Configuration\n    Hostapd--&gt;&gt;OneWifi: hostapd Reloaded\n    OneWifi--&gt;&gt;WebConfig: Success Response\n    WebConfig--&gt;&gt;WebPA: Configuration Complete\n    WebPA--&gt;&gt;Cloud: HTTP 200 OK + Status</code></pre> <p>EasyMesh Coordination Flow:</p> <pre><code>sequenceDiagram\n    participant Controller as EasyMesh Controller\n    participant UnifiedMesh as Unified-Mesh System\n    participant OneWifi as OneWifi Agent\n    participant MeshHAL as WiFi HAL (Mesh)\n    participant MeshVAP as Mesh VAP Interface\n\n    Controller-&gt;&gt;UnifiedMesh: Multi-AP Policy Config\n    UnifiedMesh-&gt;&gt;OneWifi: IEEE 1905 Configuration TLV\n    OneWifi-&gt;&gt;OneWifi: Validate Mesh Parameters\n    OneWifi-&gt;&gt;MeshHAL: Configure Mesh Backhaul\n    MeshHAL--&gt;&gt;OneWifi: Backhaul Interface Ready\n    OneWifi-&gt;&gt;MeshVAP: Activate Mesh VAP\n    MeshVAP--&gt;&gt;OneWifi: VAP Operational\n    OneWifi-&gt;&gt;UnifiedMesh: Configuration ACK + Status\n    UnifiedMesh-&gt;&gt;Controller: Policy Applied Successfully\n\n    Note over Controller,MeshVAP: Continuous mesh monitoring and optimization\n\n    OneWifi-&gt;&gt;UnifiedMesh: Periodic Metrics (RSSI, Throughput, Topology)\n    UnifiedMesh-&gt;&gt;Controller: Network Optimization Reports\n    Controller-&gt;&gt;UnifiedMesh: Dynamic Policy Updates\n    UnifiedMesh-&gt;&gt;OneWifi: Runtime Configuration Changes</code></pre>"},{"location":"docu/oct21/onewifi/#implementation-details","title":"Implementation Details","text":""},{"location":"docu/oct21/onewifi/#major-hal-apis-integration","title":"Major HAL APIs Integration","text":"<p>OneWifi integrates comprehensively with WiFi HAL v3.0+ to provide complete 802.11 protocol implementation and hardware abstraction. The HAL integration supports advanced features including 802.11ax/be, MU-MIMO, OFDMA, and vendor-specific optimizations.</p> <p>Core WiFi HAL APIs:</p> HAL API Purpose Parameters Return Values Implementation File <code>wifi_createVAP()</code> Create virtual access point with specified configuration <code>radio_index</code>, <code>vap_config_map</code>, <code>vap_info_map</code> <code>WIFI_HAL_SUCCESS</code>/<code>WIFI_HAL_ERROR</code> <code>wifi_ctrl_wifiapi_handlers.c</code> <code>wifi_setRadioOperatingParameters()</code> Configure radio operational parameters including channel, power, standards <code>radio_index</code>, <code>operationParam</code>, <code>channelParam</code> <code>WIFI_HAL_SUCCESS</code>/<code>WIFI_HAL_ERROR</code> <code>wifi_mgr.c</code> <code>wifi_hal_connect()</code> Initiate station connection to external network with credentials <code>ap_index</code>, <code>ssid</code>, <code>passphrase</code>, <code>key_mgmt</code>, <code>eap_config</code> <code>WIFI_HAL_SUCCESS</code>/Connection Status <code>wifi_ctrl_wifiapi_handlers.c</code> <code>wifi_getRadioVapInfoMap()</code> Retrieve current VAP configuration and operational status <code>radio_index</code>, <code>vap_info_map</code> Populated VAP structure/Error <code>wifi_mgr.c</code> <code>wifi_startNeighborScan()</code> Initiate neighbor network scanning for mesh and roaming optimization <code>vap_index</code>, <code>scan_mode</code>, <code>dwell_time</code>, <code>channel_list</code> <code>WIFI_HAL_SUCCESS</code>/Scan ID <code>wifi_apps/analytics/wifi_analytics.c</code> <code>wifi_setApSecurity()</code> Configure access point security parameters including WPA3 and enterprise settings <code>ap_index</code>, <code>security_config</code> <code>WIFI_HAL_SUCCESS</code>/<code>WIFI_HAL_ERROR</code> <code>wifi_mgr.c</code> <code>wifi_getApAssociatedDeviceDiagnosticResult3()</code> Retrieve detailed client statistics and diagnostic information <code>ap_index</code>, <code>associated_device_array</code>, <code>output_array_size</code> Client count/Device statistics array <code>wifi_stats.c</code>"},{"location":"docu/oct21/onewifi/#hostapd-integration-and-control","title":"hostapd Integration and Control","text":"<p>OneWifi manages hostapd through multiple control mechanisms ensuring robust access point operations with dynamic configuration updates and event handling:</p> <p>hostapd Control Architecture:</p> <ul> <li>Configuration Management: Dynamic generation of hostapd.conf files with template-based parameter injection and atomic configuration updates </li> <li>Runtime Control: hostapd_cli interface for real-time parameter changes, client management, and security policy updates without full daemon restart </li> <li>Event Monitoring: Hostapd event callback registration for client association/disassociation, authentication events, and 802.11 management frame processing </li> <li>Security Integration: WPA3 SAE configuration, Enterprise authentication with RADIUS integration, and advanced security features like Management Frame Protection (MFP) </li> </ul> <p>Key hostapd Integration Points:</p> Operation Control Method Configuration Files Event Callbacks AP Initialization <code>hostapd_ctrl_iface_init()</code> <code>/tmp/hostapd-wlan0.conf</code> <code>hostapd_event_new_sta()</code> Security Updates <code>hostapd_ctrl_command(\"SET\")</code> Dynamic parameter injection <code>hostapd_event_eapol_rx()</code> Client Management <code>hostapd_ctrl_command(\"DISASSOCIATE\")</code> Runtime MAC filter updates <code>hostapd_event_auth()</code> 802.11k/v Features Neighbor report configuration BSS transition configuration <code>hostapd_event_rrm_beacon_rep_received()</code>"},{"location":"docu/oct21/onewifi/#easymesh-architecture-and-ieee-1905-integration","title":"EasyMesh Architecture and IEEE 1905 Integration","text":"<p>OneWifi provides comprehensive EasyMesh Multi-AP protocol support through integrated IEEE 1905 implementation and unified-mesh system coordination:</p> <p>EasyMesh Component Architecture:</p> <pre><code>flowchart TD\n    subgraph \"OneWifi EasyMesh Integration\"\n        subgraph \"EasyMesh Application Layer\"\n            EMApp[EasyMesh App&lt;br/&gt;Multi-AP Logic]\n            Translator[EasyMesh Translator&lt;br/&gt;Protocol Conversion]\n            PolicyEngine[Policy Engine&lt;br/&gt;Network Optimization]\n        end\n\n        subgraph \"IEEE 1905 Protocol Stack\" \n            ProtocolHandler[1905 Message Handler&lt;br/&gt;TLV Processing]\n            TopologyDB[Topology Database&lt;br/&gt;Network Map]\n            MessageRouter[Message Router&lt;br/&gt;Multi-hop Forwarding]\n        end\n\n        subgraph \"Mesh Services\"\n            BackhaulSvc[Backhaul Service&lt;br/&gt;Inter-AP Links]\n            FronthaulSvc[Fronthaul Service&lt;br/&gt;Client Access]\n            SteeringSvc[Steering Service&lt;br/&gt;Client Optimization]\n        end\n    end\n\n    subgraph \"External Mesh Ecosystem\"\n        Controller[EasyMesh Controller&lt;br/&gt;Network Management]\n        UnifiedMesh[Unified-Mesh System&lt;br/&gt;IEEE 1905 Transport]\n        RemoteAgents[Remote EasyMesh Agents&lt;br/&gt;Mesh Nodes]\n    end\n\n    EMApp &lt;--&gt; Translator\n    Translator &lt;--&gt; ProtocolHandler\n    PolicyEngine &lt;--&gt; TopologyDB\n    ProtocolHandler &lt;--&gt; MessageRouter\n\n    BackhaulSvc &lt;--&gt; EMApp\n    FronthaulSvc &lt;--&gt; EMApp\n    SteeringSvc &lt;--&gt; PolicyEngine\n\n    MessageRouter &lt;--&gt;|Unix Domain Sockets&lt;br/&gt;IEEE 1905 TLVs| UnifiedMesh\n    UnifiedMesh &lt;--&gt;|Multi-AP Protocol&lt;br/&gt;TCP/IP| Controller\n    UnifiedMesh &lt;--&gt;|Mesh Coordination&lt;br/&gt;IEEE 1905.1| RemoteAgents\n\n    classDef easymesh fill:#e8eaf6,stroke:#3f51b5,stroke-width:2px;\n    classDef protocol fill:#e0f2f1,stroke:#00796b,stroke-width:2px;\n    classDef service fill:#fff3e0,stroke:#f57c00,stroke-width:2px;\n    classDef external fill:#fce4ec,stroke:#c2185b,stroke-width:2px;\n\n    class EMApp,Translator,PolicyEngine easymesh;\n    class ProtocolHandler,TopologyDB,MessageRouter protocol;\n    class BackhaulSvc,FronthaulSvc,SteeringSvc service;\n    class Controller,UnifiedMesh,RemoteAgents external;</code></pre> <p>EasyMesh API Endpoints and Communication:</p> Communication Type Endpoint/API Message Format Purpose Controller \u2194 OneWifi <code>/tmp/mesh_controller.sock</code> IEEE 1905 TLV Messages Multi-AP policy distribution, topology discovery, performance optimization Agent \u2194 Unified-Mesh <code>webconfig_easymesh_decode()</code> / <code>webconfig_easymesh_encode()</code> JSON Configuration Objects Mesh configuration translation, status reporting IEEE 1905 Transport TCP Socket (Port 1905) IEEE 1905.1 Protocol Frames Inter-agent communication, topology maintenance, multi-hop message forwarding Policy Engine API <code>em_policy_req_type_t</code> structures Binary Policy Objects Network optimization policies, client steering decisions, load balancing <p>EasyMesh Configuration Flow:</p> <pre><code>sequenceDiagram\n    participant Controller as EasyMesh Controller\n    participant UnifiedMesh as Unified-Mesh System\n    participant OneWifi as OneWifi Agent\n    participant MeshApp as EasyMesh App\n    participant WiFiHAL as WiFi HAL\n\n    Controller-&gt;&gt;UnifiedMesh: Multi-AP Configuration Policy\n    UnifiedMesh-&gt;&gt;OneWifi: webconfig_easymesh_decode()\n    OneWifi-&gt;&gt;MeshApp: EasyMesh Configuration Event\n    MeshApp-&gt;&gt;MeshApp: Validate Mesh Parameters\n    MeshApp-&gt;&gt;WiFiHAL: Configure Mesh VAPs\n    WiFiHAL--&gt;&gt;MeshApp: Mesh Interfaces Created\n    MeshApp-&gt;&gt;OneWifi: Configuration Applied Successfully\n    OneWifi-&gt;&gt;UnifiedMesh: webconfig_easymesh_encode() + Status\n    UnifiedMesh-&gt;&gt;Controller: IEEE 1905 ACK Response</code></pre>"},{"location":"docu/oct21/onewifi/#wifi-database-implementation","title":"WiFi Database Implementation","text":"<p>OneWifi implements a comprehensive database system providing ACID-compliant storage for configuration data, operational statistics, and network state information:</p> <p>Database Architecture: - Storage Backend: SQLite-based implementation with WAL (Write-Ahead Logging) for concurrent access and crash recovery - Schema Management: Versioned schema with automatic migration support for backward compatibility across firmware upgrades - Transaction Support: Full ACID transactions with rollback capability for configuration updates and batch operations - Performance Optimization: Prepared statements, connection pooling, and optimized indexing for high-frequency operations</p> <p>Key Database Tables and Data Models:</p> Table Name Purpose Key Fields Access Pattern <code>radio_config</code> Radio operational parameters and capabilities <code>radio_index</code>, <code>band</code>, <code>channel</code>, <code>power</code>, <code>standards</code> Read-heavy with periodic updates <code>vap_config</code> VAP configuration and security settings <code>vap_index</code>, <code>ssid</code>, <code>security_mode</code>, <code>enabled</code>, <code>bridge_name</code> Mixed read/write with atomic updates <code>client_info</code> Associated client information and statistics <code>mac_address</code>, <code>vap_index</code>, <code>rssi</code>, <code>connect_time</code>, <code>data_rates</code> High-frequency inserts/updates <code>mesh_topology</code> EasyMesh network topology and link metrics <code>node_mac</code>, <code>parent_mac</code>, <code>link_quality</code>, <code>hop_count</code>, <code>last_seen</code> Event-driven updates <code>analytics_data</code> Performance metrics and behavioral analytics <code>timestamp</code>, <code>metric_type</code>, <code>vap_index</code>, <code>value</code>, <code>client_mac</code> Time-series data with retention policies <code>security_events</code> Security-related events and intrusion detection <code>timestamp</code>, <code>event_type</code>, <code>severity</code>, <code>source_mac</code>, <code>details</code> Append-only with log rotation"},{"location":"docu/oct21/onewifi/#key-implementation-logic","title":"Key Implementation Logic","text":"<ul> <li> <p>Service Coordination Engine: Central orchestration system in <code>wifi_mgr.c</code> that manages service lifecycle, coordinates resource allocation, and ensures proper sequencing of operations across multiple VAP services</p> </li> <li> <p>Event Processing Pipeline: Multi-threaded event handling system in <code>wifi_events.c</code> that processes hardware interrupts, protocol events, and configuration changes with priority-based queuing and deadlock prevention</p> </li> <li> <p>Configuration Management: Atomic configuration update system in <code>wifi_webconfig.c</code> supporting bulk updates, parameter validation, dependency resolution, and automatic rollback on failure with persistent transaction logging</p> </li> <li> <p>Hardware Abstraction Layer: Comprehensive WiFi HAL integration in <code>wifi_ctrl_wifiapi_handlers.c</code> providing unified interface to vendor-specific hardware capabilities while abstracting 802.11 protocol complexities</p> </li> <li> <p>Database Transaction Manager: ACID-compliant transaction processing in <code>wifi_db.c</code> with connection pooling, prepared statement optimization, and automatic schema migration for reliable data persistence</p> </li> <li> <p>Security Framework: Integrated security management combining WPA3/Enterprise authentication, certificate validation, intrusion detection, and policy enforcement with audit logging</p> </li> </ul>"},{"location":"docu/oct21/onewifi/#key-configuration-files","title":"Key Configuration Files","text":"<p>OneWifi utilizes multiple configuration files and data sources to maintain operational parameters, default values, and runtime customization capabilities.</p> Configuration File Purpose Key Parameters Default Values Override Mechanisms <code>/nvram/wifi_defaults.json</code> System-wide WiFi defaults and hardware-specific parameters <code>radio_capabilities</code>, <code>default_channels</code>, <code>power_limits</code>, <code>country_code</code> Hardware-dependent Environment variables, build-time flags <code>/opt/onewifi/config/webconfig_schemas.json</code> WebConfig schema validation and parameter constraints <code>parameter_types</code>, <code>validation_rules</code>, <code>dependency_maps</code> Per TR-181 specification Runtime schema updates <code>/nvram/EasymeshCfg.json</code> EasyMesh network configuration and credentials <code>AL_MAC_ADDR</code>, <code>Colocated_mode</code>, <code>Backhaul_SSID</code>, <code>Backhaul_KeyPassphrase</code> Generated during mesh setup Controller provisioning, DPP onboarding <code>/tmp/hostapd-wlanX.conf</code> Runtime hostapd configuration per VAP <code>interface</code>, <code>ssid</code>, <code>wpa_passphrase</code>, <code>channel</code>, <code>ieee80211n</code> Template-generated OneWifi dynamic updates <code>/opt/onewifi/tr181_defaults.xml</code> TR-181 parameter default values and metadata <code>parameter_paths</code>, <code>default_values</code>, <code>access_permissions</code>, <code>notifications</code> TR-181 standard + RDK extensions PSM database overrides <code>/var/lib/onewifi/wifi.db</code> Persistent WiFi database (SQLite) Configuration state, client data, statistics, mesh topology Schema-defined defaults Database transactions, backup/restore <code>/etc/onewifi/analytics.conf</code> Analytics engine configuration and thresholds <code>collection_intervals</code>, <code>alert_thresholds</code>, <code>data_retention</code>, <code>privacy_settings</code> Conservative defaults Runtime parameter updates"},{"location":"docu/oct21/wanmanager/","title":"RDK WAN Manager Documentation","text":"<p>RDK WAN Manager is a centralized WAN connectivity management component in the RDK-B middleware stack that orchestrates multiple WAN interface technologies and manages failover policies. It serves as the primary controller for all WAN-related operations, handling interface selection, configuration, monitoring, and automatic failover to ensure continuous internet connectivity across heterogeneous WAN technologies including Ethernet, DOCSIS, DSL, GPON, and Cellular modems.</p> <pre><code>flowchart TD\n    subgraph \"External Systems\"\n        Cloud[Cloud Management/HeadEnd]\n        DNS[DNS Servers]\n        WebUI[Web Management UI]\n    end\n\n    subgraph \"RDK-B Gateway Device\"\n        subgraph \"RDK-B Middleware\"\n            WanMgr[RDK WAN Manager]\n            CcspCR[Component Registrar]\n            PSM[Persistent Storage Manager]\n            DM[Data Model Manager]\n            VlanMgr[VLAN Manager]\n            DHCPMgr[DHCP Manager]\n        end\n\n        subgraph \"Interface Managers\"\n            EthMgr[Ethernet Manager]\n            CellMgr[Cellular Manager]\n            DocsisMgr[DOCSIS Manager]\n            GPONMgr[GPON Manager]\n        end\n\n        subgraph \"HAL Layer\"\n            EthHAL[Ethernet HAL]\n            CellHAL[Cellular HAL]\n            PlatformHAL[Platform HAL]\n        end\n\n        subgraph \"Hardware\"\n            EthPort[Ethernet Ports]\n            CellModem[Cellular Modem]\n            CableModem[Cable Modem]\n            ONT[Optical Network Terminal]\n        end\n    end\n\n    %% External communications\n    Cloud &lt;--&gt;|WebConfig/TR-069| WanMgr\n    WebUI &lt;--&gt;|HTTP/HTTPS| WanMgr\n    WanMgr &lt;--&gt;|DNS Queries| DNS\n\n    %% RDK-B middleware communications\n    WanMgr &lt;--&gt;|RBus/DBus| CcspCR\n    WanMgr &lt;--&gt;|RBus| PSM\n    WanMgr &lt;--&gt;|TR-181 DM| DM\n    WanMgr &lt;--&gt;|VLAN Config| VlanMgr\n    WanMgr &lt;--&gt;|DHCP Control| DHCPMgr\n\n    %% Interface manager communications\n    WanMgr &lt;--&gt;|RBus Events| EthMgr\n    WanMgr &lt;--&gt;|RBus Events| CellMgr\n    WanMgr &lt;--&gt;|RBus Events| DocsisMgr\n    WanMgr &lt;--&gt;|RBus Events| GPONMgr\n\n    %% HAL interactions\n    EthMgr --&gt; EthHAL\n    CellMgr --&gt; CellHAL\n    WanMgr --&gt; PlatformHAL\n\n    %% Hardware connections\n    EthHAL --&gt; EthPort\n    CellHAL --&gt; CellModem\n    DocsisMgr --&gt; CableModem\n    GPONMgr --&gt; ONT\n\n    classDef external fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n    classDef wanmgr fill:#fff3e0,stroke:#ef6c00,stroke-width:3px;\n    classDef rdkb fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef interface fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;\n    classDef hal fill:#fce4ec,stroke:#c2185b,stroke-width:2px;\n    classDef hardware fill:#f1f8e9,stroke:#689f38,stroke-width:2px;\n\n    class Cloud,DNS,WebUI external;\n    class WanMgr wanmgr;\n    class CcspCR,PSM,DM,VlanMgr,DHCPMgr rdkb;\n    class EthMgr,CellMgr,DocsisMgr,GPONMgr interface;\n    class EthHAL,CellHAL,PlatformHAL hal;\n    class EthPort,CellModem,CableModem,ONT hardware;</code></pre> <p>Key Features &amp; Responsibilities: </p> <ul> <li>WAN Interface Management: Centralized management of multiple WAN interface types (Ethernet, Cellular, DOCSIS, GPON, DSL) with dynamic configuration and monitoring capabilities</li> <li>Policy-Based Selection: Implementation of configurable selection policies including AutoWAN, Parallel Scan, Fixed Mode, and Priority-based selection for intelligent interface selection</li> <li>Automatic Failover: Real-time monitoring and automatic failover between WAN interfaces based on connectivity validation and quality metrics</li> <li>Virtual Interface Support: Management of virtual WAN interfaces with VLAN, PPP, DHCP, and static IP configuration support</li> <li>TR-181 Data Model: Complete implementation of standardized TR-181 data model parameters for WAN management with RBus integration</li> <li>WebConfig Integration: Support for remote configuration management through WebConfig protocol for dynamic policy and interface updates</li> <li>Connectivity Validation: Built-in internet connectivity validation using DNS resolution and ping tests to ensure interface quality</li> </ul>"},{"location":"docu/oct21/wanmanager/#design","title":"Design","text":"<p>The RDK WAN Manager employs a multi-layered architecture designed around policy-driven selection algorithms, state machine-based interface management, and event-driven coordination. The design abstracts WAN interface complexity through a unified management layer that handles diverse interface technologies while providing consistent behavior and failover capabilities. The architecture separates concerns between interface-specific operations (handled by dedicated Interface Managers) and cross-interface coordination (managed by WAN Manager policies).</p> <p>The system integrates with RDK-B middleware through RBus message bus for real-time event communication and TR-181 data model compliance. Northbound interactions include WebConfig for remote management and TR-069 ACS integration, while southbound communications interface with HAL layers and platform-specific services. Data persistence is achieved through PSM (Persistent Storage Manager) integration, ensuring configuration and state information survives device reboots and maintains operational continuity.</p> <p>The design implements a hierarchical policy framework where Failover Policy manages inter-group switching while Selection Policies operate within interface groups. Each WAN interface is managed by a dedicated state machine that handles the complete lifecycle from initialization through active operation to teardown, ensuring proper resource management and error recovery.</p> <pre><code>flowchart TD\n    subgraph \"RDK WAN Manager Container (Linux Process)\"\n        subgraph \"Policy Engine\"\n            FP[Failover Policy Controller]\n            SP1[Selection Policy - Group 1]\n            SP2[Selection Policy - Group 2]\n            SPn[Selection Policy - Group N]\n        end\n\n        subgraph \"Interface State Machines\"\n            ISM1[Interface SM - Ethernet]\n            ISM2[Interface SM - Cellular]\n            ISM3[Interface SM - DOCSIS]\n            ISM4[Interface SM - GPON]\n        end\n\n        subgraph \"Core Modules\"\n            DC[Data Controller]\n            WCC[WebConfig Client]\n            TM[Telemetry Manager]\n            NM[Network Utils]\n        end\n\n        subgraph \"Communication Layer\"\n            RBH[RBus Handler]\n            TR181[TR-181 DML APIs]\n            IPC[IPC Manager]\n        end\n    end\n\n    subgraph \"External RDK-B Components\"\n        PSM[Persistent Storage Manager]\n        CCR[Component Registrar]\n        VLAN[VLAN Manager]\n        DHCP[DHCP Manager]\n        TELEMETRY[Telemetry 2.0]\n    end\n\n    subgraph \"Interface Managers\"\n        ETH_MGR[Ethernet Manager]\n        CELL_MGR[Cellular Manager]\n        DOCSIS_MGR[DOCSIS Manager]\n        GPON_MGR[GPON Manager]\n    end\n\n    %% Policy interactions\n    FP --&gt; SP1\n    FP --&gt; SP2\n    FP --&gt; SPn\n    SP1 --&gt; ISM1\n    SP1 --&gt; ISM2\n    SP2 --&gt; ISM3\n    SP2 --&gt; ISM4\n\n    %% Core module interactions\n    DC &lt;--&gt; ISM1\n    DC &lt;--&gt; ISM2\n    DC &lt;--&gt; ISM3\n    DC &lt;--&gt; ISM4\n\n    WCC &lt;--&gt; DC\n    TM &lt;--&gt; TR181\n\n    %% Communication layer\n    RBH &lt;--&gt; TR181\n    RBH &lt;--&gt; IPC\n    TR181 &lt;--&gt; DC\n\n    %% External communications\n    RBH &lt;--&gt;|RBus| PSM\n    RBH &lt;--&gt;|RBus| CCR\n    IPC &lt;--&gt;|RBus Events| ETH_MGR\n    IPC &lt;--&gt;|RBus Events| CELL_MGR\n    IPC &lt;--&gt;|RBus Events| DOCSIS_MGR\n    IPC &lt;--&gt;|RBus Events| GPON_MGR\n\n    NM &lt;--&gt;|System Calls| VLAN\n    NM &lt;--&gt;|System Calls| DHCP\n    TM &lt;--&gt;|RBus| TELEMETRY\n\n    classDef policy fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n    classDef statemachine fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef core fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;\n    classDef communication fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n    classDef external fill:#fce4ec,stroke:#c2185b,stroke-width:2px;\n    classDef interface fill:#f1f8e9,stroke:#689f38,stroke-width:2px;\n\n    class FP,SP1,SP2,SPn policy;\n    class ISM1,ISM2,ISM3,ISM4 statemachine;\n    class DC,WCC,TM,NM core;\n    class RBH,TR181,IPC communication;\n    class PSM,CCR,VLAN,DHCP,TELEMETRY external;\n    class ETH_MGR,CELL_MGR,DOCSIS_MGR,GPON_MGR interface;</code></pre>"},{"location":"docu/oct21/wanmanager/#prerequisites-and-dependencies","title":"Prerequisites and Dependencies","text":"<p>RDK-B Platform Requirements (MUST):</p> <ul> <li>DISTRO Features: DISTRO_FEATURES += \"rdk-b\", \"systemd\", \"rbus\"</li> <li>Build Dependencies: meta-rdk-broadband layer, ccsp-common-library, rbus, halinterface</li> <li>RDK-B Components: CcspCr (Component Registrar), CcspPsm (Persistent Storage Manager), rbus daemon</li> <li>HAL Dependencies: Platform HAL interface for system operations, Ethernet HAL for interface management</li> <li>Systemd Services: rbus.service, CcspCr.service, CcspPsm.service must be active before WAN Manager starts</li> <li>Hardware Requirements: At least one WAN-capable interface (Ethernet, Cellular, DOCSIS, GPON, or DSL)</li> </ul> <p>RDK-B Integration Requirements (MUST):</p> <ul> <li>Message Bus: RBus registration for Device.X_RDK_WanManager namespace and event subscriptions</li> <li>TR-181 Data Model: Support for Device.X_RDK_WanManager.* parameters and Interface management objects</li> <li>Configuration Files: RdkWanManager_v2.xml for TR-181 definitions, systemd service file for startup configuration</li> <li>Startup Order: Must start after rbus, CcspCr, CcspPsm, and before dependent applications requiring WAN connectivity</li> <li>Resource Constraints: Minimum 8MB RAM, persistent storage for configuration and state data</li> </ul> <p>Performance &amp; Optimization (SHOULD):</p> <ul> <li>Enhanced Features: DISTRO_FEATURES += \"webconfig\" for remote configuration support</li> <li>Recommended Hardware: Multiple WAN interfaces for failover capabilities, dedicated WAN processor for high-throughput environments</li> <li>Configuration Tuning: Optimized polling intervals, connectivity check timeouts based on network characteristics</li> <li>Monitoring Integration: Telemetry 2.0 integration for performance metrics and fault reporting</li> </ul> <p>RDK-B Design Limitations &amp; Considerations:</p> <ul> <li>Known Limitations: Maximum 16 interface groups supported, single active interface per group in most policies</li> <li>Scalability Boundaries: Up to 128 virtual interfaces, maximum 255 priority levels for interface selection</li> <li>Platform Compatibility: Supports RDK-B 2021.4+, ARM and x86 architectures, containerized and native deployments</li> <li>Resource Usage: Typical 4-8MB memory footprint, CPU usage varies with active interface count and policy complexity</li> </ul> <p>Dependent Components:</p> <ul> <li>Ethernet Manager, Cellular Manager, DOCSIS Manager, GPON Manager depend on WAN Manager for interface coordination</li> <li>Applications requiring internet connectivity depend on WAN Manager for interface availability notifications</li> <li>Network configuration tools rely on WAN Manager for active interface information and routing table updates</li> </ul> <p>Threading Model</p> <ul> <li>Threading Architecture: Multi-threaded with dedicated policy threads and shared data access synchronization</li> <li>Main Thread: Handles RBus message processing, TR-181 parameter operations, and system event coordination</li> <li>Worker Threads:</li> <li>Failover Policy Thread: Manages inter-group interface selection and failover coordination</li> <li>Selection Policy Threads: One thread per interface group handling intra-group interface selection (AutoWAN, Parallel Scan, Fixed Mode)</li> <li>Interface State Machine Threads: Individual threads for each WAN interface managing state transitions and configuration</li> <li>WebConfig Thread: Handles remote configuration processing and validation</li> <li>Telemetry Thread: Manages periodic data collection and reporting to Telemetry 2.0 system</li> <li>Synchronization: Mutex-based protection for shared data structures, condition variables for thread coordination, atomic operations for state flags</li> </ul>"},{"location":"docu/oct21/wanmanager/#component-state-flow","title":"Component State Flow","text":""},{"location":"docu/oct21/wanmanager/#initialization-to-active-state","title":"Initialization to Active State","text":"<p>The WAN Manager follows a structured initialization sequence that establishes system connectivity, registers with RDK-B middleware components, and activates policy-driven interface management. The component transitions through distinct phases ensuring all dependencies are met before beginning active WAN management operations.</p> <pre><code>stateDiagram-v2\n    [*] --&gt; Initializing\n    Initializing --&gt; LoadingConfig: Load TR-181 Parameters\n    LoadingConfig --&gt; RegisteringRBus: Register RBus Components\n    RegisteringRBus --&gt; ConnectingDeps: Connect to PSM/CcspCr\n    ConnectingDeps --&gt; StartingPolicies: Initialize Policy Engines\n    StartingPolicies --&gt; Active: All Systems Ready\n    Active --&gt; InterfaceEvent: Interface State Change\n    InterfaceEvent --&gt; Active: Policy Processed\n    Active --&gt; ConfigUpdate: WebConfig/TR-181 Update\n    ConfigUpdate --&gt; Active: Configuration Applied\n    Active --&gt; Shutdown: Stop Request\n    Shutdown --&gt; [*]\n\n    note right of Initializing\n        - Initialize logging framework\n        - Setup data structures\n        - Load default configurations\n        - Initialize mutex/semaphores\n    end note\n\n    note right of LoadingConfig\n        - Parse RdkWanManager_v2.xml\n        - Load PSM stored parameters\n        - Validate interface configurations\n        - Apply default settings\n    end note\n\n    note right of StartingPolicies\n        - Start Failover Policy thread\n        - Initialize Selection Policy threads\n        - Launch Interface State Machines\n        - Begin interface monitoring\n    end note\n\n    note right of Active\n        - Process interface events\n        - Execute policy algorithms\n        - Handle TR-181 operations\n        - Monitor connectivity status\n    end note</code></pre>"},{"location":"docu/oct21/wanmanager/#runtime-state-changes-and-context-switching","title":"Runtime State Changes and Context Switching","text":"<p>The WAN Manager dynamically responds to network conditions, interface state changes, and configuration updates through event-driven state transitions. Policy engines continuously evaluate interface availability and quality to maintain optimal connectivity.</p> <p>State Change Triggers:</p> <ul> <li>Interface physical layer state changes (up/down) from Interface Managers trigger policy re-evaluation</li> <li>Connectivity validation failures initiate automatic failover to backup interfaces</li> <li>TR-181 parameter updates or WebConfig changes cause policy reconfiguration and interface selection updates</li> <li>System events (network topology changes, DHCP lease renewals) prompt interface reassessment</li> </ul> <p>Context Switching Scenarios:</p> <ul> <li>Policy context switches occur when interface groups change priority or availability, triggering inter-group failover</li> <li>Interface State Machine context switches handle transitions between configuration states (DHCP, Static, PPP modes)</li> <li>Configuration context switches process WebConfig updates or TR-181 parameter changes requiring interface reconfiguration</li> </ul>"},{"location":"docu/oct21/wanmanager/#call-flow","title":"Call Flow","text":""},{"location":"docu/oct21/wanmanager/#primary-call-flows","title":"Primary Call Flows","text":"<p>Initialization Call Flow:</p> <pre><code>sequenceDiagram\n    participant Init as System Init\n    participant WanMgr as WAN Manager\n    participant RBus as RBus Daemon\n    participant PSM as PSM\n    participant IntfMgr as Interface Manager\n\n    Init-&gt;&gt;WanMgr: Start WAN Manager\n    WanMgr-&gt;&gt;WanMgr: Initialize Data Structures\n    WanMgr-&gt;&gt;RBus: Register TR-181 Components\n    RBus--&gt;&gt;WanMgr: Registration Complete\n    WanMgr-&gt;&gt;PSM: Load Persistent Configuration\n    PSM--&gt;&gt;WanMgr: Configuration Data\n    WanMgr-&gt;&gt;WanMgr: Start Policy Threads\n    WanMgr-&gt;&gt;IntfMgr: Subscribe to Interface Events\n    IntfMgr--&gt;&gt;WanMgr: Event Subscription Confirmed\n    WanMgr-&gt;&gt;Init: Initialization Complete (Active State)</code></pre> <p>Interface Selection Call Flow:</p> <pre><code>sequenceDiagram\n    participant Policy as Selection Policy\n    participant WanMgr as WAN Manager Core\n    participant ISM as Interface State Machine\n    participant IntfMgr as Interface Manager\n    participant NetUtils as Network Utils\n\n    Policy-&gt;&gt;WanMgr: Evaluate Available Interfaces\n    WanMgr-&gt;&gt;WanMgr: Check Interface Priority/Status\n    WanMgr-&gt;&gt;Policy: Interface Candidate List\n    Policy-&gt;&gt;ISM: Select Interface for Activation\n    ISM-&gt;&gt;IntfMgr: Configure Interface Parameters\n    IntfMgr--&gt;&gt;ISM: Configuration Applied\n    ISM-&gt;&gt;NetUtils: Validate Connectivity (DNS/Ping)\n    NetUtils--&gt;&gt;ISM: Validation Result\n    ISM-&gt;&gt;Policy: Interface Status Update\n    Policy-&gt;&gt;WanMgr: Selection Complete/Failed</code></pre> <p>Failover Call Flow:</p> <pre><code>sequenceDiagram\n    participant Monitor as Connectivity Monitor\n    participant FailPolicy as Failover Policy\n    participant WanMgr as WAN Manager Core\n    participant ISM1 as Primary Interface SM\n    participant ISM2 as Backup Interface SM\n\n    Monitor-&gt;&gt;FailPolicy: Connectivity Failure Detected\n    FailPolicy-&gt;&gt;WanMgr: Request Interface Switch\n    WanMgr-&gt;&gt;ISM1: Initiate Interface Teardown\n    ISM1--&gt;&gt;WanMgr: Teardown Complete\n    WanMgr-&gt;&gt;ISM2: Activate Backup Interface\n    ISM2-&gt;&gt;ISM2: Configure Interface\n    ISM2-&gt;&gt;Monitor: Test Connectivity\n    Monitor--&gt;&gt;ISM2: Validation Success\n    ISM2-&gt;&gt;FailPolicy: Interface Active\n    FailPolicy-&gt;&gt;WanMgr: Failover Complete</code></pre>"},{"location":"docu/oct21/wanmanager/#wan-management-policy-types","title":"WAN Management Policy Types","text":"<p>WAN Manager implements multiple policy algorithms that control interface selection and failover behavior. Each policy type serves specific deployment scenarios and network requirements.</p>"},{"location":"docu/oct21/wanmanager/#autowan-policy-wanmgr_policy_autowan_implc","title":"AutoWAN Policy (<code>wanmgr_policy_autowan_impl.c</code>)","text":"<p>Purpose: Sequential interface testing that automatically selects the first working interface from a prioritized list.</p> <p>Algorithm:  - Iterates through interfaces in priority order (highest priority first) - Tests each interface for physical connectivity and internet validation - Selects the first interface that passes all validation tests - Maintains active interface until failure, then restarts selection process</p> <p>Use Cases: Basic deployment scenarios where interface priority is predetermined and sequential selection is acceptable</p> <p>Configuration: Interface priorities set via TR-181 parameters, validation timeout configurable</p>"},{"location":"docu/oct21/wanmanager/#parallel-scan-policy-wanmgr_policy_parallel_scan_implc","title":"Parallel Scan Policy (<code>wanmgr_policy_parallel_scan_impl.c</code>)","text":"<p>Purpose: Simultaneous testing of all available interfaces to select the optimal connection based on quality metrics.</p> <p>Algorithm: - Initiates connectivity tests on all available interfaces simultaneously - Evaluates interfaces based on configurable criteria (latency, throughput, reliability) - Selects the best-performing interface from the test results - Provides faster interface selection than sequential testing</p> <p>Use Cases: Environments requiring optimal interface selection based on real-time performance metrics</p> <p>Configuration: Quality thresholds, test duration, and scoring algorithms configurable through TR-181</p>"},{"location":"docu/oct21/wanmanager/#fixed-mode-policy-wanmgr_policy_fm_implc","title":"Fixed Mode Policy (<code>wanmgr_policy_fm_impl.c</code>)","text":"<p>Purpose: Maintains a single designated interface as the active WAN connection without automatic switching.</p> <p>Algorithm: - Activates only the configured primary interface - Monitors interface health but does not perform automatic failover - Requires manual intervention or external control for interface changes - Provides predictable, stable connectivity for controlled environments</p> <p>Use Cases: Deployments requiring consistent interface usage, testing scenarios, or environments with external failover management</p> <p>Configuration: Fixed interface selection via TR-181 parameter configuration</p>"},{"location":"docu/oct21/wanmanager/#priority-policy-wanmgr_policy_pp_implc","title":"Priority Policy (<code>wanmgr_policy_pp_impl.c</code>)","text":"<p>Purpose: Maintains strict interface priority ordering with automatic failover and restoration capabilities.</p> <p>Algorithm: - Continuously monitors all interfaces in priority order - Automatically fails over to the highest priority available interface - Implements restoration logic to return to higher priority interfaces when they recover - Provides deterministic failover behavior based on configured priorities</p> <p>Use Cases: Enterprise deployments requiring predictable failover patterns with clear interface hierarchy</p> <p>Configuration: Interface priorities, restoration delays, and validation parameters via TR-181</p>"},{"location":"docu/oct21/wanmanager/#priority-with-override-bridge-policy-wanmgr_policy_ppob_implc","title":"Priority with Override Bridge Policy (<code>wanmgr_policy_ppob_impl.c</code>)","text":"<p>Purpose: Extends Priority Policy with LAN bridge integration during interface transitions.</p> <p>Algorithm: - Implements Priority Policy interface selection logic - Temporarily bridges interfaces to LAN during failover transitions to maintain connectivity - Manages bridge configuration and removal after successful interface transitions - Provides seamless connectivity during interface switching</p> <p>Use Cases: Environments requiring uninterrupted LAN connectivity during WAN interface transitions</p>"},{"location":"docu/oct21/wanmanager/#fixed-mode-with-override-bridge-policy-wanmgr_policy_fmob_implc","title":"Fixed Mode with Override Bridge Policy (<code>wanmgr_policy_fmob_impl.c</code>)","text":"<p>Purpose: Combines Fixed Mode operation with LAN bridge integration for enhanced connectivity assurance.</p> <p>Algorithm: - Maintains fixed interface operation with bridge fallback capabilities - Activates LAN bridge when primary fixed interface fails - Provides connectivity preservation without automatic interface switching - Supports manual intervention while maintaining service availability</p> <p>Use Cases: Fixed interface deployments requiring emergency connectivity preservation</p>"},{"location":"docu/oct21/wanmanager/#tr181-data-models","title":"TR\u2011181 Data Models","text":""},{"location":"docu/oct21/wanmanager/#supported-tr-181-parameters","title":"Supported TR-181 Parameters","text":"<p>The WAN Manager implements a comprehensive TR-181 data model following BBF specifications with custom RDK extensions for advanced WAN management capabilities. The implementation supports both standard TR-181 objects and RDK-specific extensions for enhanced functionality.</p>"},{"location":"docu/oct21/wanmanager/#object-hierarchy","title":"Object Hierarchy","text":"<pre><code>Device.\n\u2514\u2500\u2500 X_RDK_WanManager.\n    \u251c\u2500\u2500 Enable (boolean, R/W)\n    \u251c\u2500\u2500 Version (string, R)\n    \u251c\u2500\u2500 Data (string, R/W)\n    \u251c\u2500\u2500 AllowRemoteInterfaces (boolean, R/W)\n    \u251c\u2500\u2500 ResetDefaultConfig (boolean, R/W)\n    \u251c\u2500\u2500 RestorationDelay (uint32, R/W)\n    \u251c\u2500\u2500 WanFailoverData (string, R/W)\n    \u251c\u2500\u2500 DnsConnectivityCheck.\n    \u2502   \u2514\u2500\u2500 Enable (boolean, R/W)\n    \u251c\u2500\u2500 CPEInterface.{i}.\n    \u2502   \u251c\u2500\u2500 Enable (boolean, R/W)\n    \u2502   \u251c\u2500\u2500 Name (string, R/W)\n    \u2502   \u251c\u2500\u2500 Type (string, R/W)\n    \u2502   \u251c\u2500\u2500 DisplayName (string, R/W)\n    \u2502   \u251c\u2500\u2500 Group (uint32, R/W)\n    \u2502   \u251c\u2500\u2500 Priority (uint32, R/W)\n    \u2502   \u251c\u2500\u2500 Selection (boolean, R/W)\n    \u2502   \u251c\u2500\u2500 Status (string, R)\n    \u2502   \u251c\u2500\u2500 MonitorOperStatus (boolean, R/W)\n    \u2502   \u251c\u2500\u2500 BaseInterface (string, R/W)\n    \u2502   \u251c\u2500\u2500 Marking.\n    \u2502   \u2502   \u251c\u2500\u2500 SKBPort (int32, R/W)\n    \u2502   \u2502   \u2514\u2500\u2500 DSCPMark (int32, R/W)\n    \u2502   \u2514\u2500\u2500 VirtualInterface.{i}.\n    \u2502       \u251c\u2500\u2500 Enable (boolean, R/W)\n    \u2502       \u251c\u2500\u2500 Name (string, R/W)\n    \u2502       \u251c\u2500\u2500 Alias (string, R/W)\n    \u2502       \u251c\u2500\u2500 Status (string, R)\n    \u2502       \u251c\u2500\u2500 EnableMAPT (boolean, R/W)\n    \u2502       \u251c\u2500\u2500 EnableDSLite (boolean, R/W)\n    \u2502       \u251c\u2500\u2500 EnableIPoEHealthCheck (boolean, R/W)\n    \u2502       \u251c\u2500\u2500 Timeout (uint32, R/W)\n    \u2502       \u251c\u2500\u2500 Reset (boolean, R/W)\n    \u2502       \u251c\u2500\u2500 IP.\n    \u2502       \u2502   \u251c\u2500\u2500 Mode (string, R/W)\n    \u2502       \u2502   \u251c\u2500\u2500 PreferredMode (string, R/W)\n    \u2502       \u2502   \u251c\u2500\u2500 IPv4Source (string, R/W)\n    \u2502       \u2502   \u251c\u2500\u2500 IPv6Source (string, R/W)\n    \u2502       \u2502   \u251c\u2500\u2500 IPv4Status (string, R)\n    \u2502       \u2502   \u251c\u2500\u2500 IPv6Status (string, R)\n    \u2502       \u2502   \u2514\u2500\u2500 Interface (string, R/W)\n    \u2502       \u251c\u2500\u2500 PPP.\n    \u2502       \u2502   \u251c\u2500\u2500 Enable (boolean, R/W)\n    \u2502       \u2502   \u251c\u2500\u2500 Username (string, R/W)\n    \u2502       \u2502   \u251c\u2500\u2500 Password (string, R/W)\n    \u2502       \u2502   \u2514\u2500\u2500 AuthenticationProtocol (string, R/W)\n    \u2502       \u2514\u2500\u2500 VLAN.\n    \u2502           \u251c\u2500\u2500 Enable (boolean, R/W)\n    \u2502           \u251c\u2500\u2500 VLANID (int32, R/W)\n    \u2502           \u251c\u2500\u2500 Priority (int32, R/W)\n    \u2502           \u2514\u2500\u2500 Alias (string, R/W)\n</code></pre>"},{"location":"docu/oct21/wanmanager/#parameter-definitions","title":"Parameter Definitions","text":"<p>Core Parameters:</p> Parameter Path Data Type Access Default Value Description BBF Compliance <code>Device.X_RDK_WanManager.Enable</code> boolean R/W <code>true</code> Master enable/disable control for WAN Manager functionality. When false, all WAN management operations are suspended and interfaces remain in their current state. RDK Extension <code>Device.X_RDK_WanManager.Version</code> string R <code>\"2.0\"</code> Version string identifying the WAN Manager implementation and supported feature set. Read-only parameter for capability detection. RDK Extension <code>Device.X_RDK_WanManager.Data</code> string R/W <code>\"\"</code> JSON-formatted configuration data for advanced WAN Manager settings including policy parameters, validation thresholds, and custom behavioral configurations. RDK Extension <code>Device.X_RDK_WanManager.AllowRemoteInterfaces</code> boolean R/W <code>false</code> Controls whether WAN Manager accepts interface management requests from remote systems. When enabled, allows external controllers to influence interface selection decisions. RDK Extension <code>Device.X_RDK_WanManager.RestorationDelay</code> uint32 R/W <code>30</code> Time delay in seconds before attempting to restore a higher priority interface after it becomes available. Prevents flapping in unstable network conditions. RDK Extension <code>Device.X_RDK_WanManager.CPEInterface.{i}.Enable</code> boolean R/W <code>true</code> Per-interface enable control allowing individual interfaces to be excluded from WAN Manager control while maintaining configuration persistence. RDK Extension <code>Device.X_RDK_WanManager.CPEInterface.{i}.Type</code> string R/W <code>\"REMOTE_INTERFACE\"</code> Interface technology type identifier. Enumerated values: REMOTE_INTERFACE, ETHERNET_INTERFACE, CELLULAR_INTERFACE, DOCSIS_INTERFACE. Used for policy-specific handling. RDK Extension <code>Device.X_RDK_WanManager.CPEInterface.{i}.Priority</code> uint32 R/W <code>1</code> Interface selection priority value (1-255, where 1 is highest priority). Used by priority-based selection policies to determine interface preference order. RDK Extension <p>Virtual Interface Parameters:</p> Parameter Path Data Type Access Default Value Description BBF Compliance <code>Device.X_RDK_WanManager.CPEInterface.{i}.VirtualInterface.{i}.IP.Mode</code> string R/W <code>\"Dual Stack\"</code> IP configuration mode for the virtual interface. Enumerated values: \"IPv4 Only\", \"IPv6 Only\", \"Dual Stack\", \"No IP\". Determines IP stack configuration behavior. RDK Extension <code>Device.X_RDK_WanManager.CPEInterface.{i}.VirtualInterface.{i}.IP.IPv4Source</code> string R/W <code>\"DHCP\"</code> IPv4 address assignment method. Enumerated values: \"Static\", \"DHCP\", \"PPP\". Controls how IPv4 addressing is configured on the interface. RDK Extension <code>Device.X_RDK_WanManager.CPEInterface.{i}.VirtualInterface.{i}.EnableMAPT</code> boolean R/W <code>false</code> Enable MAP-T (Mapping of Address and Port with Translation) for IPv4-over-IPv6 connectivity. Requires IPv6 transport and MAP-T domain configuration. RDK Extension <code>Device.X_RDK_WanManager.CPEInterface.{i}.VirtualInterface.{i}.VLAN.VLANID</code> int32 R/W <code>-1</code> VLAN identifier for tagged traffic (1-4094). Value -1 indicates untagged operation. Used for VLAN-aware interface configuration. RDK Extension <p>Custom Extensions:</p> <ul> <li>Failover Data Management: Custom JSON-based failover configuration allowing complex policy definitions beyond standard TR-181 capabilities</li> <li>DNS Connectivity Validation: Enhanced connectivity testing using DNS resolution validation in addition to standard reachability tests</li> <li>Interface Marking Support: Custom packet marking capabilities for QoS and traffic engineering applications</li> <li>Remote Interface Control: Extension allowing external systems to participate in interface selection decisions through standardized APIs</li> </ul>"},{"location":"docu/oct21/wanmanager/#parameter-registration-and-access","title":"Parameter Registration and Access","text":"<ul> <li>Implemented Parameters: WAN Manager implements 150+ TR-181 parameters covering interface configuration, policy settings, status reporting, and advanced features including IPv6 transition technologies and VLAN support</li> <li>Parameter Registration: Parameters are registered via RBus message bus using the Device.X_RDK_WanManager namespace with automatic data model validation and type checking</li> <li>Access Mechanism: Other RDK-B components access parameters through RBus method calls with JSON-formatted data exchange and event-based notifications for parameter changes</li> <li>Validation Rules: Comprehensive validation including range checking for numeric parameters, enumeration validation for string parameters, dependency validation between related parameters, and consistency checking across interface configurations</li> </ul>"},{"location":"docu/oct21/wanmanager/#internal-modules","title":"Internal Modules","text":"<p>The WAN Manager architecture is organized into specialized modules that handle distinct aspects of WAN connectivity management, from policy execution to low-level interface configuration.</p> Module/Class Description Key Files Policy Controller Implements policy-specific algorithms for interface selection including AutoWAN, Parallel Scan, Fixed Mode, and Priority-based selection <code>wanmgr_policy_*.c</code>, <code>wanmgr_controller.h</code> Interface State Machine Manages complete interface lifecycle from initialization through configuration to teardown with support for multiple IP configuration modes <code>wanmgr_interface_sm.c</code>, <code>wanmgr_interface_sm.h</code> Data Manager Provides centralized data access, configuration management, and persistent storage integration with thread-safe data structures <code>wanmgr_data.c</code>, <code>wanmgr_data.h</code> RBus Communication Handles all RBus message processing, event subscriptions, and TR-181 parameter operations with automatic data validation <code>wanmgr_ssp_messagebus_interface.c</code>, <code>wanmgr_dml_*.c</code> Network Utilities Implements low-level network operations including interface configuration, routing table management, and connectivity validation <code>wanmgr_net_utils.c</code>, <code>wanmgr_net_utils.h</code> WebConfig Handler Processes remote configuration updates from cloud management systems with validation and rollback capabilities <code>wanmgr_webconfig.c</code>, <code>wanmgr_webconfig_apis.c</code> Telemetry Reporter Collects and reports operational metrics, interface statistics, and performance data to Telemetry 2.0 system <code>wanmgr_telemetry.c</code>, <code>wanmgr_t2_telemetry.c</code> DHCP Integration Manages DHCP client operations for IPv4 and IPv6 including lease management and renewal handling <code>wanmgr_dhcpv4_*.c</code>, <code>wanmgr_dhcpv6_*.c</code> <pre><code>flowchart TD\n    subgraph WanManager[WAN Manager Process]\n        subgraph PolicyLayer[Policy Management Layer]\n            PC[Policy Controller]\n            FP[Failover Policy]\n            SP[Selection Policies]\n        end\n\n        subgraph InterfaceLayer[Interface Management Layer]\n            ISM[Interface State Machines]\n            NU[Network Utilities]\n            DHCP[DHCP Integration]\n        end\n\n        subgraph DataLayer[Data Management Layer]\n            DM[Data Manager]\n            WC[WebConfig Handler]\n            TM[Telemetry Reporter]\n        end\n\n        subgraph CommLayer[Communication Layer]\n            RBC[RBus Communication]\n            TR181[TR-181 DML]\n            IPC[IPC Manager]\n        end\n    end\n\n    %% Inter-layer connections\n    PC --&gt; ISM\n    FP --&gt; SP\n    SP --&gt; ISM\n    ISM --&gt; NU\n    ISM --&gt; DHCP\n    DM --&gt; ISM\n    DM --&gt; PC\n    WC --&gt; DM\n    TM --&gt; DM\n    RBC --&gt; TR181\n    TR181 --&gt; DM\n    IPC --&gt; ISM\n\n    %% External connections\n    RBC &lt;--&gt;|RBus Messages| ExtSys[External Systems]\n    WC &lt;--&gt;|HTTP/JSON| CloudMgmt[Cloud Management]\n    TM &lt;--&gt;|Metrics| Telemetry[Telemetry System]\n    NU &lt;--&gt;|System Calls| Linux[Linux Network Stack]\n\n    classDef policy fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n    classDef interface fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef data fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;\n    classDef communication fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n    classDef external fill:#fce4ec,stroke:#c2185b,stroke-width:2px;\n\n    class PC,FP,SP policy;\n    class ISM,NU,DHCP interface;\n    class DM,WC,TM data;\n    class RBC,TR181,IPC communication;\n    class ExtSys,CloudMgmt,Telemetry,Linux external;</code></pre>"},{"location":"docu/oct21/wanmanager/#component-interactions-ipc-mechanisms","title":"Component Interactions &amp; IPC Mechanisms","text":""},{"location":"docu/oct21/wanmanager/#system-architecture-overview","title":"System Architecture Overview","text":"<p>WAN Manager operates as a central coordinator in the RDK-B ecosystem, interfacing with multiple middleware components through RBus messaging for configuration management, with Interface Managers for physical layer control, and with system services for network configuration. The component publishes interface status events, processes configuration updates from WebConfig, and coordinates with VLAN and DHCP managers for complete network stack management.</p> <pre><code>flowchart TD\n    subgraph \"Cloud/Remote Systems\"\n        ACS[TR-069 ACS]\n        CloudMgmt[Cloud Management Platform]\n        WebUI[Management Web Interface]\n    end\n\n    subgraph \"RDK-B WAN Manager\"\n        WanCore[WAN Manager Core]\n        Policies[Policy Engines]\n        StateMachines[Interface State Machines]\n    end\n\n    subgraph \"RDK-B Middleware\"\n        PSM[Persistent Storage Manager]\n        CcspCr[Component Registrar]\n        VlanMgr[VLAN Manager] \n        DHCPMgr[DHCP Manager]\n        Telemetry[Telemetry 2.0]\n    end\n\n    subgraph \"Interface Management\"\n        EthMgr[Ethernet Manager]\n        CellMgr[Cellular Manager]\n        DocsisMgr[DOCSIS Manager]\n        GPONMgr[GPON Manager]\n    end\n\n    subgraph \"System Services\"\n        SysEvent[System Event Daemon]\n        NetworkStack[Linux Network Stack]\n        DHCPClient[DHCP Clients]\n    end\n\n    %% Remote system interactions\n    ACS &lt;--&gt;|TR-069/CWMP| WanCore\n    CloudMgmt &lt;--&gt;|WebConfig/HTTPS| WanCore\n    WebUI &lt;--&gt;|HTTP/REST| WanCore\n\n    %% RDK-B middleware interactions  \n    WanCore &lt;--&gt;|RBus/JSON| PSM\n    WanCore &lt;--&gt;|RBus/Registration| CcspCr\n    WanCore &lt;--&gt;|RBus/Config| VlanMgr\n    WanCore &lt;--&gt;|RBus/Control| DHCPMgr\n    WanCore &lt;--&gt;|RBus/Metrics| Telemetry\n\n    %% Interface manager interactions\n    WanCore &lt;--&gt;|RBus/Events| EthMgr\n    WanCore &lt;--&gt;|RBus/Events| CellMgr\n    WanCore &lt;--&gt;|RBus/Events| DocsisMgr\n    WanCore &lt;--&gt;|RBus/Events| GPONMgr\n\n    %% System service interactions\n    WanCore &lt;--&gt;|SysEvents| SysEvent\n    StateMachines &lt;--&gt;|Netlink/ioctl| NetworkStack\n    StateMachines &lt;--&gt;|IPC/Signals| DHCPClient\n\n    classDef remote fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n    classDef wanmgr fill:#fff3e0,stroke:#ef6c00,stroke-width:3px;\n    classDef middleware fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef interface fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;\n    classDef system fill:#fce4ec,stroke:#c2185b,stroke-width:2px;\n\n    class ACS,CloudMgmt,WebUI remote;\n    class WanCore,Policies,StateMachines wanmgr;\n    class PSM,CcspCr,VlanMgr,DHCPMgr,Telemetry middleware;\n    class EthMgr,CellMgr,DocsisMgr,GPONMgr interface;\n    class SysEvent,NetworkStack,DHCPClient system;</code></pre>"},{"location":"docu/oct21/wanmanager/#detailed-interaction-matrix","title":"Detailed Interaction Matrix","text":"Target Component/Layer Interaction Purpose IPC Mechanism Message Format Communication Pattern Key APIs/Endpoints RDK-B Middleware Components CcspCr (Component Registrar) Component registration and discovery, namespace management RBus Method Calls JSON-RPC Request-Response <code>registerComponent()</code>, <code>discoverComponent()</code> CcspPsm (Persistent Storage) Configuration persistence, parameter storage, system state RBus Method Calls JSON Key-Value Request-Response <code>PSM_Get_Record_Value2()</code>, <code>PSM_Set_Record_Value2()</code> VLAN Manager VLAN configuration, tagged interface creation, bridge management RBus Method Calls JSON Config Objects Request-Response <code>Device.Ethernet.VLANTermination.{i}.*</code> DHCP Manager DHCP client lifecycle, lease management, IP address assignment RBus Events + Method Calls JSON Configuration Pub-Sub + RPC <code>Device.DHCPv4.Client.{i}.*</code>, <code>dhcpv4c_get_ert_lease()</code> Telemetry 2.0 Performance metrics reporting, fault telemetry, usage statistics RBus Events T2 Event Format Pub-Sub <code>WAN_INTERFACE_ACTIVE</code>, <code>WAN_FAILOVER_EVENT</code> System &amp; HAL Layers Linux Network Stack Interface configuration, routing table updates, network namespace management Netlink Sockets + ioctl Binary Netlink Messages Asynchronous <code>RTM_NEWADDR</code>, <code>RTM_NEWROUTE</code>, <code>SIOCGIFFLAGS</code> System Event Daemon System-wide event coordination, service state changes Named Pipes + Shared Memory Text-based Events Pub-Sub <code>sysevent_set()</code>, <code>sysevent_get()</code>, <code>wan-status</code> Platform HAL Hardware abstraction for platform-specific operations Direct Function Calls C Structures Synchronous <code>platform_hal_GetFactoryResetCount()</code>, <code>platform_hal_SetLED()</code> Interface Management Layer Ethernet Manager Physical interface state monitoring, cable detection, link status RBus Events JSON Status Objects Event-driven <code>Device.Ethernet.Interface.{i}.Status</code>, <code>eth_hal_getAssociatedDevice()</code> Cellular Manager Cellular modem control, signal quality monitoring, PDP context management RBus Events + Method Calls JSON + Binary Data Hybrid <code>Device.Cellular.Interface.{i}.*</code>, <code>cellular_hal_get_signal_info()</code> DOCSIS Manager Cable modem status, downstream/upstream channel monitoring RBus Events JSON Status Reports Event-driven <code>Device.X_CISCO_COM_CableModem.*</code> GPON Manager Optical network terminal status, ONT registration state RBus Events JSON Status Objects Event-driven <code>Device.Optical.Interface.{i}.*</code> External Systems TR-069 ACS Remote device management, parameter configuration, firmware updates HTTP/HTTPS SOAP XML CWMP Messages Request-Response <code>GetParameterValues</code>, <code>SetParameterValues</code>, <code>AddObject</code> WebConfig Cloud Service Bulk configuration updates, policy deployment HTTPS REST JSON Configuration Blobs Pull-based Polling <code>GET /api/v1/device/{mac}/config</code>, <code>POST /api/v1/device/config</code> Management Web UI Real-time status monitoring, manual configuration HTTP/HTTPS REST JSON API Responses Request-Response <code>GET /api/wan/status</code>, <code>PUT /api/wan/interface/{id}/config</code>"},{"location":"docu/oct21/wanmanager/#event-publishing-subscription","title":"Event Publishing &amp; Subscription","text":"<p>Events Published by WAN Manager:</p> Event Name Event Topic/Path Trigger Condition Payload Format Subscriber Components <code>WAN_INTERFACE_ACTIVE</code> <code>Device.X_RDK_WanManager.InterfaceActiveEvent</code> Interface becomes active and passes connectivity validation JSON: <code>{interface_name, type, ip_address, timestamp, validation_method}</code> Applications requiring internet connectivity, Telemetry system, Management UI <code>WAN_INTERFACE_DOWN</code> <code>Device.X_RDK_WanManager.InterfaceDownEvent</code> Active interface loses connectivity or becomes unavailable JSON: <code>{interface_name, reason, timestamp, backup_available}</code> Dependent applications, Monitoring systems, Cloud management <code>WAN_FAILOVER_EVENT</code> <code>Device.X_RDK_WanManager.FailoverEvent</code> Automatic failover between interfaces occurs JSON: <code>{from_interface, to_interface, reason, policy_type, timestamp}</code> Network monitoring, Telemetry 2.0, Management systems <code>WAN_CONFIG_CHANGED</code> <code>Device.X_RDK_WanManager.ConfigChangeEvent</code> WAN Manager configuration parameters are modified JSON: <code>{parameter_name, old_value, new_value, source, timestamp}</code> Configuration management, Audit systems <p>Events Consumed by WAN Manager:</p> Event Source Event Topic/Path Purpose Expected Payload Handler Function Interface Managers <code>Device.{Technology}.Interface.{i}.StatusChange</code> React to physical interface state changes JSON: <code>{interface_id, status, link_speed, duplex_mode}</code> <code>WanMgr_HandleInterfaceStatusChange()</code> DHCP Manager <code>Device.DHCPv4.Client.{i}.LeaseEvent</code> Process DHCP lease acquisition or renewal JSON: <code>{client_id, ip_address, lease_time, gateway, dns_servers}</code> <code>WanMgr_HandleDHCPLeaseEvent()</code> WebConfig Service <code>Device.X_RDK_WebConfig.ConfigUpdate</code> Apply remote configuration changes JSON: <code>{config_version, parameters, validation_token}</code> <code>WanMgr_ProcessWebConfigUpdate()</code> System Event Daemon <code>wan-restart</code> Handle system-initiated WAN restart requests Text: <code>restart_reason</code> <code>WanMgr_HandleSystemRestartEvent()</code>"},{"location":"docu/oct21/wanmanager/#ipc-flow-patterns","title":"IPC Flow Patterns","text":"<p>Primary IPC Flow - Interface Activation:</p> <pre><code>sequenceDiagram\n    participant Policy as Selection Policy\n    participant WanCore as WAN Manager Core\n    participant RBus as RBus Message Bus\n    participant IntfMgr as Interface Manager\n    participant DHCP as DHCP Manager\n    participant NetStack as Network Stack\n\n    Policy-&gt;&gt;WanCore: Select Interface for Activation\n    WanCore-&gt;&gt;RBus: Publish Interface Selection Event\n    RBus-&gt;&gt;IntfMgr: Forward Selection Event\n    IntfMgr-&gt;&gt;WanCore: Confirm Interface Ready\n    WanCore-&gt;&gt;DHCP: Request IP Configuration\n    DHCP-&gt;&gt;NetStack: Configure IP Address/Routes\n    NetStack--&gt;&gt;DHCP: Configuration Success\n    DHCP--&gt;&gt;WanCore: IP Configuration Complete\n    WanCore-&gt;&gt;RBus: Publish Interface Active Event\n    RBus-&gt;&gt;Policy: Acknowledge Activation Success</code></pre> <p>Event Notification Flow:</p> <pre><code>sequenceDiagram\n    participant HW as Hardware Interface\n    participant HAL as Interface HAL\n    participant IntfMgr as Interface Manager\n    participant RBus as RBus Message Bus\n    participant WanCore as WAN Manager Core\n    participant Subscribers as Event Subscribers\n\n    HW-&gt;&gt;HAL: Physical Layer State Change\n    HAL-&gt;&gt;IntfMgr: Interface Status Update\n    IntfMgr-&gt;&gt;RBus: Publish Interface Event\n    RBus-&gt;&gt;WanCore: Deliver Interface Event\n    WanCore-&gt;&gt;WanCore: Process State Change\n    WanCore-&gt;&gt;RBus: Publish WAN Status Event\n    RBus-&gt;&gt;Subscribers: Deliver Status to Subscribers\n    Subscribers--&gt;&gt;RBus: Event Acknowledgment</code></pre>"},{"location":"docu/oct21/wanmanager/#implementation-details","title":"Implementation Details","text":""},{"location":"docu/oct21/wanmanager/#major-hal-apis-integration","title":"Major HAL APIs Integration","text":"<p>WAN Manager integrates with multiple HAL interfaces to manage diverse WAN technologies and perform platform-specific operations. The HAL integration provides hardware abstraction while enabling technology-specific optimizations.</p> <p>Core HAL APIs:</p> HAL API Purpose Parameters Return Values Implementation File <code>platform_hal_GetFactoryResetCount</code> Retrieve system factory reset counter for configuration validation <code>pulValue</code> (output counter) <code>RETURN_OK/RETURN_ERR</code> <code>wanmgr_platform_events.h</code> <code>platform_hal_SetLED</code> Control platform LED indicators for interface status display <code>LedColor</code>, <code>State</code>, <code>Interval</code> <code>RETURN_OK/RETURN_ERR</code> <code>wanmgr_controller.c</code> <code>ethernet_hal_getAssociatedDevice</code> Query ethernet interface association and capability information <code>interface_name</code>, <code>device_info</code> (output) <code>RETURN_OK/RETURN_ERR</code> <code>wanmgr_net_utils.c</code> <code>cellular_hal_get_signal_info</code> Retrieve cellular signal strength and quality metrics <code>interface_id</code>, <code>signal_data</code> (output) <code>RETURN_OK/RETURN_ERR</code> Policy validation logic <code>docsis_hal_GetDOCSISInfo</code> Access cable modem operational parameters and channel information <code>docsis_info</code> (output structure) <code>RETURN_OK/RETURN_ERR</code> Interface validation"},{"location":"docu/oct21/wanmanager/#key-implementation-logic","title":"Key Implementation Logic","text":"<ul> <li> <p>State Machine Engine: Core state machine implementation in <code>wanmgr_interface_sm.c</code> manages interface lifecycle with states including DISABLED, STANDBY, CONFIGURING, VALIDATING, and ACTIVE. State transition handlers in <code>wanmgr_interface_sm.h</code> define valid transitions and trigger appropriate configuration actions based on interface type and policy requirements.</p> </li> <li> <p>Event Processing: Hardware events are processed through RBus message handlers that map physical layer notifications to state machine inputs. The event processing pipeline includes event filtering, validation, and routing to appropriate policy engines or interface state machines based on interface group configuration.</p> </li> <li> <p>Error Handling Strategy: Multi-level error handling includes HAL error code mapping to standardized WAN Manager error states, automatic retry logic with exponential backoff for transient failures, timeout handling for configuration operations, and comprehensive logging with error correlation for troubleshooting support.</p> </li> <li> <p>Logging &amp; Debugging: State transition logging captures all interface state changes with timestamps and triggering conditions. Debug logging includes policy decision rationale, connectivity validation details, and performance metrics. Integration with RDK Logger provides configurable verbosity levels and category-based filtering for focused debugging.</p> </li> </ul>"},{"location":"docu/oct21/wanmanager/#key-configuration-files","title":"Key Configuration Files","text":"<p>WAN Manager utilizes multiple configuration files for TR-181 data model definitions, runtime parameters, and integration with the RDK-B system. These files define the component's operational parameters and integration points.</p> Configuration File Purpose Key Parameters Default Values Override Mechanisms <code>RdkWanManager_v2.xml</code> TR-181 data model definitions and DML API mappings Object hierarchy, parameter types, access permissions, function mappings Per-parameter defaults defined in XML schema WebConfig updates, TR-069 parameter operations <code>wanmanager.service</code> Systemd service configuration for WAN Manager daemon Service dependencies, startup ordering, resource limits <code>After=rbus.service CcspCr.service</code>, <code>Type=forking</code> Systemd override files, runtime service modifications <code>rdkwanmanager.conf</code> Runtime configuration parameters and policy settings Interface priorities, validation timeouts, policy selection <code>INTERFACE_TIMEOUT=30</code>, <code>CONNECTIVITY_CHECK=DNS</code> Environment variables, command-line arguments <code>wanmanager_webconfig.json</code> WebConfig parameter mappings and validation rules Parameter validation schemas, transformation rules Vendor-specific parameter mappings Remote WebConfig updates from cloud management <code>wanmanager_telemetry.conf</code> Telemetry 2.0 marker definitions and reporting configuration T2 event markers, reporting intervals, metric thresholds Standard RDK-B T2 markers for WAN events T2 configuration updates, runtime marker registration <p>The configuration system supports hierarchical parameter resolution with precedence order: WebConfig remote updates &gt; Local file overrides &gt; Compiled defaults. All configuration changes trigger validation and may require service restart for certain parameters to take effect.</p>"},{"location":"docu/raheen/cl_claude/","title":"CcspCommonLibrary Documentation","text":""},{"location":"docu/raheen/cl_claude/#1-overview","title":"1. Overview","text":"<ul> <li> <p>Purpose in RDK\u2011B Stack: CcspCommonLibrary serves as the foundational shared infrastructure and support framework for the entire RDK\u2011B CCSP (Common Component Software Platform) ecosystem. It provides centralized runtime services, configuration templates, service orchestration scripts, and common utility libraries that enable consistent deployment, management, and inter-component communication across all CCSP agents and RDK\u2011B middleware components.</p> </li> <li> <p>Key Features &amp; Responsibilities: CcspCommonLibrary delivers common runtime support code for CCSP component initialization and lifecycle management, standardized message bus configuration templates for both legacy CCSP and modern RBUS communication, comprehensive service orchestration scripts supporting multiple hardware architectures (ARM, Atom, MIPS, PC), extensive systemd service unit definitions for unified RDK\u2011B component deployment, shared utility APIs for configuration parsing and inter-component coordination, debug and diagnostic infrastructure for system-wide troubleshooting, data model packing utilities for TR-181 parameter serialization, and controlled migration tools for system upgrades and configuration evolution.</p> </li> <li> <p>Role in Broadband Router Architecture: Architecturally, CcspCommonLibrary operates as the horizontal infrastructure substrate beneath all functional CCSP agents and RDK\u2011B components. It eliminates code duplication by providing shared services for component bootstrapping, configuration management, message bus integration, and service lifecycle control. The library enables consistent deployment patterns, standardized logging mechanisms, and unified restart/recovery procedures across the entire platform, ensuring that diverse functional components (WiFi, Ethernet, Telemetry, TR-069, etc.) operate within a cohesive and manageable framework.</p> </li> </ul>"},{"location":"docu/raheen/cl_claude/#2-architecture-design","title":"2. Architecture / Design","text":""},{"location":"docu/raheen/cl_claude/#21-highlevel-design-principles","title":"2.1 High\u2011Level Design Principles","text":"<p>The architecture embodies principles of centralized infrastructure provision through shared libraries and configuration templates, modular separation with distinct source directories for different functional concerns (ccsp/, cosa/, util_api/, debug_api/, dm_pack/), deployment standardization via comprehensive systemd unit definitions and architecture-specific scripts, configuration abstraction enabling tunneled vs direct operation modes through paired config files, controlled evolution through version tracking and migration tooling, and operational consistency through standardized service lifecycle management and restart procedures. The design emphasizes reducing duplication across CCSP components while maintaining flexibility for platform-specific customization and deployment variations.</p>"},{"location":"docu/raheen/cl_claude/#22-component-boundaries-responsibilities","title":"2.2 Component Boundaries &amp; Responsibilities","text":"<p>CCSP Core Infrastructure: Provides fundamental CCSP framework support through the <code>source/ccsp/</code> directory, including component registration, identity management, and baseline service patterns that enable consistent CCSP agent behavior across the platform.</p> <p>COSA Abstraction Layer: Implements Component Object Service Abstraction patterns via <code>source/cosa/</code> modules, providing object-oriented interfaces and wrapper utilities that simplify data model implementation and parameter management for CCSP agents.</p> <p>Utility API Layer: Delivers reusable utility functions through <code>source/util_api/</code> for configuration parsing, string manipulation, time management, and other common operations required across multiple CCSP components.</p> <p>Debug and Diagnostic Infrastructure: Supplies debugging and diagnostic capabilities via <code>source/debug_api/</code> with structured logging frameworks, conditional trace mechanisms, and diagnostic hooks that enable systematic troubleshooting across the platform.</p> <p>Data Model Packing Services: Provides TR-181 data model serialization and marshalling utilities through <code>source/dm_pack/</code> that enable consistent parameter handling and inter-component data exchange.</p> <p>Service Orchestration Framework: Manages component lifecycle through comprehensive scripts in <code>scripts/</code> directory, supporting multi-architecture deployment, controlled startup/shutdown sequences, and restart coordination across CCSP agents.</p> <p>Configuration Management: Centralizes configuration templates in <code>config/</code> directory with support for operational mode variations (tunneled vs direct) and message bus parameter standardization across deployment scenarios.</p>"},{"location":"docu/raheen/cl_claude/#23-threading-model-if-applicable","title":"2.3 Threading Model (if applicable)","text":"<p>CcspCommonLibrary itself does not implement a specific threading model, as it primarily provides infrastructure libraries and configuration templates. However, it supplies thread-safe utility functions and synchronization primitives that consuming CCSP components can utilize. The service orchestration scripts operate in single-threaded shell environments, while the shared libraries provide thread-safe APIs that support multi-threaded CCSP agent implementations.</p>"},{"location":"docu/raheen/cl_claude/#24-c4-system-context-diagram","title":"2.4 C4 System Context Diagram","text":"<pre><code>graph TD\n    subgraph \"RDK\u2011B Platform\"\n        Operators[\ud83d\udc64 System Operators&lt;br/&gt;Configuration &amp; Management]\n        CCSPAgents[\ud83d\udd27 CCSP Agents&lt;br/&gt;WiFi, Ethernet, Telemetry, TR-069]\n    end\n\n    subgraph \"External Systems\"\n        Management[\ud83c\udf10 Management Systems&lt;br/&gt;ACS, Cloud Services]\n        Hardware[\u2699\ufe0f Hardware Platform&lt;br/&gt;Network Interfaces, Storage]\n    end\n\n    Operators --&gt;|Configuration Scripts| CcspCommonLibrary\n    CCSPAgents --&gt;|Shared Libraries &amp; APIs| CcspCommonLibrary\n    Management --&gt;|Remote Configuration| CcspCommonLibrary\n\n    subgraph \"CcspCommonLibrary Container\"\n        Infrastructure[\ud83c\udfd7\ufe0f Common Infrastructure&lt;br/&gt;Libraries, Scripts, Configuration Templates]\n        Infrastructure -.-&gt;|\"Service Orchestration, Config Management, Utility APIs\"| Infrastructure\n    end\n\n    CcspCommonLibrary --&gt;|Service Control| SystemD[\ud83d\udd27 systemd Service Manager]\n    CcspCommonLibrary --&gt;|Message Bus Config| MessageBus[\ud83d\udce1 DBus/RBUS Infrastructure]\n    CcspCommonLibrary --&gt;|Platform Integration| Hardware\n\n    classDef user fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n    classDef component fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef external fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n\n    class Operators,CCSPAgents user;\n    class CcspCommonLibrary,Infrastructure component;\n    class Management,Hardware,SystemD,MessageBus external;</code></pre>"},{"location":"docu/raheen/cl_claude/#25-c4-container-diagram","title":"2.5 C4 Container Diagram","text":"<pre><code>graph TD\n    subgraph Runtime [\"Linux/RDK\u2011B Runtime Environment\"]\n        subgraph CommonLibContainer [\"CcspCommonLibrary Infrastructure\"]\n            SourceLibs[Source Libraries&lt;br/&gt;ccsp/, cosa/, util_api/, debug_api/, dm_pack/]\n            ConfigTemplates[Configuration Templates&lt;br/&gt;Message Bus &amp; Service Configs]\n            Scripts[Orchestration Scripts&lt;br/&gt;Multi-Architecture Service Control]\n            SystemDUnits[SystemD Service Units&lt;br/&gt;Comprehensive Component Definitions]\n        end\n        subgraph ConfigFiles [\"Configuration Storage\"]\n            BasicConf[(\"basic.conf / basic_tunneled.conf\")]\n            MessageConf[(\"ccsp_msg.cfg / ccsp_msg_tunneled.cfg\")]\n        end\n        subgraph ServiceRuntime [\"Service Runtime\"]\n            SystemDMgr[systemd Manager]\n            MessageBus[DBus/RBUS Infrastructure]\n        end\n    end\n\n    SourceLibs --&gt;|Link-time Integration| CCSPComponents[CCSP Components]\n    ConfigTemplates --&gt;|Runtime Configuration| ConfigFiles\n    Scripts --&gt;|Service Control| SystemDMgr\n    SystemDUnits --&gt;|Service Definitions| SystemDMgr\n    ConfigFiles --&gt;|Bus Configuration| MessageBus\n\n    classDef infrastructure fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef config fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n    classDef runtime fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;\n\n    class SourceLibs,ConfigTemplates,Scripts,SystemDUnits infrastructure;\n    class BasicConf,MessageConf,ConfigFiles config;\n    class SystemDMgr,MessageBus,ServiceRuntime runtime;</code></pre>"},{"location":"docu/raheen/cl_claude/#26-design-explanation-request-flow","title":"2.6 Design Explanation &amp; Request Flow","text":"<p>Library Integration Flow: CCSP components link against shared libraries during build-time, incorporating common utility functions, CCSP framework support, and data model packing capabilities. Runtime initialization utilizes configuration templates and service scripts to establish consistent component behavior and message bus connectivity.</p> <p>Service Orchestration Flow: System deployment begins with systemd service unit installation, followed by architecture-specific script execution that initializes components with appropriate configuration templates. The restart and termination handlers provide coordinated lifecycle management across all CCSP agents.</p> <p>Configuration Management Flow: Deployment scenarios select between standard and tunneled configuration variants, enabling operational mode flexibility without code changes. Message bus configuration templates ensure consistent communication parameters across all components.</p> <p>Technology Stack: C programming language for shared libraries, Bash scripting for service orchestration, systemd for service management, DBus and RBUS for inter-component communication, GNU Autotools for build system, XML for configuration templates.</p>"},{"location":"docu/raheen/cl_claude/#3-internal-modules","title":"3. Internal Modules","text":"<p>The internal structure of CcspCommonLibrary reflects a comprehensive infrastructure approach with clear functional separation across distinct source directories. Each module provides specialized services that eliminate code duplication across CCSP components while maintaining clear boundaries and responsibilities.</p> Module/Class Description Key Files CCSP Core Framework Fundamental CCSP component support and framework utilities <code>source/ccsp/*</code> (directory structure) COSA Abstraction Component Object Service Abstraction layer and wrapper utilities <code>source/cosa/*</code> (directory structure) Utility API Library Common utility functions for configuration, string handling, time management <code>source/util_api/*</code> Debug API Framework Structured logging, diagnostic hooks, conditional tracing infrastructure <code>source/debug_api/*</code> Data Model Packing TR-181 parameter serialization and marshalling utilities <code>source/dm_pack/*</code> Test Framework Unit testing infrastructure and validation frameworks <code>source/test/*</code> Service Orchestration Scripts Multi-architecture service lifecycle management scripts <code>scripts/ccsp_restart.sh</code>, <code>scripts/cosa_start_*.sh</code> Architecture-Specific Launchers Platform-specific component initialization scripts <code>scripts/cli_start_arm.sh</code>, <code>scripts/cli_start_atom.sh</code>, etc. RBUS Integration Scripts RBUS flag synchronization and termination handling <code>scripts/rbusFlagSync.sh</code>, <code>scripts/rbus_termination_handler.sh</code> Configuration Templates Message bus and service configuration templates <code>config/basic.conf</code>, <code>config/ccsp_msg.cfg</code> Tunneled Config Variants Alternative configuration for tunneled operation modes <code>config/basic_tunneled.conf</code>, <code>config/ccsp_msg_tunneled.cfg</code> SystemD Service Definitions Comprehensive service unit definitions for all CCSP components <code>systemd_units/*.service</code>, <code>systemd_units/*.conf</code> SystemD Timer Units Timer-based service scheduling and monitoring <code>systemd_units/*.timer</code>, <code>systemd_units/*.path</code> Platform Config Files Hardware-specific configuration templates <code>systemd_units/docsis.conf</code>, <code>systemd_units/epon.conf</code>"},{"location":"docu/raheen/cl_claude/#31-module-breakdown-diagram","title":"3.1 Module Breakdown Diagram","text":"<pre><code>flowchart TD\n    subgraph SourceLibs [\"Source Libraries\"]\n        CCSPCore[ccsp/&lt;br/&gt;Framework Core]\n        COSALayer[cosa/&lt;br/&gt;Object Abstraction]\n        UtilAPI[util_api/&lt;br/&gt;Common Utilities]\n        DebugAPI[debug_api/&lt;br/&gt;Diagnostics]\n        DMPack[dm_pack/&lt;br/&gt;Data Model Packing]\n        TestSuite[test/&lt;br/&gt;Testing Framework]\n    end\n\n    subgraph Scripts [\"Orchestration Scripts\"]\n        ServiceScripts[Service Control&lt;br/&gt;ccsp_restart.sh, cosa_start_*.sh]\n        ArchScripts[Architecture Scripts&lt;br/&gt;cli_start_arm.sh, cli_start_atom.sh]\n        RBUSScripts[RBUS Integration&lt;br/&gt;rbusFlagSync.sh, rbus_termination_handler.sh]\n    end\n\n    subgraph Config [\"Configuration Management\"]\n        BasicConfig[Basic Configuration&lt;br/&gt;basic.conf, basic_tunneled.conf]\n        MessageConfig[Message Bus Config&lt;br/&gt;ccsp_msg.cfg, ccsp_msg_tunneled.cfg]\n    end\n\n    subgraph SystemD [\"SystemD Integration\"]\n        ServiceUnits[Service Units&lt;br/&gt;*.service files]\n        TimerUnits[Timer Units&lt;br/&gt;*.timer, *.path files]\n        ConfigUnits[Config Units&lt;br/&gt;*.conf files]\n    end\n\n    subgraph External [\"External Integration\"]\n        CCSPComponents[CCSP Components&lt;br/&gt;Link-time Integration]\n        SystemDMgr[systemd Manager&lt;br/&gt;Runtime Control]\n        MessageBus[Message Bus&lt;br/&gt;DBus/RBUS]\n    end\n\n    SourceLibs --&gt;|Link Libraries| CCSPComponents\n    Scripts --&gt;|Control Services| SystemDMgr\n    Config --&gt;|Configure| MessageBus\n    SystemD --&gt;|Define Services| SystemDMgr\n    CCSPComponents --&gt;|Use Framework| SourceLibs\n\n    classDef sourcelib fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef scripts fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n    classDef config fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n    classDef systemd fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;\n    classDef external fill:#fce4ec,stroke:#c2185b,stroke-width:2px;\n\n    class CCSPCore,COSALayer,UtilAPI,DebugAPI,DMPack,TestSuite sourcelib;\n    class ServiceScripts,ArchScripts,RBUSScripts scripts;\n    class BasicConfig,MessageConfig config;\n    class ServiceUnits,TimerUnits,ConfigUnits systemd;\n    class CCSPComponents,SystemDMgr,MessageBus external;</code></pre>"},{"location":"docu/raheen/cl_claude/#4-interaction-with-other-middleware-components","title":"4. Interaction with Other Middleware Components","text":"<p>CcspCommonLibrary serves as the foundational infrastructure layer that enables and coordinates interactions among all RDK\u2011B middleware components. Rather than direct peer-to-peer communication, the library provides the common substrate that facilitates standardized component behavior, consistent configuration management, and unified service lifecycle control across the entire CCSP ecosystem.</p> Component Purpose of Interaction Protocols/Mechanisms All CCSP Agents Link-time library integration and runtime framework support Static/dynamic linking, shared header inclusion CcspLMLite Service definition and lifecycle management systemd service units, orchestration scripts CcspPsm Configuration template provision and service control systemd units, configuration files CcspTr069PaSsp Message bus configuration and service orchestration DBus/RBUS config templates, service scripts CcspWifiAgent Framework utilities and diagnostic infrastructure Shared libraries, debug API integration CcspTelemetry Data model packing and service management dm_pack utilities, systemd service definitions CcspWebUI Service coordination and configuration templates systemd dependencies, config file templates Harvester Service definition and orchestration support systemd service units, startup scripts systemd Manager Service unit provisioning and lifecycle coordination Service unit files, timer definitions, path monitoring DBus/RBUS Infrastructure Configuration template provision and parameter standardization Configuration files, message bus templates"},{"location":"docu/raheen/cl_claude/#41-middleware-interaction-diagram","title":"4.1 Middleware Interaction Diagram","text":"<pre><code>flowchart TD\n    subgraph \"CCSP Agent Layer\"\n        LMLite[\ud83d\udcca CcspLMLite&lt;br/&gt;Network Monitoring]\n        PSM[\ud83d\udcbe CcspPsm&lt;br/&gt;Parameter Storage]\n        TR069[\ud83d\udd27 CcspTr069PaSsp&lt;br/&gt;Remote Management]\n        WiFi[\ud83d\udce1 CcspWifiAgent&lt;br/&gt;WiFi Management]\n        Telemetry[\ud83d\udcc8 CcspTelemetry&lt;br/&gt;Data Collection]\n        WebUI[\ud83d\udda5\ufe0f CcspWebUI&lt;br/&gt;Web Interface]\n        Harvester[\ud83d\udcca Harvester&lt;br/&gt;Data Harvesting]\n    end\n\n    subgraph \"CcspCommonLibrary Infrastructure\"\n        CommonLib[\ud83c\udfd7\ufe0f CcspCommonLibrary&lt;br/&gt;Shared Infrastructure]\n    end\n\n    subgraph \"System Infrastructure\"\n        SystemD[\u2699\ufe0f systemd Manager&lt;br/&gt;Service Control]\n        MessageBus[\ud83d\udce1 DBus/RBUS&lt;br/&gt;Message Bus]\n        FileSystem[\ud83d\udcbe Configuration Storage&lt;br/&gt;Templates &amp; Scripts]\n    end\n\n    LMLite -.-&gt;|Links Libraries &amp; Uses Config| CommonLib\n    PSM -.-&gt;|Links Libraries &amp; Uses Config| CommonLib\n    TR069 -.-&gt;|Links Libraries &amp; Uses Config| CommonLib\n    WiFi -.-&gt;|Links Libraries &amp; Uses Config| CommonLib\n    Telemetry -.-&gt;|Links Libraries &amp; Uses Config| CommonLib\n    WebUI -.-&gt;|Links Libraries &amp; Uses Config| CommonLib\n    Harvester -.-&gt;|Links Libraries &amp; Uses Config| CommonLib\n\n    CommonLib --&gt;|Provides Service Units| SystemD\n    CommonLib --&gt;|Provides Config Templates| MessageBus\n    CommonLib --&gt;|Stores Scripts &amp; Configs| FileSystem\n\n    SystemD --&gt;|Controls Services| LMLite\n    SystemD --&gt;|Controls Services| PSM\n    SystemD --&gt;|Controls Services| TR069\n    SystemD --&gt;|Controls Services| WiFi\n    SystemD --&gt;|Controls Services| Telemetry\n    SystemD --&gt;|Controls Services| WebUI\n    SystemD --&gt;|Controls Services| Harvester\n\n    classDef agents fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef common fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;\n    classDef system fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n\n    class LMLite,PSM,TR069,WiFi,Telemetry,WebUI,Harvester agents;\n    class CommonLib common;\n    class SystemD,MessageBus,FileSystem system;</code></pre>"},{"location":"docu/raheen/cl_claude/#5-interaction-with-other-layers","title":"5. Interaction with Other Layers","text":"<p>CcspCommonLibrary operates as a critical bridging layer between CCSP application components and the underlying Linux/RDK\u2011B system infrastructure. The library abstracts platform-specific details while providing standardized interfaces for component initialization, configuration management, and service lifecycle control. Upward interactions focus on providing consistent APIs and configuration templates to CCSP agents, while downward interactions involve direct integration with systemd for service management, filesystem operations for configuration template deployment, and message bus infrastructure for inter-component communication coordination.</p> Layer/Service Interaction Description Mechanism Linux systemd Service unit provisioning, lifecycle management, dependency coordination Service unit files, timer definitions, path monitoring units File System Configuration template storage, script deployment, log file management Standard file I/O, directory structures, script execution Message Bus (DBus/RBUS) Configuration template provision, parameter standardization Configuration files, template deployment Build System Library compilation, header distribution, package creation GNU Autotools, Makefile integration, static/dynamic linking Hardware Abstraction Platform-specific script variants, architecture adaptation Architecture-specific scripts, conditional compilation Process Management Service startup coordination, restart handling, termination control Shell script execution, signal handling, process supervision"},{"location":"docu/raheen/cl_claude/#51-layered-architecture-view","title":"5.1 Layered Architecture View","text":"<pre><code>graph TD\n    subgraph \"Application Layer\"\n        CCSPAgents[CCSP Functional Agents&lt;br/&gt;LMLite, PSM, TR-069, WiFi, Telemetry]\n        Management[Management Applications&lt;br/&gt;Web UI, ACS Integration, Diagnostics]\n    end\n\n    subgraph \"Middleware Infrastructure Layer\"\n        CommonLibrary[\ud83c\udfd7\ufe0f CcspCommonLibrary&lt;br/&gt;Shared Infrastructure &amp; Templates]\n        MessageBus[\ud83d\udce1 Message Bus Infrastructure&lt;br/&gt;DBus/RBUS Configuration]\n    end\n\n    subgraph \"System Services Layer\"\n        SystemD[\u2699\ufe0f systemd Service Manager&lt;br/&gt;Lifecycle Control]\n        FileSystem[\ud83d\udcbe File System&lt;br/&gt;Configuration Storage]\n        ProcessMgmt[\ud83d\udd27 Process Management&lt;br/&gt;Script Execution]\n    end\n\n    subgraph \"Operating System Layer\"\n        LinuxKernel[\ud83d\udc27 Linux Kernel&lt;br/&gt;System Calls, IPC Primitives]\n        Hardware[\u2699\ufe0f Hardware Platform&lt;br/&gt;Network, Storage, CPU Architecture]\n    end\n\n    CCSPAgents --&gt; CommonLibrary\n    Management --&gt; CommonLibrary\n    CommonLibrary --&gt; MessageBus\n    CommonLibrary --&gt; SystemD\n    CommonLibrary --&gt; FileSystem\n    CommonLibrary --&gt; ProcessMgmt\n    SystemD --&gt; LinuxKernel\n    FileSystem --&gt; LinuxKernel\n    ProcessMgmt --&gt; LinuxKernel\n    MessageBus --&gt; LinuxKernel\n    LinuxKernel --&gt; Hardware\n\n    classDef app fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n    classDef middleware fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef system fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;\n    classDef os fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n\n    class CCSPAgents,Management app;\n    class CommonLibrary,MessageBus middleware;\n    class SystemD,FileSystem,ProcessMgmt system;\n    class LinuxKernel,Hardware os;</code></pre>"},{"location":"docu/raheen/cl_claude/#6-ipc-mechanism","title":"6. IPC Mechanism","text":"<p>CcspCommonLibrary does not implement IPC mechanisms directly but provides the configuration templates and infrastructure support that enable consistent IPC operation across all CCSP components. The library supplies configuration templates for both DBus and RBUS message bus operations, ensuring standardized communication parameters and connection handling across the platform.</p> <ul> <li> <p>Type of IPC Support: Configuration template provision for DBus (legacy CCSP communication) and RBUS (modern high-performance messaging) with support for both standard and tunneled operation modes through paired configuration files.</p> </li> <li> <p>Message Format Configuration: Templates define message bus parameters, endpoint configurations, connection timeouts, and authentication settings. Configuration variants support different deployment scenarios (tunneled vs direct) without requiring code changes in consuming components.</p> </li> <li> <p>Flow Support: Templates enable both synchronous request/response patterns and asynchronous event publication across CCSP components. RBUS flag synchronization scripts coordinate transition between legacy and modern message bus implementations.</p> </li> </ul>"},{"location":"docu/raheen/cl_claude/#61-ipc-configuration-flow-diagram","title":"6.1 IPC Configuration Flow Diagram","text":"<pre><code>sequenceDiagram\n    participant Deploy as Deployment System\n    participant CommonLib as CcspCommonLibrary\n    participant Config as Configuration Templates\n    participant MessageBus as DBus/RBUS Infrastructure\n    participant Component as CCSP Component\n\n    note over Deploy,Component: Configuration Template Deployment\n    Deploy-&gt;&gt;CommonLib: Select Deployment Mode (Standard/Tunneled)\n    CommonLib-&gt;&gt;Config: Deploy Appropriate Config Templates\n    Config-&gt;&gt;Config: basic.conf vs basic_tunneled.conf\n    Config-&gt;&gt;Config: ccsp_msg.cfg vs ccsp_msg_tunneled.cfg\n\n    note over Deploy,Component: Message Bus Initialization\n    CommonLib-&gt;&gt;MessageBus: Apply Configuration Templates\n    MessageBus-&gt;&gt;MessageBus: Initialize with Template Parameters\n\n    note over Deploy,Component: Component Integration\n    Component-&gt;&gt;Config: Read Configuration Templates\n    Component-&gt;&gt;MessageBus: Connect Using Template Parameters\n    MessageBus--&gt;&gt;Component: Connection Established\n\n    note over Deploy,Component: RBUS Transition Coordination\n    CommonLib-&gt;&gt;CommonLib: Execute rbusFlagSync.sh\n    CommonLib-&gt;&gt;MessageBus: Coordinate DBus/RBUS Transition\n    MessageBus--&gt;&gt;Component: Update Connection Parameters</code></pre>"},{"location":"docu/raheen/cl_claude/#7-tr181-data-models","title":"7. TR\u2011181 Data Models","text":"<p>CcspCommonLibrary does not implement specific TR\u2011181 data models but provides the infrastructure and utilities that enable consistent TR\u2011181 parameter handling across all CCSP components. The library's data model packing utilities (dm_pack) provide serialization and marshalling capabilities that CCSP agents use to implement their respective TR\u2011181 object hierarchies.</p> <ul> <li> <p>Infrastructure Support: The dm_pack module provides generic TR\u2011181 parameter serialization, marshalling utilities for inter-component parameter exchange, and validation frameworks that ensure consistent parameter handling across all CCSP agents.</p> </li> <li> <p>Component Integration: CCSP agents utilize the shared data model packing utilities to implement their specific TR\u2011181 objects while maintaining consistent serialization formats and validation procedures.</p> </li> <li> <p>Configuration Template Support: The library provides configuration templates that enable consistent TR\u2011181 parameter access patterns across components, supporting both DBus CCSP parameter interfaces and RBUS property-based access mechanisms.</p> </li> </ul>"},{"location":"docu/raheen/cl_claude/#71-tr181-infrastructure-support-table","title":"7.1 TR\u2011181 Infrastructure Support Table","text":"Infrastructure Component Purpose Implementation Notes dm_pack Utilities TR\u2011181 parameter serialization and marshalling <code>source/dm_pack/*</code> Generic utilities for all CCSP components COSA Framework Object-oriented TR\u2011181 implementation support <code>source/cosa/*</code> Abstraction layer for data model objects Configuration Templates Standardized parameter access configuration <code>config/*.cfg</code> Message bus parameter access templates Debug Infrastructure TR\u2011181 parameter debugging and validation <code>source/debug_api/*</code> Diagnostic hooks for parameter operations"},{"location":"docu/raheen/cl_claude/#8-implementation-details","title":"8. Implementation Details","text":"<p>The implementation of CcspCommonLibrary emphasizes infrastructure provision and code reuse through carefully designed shared libraries and configuration templates. The modular architecture enables independent evolution of different infrastructure concerns while maintaining consistent integration patterns across all consuming CCSP components.</p> <ul> <li>Key Infrastructure Patterns: </li> <li>Shared Library Architecture: Common utilities compiled into shared libraries that CCSP components link against, eliminating code duplication while enabling centralized maintenance and updates</li> <li>Configuration Template System: Paired configuration files (standard vs tunneled) enabling operational mode selection without code changes, supporting flexible deployment scenarios</li> <li>Multi-Architecture Script Framework: Architecture-specific startup scripts (ARM, Atom, MIPS, PC) providing consistent component initialization across diverse hardware platforms</li> <li> <p>SystemD Integration Pattern: Comprehensive service unit definitions enabling unified lifecycle management, dependency coordination, and restart procedures across all CCSP components</p> </li> <li> <p>Error Handling Strategy: </p> </li> <li>Centralized Logging Framework: Debug API provides consistent logging infrastructure with configurable verbosity levels and component-specific prefixes for systematic troubleshooting</li> <li>Script Error Propagation: Service orchestration scripts implement robust error checking with clear exit codes and diagnostic output for deployment troubleshooting</li> <li>Configuration Validation: Template deployment includes validation mechanisms to ensure configuration consistency and detect deployment errors early</li> <li> <p>Service Recovery Coordination: Restart scripts provide coordinated recovery procedures that maintain system consistency during component failures</p> </li> <li> <p>Operational Support:</p> </li> <li>Version Control Integration: Version.txt and ChangeLog provide controlled evolution tracking with semantic versioning and migration support</li> <li>Testing Infrastructure: Comprehensive test framework in source/test/ validates shared library functionality and configuration template correctness</li> <li>Migration Support: Upgrade procedures coordinate configuration template updates and service restart sequences during platform evolution</li> <li>Diagnostic Integration: Debug API provides systematic diagnostic hooks and structured logging that enables effective troubleshooting across component boundaries</li> </ul>"},{"location":"docu/raheen/cl_claude/#9-key-configuration-files","title":"9. Key Configuration Files","text":"<p>CcspCommonLibrary's configuration architecture centers on providing flexible template-based configuration that supports multiple deployment scenarios without requiring code modifications. The paired configuration approach enables operational mode selection while maintaining consistent parameter definitions across all CCSP components.</p> Configuration File Purpose Key Parameters Default Values Override Mechanisms <code>config/basic.conf</code> Standard operation mode configuration template Service parameters, timeout values, logging levels Platform-specific defaults Environment variables, deployment scripts <code>config/basic_tunneled.conf</code> Tunneled operation mode configuration template Modified endpoints, tunnel parameters, security settings Tunneled-specific defaults Deployment mode selection scripts <code>config/ccsp_msg.cfg</code> Standard message bus configuration template Bus endpoints, connection parameters, timeout values Standard DBus/RBUS defaults Runtime parameter updates <code>config/ccsp_msg_tunneled.cfg</code> Tunneled message bus configuration template Tunnel endpoints, encryption parameters, routing config Tunneled communication defaults Deployment-time template selection"},{"location":"docu/raheen/cl_claude/#91-systemd-service-configuration","title":"9.1 SystemD Service Configuration","text":"<p>The extensive systemd service unit collection provides comprehensive service definitions for the entire RDK\u2011B component ecosystem:</p> Service Category Examples Purpose Configuration Parameters CCSP Core Services <code>CcspLMLite.service</code>, <code>PsmSsp.service</code>, <code>CcspTr069PaSsp.service</code> Core CCSP component service definitions Dependencies, restart policies, environment variables Network Services <code>CcspWanAgent.service</code>, <code>ccspwifiagent.service</code>, <code>CcspMoca.service</code> Network interface management services Interface dependencies, startup ordering Management Services <code>CcspWebUI.service</code>, <code>CcspTelemetry.service</code>, <code>harvester.service</code> System management and monitoring services Resource limits, security contexts Timer Services <code>nvram-monitor.timer</code>, <code>rdkntp.path</code> Scheduled and event-triggered services Timer intervals, path monitoring Platform Services <code>RdkWanManager.service</code>, <code>RdkLedManager.service</code> Hardware-specific platform services Platform dependencies, hardware requirements"},{"location":"docu/raheen/cl_claude/#92-configuration-management-strategy","title":"9.2 Configuration Management Strategy","text":"<ul> <li>Template Selection: Deployment scripts select appropriate configuration templates based on operational requirements (standard vs tunneled mode)</li> <li>Parameter Override: Environment variables and deployment-specific settings can override template defaults without modifying base configuration files</li> <li>Version Coordination: Configuration template updates are coordinated with component version requirements to ensure compatibility</li> <li>Validation Integration: Configuration deployment includes validation procedures to verify template consistency and parameter correctness</li> </ul>"},{"location":"docu/raheen/cl_claude/#10-api-endpoints-if-applicable","title":"10. API Endpoints (if applicable)","text":"<p>CcspCommonLibrary provides shared library APIs rather than network endpoints. Key programming interfaces include:</p> API Category Library Module Description Key Functions Integration Method CCSP Framework APIs <code>source/ccsp/</code> Component registration and framework integration Component initialization, message bus registration Link-time library integration COSA Object APIs <code>source/cosa/</code> Object-oriented data model support Object creation, property management, validation Header inclusion and linking Utility APIs <code>source/util_api/</code> Common utility functions String handling, configuration parsing, time management Static library linking Debug APIs <code>source/debug_api/</code> Diagnostic and logging infrastructure Log level control, trace hooks, diagnostic output Compile-time integration Data Model APIs <code>source/dm_pack/</code> TR\u2011181 parameter serialization utilities Parameter packing, marshalling, validation Library linking and header inclusion"},{"location":"docu/raheen/cl_claude/#11-deployment-runtime-environment","title":"11. Deployment &amp; Runtime Environment","text":"<ul> <li>Integration Method: Compile-time and link-time integration into CCSP component builds, with runtime script and configuration deployment</li> <li>Orchestration: systemd service management with comprehensive dependency ordering and coordinated restart procedures</li> <li>Resource Requirements: </li> <li>Disk Storage: ~50MB for complete library, script, and configuration deployment</li> <li>Memory: Minimal baseline overhead, scales with number of active CCSP components</li> <li>CPU: Negligible baseline usage, brief activity during service orchestration and restart operations</li> <li>Supported Platforms: Multi-architecture support (ARM, Atom, MIPS, PC) with platform-specific deployment scripts and configuration variants</li> <li>Deployment Parameters: Architecture selection, operational mode (standard/tunneled), systemd service unit installation, configuration template deployment</li> </ul>"},{"location":"docu/raheen/cl_claude/#12-monitoring-security","title":"12. Monitoring &amp; Security","text":"<ul> <li>Infrastructure Monitoring: Component health tracking through systemd service status, script execution monitoring, configuration template validation</li> <li>Logging Coordination: Centralized logging framework integration across all CCSP components with consistent log formats and diagnostic capabilities</li> <li>Security Configuration: Template-based security parameter deployment, tunneled communication mode support, configuration validation and integrity checking</li> <li>Operational Auditing: Service lifecycle event logging, configuration change tracking, restart and recovery procedure auditing</li> </ul>"},{"location":"docu/raheen/cl_claude/#13-validation-review-checklist","title":"13. Validation &amp; Review Checklist","text":"<ul> <li>[x] Deployment Accuracy: Service units and scripts reflect actual RDK\u2011B component deployment patterns and dependencies</li> <li>[x] Infrastructure Completeness: All shared libraries, configuration templates, and orchestration scripts documented with accurate file references</li> <li>[x] Integration Patterns: Link-time and runtime integration mechanisms properly explained with specific API and configuration details</li> <li>[x] Multi-Architecture Support: Platform-specific scripts and configuration variants accurately represented</li> <li>[x] Service Coordination: systemd integration and service dependency management properly documented</li> <li>[x] Configuration Management: Template-based configuration approach and operational mode variants clearly explained</li> <li>[x] Shared Resource Management: Library APIs and utility functions documented with integration procedures and usage patterns</li> <li>[x] Version Control: Evolution management and migration procedures properly addressed</li> </ul>"},{"location":"docu/raheen/cl_claude/#14-conclusion-next-steps","title":"14. Conclusion &amp; Next Steps","text":"<p>CcspCommonLibrary serves as the essential infrastructure foundation for the entire RDK\u2011B CCSP ecosystem, providing the shared libraries, configuration templates, and service orchestration capabilities that enable consistent and manageable deployment of broadband router middleware components. Its comprehensive approach to infrastructure provision eliminates code duplication while maintaining flexibility for platform-specific adaptation and operational mode variations.</p> <p>The library's design successfully abstracts common infrastructure concerns while providing the necessary hooks and extension points for component-specific customization. Future enhancements may include expanded debugging and diagnostic capabilities, enhanced configuration template management, and improved multi-platform deployment automation.</p> <p>Related Resources: - Source Repository: CcspCommonLibrary component codebase with complete library and script collections - Build System: GNU Autotools integration with multi-architecture compilation support - SystemD Integration: Comprehensive service unit definitions and dependency management - Configuration Templates: Flexible template system supporting multiple operational modes and deployment scenarios</p> <p>This documentation provides comprehensive technical detail for developers, system architects, and operators working with CcspCommonLibrary within the RDK\u2011B platform. It serves as the authoritative reference for infrastructure integration, component development, and platform deployment procedures.</p>"},{"location":"docu/raheen/cl_gpt5/","title":"CcspCommonLibrary Documentation","text":""},{"location":"docu/raheen/cl_gpt5/#1-overview","title":"1. Overview","text":"<ul> <li>Purpose in RDK\u2011B Stack: <code>CcspCommonLibrary</code> provides the shared framework, runtime abstractions, utility APIs, message\u2011bus integration, data model scaffolding, logging, memory, timing, protocol helpers (HTTP, TLS, STUN), and object/service containers required by higher\u2011level CCSP / RDK\u2011B components (agents, managers, telemetry, provisioning). It standardizes bootstrapping and IPC wiring while reducing duplication across individual CCSP services.</li> <li>Key Features &amp; Responsibilities:</li> <li>Unified message bus (DBus / RBus) connection and configuration indirection.</li> <li>Data Model (DSLH) object/entity infrastructure and dynamic registration helpers.</li> <li>ANSC component object framework (containers, timers, sockets, crypto, XML parser, HTTP/TLS stacks).</li> <li>Logging and trace level harmonization (mapping CCSP levels to RDK LOG modules).</li> <li>Common startup / orchestration scripts for multi\u2011architecture (ARM / ATOM / MIPS / PC / remote) launches.</li> <li>Systemd unit templates &amp; service definitions consumed by downstream components.</li> <li>Utility APIs (ASN.1, SLAP service layer, STUN, TLS, Web server helpers) for feature components.</li> <li>Repository / object persistence abstractions leveraged by PSM and other managers.</li> <li>Role in Broadband Router Architecture: Acts as foundational \u201cinfrastructure substrate\u201d below functional agents (CM, WAN, WiFi, Telemetry, PSM, TR\u2011069 PA, etc.). All agents rely on its standardized bus access, logging, component object lifecycle, and data model registration pattern to expose TR\u2011181 parameters and perform inter\u2011component IPC.</li> </ul>"},{"location":"docu/raheen/cl_gpt5/#2-architecture-design","title":"2. Architecture / Design","text":""},{"location":"docu/raheen/cl_gpt5/#21-highlevel-design-principles","title":"2.1 High\u2011Level Design Principles","text":"<ul> <li>Modularity: Fine\u2011grained submodules (e.g., <code>AnscTimerScheduler</code>, <code>HttpSimpleServer</code>, <code>TlsHandShaker</code>) enable selective linking.</li> <li>Abstraction First: Bus, crypto, HTTP/TLS, object container, and data model layers isolate platform or protocol changes.</li> <li>Configurability: Deployment chooses local (UNIX) or tunneled (TCP) bus endpoints via simple config file swap.</li> <li>Reusability &amp; Consistency: Uniform memory, logging, and error handling macros across agents.</li> <li>Portability: Minimal platform\u2011specific conditionals; cross\u2011compile friendly (per README environment vars).</li> <li>Security Enablement: Central point to evolve auth/logging/transport hardening without touching each agent.</li> </ul>"},{"location":"docu/raheen/cl_gpt5/#22-component-boundaries-responsibilities","title":"2.2 Component Boundaries &amp; Responsibilities","text":"Boundary Provided By Responsibility Consumed By IPC Bus Abstraction <code>ccsp_msg_bus</code>, config files Connection endpoint resolution &amp; session establishment All CCSP Agents Data Model Core (DSLH Objects) <code>ccsp/components/common/DataModel/dml</code> Object/entity creation, parameter mapping PSM, TR\u2011069 PA, Agents Utility Protocol Stacks <code>util_api/http</code>, <code>util_api/tls</code>, <code>util_api/stun</code> Client/server + crypto handshake helpers WebUI, Telemetry, Remote Mgmt Object/Service Containers <code>util_api/ansc</code> Lifecycle, timers, async, module mapping All dynamic services Logging &amp; Debug <code>debug_api</code> Level mapping, module classification All components Scripts / Launch <code>scripts/*.sh</code> Standardized startup &amp; integration steps Device boot sequence Systemd Units (templates) <code>systemd_units/</code> Runtime orchestration &amp; dependency wiring Platform integration layer"},{"location":"docu/raheen/cl_gpt5/#23-threading-model-indicative","title":"2.3 Threading Model (Indicative)","text":"<p>While specific final linking choices depend on downstream components, the common patterns are: - Main Initialization Thread: Parses configuration, attaches to bus, registers objects. - Timer Scheduler Thread(s): Provided by <code>AnscTimerScheduler</code> for periodic tasks. - I/O Threads: For HTTP/TLS or socket oriented modules when embedded web/transport servers are used. - Event Callback Context: Bus callbacks (DBus/RBus) execute in library\u2011managed dispatch loops; design encourages minimal work then deferral to worker utilities.</p>"},{"location":"docu/raheen/cl_gpt5/#24-c4-system-context-diagram","title":"2.4 C4 System Context Diagram","text":"<pre><code>graph TD\n    classDef user fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n    classDef component fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef external fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n    classDef infra fill:#ede7f6,stroke:#5e35b1,stroke-width:2px;\n\n    Operator[\"\ud83d\udc64 Operator / Management Tools\"]:::user --&gt;|CLI / Remote Mgmt| CCSPAgents[\"Functional CCSP Agents\\n(CM, WAN, WiFi, Telemetry, PSM, TR-069)\"]:::component\n    ExternalACS[\"ACS / Cloud Services\"]:::external --&gt;|TR-069 / HTTPS| CCSPAgents\n    CCSPAgents --&gt;|IPC: DBus/RBus (method calls, events)| CommonLib[\"CcspCommonLibrary\\n(Infrastructure Substrate)\"]:::infra\n    CommonLib --&gt;|APIs / Utility Calls| PlatformHAL[\"Platform HAL / Drivers\"]:::external\n    CommonLib --&gt;|Logging / Metrics| LogStack[\"RDK Logging System\"]:::external\n    CommonLib --&gt;|Config Read| FS[(Filesystem Configs)]:::external</code></pre>"},{"location":"docu/raheen/cl_gpt5/#25-c4-container-diagram","title":"2.5 C4 Container Diagram","text":"<pre><code>graph TD\n    classDef layer fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef runtime fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;\n    classDef infra fill:#ede7f6,stroke:#5e35b1,stroke-width:2px;\n    classDef util fill:#e8f5e8,stroke:#2e7d32,stroke-width:1.5px;\n\n    subgraph RuntimeEnv[\"RDK-B Runtime (Linux)\"]\n        subgraph CommonLib[\"CcspCommonLibrary Process / Static Lib\"]\n            MsgBus[\"IPC Layer\\n(ccsp_msg_bus)\"]:::infra\n            DMCore[\"Data Model Core\\n(DSLH dml components)\"]:::infra\n            Ansc[\"ANSC Core\\n(object/timer/socket)\"]:::infra\n            UtilProto[\"Protocol Stacks\\n(HTTP / TLS / STUN / ASN.1)\"]:::util\n            Slap[\"SLAP Service Layer\"]:::util\n            DebugAPI[\"Debug &amp; Logging\\n(ansc_debug, trace mapping)\"]:::infra\n        end\n        subgraph AgentProc[\"Example Agent (e.g., CcspWanAgent)\"]\n            AgentDM[\"Agent-Specific DML\"]:::layer\n            AgentLogic[\"Business Logic\"]:::layer\n        end\n    end\n    AgentLogic --&gt;|Register Params| DMCore\n    AgentLogic --&gt;|Trace Calls| DebugAPI\n    AgentLogic --&gt;|Timer / Async| Ansc\n    AgentLogic --&gt;|IPC (method/event)| MsgBus\n    UtilProto --&gt;|Secure Transport| ExternalSvc[\"Cloud / ACS / Remote Service\"]</code></pre>"},{"location":"docu/raheen/cl_gpt5/#26-design-explanation-request-flow","title":"2.6 Design Explanation &amp; Request Flow","text":"<ul> <li>Initialization Flow: Script launches process \u2192 library parses <code>ccsp_msg*.cfg</code> \u2192 establishes DBus (or tunneled) connection \u2192 registers base component object(s) \u2192 DML modules publish parameter tree \u2192 agent logic attaches timers and event subscriptions.</li> <li>Request Handling: Incoming IPC method (Get/SetParameterValues, events) routed through message bus adapter \u2192 mapped to DSLH object tree \u2192 parameter accessors call ANSC/utility helpers \u2192 response serialized and returned.</li> <li>Technology Stack: C (ANSI), custom ANSC framework, DBus 1.x / RBus (version runtime dependent), TLS (OpenSSL backend via SSLeay wrappers), HTTP stack (custom lightweight), ASN.1 parsers, systemd for service orchestration, shell scripts for multi\u2011arch adaptation.</li> </ul>"},{"location":"docu/raheen/cl_gpt5/#3-internal-modules","title":"3. Internal Modules","text":"Module / Group Description Representative Paths Message Bus Adapter Abstracts DBus / RBus addressing &amp; connection; loads cfg; exposes method/event wrapper functions <code>config/ccsp_msg*.cfg</code>, <code>source/util_api/ccsp_msg_bus/</code> Data Model (DSLH) Components Core TR\u2011181 object/entity management scaffolding <code>source/ccsp/components/common/DataModel/dml/components/*</code> ANSC Core Objects Component object model, timers, containers, XML, sockets <code>source/util_api/ansc/Ansc*</code>, <code>source/util_api/ansc/AnscTimerScheduler</code> Crypto &amp; TLS Public/private crypto, session, handshake, record mgmt <code>source/util_api/ansc/AnscCrypto*</code>, <code>source/util_api/tls/components/*</code> HTTP Stack Client/server, proxies, message body, parsers <code>source/util_api/http/components/*</code> Web Module Web resource handling &amp; virtual host mapping <code>source/util_api/web/components/*</code> SLAP Services Service layer application proxying &amp; object wrappers <code>source/util_api/slap/components/*</code> STUN Client NAT traversal simple client logic <code>source/util_api/stun/components/StunSimpleClient</code> ASN.1 &amp; PKI ASN.1 basic, X509, PKCS12 parsing <code>source/util_api/asn.1/components/*</code> Logging &amp; Debug Trace level mapping to RDK log modules <code>source/debug_api/ansc_debug.c</code>, <code>source/debug_api/*.h</code> Utility Collections Object arrays, string utilities <code>source/cosa/utilities/AnscObjectArray/*</code> Scripts Multi\u2011arch launch, restart, flag sync <code>scripts/*.sh</code> Systemd Units (Reference) Service definitions for downstream agents <code>systemd_units/*.service</code> Build Integration Autotools metadata <code>configure.ac</code>, <code>Makefile.am</code>, <code>source/*/Makefile.am</code>"},{"location":"docu/raheen/cl_gpt5/#31-module-breakdown-diagram","title":"3.1 Module Breakdown Diagram","text":"<pre><code>flowchart TD\n    subgraph CcspCommonLibrary\n        MB[Message Bus Adapter]\\n\"ccsp_msg_bus\" --&gt; DM[Data Model Core]\\n\"DSLH dml\"\n        DM --&gt; ANSC[ANSC Core]\\n\"timers / sockets\"\n        ANSC --&gt; Utils[Utility Stacks]\\n\"HTTP / TLS / STUN / ASN.1\"\n        ANSC --&gt; SLAP[SLAP Layer]\n        Utils --&gt; Debug[Debug &amp; Logging]\n        Debug --&gt; MB\n    end</code></pre>"},{"location":"docu/raheen/cl_gpt5/#4-interaction-with-other-middleware-components","title":"4. Interaction with Other Middleware Components","text":"Component Purpose of Interaction Protocols/Mechanisms PSM (Persistence) Stores parameter values via registered DSLH tree DBus/RBus method calls TR-069 PA Retrieves/sets TR\u2011181 params using library DM scaffolding DBus/RBus (Get/SetParameterValues) Telemetry / T2 Uses logging &amp; bus helpers to emit events DBus/RBus events, trace macros WAN / WiFi / CM Agents Reuse bus, timers, HTTP/TLS, debug, DM building blocks Direct linkage + DBus/RBus Security / AdvSec Logging channel mapping &amp; parameter exposure DBus/RBus"},{"location":"docu/raheen/cl_gpt5/#41-middleware-interaction-diagram","title":"4.1 Middleware Interaction Diagram","text":"<pre><code>flowchart TD\n    classDef agent fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef infra fill:#ede7f6,stroke:#5e35b1,stroke-width:2px;\n\n    PSM[PSM Agent]:::agent --&gt;|Get/Set Params (DBus/RBus)| Common[ CcspCommonLibrary ]:::infra\n    TR069[TR-069 PA]:::agent --&gt;|DM Query (DBus/RBus)| Common\n    Telemetry[Telemetry]:::agent --&gt;|Event Publish| Common\n    WAN[WanAgent]:::agent --&gt;|Timers / HTTP / TLS APIs| Common\n    WiFi[WiFiAgent]:::agent --&gt;|DM Registration Helpers| Common</code></pre>"},{"location":"docu/raheen/cl_gpt5/#5-interaction-with-other-layers","title":"5. Interaction with Other Layers","text":"Layer/Service Interaction Description Mechanism HAL Drivers Agents (through library) call HAL after DM resolution Function calls / vendor APIs Filesystem Reads bus &amp; basic config files File I/O Systemd Launch &amp; supervise agent processes Service units (<code>systemd_units/*</code>) Cloud / ACS Via HTTP/TLS utilities for management flows HTTPS (custom stack)"},{"location":"docu/raheen/cl_gpt5/#51-layered-architecture-view","title":"5.1 Layered Architecture View","text":"<pre><code>graph TD\n    HAL[(HAL Layer)] --&gt; Agents[\"CCSP Agents\"] --&gt; CommonLib[\"CcspCommonLibrary\"] --&gt; Platform[(Linux / Systemd)]\n    CommonLib --&gt; Cloud[(Cloud / ACS Services)]</code></pre>"},{"location":"docu/raheen/cl_gpt5/#6-ipc-mechanism","title":"6. IPC Mechanism","text":"<ul> <li>Type of IPC: DBus (system bus) primary; RBus optional/parallel in some builds (abstracted by <code>ccsp_msg_bus</code>).</li> <li>Address Configuration: <code>ccsp_msg.cfg</code> (UNIX domain) vs <code>ccsp_msg_tunneled.cfg</code> (TCP host:port) selected by environment or compile\u2011time defines.</li> <li>DBus Policy Files: Provided minimal permissive example (<code>basic.conf</code> vs <code>basic_tunneled.conf</code>) controlling listen transport.</li> <li>Message Format: Conventional CCSP method signatures (e.g., GetParameterValues, SetParameterValues) with name/value arrays; events categorized by component namespaces.</li> <li>Flow: Agents use helper wrappers that hide raw DBus invocation building, enabling consistent error mapping and logging.</li> </ul>"},{"location":"docu/raheen/cl_gpt5/#61-ipc-flow-diagram","title":"6.1 IPC Flow Diagram","text":"<pre><code>sequenceDiagram\n    participant Agent as CCSP Agent\n    participant Common as CcspCommonLibrary\n    participant Bus as System Bus (DBus/RBus)\n    participant Target as Target Agent\n\n    Agent-&gt;&gt;Common: GetParameterValues(req)\n    Common-&gt;&gt;Bus: DBus Method Call (serialized)\n    Bus-&gt;&gt;Target: Dispatch getValues()\n    Target--&gt;&gt;Bus: Return values\n    Bus--&gt;&gt;Common: Reply (status, list)\n    Common--&gt;&gt;Agent: Normalized result</code></pre>"},{"location":"docu/raheen/cl_gpt5/#7-tr181-data-models","title":"7. TR\u2011181 Data Models","text":"<p><code>CcspCommonLibrary</code> does not own domain\u2011specific TR\u2011181 parameters; instead it supplies the DSLH infrastructure enabling other components to register and serve their parameter hierarchies. Typical interactions: - Parameter tree creation via DSLH object/entity constructors. - Registration hooks invoked during agent startup referencing library APIs. - Centralized mapping of parameter get/set to actual backend logic implemented in respective agent modules.</p>"},{"location":"docu/raheen/cl_gpt5/#71-tr181-parameter-facilitation-table-representative","title":"7.1 TR\u2011181 Parameter Facilitation Table (Representative)","text":"Aspect Library Role Example Consumer Object Entity Allocation Provides constructors and lifecycle mgmt TR\u2011069 PA, PSM Parameter Access Wrappers Normalizes get/set prototypes WANAgent, WiFiAgent Validation Hooks Supplies callback signatures PSM, TR\u2011069 PA Notification Dispatch Bridges change events to bus signals Telemetry, WebUI Type/Range Helpers Utility macros for validation All agents"},{"location":"docu/raheen/cl_gpt5/#8-implementation-details","title":"8. Implementation Details","text":"<ul> <li>Core Algorithms: Lightweight dispatcher patterns for message bus calls; object container registry for dynamic lookup (ANSC Object Mapper); timer wheel/scheduler for periodic tasks; layered crypto handshake orchestrating record and session managers.</li> <li>Error Handling Strategy: Functions return standardized status codes; bridging layer maps raw bus errors to CCSP trace outputs; validation short\u2011circuits propagate earliest failing module.</li> <li>Logging &amp; Debugging: <code>ansc_debug.c</code> maps component names to <code>LOG.RDK.*</code> domains; dynamic trace level adjustment ensures consistent verbosity; macros centralize formatting.</li> <li>Performance Considerations: Modular linking reduces footprint by excluding unused protocol stacks at build; config selection avoids runtime branching for bus transport.</li> <li>Extensibility: Adding a new protocol helper involves creating a subdirectory with consistent <code>Makefile.am</code> then exporting wrapper headers used by agents.</li> </ul>"},{"location":"docu/raheen/cl_gpt5/#9-key-configuration-files","title":"9. Key Configuration Files","text":"Configuration File Purpose Key Parameters / Values Default / Example Override Mechanisms <code>config/ccsp_msg.cfg</code> Local system bus endpoint <code>unix:path=/var/run/dbus/system_bus_socket</code> Local UNIX socket Replace file / alt env var at build integration <code>config/ccsp_msg_tunneled.cfg</code> Remote/tunneled bus endpoint <code>tcp:host=192.168.101.1,port=12368</code> Sample host/port Provide custom host/port or swap symlink <code>config/basic.conf</code> DBus policy (local) <code>&lt;listen&gt;unix:path=...</code> plus permissive policy Permissive Harden via allow rules <code>config/basic_tunneled.conf</code> DBus policy (tunneled transport) <code>&lt;listen&gt;tcp:host=...,port=...</code> Sample remote listen Restrict to specific users / SSL tunnel <code>source/ccsp/include/ccsp_custom_*.h</code> Platform customization hooks Compile\u2011time macros (e.g., bus cfg path) Per\u2011arch variant Select via architecture build"},{"location":"docu/raheen/cl_gpt5/#10-api-endpoints-interface-groups","title":"10. API Endpoints / Interface Groups","text":"<p>Although the library itself is not an HTTP service, its exported C APIs form logical groups:</p> Group Purpose Example Functions (Representative Names) Bus Connection Attach, register components, send methods <code>CcspBaseIf_registerCapabilities()</code>, <code>CcspBaseIf_discComponentSupportingNamespace()</code> DM Registration Create objects &amp; param mapping <code>DslhObjEntityCreate()</code>, <code>DslhVarEntityAdd()</code> Logging/Trace Set levels &amp; emit logs <code>AnscSetTraceLevel()</code>, <code>CcspTraceExec()</code> Timers &amp; Async Schedule periodic tasks <code>AnscCreateTimer()</code>, (timer scheduler APIs) HTTP/TLS Utilities Client/server sessions, handshake <code>HttpSimpleClient*</code>, <code>TlsSessionManager*</code> Crypto / ASN.1 Certificate / key parsing <code>AnscCryptoPub*</code>, <code>asn1_x509*</code> SLAP / Service Layer Object brokerage &amp; mapping <code>SlapObjContainer*</code>, <code>SlapEnvController*</code>"},{"location":"docu/raheen/cl_gpt5/#11-deployment-runtime-environment","title":"11. Deployment &amp; Runtime Environment","text":"<ul> <li>Build System: GNU Autotools (<code>autogen.sh</code>, <code>configure.ac</code>, <code>Makefile.am</code> hierarchy).</li> <li>Cross Compilation: Requires <code>CROSS_COMPILE</code>, <code>CCSP_COMMON_DIR</code>, <code>CCSP_OPENSOURCE_DIR</code> per README.</li> <li>Systemd Integration: Library content reused by units under <code>systemd_units/</code> (e.g., <code>CcspWanAgent.service</code>, <code>CcspTelemetry.service</code>).</li> <li>Resource Requirements: Scales with linked subsets; minimal core includes message bus + logging + DM; optional HTTP/TLS/ASN.1 increase footprint.</li> <li>Supported Platforms: Multi\u2011arch (ARM / x86 Atom / MIPS / PC) evidenced by architecture\u2011specific scripts &amp; headers.</li> <li>Startup Parameters: Usually indirect via environment and configuration file paths compiled into <code>ccsp_custom_*.h</code>.</li> </ul>"},{"location":"docu/raheen/cl_gpt5/#12-monitoring-security","title":"12. Monitoring &amp; Security","text":"<ul> <li>Monitoring: Centralized logging to RDK log system; can be scraped for component health; timers enable watchdog heartbeats in higher layers.</li> <li>Security Considerations:</li> <li>DBus policy samples are permissive; production should narrow <code>own</code> and <code>send_destination</code> to approved component names.</li> <li>TLS stack provides basis for secure outbound connections; ensure OpenSSL patched level externally.</li> <li>Logging module classification prevents information sprawl by channeling sensitive logs to correct domains.</li> <li>Hardening Opportunities: Introduce access control wrappers for bus calls, parameter validation enforcement layer, optional structured logging (JSON) for telemetry ingestion.</li> </ul>"},{"location":"docu/raheen/cl_gpt5/#13-validation-review-checklist","title":"13. Validation &amp; Review Checklist","text":"<ul> <li>[x] Deployment Accuracy: Diagrams show runtime grouping and agent/library relation.</li> <li>[x] Communication Specificity: IPC edges labeled (DBus/RBus).</li> <li>[x] Scaling Representation: Agents separated from shared library container.</li> <li>[x] Technology Versions: Mentioned DBus 1.x, TLS (OpenSSL), Autotools; concrete versions can be appended when build metadata available.</li> <li>[x] Implementation Details: Module paths &amp; representative directories included.</li> <li>[x] Visual Hierarchy: Mermaid classDefs distinguish actors vs infra.</li> <li>[x] Protocol Labels: Edges annotated clearly.</li> <li>[x] Mermaid Syntax: Uses valid graphs/flowcharts/sequence diagrams.</li> <li>[x] TR\u2011181 Coverage: Clarified facilitation role.</li> <li>[x] Code Accuracy: Paths &amp; file examples reflect repository (ChangeLog &amp; directory listings).</li> </ul>"},{"location":"docu/raheen/cl_gpt5/#14-conclusion-next-steps","title":"14. Conclusion &amp; Next Steps","text":"<p><code>CcspCommonLibrary</code> is the structural backbone of RDK\u2011B middleware, abstracting infrastructure complexities (IPC, data model scaffolding, protocol utilities, logging) so functional agents can focus on domain logic. Maintaining its modular clarity and tightening security policies will yield broad ecosystem benefits.</p> <p>Planned / Recommended Enhancements: 1. Harden DBus policy examples with least\u2011privilege defaults. 2. Introduce optional structured (JSON) logging adapter for telemetry uniformity. 3. Provide a consolidated API reference (auto\u2011generated headers \u2192 Markdown) for discoverability. 4. Add unit smoke tests in <code>test/</code> validating bus attach, DM registration lifecycle, and logging domain mapping. 5. Document RBus transition strategy (if/when migrating from DBus) including conditional compilation flags.</p> <p>References: README, ChangeLog, <code>configure.ac</code>, systemd unit files, downstream agent repositories (CcspWanAgent, CcspTelemetry, etc.).</p> <p>Generated following the provided RDK\u2011B documentation template, workflow, and diagram guidelines (deployment\u2011accurate grouping, protocol specificity, and consistent visual hierarchy). </p>"},{"location":"docu/raheen/lmlite_claude/","title":"CcspLMLite Documentation","text":""},{"location":"docu/raheen/lmlite_claude/#1-overview","title":"1. Overview","text":"<ul> <li> <p>Purpose in RDK\u2011B Stack: CcspLMLite (LAN Manager Lite) serves as the network device discovery, monitoring, and telemetry collection service within the RDK\u2011B middleware stack. It provides comprehensive visibility into connected network devices, traffic patterns, presence detection, and reporting capabilities for both local management and cloud telemetry systems. The component acts as the central hub for collecting, processing, and reporting network device information across the broadband gateway platform.</p> </li> <li> <p>Key Features &amp; Responsibilities: CcspLMLite delivers device discovery and enumeration for connected hosts, network traffic monitoring and reporting, device presence detection with configurable intervals, TR\u2011181 parameter management for network device data models, Avro\u2011based telemetry data serialization and transmission, WebPA integration for cloud connectivity, RBUS and DBus IPC support for middleware communication, extender device association tracking, and comprehensive reporting infrastructure for network analytics. The component mediates between low\u2011level network stack information and higher\u2011level management and telemetry systems.</p> </li> <li> <p>Role in Broadband Router Architecture: Architecturally, CcspLMLite operates as a middleware service layer between the network stack and management applications. It consumes network interface statistics, ARP tables, and device association data from the platform while providing structured device information to TR\u2011069 agents, telemetry services, and cloud management systems. The component bridges local network visibility with remote monitoring capabilities, enabling both real\u2011time device management and historical analytics.</p> </li> </ul>"},{"location":"docu/raheen/lmlite_claude/#2-architecture-design","title":"2. Architecture / Design","text":""},{"location":"docu/raheen/lmlite_claude/#21-highlevel-design-principles","title":"2.1 High\u2011Level Design Principles","text":"<p>The architecture manifests principles of modular separation through distinct LM (LAN Manager) and Ssp (Service Shell Provider) subsystems, telemetry\u2011first design with comprehensive Avro schema support for structured data serialization, event\u2011driven reporting with configurable intervals and thresholds, abstracted platform interfaces through wrapper APIs, standardized TR\u2011181 parameter modeling for device and traffic data, dual IPC transport support (DBus/RBUS) for flexible integration, plugin\u2011based extensibility for custom reporting modules, and comprehensive test coverage ensuring reliability across network monitoring scenarios. The design emphasizes real\u2011time data collection balanced with efficient resource utilization.</p>"},{"location":"docu/raheen/lmlite_claude/#22-component-boundaries-responsibilities","title":"2.2 Component Boundaries &amp; Responsibilities","text":"<p>LM (LAN Manager) Subsystem: Responsible for core network device discovery and monitoring logic, TR\u2011181 data model implementation for hosts and network devices, traffic monitoring and statistics collection, device presence detection algorithms, Avro\u2011based telemetry data packaging, WebPA interface implementation for cloud connectivity, RBUS API handlers for external communication, and report generation with configurable scheduling.</p> <p>Ssp Service Shell: Acts as the service entry point handling process initialization, DBus message bus integration, internal action dispatching, and service lifecycle management. It provides the standardized CCSP service framework while delegating functional operations to the LM subsystem.</p> <p>Telemetry Infrastructure: Manages Avro schema\u2011based data serialization for network device status and traffic reports, provides structured data export for cloud telemetry systems, and supports multiple reporting formats and destinations.</p>"},{"location":"docu/raheen/lmlite_claude/#23-threading-model-if-applicable","title":"2.3 Threading Model (if applicable)","text":"<p>The component employs an event\u2011driven single\u2011threaded model with periodic timer\u2011based reporting cycles. Network device scanning, presence detection, and traffic monitoring operate through scheduled callbacks and event handlers rather than dedicated threads. The RBUS and DBus integration layers handle asynchronous message processing while maintaining thread safety through the underlying transport mechanisms.</p>"},{"location":"docu/raheen/lmlite_claude/#24-c4-system-context-diagram","title":"2.4 C4 System Context Diagram","text":"<pre><code>graph TD\n    subgraph \"Network Infrastructure\"\n        Devices[\ud83d\udcf1 Connected Devices&lt;br/&gt;WiFi, Ethernet, MoCA]\n        Extenders[\ud83d\udce1 Mesh Extenders&lt;br/&gt;Associated Devices]\n    end\n\n    subgraph \"Management Systems\"\n        TR069[\ud83d\udd27 TR\u2011069 Agent&lt;br/&gt;Remote Management]\n        WebUI[\ud83d\udda5\ufe0f Web Interface&lt;br/&gt;Local Management]\n        Cloud[\u2601\ufe0f Cloud Telemetry&lt;br/&gt;Analytics Platform]\n    end\n\n    User[\ud83d\udc64 Network Administrator] --&gt;|Configuration| CcspLMLite\n    Devices --&gt;|Network Traffic| CcspLMLite\n    Extenders --&gt;|Device Association| CcspLMLite\n    TR069 --&gt;|DBus/RBUS Parameter Access| CcspLMLite\n    WebUI --&gt;|Device Status Queries| CcspLMLite\n\n    subgraph \"CcspLMLite Container\"\n        ComponentCore[\ud83d\udd27 LAN Manager Lite&lt;br/&gt;Device Discovery, Traffic Monitoring, Telemetry]\n        ComponentCore -.-&gt;|\"Real\u2011time Monitoring, Presence Detection, Report Generation\"| ComponentCore\n    end\n\n    CcspLMLite --&gt;|Avro Telemetry| Cloud\n    CcspLMLite --&gt;|WebPA Interface| Cloud\n    CcspLMLite --&gt;|Network Stack Queries| Platform[\u2699\ufe0f Platform Network Stack]\n\n    classDef user fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n    classDef component fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef external fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n\n    class User,TR069,WebUI,Devices,Extenders user;\n    class CcspLMLite,ComponentCore component;\n    class Cloud,Platform external;</code></pre>"},{"location":"docu/raheen/lmlite_claude/#25-c4-container-diagram","title":"2.5 C4 Container Diagram","text":"<pre><code>graph TD\n    subgraph Runtime [\"Linux/RDK\u2011B Middleware\"]\n        subgraph CcspLMLiteContainer [\"CcspLMLite Process\"]\n            SspLayer[Ssp Layer&lt;br/&gt;ssp_main.c, ssp_messagebus_interface.c]\n            LMCore[LM Core&lt;br/&gt;Device Discovery &amp; Monitoring]\n            TelemetryEngine[Telemetry Engine&lt;br/&gt;Avro Serialization &amp; Reporting]\n            RBUSInterface[RBUS Interface&lt;br/&gt;wtc_rbus_apis.c]\n            WebPAInterface[WebPA Interface&lt;br/&gt;webpa_interface.c]\n        end\n        subgraph ConfigFiles [\"Configuration\"]\n            LMLiteXML[(\"LMLite.XML\")]\n            AvroSchemas[(\"NetworkDevices*.avsc\")]\n        end\n    end\n\n    SspLayer --&gt;|\"Internal API Calls\"| LMCore\n    LMCore --&gt;|\"Report Generation\"| TelemetryEngine\n    TelemetryEngine --&gt;|\"Schema Validation\"| AvroSchemas\n    LMCore --&gt;|\"Configuration\"| LMLiteXML\n    RBUSInterface --&gt;|\"Parameter Access\"| LMCore\n    WebPAInterface --&gt;|\"Cloud Connectivity\"| TelemetryEngine\n\n    classDef process fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef config fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n\n    class SspLayer,LMCore,TelemetryEngine,RBUSInterface,WebPAInterface process;\n    class LMLiteXML,AvroSchemas config;</code></pre>"},{"location":"docu/raheen/lmlite_claude/#26-design-explanation-request-flow","title":"2.6 Design Explanation &amp; Request Flow","text":"<p>Initialization Sequence: Service startup begins in <code>ssp_main.c</code>, which initializes the DBus message bus interface through <code>ssp_messagebus_interface.c</code>, loads configuration from <code>LMLite.XML</code>, and initializes the LM subsystem with device discovery and monitoring capabilities. The plugin system loads through <code>plugin_main.c</code>, establishing TR\u2011181 parameter handlers and report generation infrastructure.</p> <p>Device Discovery Flow: Network device enumeration operates through periodic scans that query platform network interfaces, ARP tables, and association databases. Discovered devices are processed through <code>cosa_hosts_dml.c</code> for TR\u2011181 modeling and <code>network_devices_status.c</code> for telemetry reporting.</p> <p>Traffic Monitoring Flow: Network traffic collection utilizes <code>cosa_wantraffic_api.c</code> and related utilities to gather interface statistics, process bandwidth metrics, and generate traffic reports through the Avro\u2011based telemetry infrastructure.</p> <p>Technology Stack: C programming language, DBus and RBUS for IPC, Avro for data serialization, XML for configuration, TR\u2011181 data modeling, WebPA for cloud connectivity, GNU build system (autotools), Google Test framework for unit testing.</p>"},{"location":"docu/raheen/lmlite_claude/#3-internal-modules","title":"3. Internal Modules","text":"Module/Class Description Key Files LM Main Core LAN Manager initialization and coordination <code>lm_main.c</code>, <code>lm_main.h</code> LM API Public API interface for device and traffic management <code>lm_api.c</code>, <code>lm_api.h</code> LM Wrapper Platform abstraction and utility functions <code>lm_wrapper.c</code>, <code>lm_wrapper.h</code>, <code>lm_wrapper_priv.c</code> LM Utilities Common utility functions and helper routines <code>lm_util.c</code>, <code>lm_util.h</code> Device Hosts DML TR\u2011181 Hosts data model implementation <code>cosa_hosts_dml.c</code>, <code>cosa_hosts_dml.h</code> Extended Hosts DML Extended device information and capabilities <code>cosa_xhosts_dml.c</code>, <code>cosa_xhosts_dml.h</code> Network Device Status DML Device status monitoring data model <code>cosa_ndstatus_dml.c</code>, <code>cosa_ndstatus_dml.h</code> Network Device Traffic DML Traffic monitoring data model <code>cosa_ndtraffic_dml.c</code>, <code>cosa_ndtraffic_dml.h</code> Management Server DML TR\u2011181 ManagementServer implementation <code>cosa_managementserver_dml.c</code>, <code>cosa_managementserver_apis.c</code> Network Device Status Device status monitoring and reporting engine <code>network_devices_status.c</code>, <code>network_devices_status.h</code> Network Device Traffic Traffic monitoring and bandwidth analysis engine <code>network_devices_traffic.c</code>, <code>network_devices_traffic.h</code> WAN Traffic API WAN interface traffic collection and utilities <code>cosa_wantraffic_api.c</code>, <code>cosa_wantraffic_utils.c</code> Device Presence Detection Configurable device presence monitoring algorithms <code>device_presence_detection.c</code>, <code>device_presence_detection.h</code> Status Avro Serialization Device status telemetry Avro serialization <code>network_devices_status_avropack.c</code>, <code>network_devices_status_avropack.h</code> Traffic Avro Serialization Traffic telemetry Avro serialization <code>network_devices_traffic_avropack.c</code>, <code>network_devices_traffic_avropack.h</code> Extender Avro Serialization Extender device telemetry Avro serialization <code>extender_associated_devices_avropack.c</code>, <code>extender_associated_devices.c</code> WebPA Interface Cloud connectivity and remote management interface <code>webpa_interface.c</code>, <code>webpa_interface.h</code> WebPA Presence Detection WebPA\u2011integrated presence detection variants <code>webpa_pd_with_seshat.c</code>, <code>webpa_pd_without_seshat.c</code>, <code>webpa_pd.h</code> RBUS APIs RBUS transport implementation and management <code>wtc_rbus_apis.c</code>, <code>wtc_rbus_apis.h</code> RBUS Handler APIs RBUS event and parameter handler implementation <code>wtc_rbus_handler_apis.c</code>, <code>wtc_rbus_handler_apis.h</code> Network Devices Interface Generic network device interface abstraction <code>network_devices_interface.c</code>, <code>network_devices_interface.h</code> Reports Infrastructure Common reporting framework and utilities <code>cosa_reports_internal.c</code>, <code>cosa_reports_internal.h</code>, <code>report_common.h</code> Ssp Main Service shell process entry and initialization <code>ssp_main.c</code> Ssp Message Bus DBus integration and message handling <code>ssp_messagebus_interface.c</code>, <code>ssp_messagebus_interface.h</code> Ssp Action Internal action dispatching and coordination <code>ssp_action.c</code> Plugin Main Plugin system initialization and TR\u2011181 registration <code>plugin_main.c</code>, <code>plugin_main.h</code>"},{"location":"docu/raheen/lmlite_claude/#31-module-breakdown-diagram","title":"3.1 Module Breakdown Diagram","text":"<p>The module breakdown diagram illustrates the layered architecture and functional groupings within CcspLMLite. The Ssp layer provides process infrastructure and DBus integration, the LM Core manages fundamental device discovery and platform abstraction, TR\u2011181 Data Models implement standardized parameter interfaces, Device Monitoring engines provide real\u2011time network visibility, Telemetry infrastructure handles structured data export, External Interfaces enable cloud and RBUS connectivity, and the Plugin System provides extensible TR\u2011181 registration. Configuration files and Avro schemas serve as external inputs that define operational behavior and telemetry structure.</p> <pre><code>flowchart TD\n    subgraph Ssp[\"Ssp Service Shell\"]\n        SspMain[ssp_main.c&lt;br/&gt;Process Entry]\n        SspDBus[ssp_messagebus_interface.c&lt;br/&gt;DBus Integration]\n        SspAction[ssp_action.c&lt;br/&gt;Action Dispatcher]\n    end\n\n    subgraph LMCore[\"LM Core Services\"]\n        LMMain[lm_main.c&lt;br/&gt;Core Initialization]\n        LMAPI[lm_api.c&lt;br/&gt;Public Interface]\n        LMWrapper[lm_wrapper.c&lt;br/&gt;Platform Abstraction]\n        LMUtil[lm_util.c&lt;br/&gt;Utilities]\n    end\n\n    subgraph DataModels[\"TR\u2011181 Data Models\"]\n        HostsDML[cosa_hosts_dml.c&lt;br/&gt;Hosts Model]\n        XHostsDML[cosa_xhosts_dml.c&lt;br/&gt;Extended Hosts]\n        NDStatusDML[cosa_ndstatus_dml.c&lt;br/&gt;Device Status]\n        NDTrafficDML[cosa_ndtraffic_dml.c&lt;br/&gt;Traffic Model]\n        MgmtDML[cosa_managementserver_dml.c&lt;br/&gt;Management Server]\n    end\n\n    subgraph Monitoring[\"Device Monitoring\"]\n        DeviceStatus[network_devices_status.c&lt;br/&gt;Status Monitoring]\n        DeviceTraffic[network_devices_traffic.c&lt;br/&gt;Traffic Analysis]\n        PresenceDetect[device_presence_detection.c&lt;br/&gt;Presence Detection]\n        WANTraffic[cosa_wantraffic_api.c&lt;br/&gt;WAN Statistics]\n    end\n\n    subgraph Telemetry[\"Telemetry &amp; Reporting\"]\n        StatusAvro[network_devices_status_avropack.c&lt;br/&gt;Status Serialization]\n        TrafficAvro[network_devices_traffic_avropack.c&lt;br/&gt;Traffic Serialization]\n        ExtenderAvro[extender_associated_devices_avropack.c&lt;br/&gt;Extender Data]\n        ReportsCommon[cosa_reports_internal.c&lt;br/&gt;Report Framework]\n    end\n\n    subgraph Interfaces[\"External Interfaces\"]\n        WebPAIf[webpa_interface.c&lt;br/&gt;Cloud Interface]\n        WebPAPD[webpa_pd_with_seshat.c&lt;br/&gt;WebPA Presence Detection]\n        RBUSApi[wtc_rbus_apis.c&lt;br/&gt;RBUS Transport]\n        RBUSHandler[wtc_rbus_handler_apis.c&lt;br/&gt;RBUS Handlers]\n        NetworkIf[network_devices_interface.c&lt;br/&gt;Network Interface]\n    end\n\n    subgraph Plugin[\"Plugin System\"]\n        PluginMain[plugin_main.c&lt;br/&gt;Plugin Loader]\n    end\n\n    ConfigXML[config/LMLite.XML&lt;br/&gt;Configuration]\n    AvroSchemas[config/*.avsc&lt;br/&gt;Avro Schemas]\n\n    Ssp --&gt;|Initialize| LMCore\n    LMCore --&gt;|Register| DataModels\n    DataModels --&gt;|Query| Monitoring\n    Monitoring --&gt;|Generate| Telemetry\n    Telemetry --&gt;|Export| Interfaces\n    Plugin --&gt;|Load| DataModels\n    LMCore --&gt;|Configure| ConfigXML\n    Telemetry --&gt;|Validate| AvroSchemas\n\n    classDef ssp fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n    classDef core fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef datamodel fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;\n    classDef monitoring fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n    classDef telemetry fill:#fce4ec,stroke:#c2185b,stroke-width:2px;\n    classDef interface fill:#fff8e1,stroke:#f57c00,stroke-width:2px;\n    classDef plugin fill:#f1f8e9,stroke:#689f38,stroke-width:2px;\n\n    class SspMain,SspDBus,SspAction ssp;\n    class LMMain,LMAPI,LMWrapper,LMUtil core;\n    class HostsDML,XHostsDML,NDStatusDML,NDTrafficDML,MgmtDML datamodel;\n    class DeviceStatus,DeviceTraffic,PresenceDetect,WANTraffic monitoring;\n    class StatusAvro,TrafficAvro,ExtenderAvro,ReportsCommon telemetry;\n    class WebPAIf,WebPAPD,RBUSApi,RBUSHandler,NetworkIf interface;\n    class PluginMain plugin;</code></pre>"},{"location":"docu/raheen/lmlite_claude/#4-interaction-with-other-middleware-components","title":"4. Interaction with Other Middleware Components","text":"<p>CcspLMLite operates as a central network intelligence hub within the RDK\u2011B middleware ecosystem, providing comprehensive device discovery, monitoring, and telemetry services to a diverse array of functional components. The component's architecture emphasizes passive data collection and active reporting, interfacing with network management agents to gather association and capability information while simultaneously providing structured device and traffic data to telemetry, management, and user interface systems. Rather than maintaining direct peer\u2011to\u2011peer connections, all interactions are mediated through standardized DBus and RBUS IPC mechanisms that ensure consistent access patterns, reliable data delivery, and comprehensive error handling across component boundaries. The telemetry infrastructure with Avro\u2011based serialization enables structured data export to cloud analytics platforms, while the TR\u2011181 parameter implementation provides standardized access for both local management applications and remote TR\u2011069 operations. This architectural approach promotes loose coupling between components while enabling comprehensive network visibility and coordinated management workflows.</p> Component Purpose of Interaction Protocols/Mechanisms TR\u2011069 Agent (CcspTr069Pa) Provides TR\u2011181 parameter access for remote device management and bulk operations DBus parameter get/set operations, CCSP parameter interface WiFi Manager (CcspWifiAgent) Retrieves WiFi client association information, signal strength, and connection statistics RBUS property access, DBus method calls, event subscriptions Ethernet Manager Collects wired device information, link status, and port statistics DBus parameter queries, interface status notifications MoCA Agent (CcspMoCAAgent) Gathers MoCA network device data, topology information, and performance metrics RBUS/DBus parameter access, association table queries Telemetry Agent (Harvester) Receives Avro\u2011serialized device and traffic reports for cloud analytics WebPA interface, structured data export, periodic uploads Web UI (CcspWebUI) Provides real\u2011time device status and network information for user dashboard RBUS parameter access, real\u2011time queries, event notifications System Health Monitor Reports component health, operational status, and performance metrics DBus health check interfaces, status reporting PAM (CcspPandM) Coordinates with network configuration management and device provisioning DBus parameter coordination, configuration validation CM Agent (CcspCMAgent) Integrates with cable modem status and WAN connectivity information DBus interface queries, connection status updates DHCP Agent Correlates DHCP lease information with discovered network devices Parameter queries, lease table integration"},{"location":"docu/raheen/lmlite_claude/#41-middleware-interaction-diagram","title":"4.1 Middleware Interaction Diagram","text":"<pre><code>flowchart TD\n    subgraph \"Management Layer\"\n        TR069[TR\u2011069 Agent&lt;br/&gt;Remote Management]\n        WebUI[Web Interface&lt;br/&gt;Device Dashboard]\n        Harvester[Telemetry Harvester&lt;br/&gt;Cloud Analytics]\n    end\n\n    subgraph \"Network Components\"\n        WiFiMgr[\ud83d\udce1 WiFi Manager&lt;br/&gt;Client Associations]\n        EthMgr[\ud83d\udd0c Ethernet Manager&lt;br/&gt;Wired Devices]\n        MoCAMgr[\ud83d\udd17 MoCA Agent&lt;br/&gt;Network Topology]\n        HealthMon[\ud83d\udc8a Health Monitor&lt;br/&gt;System Status]\n    end\n\n    subgraph \"CcspLMLite Process\"\n        LMLiteCore[\ud83d\udd27 CcspLMLite Core&lt;br/&gt;Device Discovery + Traffic Monitoring]\n    end\n\n    TR069 --&gt;|DBus: TR\u2011181 Parameters| LMLiteCore\n    WebUI --&gt;|RBUS: Device Status Queries| LMLiteCore\n    Harvester --&gt;|WebPA: Avro Telemetry| LMLiteCore\n    WiFiMgr --&gt;|RBUS: Association Data| LMLiteCore\n    EthMgr --&gt;|DBus: Wired Device Info| LMLiteCore\n    MoCAMgr --&gt;|RBUS: Topology Data| LMLiteCore\n    HealthMon --&gt;|DBus: Health Status| LMLiteCore\n\n    LMLiteCore --&gt;|Avro Reports| Cloud[\u2601\ufe0f Cloud Analytics]\n    LMLiteCore --&gt;|Network Queries| Platform[\u2699\ufe0f Network Stack]\n\n    classDef mgmt fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n    classDef network fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef core fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;\n    classDef external fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n\n    class TR069,WebUI,Harvester mgmt;\n    class WiFiMgr,EthMgr,MoCAMgr,HealthMon network;\n    class LMLiteCore core;\n    class Cloud,Platform external;</code></pre>"},{"location":"docu/raheen/lmlite_claude/#5-interaction-with-other-layers","title":"5. Interaction with Other Layers","text":"<p>CcspLMLite interfaces upward with CCSP middleware components through standardized DBus and RBUS IPC mechanisms, ensuring consistent access to network device information and telemetry data. The component abstracts platform\u2011specific network stack interactions through wrapper APIs and utility functions, enabling portability across different RDK\u2011B hardware platforms. Downward interactions include direct network interface queries for device discovery, ARP table access for MAC address resolution, platform\u2011specific association databases for WiFi and MoCA devices, and filesystem access for configuration and temporary data storage. The layered design promotes modularity while maintaining efficient access to low\u2011level network information required for comprehensive device monitoring and reporting.</p> Layer/Service Interaction Description Mechanism Network Stack Device enumeration via ARP tables, interface statistics collection, routing table queries System calls, /proc filesystem, netlink sockets, ioctl operations Platform APIs Hardware\u2011specific device association queries, WiFi client tables, MoCA topology Wrapper functions via <code>lm_wrapper.c</code>, platform\u2011specific HAL calls System Services Timer management for periodic scanning, presence detection scheduling Timer callbacks, event loops, cron\u2011like scheduling File System Configuration file loading, temporary data storage, log file management Standard file I/O operations, XML parsing, directory monitoring Memory Management Device registry caching, telemetry data buffering, configuration storage Dynamic allocation, structured data caching, memory pool management Process Management Service lifecycle, component health monitoring, restart coordination Systemd integration, process signaling, dependency management"},{"location":"docu/raheen/lmlite_claude/#51-layered-architecture-view","title":"5.1 Layered Architecture View","text":"<p>The layered architecture diagram illustrates CcspLMLite's strategic position within the RDK\u2011B technology stack, showing how it serves as a horizontal service that spans multiple abstraction layers while maintaining clear boundaries and responsibilities. The component provides upward abstraction for network device information while efficiently accessing downward platform capabilities through well\u2011defined interfaces.</p> <pre><code>graph TD\n    subgraph \"Application Layer\"\n        Management[Management Applications&lt;br/&gt;TR\u2011069, WebUI, Cloud Services]\n        Analytics[Analytics &amp; Reporting&lt;br/&gt;Telemetry, Harvester, Dashboard]\n    end\n\n    subgraph \"Middleware Layer\"\n        IPC[IPC Transport&lt;br/&gt;DBus/RBUS]\n        CcspLMLite[\ud83d\udd27 CcspLMLite&lt;br/&gt;Network Device Manager]\n        OtherAgents[Other CCSP Agents&lt;br/&gt;WiFi, Ethernet, MoCA]\n    end\n\n    subgraph \"Platform Layer\"\n        NetworkStack[Network Stack&lt;br/&gt;Interface APIs, ARP Tables]\n        PlatformAPIs[Platform APIs&lt;br/&gt;Device Associations, Capabilities]\n        TimerServices[Timer Services&lt;br/&gt;Periodic Tasks, Scheduling]\n    end\n\n    subgraph \"System Layer\"\n        FileSystem[File System&lt;br/&gt;Configuration, Logs, Temp Data]\n        OS[Operating System&lt;br/&gt;Linux/RDK\u2011B Runtime]\n        Hardware[Network Hardware&lt;br/&gt;WiFi, Ethernet, MoCA Interfaces]\n    end\n\n    Management --&gt; IPC\n    Analytics --&gt; IPC\n    IPC --&gt; CcspLMLite\n    CcspLMLite &lt;--&gt; OtherAgents\n    CcspLMLite --&gt; NetworkStack\n    CcspLMLite --&gt; PlatformAPIs\n    CcspLMLite --&gt; TimerServices\n    CcspLMLite --&gt; FileSystem\n    NetworkStack --&gt; OS\n    PlatformAPIs --&gt; OS\n    FileSystem --&gt; OS\n    OS --&gt; Hardware\n\n    classDef app fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n    classDef middleware fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef platform fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;\n    classDef system fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n\n    class Management,Analytics app;\n    class IPC,CcspLMLite,OtherAgents middleware;\n    class NetworkStack,PlatformAPIs,TimerServices platform;\n    class FileSystem,OS,Hardware system;</code></pre>"},{"location":"docu/raheen/lmlite_claude/#6-ipc-mechanism","title":"6. IPC Mechanism","text":"<p>CcspLMLite utilizes dual IPC transport mechanisms to support both legacy DBus integration and modern RBUS communication patterns within the RDK\u2011B ecosystem. The DBus interface provides backward compatibility with existing CCSP components and TR\u2011069 agents, while the RBUS implementation enables high\u2011performance parameter access and event\u2011driven communication with newer middleware components. All external communication follows well\u2011defined message formats with structured parameter names, typed values, and comprehensive error reporting to ensure reliable integration across the platform.</p> <ul> <li> <p>Type of IPC: Dual transport architecture with DBus (via <code>ssp_messagebus_interface.c</code>) for CCSP compatibility and TR\u2011069 integration, RBUS (via <code>wtc_rbus_apis.c</code>) for enhanced performance and modern middleware communication, plus WebPA interfaces for cloud telemetry export and remote management connectivity.</p> </li> <li> <p>Message Format: DBus messages follow CCSP TR\u2011181 parameter conventions with hierarchical naming (e.g., <code>Device.Hosts.Host.{i}.PhysAddress</code>, <code>Device.DeviceInfo.NetworkDeviceTraffic.Enable</code>), strongly typed values (string, boolean, integer, unsigned integer, datetime), and standardized CCSP method signatures for GetParameterValues, SetParameterValues, and GetParameterNames operations. RBUS messages utilize property\u2011based access with subscription support for real\u2011time device status and traffic threshold events. Avro serialization provides structured telemetry data export with schema validation for NetworkDevicesStatus and NetworkDevicesTraffic reports.</p> </li> <li> <p>Flow: Synchronous request/response patterns for parameter access operations with immediate response for cached device information, asynchronous event publication for device discovery, association changes, and traffic threshold notifications, periodic telemetry report generation with configurable intervals for different data types, and WebPA\u2011based cloud communication for structured Avro data transmission with retry mechanisms and delivery confirmation.</p> </li> </ul>"},{"location":"docu/raheen/lmlite_claude/#61-ipc-flow-diagram","title":"6.1 IPC Flow Diagram","text":"<p>The following sequence diagram illustrates the complete interaction flow for device discovery, parameter access, real\u2011time monitoring, and telemetry export operations. The diagram shows how different IPC mechanisms are utilized for various operational patterns, from immediate parameter queries to long\u2011term telemetry data collection and cloud reporting.</p> <pre><code>sequenceDiagram\n    participant External as External Component\n    participant DBusIf as DBus Interface&lt;br/&gt;(ssp_messagebus_interface.c)\n    participant RBusIf as RBUS Interface&lt;br/&gt;(wtc_rbus_apis.c)\n    participant LMCore as LM Core&lt;br/&gt;(lm_api.c)\n    participant Monitoring as Device Monitoring&lt;br/&gt;(network_devices_status.c)\n    participant Telemetry as Telemetry Engine&lt;br/&gt;(*_avropack.c)\n\n    note over External,Telemetry: Device Status Query (DBus)\n    External-&gt;&gt;DBusIf: GetParameterValues(Device.Hosts.Host.{i}.*)\n    DBusIf-&gt;&gt;LMCore: Parameter Request\n    LMCore-&gt;&gt;Monitoring: Query Device Status\n    Monitoring--&gt;&gt;LMCore: Device Information\n    LMCore--&gt;&gt;DBusIf: Parameter Values\n    DBusIf--&gt;&gt;External: Response with Device Data\n\n    note over External,Telemetry: Real\u2011time Updates (RBUS)\n    External-&gt;&gt;RBusIf: Subscribe(Device.DeviceInfo.NetworkDeviceTraffic)\n    RBusIf-&gt;&gt;LMCore: Event Subscription\n    LMCore-&gt;&gt;Monitoring: Enable Traffic Monitoring\n\n    loop Periodic Reports\n        Monitoring-&gt;&gt;Telemetry: Generate Report Data\n        Telemetry-&gt;&gt;Telemetry: Avro Serialization\n        Telemetry--&gt;&gt;RBusIf: Event Notification\n        RBusIf--&gt;&gt;External: Traffic Update Event\n    end\n\n    note over External,Telemetry: Cloud Telemetry Export\n    LMCore-&gt;&gt;Telemetry: Schedule Report Generation\n    Telemetry-&gt;&gt;Telemetry: Avro Schema Validation\n    Telemetry-&gt;&gt;External: WebPA Upload (Avro Data)</code></pre>"},{"location":"docu/raheen/lmlite_claude/#7-tr181-data-models","title":"7. TR\u2011181 Data Models","text":"<p>CcspLMLite implements comprehensive TR\u2011181 data models focused on network device management, traffic monitoring, and presence detection capabilities. The component provides both standard TR\u2011181 objects for device information and extended custom parameters for enhanced network visibility and telemetry collection. All parameters support both read access for monitoring applications and write access for configuration management, with appropriate validation and persistence mechanisms.</p> <ul> <li> <p>Implemented Parameters: CcspLMLite implements TR\u2011181 Device.Hosts for network device enumeration, Device.DeviceInfo.NetworkDeviceStatus for device monitoring configuration, Device.DeviceInfo.NetworkDeviceTraffic for traffic analysis settings, Device.ManagementServer for TR\u2011069 integration, and comprehensive RDK\u2011Central custom extensions for enhanced network visibility and telemetry collection capabilities.</p> </li> <li> <p>Parameter Registration: Parameters are registered through the plugin system (<code>plugin_main.c</code>) during component initialization, with TR\u2011181 object handlers distributed across specialized DML modules (<code>cosa_hosts_dml.c</code>, <code>cosa_ndstatus_dml.c</code>, <code>cosa_ndtraffic_dml.c</code>). External components access parameters via both DBus CCSP parameter interfaces for legacy compatibility and RBUS property mechanisms for modern high\u2011performance access patterns.</p> </li> <li> <p>Custom Extensions: RDK\u2011Central extensions include advanced device presence detection with configurable algorithms and intervals, traffic monitoring with bandwidth thresholds and alerting capabilities, Avro\u2011based telemetry export configuration, extender device association tracking, and enhanced device capability reporting beyond standard TR\u2011181 specifications.</p> </li> </ul>"},{"location":"docu/raheen/lmlite_claude/#71-tr181-parameter-table","title":"7.1 TR\u2011181 Parameter Table","text":"Parameter Description Access (R/W) Default Notes <code>Device.Hosts.HostNumberOfEntries</code> Number of connected host devices R <code>0</code> Dynamic count <code>Device.Hosts.Host.{i}.PhysAddress</code> MAC address of connected device R <code>\"\"</code> Discovered via ARP <code>Device.Hosts.Host.{i}.IPAddress</code> IP address of connected device R <code>\"\"</code> Current network assignment <code>Device.Hosts.Host.{i}.AssociatedDevice</code> WiFi association path reference R <code>\"\"</code> WiFi devices only <code>Device.Hosts.Host.{i}.Layer3Interface</code> Layer 3 interface reference R <code>\"\"</code> Network interface path <code>Device.Hosts.Host.{i}.Active</code> Device active status R <code>false</code> Presence detection result <code>Device.DeviceInfo.NetworkDeviceStatus.Enable</code> Network device status reporting R/W <code>false</code> Enable/disable monitoring <code>Device.DeviceInfo.NetworkDeviceStatus.ReportingInterval</code> Status reporting interval (seconds) R/W <code>300</code> Configurable period <code>Device.DeviceInfo.NetworkDeviceTraffic.Enable</code> Traffic monitoring enable R/W <code>false</code> Enable/disable traffic reports <code>Device.DeviceInfo.NetworkDeviceTraffic.ReportingInterval</code> Traffic reporting interval (seconds) R/W <code>3600</code> Configurable period <code>Device.ManagementServer.URL</code> Management server endpoint R/W <code>\"\"</code> TR\u2011069 ACS URL <code>Device.X_RDKCENTRAL\u2011COM_Hosts.PresenceDetection.Enable</code> Device presence detection R/W <code>true</code> Custom extension <code>Device.X_RDKCENTRAL\u2011COM_Hosts.PresenceDetection.Interval</code> Presence check interval (seconds) R/W <code>60</code> Custom parameter"},{"location":"docu/raheen/lmlite_claude/#8-implementation-details","title":"8. Implementation Details","text":"<p>The implementation architecture emphasizes modular design with clear separation between data collection, processing, and reporting functions. Core algorithms include periodic network scanning using ARP table enumeration and platform\u2011specific device association queries, presence detection through configurable ping\u2011based and traffic\u2011based algorithms, traffic analysis using interface statistics with bandwidth calculation and threshold monitoring, and Avro\u2011based data serialization ensuring structured telemetry export with schema validation. The design balances real\u2011time responsiveness with resource efficiency through intelligent caching, lazy evaluation, and configurable reporting intervals.</p> <ul> <li> <p>Key Algorithms or Logic: Periodic network device discovery through ARP table scanning and platform association queries, presence detection using configurable ping and traffic analysis algorithms, traffic monitoring with bandwidth calculation and threshold\u2011based alerting, Avro schema\u2011based telemetry serialization for structured cloud reporting, and device capability detection through platform\u2011specific wrapper APIs.</p> </li> <li> <p>Error Handling Strategy: Hierarchical error propagation with component\u2011specific error codes, graceful degradation when platform APIs are unavailable, comprehensive logging with configurable verbosity levels, automatic retry mechanisms for transient network failures, and validation error reporting for configuration and parameter access operations.</p> </li> <li> <p>Logging &amp; Debugging: Structured logging integrated throughout all modules with component\u2011specific prefixes and configurable log levels. Device discovery, traffic monitoring, and telemetry generation provide detailed trace information for troubleshooting. Unit tests validate both success and failure paths across all major functional areas with mock frameworks enabling isolated component testing.</p> </li> </ul>"},{"location":"docu/raheen/lmlite_claude/#9-key-configuration-files","title":"9. Key Configuration Files","text":"Configuration File Purpose Key Parameters Default Values Override Mechanisms <code>config/LMLite.XML</code> Main component configuration Reporting intervals, feature enables, device limits Various defaults Environment variables, runtime parameter changes <code>config/NetworkDevicesStatus.avsc</code> Avro schema for device status telemetry Schema structure, field definitions N/A Schema versioning and compatibility <code>config/NetworkDevicesTraffic.avsc</code> Avro schema for traffic telemetry Schema structure, traffic metrics N/A Schema versioning and compatibility"},{"location":"docu/raheen/lmlite_claude/#91-configuration-file-details","title":"9.1 Configuration File Details","text":"<ul> <li>LMLite.XML: Controls device discovery, reporting intervals, presence detection, traffic monitoring, and telemetry export settings.</li> <li>NetworkDevicesStatus.avsc: Defines the Avro schema for device status telemetry, ensuring structured and validated data for analytics.</li> <li>NetworkDevicesTraffic.avsc: Defines the Avro schema for traffic telemetry, specifying the structure for bandwidth and traffic metrics.</li> </ul> <p>Configuration parameters can be overridden at runtime via TR\u2011181 parameter updates, RBUS property sets, or environment variables, supporting flexible deployment and operational tuning.</p>"},{"location":"docu/raheen/lmlite_gpt5/","title":"CcspLMLite Documentation","text":""},{"location":"docu/raheen/lmlite_gpt5/#1-overview","title":"1. Overview","text":"<ul> <li>Purpose in RDK\u2011B Stack: <code>CcspLMLite</code> (Lightweight Local Manager) discovers, tracks, and reports connected LAN devices (Ethernet / MoCA / WiFi) and produces presence, status, and traffic telemetry while exposing TR\u2011181 parameter trees (Hosts, XHosts, NetworkDevicesStatus, NetworkDevicesTraffic, Presence detection controls) for management and analytics.</li> <li>Key Features &amp; Responsibilities:</li> <li>Dynamic enumeration of connected devices with multi\u2011interface correlation.</li> <li>Presence detection (joins/leaves, dwell timing, IPv4/IPv6 probing, configurable retry intervals).</li> <li>Traffic &amp; status telemetry serialization using Avro schemas (<code>NetworkDevicesStatus.avsc</code>, <code>NetworkDevicesTraffic.avsc</code>).</li> <li>TR\u2011181 parameter exposure for device host tables and reporting control (enable, periods, schemas, override TTL, etc.).</li> <li>WebPA / RDK event publication for presence &amp; network device updates.</li> <li>RBus / DBus IPC integration through CCSP message bus wrappers.</li> <li>Modular DML source separation for Hosts, Extended Hosts, Network Device Status, Network Device Traffic, ManagementServer manageable devices.</li> <li>Role in Broadband Router Architecture: Sits between low\u2011level discovery (ARP tables, WiFi/MoCA driver info, DHCP lease state) and higher\u2011level telemetry / remote management (Telemetry, Cloud analytics platforms, TR\u2011069 PA / WebPA). It normalizes device identity, state transitions, and usage counters, providing consistent, queryable state plus event and periodic reporting streams.</li> </ul>"},{"location":"docu/raheen/lmlite_gpt5/#2-architecture-design","title":"2. Architecture / Design","text":""},{"location":"docu/raheen/lmlite_gpt5/#21-highlevel-design-principles","title":"2.1 High\u2011Level Design Principles","text":"<ul> <li>Incremental Discovery: Periodic polling plus change detection drives minimal diff reporting.</li> <li>Separation of Concerns: Presence logic, DML accessor functions, serialization (Avro pack), and IPC interfaces housed in distinct files.</li> <li>Configurable Reporting Cadence: Exposed TR\u2011181 parameters permit runtime tuning (ReportingPeriod, PollingPeriod, Override TTL fields, enable flags).</li> <li>Extensibility: Additional telemetry schemas or device augmentations can be added via new *avropack.c modules and matching DML objects.</li> <li>Resource Efficiency: Optimized for constrained devices; only essential data serialized based on enabled flags.</li> <li>Observability\u2011Friendly: Rich parameter exposure and consistent event naming enable external monitoring tools.</li> </ul>"},{"location":"docu/raheen/lmlite_gpt5/#22-component-boundaries-responsibilities","title":"2.2 Component Boundaries &amp; Responsibilities","text":"Boundary Responsibility Representative Files / Paths Consumers Core Lifecycle / Main Init, config load, bus attach, loop <code>lm_main.c</code>, <code>lm_api.c</code>, <code>lm_wrapper.c</code> All internal modules Device Discovery &amp; Status Enumerate hosts &amp; status tables <code>network_devices_status*.c</code>, <code>cosa_hosts_dml.c</code> DML / Telemetry Traffic Collection Per\u2011device traffic counters <code>network_devices_traffic*.c</code>, <code>cosa_ndtraffic_dml.c</code> Telemetry / Reports Presence Detection Join/leave heuristics, timers <code>device_presence_detection.c</code> Events / DML parameters Avro Serialization Pack structured telemetry <code>*_avropack.c</code> (status/traffic/extender) Telemetry publisher Reporting Control Parameter gating &amp; cadence <code>cosa_reports_internal.c</code>, <code>cosa_wantraffic_api.c</code> WebPA / Remote mgmt WebPA Interface WebPA parameter bridging <code>webpa_interface.c</code>, <code>webpa_pd_*</code> Cloud controller RBUS / Message Bus IPC bridging &amp; handler APIs <code>wtc_rbus_apis.c</code>, <code>wtc_rbus_handler_apis.c</code> Other CCSP agents Management Server Table Manageable device enumeration <code>cosa_managementserver_*</code> TR\u2011069 / Cloud mgmt Tests Unit tests &amp; mocks <code>test/*.cpp</code> CI / QA"},{"location":"docu/raheen/lmlite_gpt5/#23-threading-model","title":"2.3 Threading Model","text":"<p>CcspLMLite primarily operates with: - Main Thread: Initialization, configuration parsing, registration of TR\u2011181 trees, scheduling polling handlers. - Timer / Poll Threads: Timer callbacks (presence intervals, polling periods) may run in library\u2011provided scheduler; heavy work offloaded to avoid blocking. - IPC Dispatch Context: RBus/DBus callbacks trigger parameter get/set functions; these typically perform quick mapping then refer to cached host/traffic structures. - Optional Serialization Worker: Avro packing could be executed inline or via deferred worker depending on compile configuration (not always separate thread; left as implementation detail / potential enhancement).</p>"},{"location":"docu/raheen/lmlite_gpt5/#24-c4-system-context-diagram","title":"2.4 C4 System Context Diagram","text":"<pre><code>graph TD\n    classDef user fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n    classDef component fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef external fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n    classDef infra fill:#ede7f6,stroke:#5e35b1,stroke-width:2px;\n\n    Operator[\"\ud83d\udc64 Remote Ops / Analytics\"]:::user --&gt;|WebPA Queries| LMLite[CcspLMLite]:::component\n    Telemetry[\"Telemetry Service\"]:::external --&gt;|Event Ingest (Avro)| LMLite\n    TR069[\"TR-069 PA\"]:::external --&gt;|Get/Set Hosts.*| LMLite\n    LMLite --&gt;|TR-181 Params (Hosts/Status/Traffic)| OtherAgents[\"Other CCSP Agents\"]:::infra\n    LMLite --&gt;|Raw Stats| Telemetry\n    LMLite --&gt;|Presence Events| WebPACloud[\"WebPA / Cloud\"]:::external</code></pre>"},{"location":"docu/raheen/lmlite_gpt5/#25-c4-container-diagram","title":"2.5 C4 Container Diagram","text":"<pre><code>graph TD\n    classDef proc fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef module fill:#ede7f6,stroke:#5e35b1,stroke-width:1.5px;\n    classDef io fill:#e8f5e8,stroke:#2e7d32,stroke-width:1.5px;\n\n    subgraph Runtime[\"RDK-B Runtime (Linux)\"]\n        subgraph LMLiteProc[\"CcspLMLite Process\"]\n            MainCore[\"Main &amp; Wrapper\\n(lm_main / lm_wrapper)\"]:::module\n            Presence[\"Presence Detection\\n(device_presence_detection)\"]:::module\n            Status[\"Status Engine\\n(network_devices_status*)\"]:::module\n            Traffic[\"Traffic Engine\\n(network_devices_traffic*)\"]:::module\n            Avro[\"Serialization\\n(*_avropack.c)\"]:::module\n            Reports[\"Reporting Control\\ncosa_reports_internal\"]:::module\n            WebPA[\"WebPA Bridge\\nwebpa_interface\"]:::module\n            RBUS[\"RBUS / IPC APIs\\nwtc_rbus_*\"]:::module\n        end\n        HALs[\"Interface HAL Data\\n(ARP/WiFi/MoCA/DHCP)\"]:::io\n        Cloud[\"Telemetry / WebPA Cloud\"]:::io\n    end\n\n    Presence --&gt; Status\n    Status --&gt; Avro\n    Traffic --&gt; Avro\n    Avro --&gt; Cloud\n    WebPA --&gt; Cloud\n    RBUS --&gt; OtherAgents[\"Other CCSP Agents\"]\n    HALs --&gt; Status\n    HALs --&gt; Traffic</code></pre>"},{"location":"docu/raheen/lmlite_gpt5/#26-design-explanation-request-flow","title":"2.6 Design Explanation &amp; Request Flow","text":"<ol> <li>Initialization: <code>lm_main</code> loads configuration (implicit via bus &amp; data model setup) \u2192 registers TR\u2011181 objects.</li> <li>Poll Loop: Timers trigger status &amp; traffic polling; host tables refreshed; diffs flagged.</li> <li>Presence Logic: Device MAC/IP heuristics update active/inactive timestamps; join/leave events published when thresholds met.</li> <li>Reporting: On schedule or triggered change, engines marshal current structures \u2192 Avro pack modules \u2192 emit event to Telemetry service.</li> <li>External Queries: TR\u2011069 or WebPA requests call DML accessors mapping to in\u2011memory structures; writes adjust configuration (e.g., ReportingPeriod) which alters scheduler settings.</li> <li>Technologies: C (POSIX), RBus/DBus, Avro schema definitions, internal timers, optional logging macros from common infra.</li> </ol>"},{"location":"docu/raheen/lmlite_gpt5/#3-internal-modules","title":"3. Internal Modules","text":"Module Description Key Files Core Entry &amp; API Startup, lifecycle, exported public API wrappers <code>lm_main.c</code>, <code>lm_api.c</code>, <code>lm_wrapper.c</code>, <code>lm_wrapper_priv.c</code> Hosts DML Implements Hosts.* TR\u2011181 get/set logic <code>cosa_hosts_dml.c</code>, <code>cosa_xhosts_dml.c</code> Network Device Status Collects and caches status metrics; Avro status packing <code>network_devices_status*.c</code>, <code>network_devices_status_avropack.c</code> Network Device Traffic Collects traffic counters; Avro traffic packing <code>network_devices_traffic*.c</code>, <code>network_devices_traffic_avropack.c</code> Presence Detection Determines active/inactive, join/leave events <code>device_presence_detection.c</code> WAN Traffic Utils Additional traffic API + utilities <code>cosa_wantraffic_api.c</code>, <code>cosa_wantraffic_utils.c</code> Reports Internal Configurable reporting &amp; override TTL logic <code>cosa_reports_internal.c</code> Avro Extender Devices Extender device association reporting <code>extender_associated_devices*.c</code> Management Server DML Manageable devices table <code>cosa_managementserver_*</code> WebPA Interface WebPA parameter mapping &amp; presence publish <code>webpa_interface.c</code>, <code>webpa_pd_*</code> RBUS APIs &amp; Handlers RBUS call registration and handling <code>wtc_rbus_apis.c</code>, <code>wtc_rbus_handler_apis.c</code> Test Suite Unit and integration tests <code>test/*.cpp</code>, <code>run_ut.sh</code>"},{"location":"docu/raheen/lmlite_gpt5/#31-module-breakdown-diagram","title":"3.1 Module Breakdown Diagram","text":"<pre><code>flowchart TD\n    subgraph CcspLMLite\n        Core[Core Init / API]\n        Hosts[Hosts DML]\n        Status[Status Engine]\n        Traffic[Traffic Engine]\n        Presence[Presence Detection]\n        Avro[Avro Serialization]\n        Reports[Reporting Control]\n        WebPA[WebPA Bridge]\n        RBUS[RBUS Handlers]\n        Mgmt[ManagementServer DML]\n    end\n    Presence --&gt; Status\n    Status --&gt; Avro\n    Traffic --&gt; Avro\n    Reports --&gt; Avro\n    WebPA --&gt; Reports\n    RBUS --&gt; Hosts</code></pre>"},{"location":"docu/raheen/lmlite_gpt5/#4-interaction-with-other-middleware-components","title":"4. Interaction with Other Middleware Components","text":"Component Interaction Purpose Protocol / Mechanism Telemetry Service Ingest Avro encoded status &amp; traffic events Event publish (RBus / message bus) TR\u2011069 PA Query host / traffic parameters via TR\u2011181 DBus/RBus Get/SetParameterValues WebPA Cloud Stack Presence notifications &amp; dynamic control WebPA param get/set + events PSM Persist writable config parameters if needed Indirect via CCSP DM/PSM integration Other CCSP Agents Potential subscription to presence or host changes RBus events / method calls"},{"location":"docu/raheen/lmlite_gpt5/#41-middleware-interaction-diagram","title":"4.1 Middleware Interaction Diagram","text":"<pre><code>flowchart TD\n    LMLite[CcspLMLite] --&gt;|Avro Events| Telemetry[Telemetry]\n    LMLite --&gt;|TR-181 Get/Set| TR069[TR-069 PA]\n    WebPACloud[WebPA / Cloud] --&gt;|Set ReportingPeriod| LMLite\n    LMLite --&gt;|Presence Events| WebPACloud\n    LMLite --&gt;|Status/Traffic Params| OtherAgents[Other Agents]</code></pre>"},{"location":"docu/raheen/lmlite_gpt5/#5-interaction-with-other-layers","title":"5. Interaction with Other Layers","text":"Layer/Service Description Mechanism HAL / Drivers Source of raw MAC / RSSI / interface &amp; traffic data Direct system calls / platform APIs Filesystem Access Avro schemas &amp; (if any) local config File I/O Systemd Launch / supervise process Unit service Cloud Telemetry Receives serialized events Message bus \u2192 Telemetry pipeline"},{"location":"docu/raheen/lmlite_gpt5/#51-layered-architecture-view","title":"5.1 Layered Architecture View","text":"<pre><code>graph TD\n    HAL[(Interface HALs)] --&gt; LMLite[CcspLMLite]\n    LMLite --&gt; Telemetry[(Telemetry Pipeline)]\n    LMLite --&gt; WebPA[WebPA / Cloud]\n    WebPA --&gt; Operators[Remote Operators]</code></pre>"},{"location":"docu/raheen/lmlite_gpt5/#6-ipc-mechanism","title":"6. IPC Mechanism","text":"<ul> <li>IPC Type: RBus (primary in modern builds) and/or DBus via CCSP bus abstraction.</li> <li>Invocation Patterns: Synchronous parameter Get/Set; asynchronous event publish (presence, status period completion, traffic sample).</li> <li>Message Structure: Parameter maps (name/value pairs) for TR\u2011181 access; Avro payload (binary or base64) for telemetry events with header metadata (timestamp, uuid, source).</li> <li>Flow Control: Reporting periods regulate frequency; presence events de\u2011bounced by configurable join/leave intervals &amp; retry counts.</li> </ul>"},{"location":"docu/raheen/lmlite_gpt5/#61-ipc-event-flow-sequence","title":"6.1 IPC / Event Flow Sequence","text":"<pre><code>sequenceDiagram\n    participant Poll as PollTimer\n    participant LML as CcspLMLite\n    participant RB as RBus/DBus\n    participant Tele as Telemetry Service\n    Poll-&gt;&gt;LML: Timer Fire (Status Poll)\n    LML-&gt;&gt;LML: Refresh Host/Traffic Caches\n    LML-&gt;&gt;LML: Presence Evaluation (joins/leaves?)\n    alt Changes or Period Elapsed\n        LML-&gt;&gt;LML: Avro Pack (status/traffic)\n        LML-&gt;&gt;RB: Publish Event (Avro blob)\n        RB--&gt;&gt;Tele: Deliver Event\n    end</code></pre>"},{"location":"docu/raheen/lmlite_gpt5/#7-tr181-data-models","title":"7. TR\u2011181 Data Models","text":"<p>Implemented object roots (subset shown): - <code>Device.Hosts.*</code> (dynamic Host table with IPv4/IPv6 sub\u2011objects) - <code>Device.XHosts.*</code> (extended variant under resource optimization conditions) - <code>Device.X_RDKCENTRAL-COM_Report.NetworkDevicesStatus.*</code> - <code>Device.X_RDKCENTRAL-COM_Report.NetworkDevicesTraffic.*</code> - <code>Device.ManagementServer.ManageableDevice.*</code> (conditional)</p>"},{"location":"docu/raheen/lmlite_gpt5/#71-representative-parameter-table-excerpt","title":"7.1 Representative Parameter Table (Excerpt)","text":"Parameter Description Access Notes <code>Device.Hosts.X_CISCO_COM_ConnectedDeviceNumber</code> Count of connected devices R Updated on discovery refresh <code>Device.Hosts.X_RDKCENTRAL-COM_HostCountPeriod</code> Host count reporting period R/W Affects poll cadence <code>Device.Hosts.Host.{i}.Alias</code> Friendly name alias R/W Writable field <code>Device.Hosts.Host.{i}.Active</code> Active presence indicator R Derived from presence state <code>Device.Hosts.Host.{i}.X_CISCO_COM_RSSI</code> WiFi signal strength R Present for WiFi devices <code>Device.X_RDKCENTRAL-COM_Report.NetworkDevicesStatus.Enabled</code> Enable status reporting R/W Governs status Avro emission <code>Device.X_RDKCENTRAL-COM_Report.NetworkDevicesStatus.ReportingPeriod</code> Status report period seconds R/W Scheduler input <code>Device.X_RDKCENTRAL-COM_Report.NetworkDevicesTraffic.Enabled</code> Enable traffic reporting R/W Governs traffic Avro emission <code>Device.X_RDKCENTRAL-COM_Report.NetworkDevicesTraffic.Default.ReportingPeriod</code> Default override period R/W Applies fallback cadence <code>Device.ManagementServer.ManageableDevice.{i}.SerialNumber</code> Managed device serial R Conditional object"},{"location":"docu/raheen/lmlite_gpt5/#8-implementation-details","title":"8. Implementation Details","text":"<ul> <li>Presence Algorithm: Maintains per\u2011device timers; join when first seen or after inactivity threshold exceeded; leave when no activity for configured IPv4/IPv6 retry * interval windows.</li> <li>Diff Tracking: Host version ID increments on structural changes (add/remove/hostname change) enabling incremental Avro emission filtering.</li> <li>Avro Serialization: Packs header (timestamp, uuid, source), device identifier record, and arrays of status/traffic records; supports optional null fields for compactness.</li> <li>Error Handling: Parameter accessors validate indices; serialization fails fast with logged error; absent counters treated as null to avoid blocking pipeline.</li> <li>Logging: Uses common trace macros; presence transitions and reporting skips logged at INFO/DEBUG to assist tuning.</li> </ul>"},{"location":"docu/raheen/lmlite_gpt5/#9-key-configuration-schema-files","title":"9. Key Configuration &amp; Schema Files","text":"File Purpose Notable Fields <code>config/LMLite.XML</code> TR\u2011181 object &amp; function binding definitions Hosts, XHosts, NetworkDevicesStatus/Traffic, Presence params <code>config/NetworkDevicesStatus.avsc</code> Avro schema for status events <code>header</code>, <code>cpe_id</code>, <code>data[].device_id.device_type</code>, timestamps <code>config/NetworkDevicesTraffic.avsc</code> Avro schema for traffic events <code>last_traffic_counter_reset</code>, <code>data[].device_id</code>, counters (further fields)"},{"location":"docu/raheen/lmlite_gpt5/#10-api-endpoints-interface-groups","title":"10. API Endpoints / Interface Groups","text":"Group Purpose Example (Representative) DML Get/Set Parameter accessors <code>Hosts_GetParamStringValue</code>, <code>NetworkDevicesTraffic_SetParamUlongValue</code> Entry Enumeration Dynamic table enumeration <code>Host_GetEntryCount</code>, <code>XHost_GetEntry</code> Presence Control Adjust detection parameters Writes to presence interval/retry TR\u2011181 params Reporting Control Enable/disable, period tuning Set <code>Enabled</code>, <code>ReportingPeriod</code>, <code>PollingPeriod</code> Avro Packing Transform in-memory to payload <code>network_devices_status_avropack.c</code> functions RBUS Publishing Emit events RBUS publish helper in <code>wtc_rbus_apis.c</code>"},{"location":"docu/raheen/lmlite_gpt5/#11-deployment-runtime-environment","title":"11. Deployment &amp; Runtime Environment","text":"<ul> <li>Process Type: Stand\u2011alone CCSP component launched via systemd (<code>CcspLMLite.service</code>).</li> <li>Dependencies: CCSP common libs (message bus, logging), Avro library (linked externally), RBus/DBus.</li> <li>Resource Footprint: Scales with host table size and reporting frequency; capped dynamic host instances (e.g., 64).</li> <li>Startup Sequence: systemd \u2192 bus attach \u2192 TR\u2011181 registration \u2192 schedule polling timers.</li> <li>Cross Compile: Uses Autotools; inherits environment variables consistent with other CCSP components.</li> </ul>"},{"location":"docu/raheen/lmlite_gpt5/#12-monitoring-security","title":"12. Monitoring &amp; Security","text":"<ul> <li>Monitoring Hooks: Telemetry events constitute primary metric channel; count of devices, active sessions, reporting success/fail counts derivable from logs.</li> <li>Security Considerations: Ensure Avro payloads exclude PII beyond authorized identifiers; restrict writable TR\u2011181 parameters to authenticated channels (WebPA / TR\u2011069). Harden bus policies to limit method invocation to expected namespaces.</li> <li>Data Integrity: Version IDs in host table assist in validating sequence ordering.</li> </ul>"},{"location":"docu/raheen/lmlite_gpt5/#13-validation-review-checklist","title":"13. Validation &amp; Review Checklist","text":"<ul> <li>[x] Deployment boundaries represented (process vs HAL vs cloud).</li> <li>[x] Protocol specificity (RBus/DBus, Avro events) labeled.</li> <li>[x] Scaling (dynamic tables maxInstance) noted.</li> <li>[x] Technology stack (C, Avro, CCSP bus) described.</li> <li>[x] Implementation details (presence algorithm, diff tracking) documented.</li> <li>[x] Visual hierarchy via Mermaid classDefs &amp; node grouping.</li> <li>[x] TR\u2011181 coverage with representative parameters.</li> <li>[x] Schema references included.</li> <li>[x] Mermaid syntax validated conceptually (no HTML breaks, quoted multi\u2011line labels).</li> </ul>"},{"location":"docu/raheen/lmlite_gpt5/#14-conclusion-next-steps","title":"14. Conclusion &amp; Next Steps","text":"<p><code>CcspLMLite</code> delivers an extensible, telemetry\u2011ready substrate for connected device visibility and presence analytics within RDK\u2011B. Its modular organization (discovery, presence, serialization, reporting control) simplifies maintenance and feature extension.</p> <p>Recommended Enhancements: 1. Introduce unified metrics endpoint (e.g., JSON snapshot) for on\u2011device introspection. 2. Add adaptive reporting (dynamic period adjustment based on churn rate). 3. Implement per\u2011device anomaly tagging (RSSI volatility, traffic spikes) before Avro emission. 4. Expand unit tests for presence edge cases (IPv6 only, rapid re-association). 5. Provide structured logging correlation IDs aligned with Avro header UUID.</p> <p>References: Source files under <code>source/lm/</code>, Avro schemas (<code>config/*.avsc</code>), TR\u2011181 model (<code>config/LMLite.XML</code>), service unit <code>CcspLMLite.service</code>.</p> <p>Generated using the provided RDK\u2011B documentation template, workflow, and diagram guidelines (deployment accuracy, protocol specificity, modular clarity). </p>"},{"location":"docu/raheen/psm_claude/","title":"CcspPsm Documentation","text":""},{"location":"docu/raheen/psm_claude/#1-overview","title":"1. Overview","text":"<ul> <li> <p>Purpose in RDK\u2011B Stack: CcspPsm (Platform Storage Manager) serves as the centralized persistence and configuration state management service within the RDK\u2011B middleware stack. It provides reliable storage, retrieval, validation, and lifecycle management of configuration and operational parameters used by other CCSP/RDK\u2011B components. The component ensures that device configuration and operational parameters survive restarts, firmware upgrades, and controlled recovery scenarios while maintaining data integrity through schema validation and atomic operations.</p> </li> <li> <p>Key Features &amp; Responsibilities: CcspPsm delivers schema\u2011driven configuration loading from XML definitions, parameter storage with atomic update semantics, dual\u2011subsystem architecture (file loader and system registry), state machine governance for lifecycle transitions, HAL integration points for platform abstraction, IPC exposure over both DBus and RBUS protocols, structured exported APIs with clear boundaries, controlled migration support via patch scripting, and comprehensive unit test coverage validating all internal modules. The component mediates the entire lifecycle from initial parsing through steady\u2011state runtime operations and subsequent mutation or synchronization sequences.</p> </li> <li> <p>Role in Broadband Router Architecture: Architecturally, CcspPsm occupies the persistence tier immediately beneath higher\u2011level management agents and above platform storage abstractions (filesystem/flash/NVRAM). It forms a horizontal service consumed by multiple vertical functional domains including telemetry, WAN management, Wi\u2011Fi configuration, provisioning services, and diagnostics through standardized bus interfaces. Rather than acting as a HAL or business logic orchestrator, it supplies the durable substrate and access discipline that other components depend upon for configuration fidelity and transactional integrity.</p> </li> </ul>"},{"location":"docu/raheen/psm_claude/#2-architecture-design","title":"2. Architecture / Design","text":""},{"location":"docu/raheen/psm_claude/#21-highlevel-design-principles","title":"2.1 High\u2011Level Design Principles","text":"<p>The architecture manifests principles of modular separation through distinct directories for file loader and system registry subsystems, interface clarity via explicit interface and exported API headers for each subsystem, layered responsibility separating file parsing from runtime registry from service shell functions, explicit state modeling with dedicated states modules controlling lifecycle transitions, portability through schema files detached from core logic, controlled evolution supported by ChangeLog and Version.txt tracking, comprehensive testability with granular unit tests per internal concern, and IPC abstraction providing dual DBus/RBUS support. Schema\u2011driven operation reduces hard\u2011coded structural assumptions while atomicity and consistency are enforced through separate operation modules distinct from control and state logic.</p>"},{"location":"docu/raheen/psm_claude/#22-component-boundaries-responsibilities","title":"2.2 Component Boundaries &amp; Responsibilities","text":"<p>PsmFileLoader Subsystem: Responsible for ingesting XML schema and persisted data, validating structure and types through parsing logic, orchestrating state transitions via dedicated state machines, coordinating higher\u2011level control flows, executing concrete file operations including atomic commits, and furnishing consolidated external interfaces through interface and exported API headers.</p> <p>PsmSysRegistry Subsystem: Maintains authoritative in\u2011memory parameter registry, mediates configuration manager interface functions, implements runtime control logic, provides storage interfacing behind system RAM abstraction, and mirrors the file loader with analogous base, operation, states, interface, and exported API segmentation for consistent architectural patterns.</p> <p>Ssp Service Shell: Acts as the process entry point handling initialization, DBus transport integration, RBUS transport integration, configuration manager coordination, and HAL abstraction bridging. It decouples transport and environmental concerns from core persistence logic while providing unified IPC endpoints.</p>"},{"location":"docu/raheen/psm_claude/#23-threading-model-if-applicable","title":"2.3 Threading Model (if applicable)","text":"<p>The codebase exhibits a single\u2011threaded design pattern with no explicit threading primitives or concurrency layer files present in the repository structure. The component operates as an event\u2011driven service where the main processing loop handles requests sequentially. State machine transitions in both subsystems are designed for deterministic sequencing rather than concurrent scheduling. External synchronization and reentrancy protection are handled at IPC layer boundaries to prevent concurrent mutation of internal state.</p>"},{"location":"docu/raheen/psm_claude/#24-c4-system-context-diagram","title":"2.4 C4 System Context Diagram","text":"<pre><code>graph TD\n    subgraph \"RDK-B Components\"\n        Telemetry[\ud83d\udcca Telemetry Service]\n        WAN[\ud83c\udf10 WAN Manager]\n        WiFi[\ud83d\udce1 WiFi Manager]\n        TR069[\ud83d\udd27 TR-069 Agent]\n    end\n\n    User[\ud83d\udc64 Management Systems] --&gt;|Configuration Requests| CcspPsm\n    Telemetry --&gt;|DBus/RBUS| CcspPsm\n    WAN --&gt;|Parameter Get/Set| CcspPsm\n    WiFi --&gt;|Configuration Storage| CcspPsm\n    TR069 --&gt;|Bulk Parameter Operations| CcspPsm\n\n    subgraph \"CcspPsm Container\"\n        ComponentCore[\ud83d\udd27 Platform Storage Manager]\n        ComponentCore -.-&gt;|\"Schema Validation, Atomic Persistence, State Management\"| ComponentCore\n    end\n\n    CcspPsm --&gt;|File I/O| FileSystem[\ud83d\udcbe Persistent Storage]\n    CcspPsm --&gt;|Platform Calls| HAL[\u2699\ufe0f Hardware Abstraction Layer]\n\n    classDef user fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n    classDef component fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef external fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n\n    class User,Telemetry,WAN,WiFi,TR069 user;\n    class CcspPsm,ComponentCore component;\n    class FileSystem,HAL external;</code></pre>"},{"location":"docu/raheen/psm_claude/#25-c4-container-diagram","title":"2.5 C4 Container Diagram","text":"<pre><code>graph TD\n    subgraph Runtime [\"Linux/RDK-B Middleware\"]\n        subgraph CcspPsmContainer [\"CcspPsm Process\"]\n            SspLayer[Ssp Layer&lt;br/&gt;ssp_main.c, ssp_dbus.c, ssp_rbus.c]\n            SysRegistry[PsmSysRegistry&lt;br/&gt;In-Memory Parameter Store]\n            FileLoader[PsmFileLoader&lt;br/&gt;Schema Parser &amp; File Operations]\n            HALInterface[HAL Interface&lt;br/&gt;psm_hal_apis.c]\n        end\n        subgraph Storage [\"Persistent Storage\"]\n            ConfigFile[(\"bbhm_def_cfg_qemu.xml\")]\n            RuntimeData[(\"Runtime Parameter Files\")]\n        end\n    end\n\n    SspLayer --&gt;|\"Internal API Calls\"| SysRegistry\n    SysRegistry --&gt;|\"Persistence Requests\"| FileLoader\n    FileLoader --&gt;|\"Read/Write\"| Storage\n    SspLayer --&gt;|\"Platform Calls\"| HALInterface\n\n    classDef process fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef storage fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n\n    class SspLayer,SysRegistry,FileLoader,HALInterface process;\n    class ConfigFile,RuntimeData storage;</code></pre>"},{"location":"docu/raheen/psm_claude/#26-design-explanation-request-flow","title":"2.6 Design Explanation &amp; Request Flow","text":"<p>Initialization Sequence: Service startup begins in <code>ssp_main.c</code>, which initializes selected IPC transports (DBus via <code>ssp_dbus.c</code> or RBUS via <code>ssp_rbus.c</code>), binds configuration manager interfaces through <code>ssp_cfmif.c</code>, and prepares HAL interaction stubs via <code>psm_hal_apis.c</code>. During startup, SysRegistry logic coordinates with the FileLoader to parse and load persisted data using <code>psm_flo_parse.c</code>. The FileLoader state machine advances through parsing, validation, and ready stages before returning control for runtime operations.</p> <p>Runtime Request Flow: Get/set operations enter through registry interface APIs, invoking operation modules that coordinate atomic changes. When persistence is required, the registry triggers commit sequences through FileLoader operation and control modules. State machines in both subsystems ensure valid transitions and prevent inconsistent states.</p> <p>Technology Stack: C programming language, DBus and RBUS for IPC, XML for schema definition, Linux filesystem for persistence, GNU build system (autotools), Google Test framework for unit testing.</p>"},{"location":"docu/raheen/psm_claude/#3-internal-modules","title":"3. Internal Modules","text":"Module/Class Description Key Files File Loader Base Core foundational routines and shared context initialization <code>psm_flo_base.c</code> File Loader Parse XML schema parsing, structural validation, type checking <code>psm_flo_parse.c</code> File Loader Operation Atomic file I/O operations, commit logic, rollback handling <code>psm_flo_operation.c</code> File Loader Control High\u2011level orchestration of parse/load/save sequences <code>psm_flo_control.c</code> File Loader States State machine transitions and lifecycle management <code>psm_flo_states.c</code> File Loader Interface External API boundary and function dispatching <code>psm_flo_interface.c</code>, <code>psm_flo_interface.h</code> Registry Base Foundational registry initialization and context setup <code>psm_sysro_base.c</code> Registry Operation Parameter access, mutation, and validation logic <code>psm_sysro_operation.c</code> Registry Control Registry lifecycle orchestration and coordination <code>psm_sysro_control.c</code> Registry States Registry state machine and transition handling <code>psm_sysro_states.c</code> Registry Storage Persistent storage mediation and staging operations <code>psm_sysro_storage.c</code> Registry SysRAM Interface System RAM abstraction and memory management <code>psm_sysro_sysramif.c</code> Registry CFM Interface Configuration Manager integration adapter <code>psm_sysro_cfmif.c</code> Ssp Main Process entry point and master initialization <code>ssp_main.c</code> Ssp DBus DBus transport endpoint and message marshaling <code>ssp_dbus.c</code> Ssp RBUS RBUS transport endpoint and message handling <code>ssp_rbus.c</code> Ssp CFM Interface Service\u2011level configuration manager integration <code>ssp_cfmif.c</code> HAL APIs Hardware abstraction layer interface stubs <code>psm_hal_apis.c</code>, <code>psm_hal_apis.h</code>"},{"location":"docu/raheen/psm_claude/#31-module-breakdown-diagram","title":"3.1 Module Breakdown Diagram","text":"<p>The module breakdown diagram groups related files into their functional subsystems and illustrates directional dependencies: the Ssp layer depends on the registry and loader to fulfill IPC requests, the registry invokes the loader for persistence operations, and tests exercise all boundaries without being part of the production runtime path. The schema file and patch script act as external inputs influencing initialization and migration flows.</p> <pre><code>flowchart TD\n    subgraph Ssp[\"Ssp Service Shell\"]\n        SspMain[ssp_main.c&lt;br/&gt;Process Entry]\n        SspDBus[ssp_dbus.c&lt;br/&gt;DBus Transport]\n        SspRBus[ssp_rbus.c&lt;br/&gt;RBUS Transport]\n        SspCFM[ssp_cfmif.c&lt;br/&gt;CFM Integration]\n        SspHAL[psm_hal_apis.c&lt;br/&gt;HAL Interface]\n    end\n\n    subgraph Registry[\"PsmSysRegistry\"]\n        RegBase[psm_sysro_base.c&lt;br/&gt;Foundation]\n        RegOp[psm_sysro_operation.c&lt;br/&gt;Parameter Access]\n        RegCtrl[psm_sysro_control.c&lt;br/&gt;Lifecycle]\n        RegStates[psm_sysro_states.c&lt;br/&gt;State Machine]\n        RegStore[psm_sysro_storage.c&lt;br/&gt;Storage Interface]\n        RegSysRAM[psm_sysro_sysramif.c&lt;br/&gt;Memory Interface]\n        RegCFM[psm_sysro_cfmif.c&lt;br/&gt;CFM Adapter]\n        RegInterface[psm_sysro_interface.c&lt;br/&gt;External API]\n    end\n\n    subgraph Loader[\"PsmFileLoader\"]\n        LoadBase[psm_flo_base.c&lt;br/&gt;Foundation]\n        LoadParse[psm_flo_parse.c&lt;br/&gt;XML Parser]\n        LoadOp[psm_flo_operation.c&lt;br/&gt;File Operations]\n        LoadCtrl[psm_flo_control.c&lt;br/&gt;Orchestration]\n        LoadStates[psm_flo_states.c&lt;br/&gt;State Machine]\n        LoadInterface[psm_flo_interface.c&lt;br/&gt;External API]\n    end\n\n    subgraph Tests[\"Unit Tests\"]\n        TestSuite[Comprehensive Test Coverage&lt;br/&gt;psm_*_test.cpp]\n    end\n\n    Schema[config/bbhm_def_cfg_qemu.xml&lt;br/&gt;Configuration Schema]\n    Patch[scripts/bbhm_patch.sh&lt;br/&gt;Migration Script]\n\n    Ssp --&gt;|Internal API| Registry\n    Registry --&gt;|Persistence Request| Loader\n    Loader --&gt;|Parse Schema| Schema\n    Patch -.-&gt;|Migration| Loader\n    Tests -.-&gt;|Validate| Ssp\n    Tests -.-&gt;|Validate| Registry\n    Tests -.-&gt;|Validate| Loader\n\n    classDef ssp fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n    classDef registry fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef loader fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;\n    classDef support fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n\n    class SspMain,SspDBus,SspRBus,SspCFM,SspHAL ssp;\n    class RegBase,RegOp,RegCtrl,RegStates,RegStore,RegSysRAM,RegCFM,RegInterface registry;\n    class LoadBase,LoadParse,LoadOp,LoadCtrl,LoadStates,LoadInterface loader;\n    class Tests,Schema,Patch support;</code></pre>"},{"location":"docu/raheen/psm_claude/#4-interaction-with-other-middleware-components","title":"4. Interaction with Other Middleware Components","text":"Component Purpose of Interaction Protocols/Mechanisms Telemetry Service Stores telemetry configuration parameters and reporting settings DBus method calls, RBUS property access WAN Manager Persists WAN interface configuration, IP settings, routing parameters DBus/RBUS parameter get/set operations WiFi Manager Maintains WiFi configuration, security settings, access point parameters DBus/RBUS bulk parameter operations TR\u2011069 Agent Handles TR\u2011181 parameter persistence for remote management operations DBus/RBUS parameter validation and commit MoCA Agent Stores MoCA interface configuration and network topology data DBus/RBUS configuration parameter storage Voice Manager Persists VoIP configuration, SIP settings, voice service parameters DBus/RBUS parameter storage and retrieval Diagnostic Agent Maintains diagnostic test results and configuration DBus/RBUS data persistence"},{"location":"docu/raheen/psm_claude/#41-middleware-interaction-diagram","title":"4.1 Middleware Interaction Diagram","text":"<p>The following diagram illustrates how various RDK\u2011B functional components interact with CcspPsm through the message bus layer. Management components typically perform bulk operations and configuration commits, while feature components focus on domain\u2011specific parameter persistence. All interactions flow through the standardized IPC mechanisms to ensure consistent access patterns and transactional integrity.</p> <pre><code>flowchart TD\n    subgraph \"Management Layer\"\n        TR069[TR-069 Agent&lt;br/&gt;Remote Management]\n        WebUI[Web Interface&lt;br/&gt;Local Management]\n    end\n\n    subgraph \"Feature Components\"\n        Telemetry[\ud83d\udcca Telemetry Service]\n        WAN[\ud83c\udf10 WAN Manager]\n        WiFi[\ud83d\udce1 WiFi Manager]\n        Voice[\ud83d\udcde Voice Manager]\n        MoCA[\ud83d\udd17 MoCA Agent]\n        Diag[\ud83d\udd0d Diagnostic Agent]\n    end\n\n    subgraph \"CcspPsm Process\"\n        PsmCore[\ud83d\udd27 CcspPsm Core&lt;br/&gt;Registry + FileLoader]\n    end\n\n    TR069 --&gt;|DBus: Bulk Parameter Operations| PsmCore\n    WebUI --&gt;|RBUS: Configuration Changes| PsmCore\n    Telemetry --&gt;|DBus: Config Persistence| PsmCore\n    WAN --&gt;|RBUS: Interface Settings| PsmCore\n    WiFi --&gt;|DBus: Security Parameters| PsmCore\n    Voice --&gt;|RBUS: VoIP Configuration| PsmCore\n    MoCA --&gt;|DBus: Network Topology| PsmCore\n    Diag --&gt;|RBUS: Test Results| PsmCore\n\n    PsmCore --&gt;|Validated Storage| FileSystem[\ud83d\udcbe Persistent Storage]\n\n    classDef mgmt fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n    classDef feature fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef core fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;\n    classDef storage fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n\n    class TR069,WebUI mgmt;\n    class Telemetry,WAN,WiFi,Voice,MoCA,Diag feature;\n    class PsmCore core;\n    class FileSystem storage;</code></pre>"},{"location":"docu/raheen/psm_claude/#5-interaction-with-other-layers","title":"5. Interaction with Other Layers","text":"<p>CcspPsm interfaces upward with CCSP functional agents through standardized DBus and RBUS IPC mechanisms, ensuring all parameter access follows controlled pathways with schema validation and state machine governance. Downward interactions include the platform storage layer (filesystem/NVRAM) for persistent data, the Hardware Abstraction Layer (HAL) for platform\u2011specific operations through <code>psm_hal_apis.c</code>, and system memory management through <code>psm_sysro_sysramif.c</code>. The component abstracts lower\u2011level configuration complexities behind clean API boundaries, reducing duplication across agents while enforcing consistent persistence semantics.</p> Layer/Service Interaction Description Mechanism HAL Layer Platform\u2011specific storage hints, environment queries, low\u2011level access Function calls via <code>psm_hal_apis.c</code> File System Persistent configuration storage, atomic write operations, backup/restore Standard file I/O with transactional semantics System Memory In\u2011memory parameter caching, runtime state management Memory allocation via <code>psm_sysro_sysramif.c</code> Configuration Manager Policy enforcement, coordinated configuration workflows Interface calls via CFM adapters"},{"location":"docu/raheen/psm_claude/#51-layered-architecture-view","title":"5.1 Layered Architecture View","text":"<p>The layered architecture diagram illustrates CcspPsm's position within the RDK\u2011B technology stack, showing how it mediates between application\u2011level management systems and platform infrastructure. The component serves as a horizontal service that spans multiple abstraction layers while maintaining clear boundaries and responsibilities at each level.</p> <pre><code>graph TD\n    subgraph \"Application Layer\"\n        Management[Management Applications&lt;br/&gt;TR-069, WebUI, CLI]\n        Features[Feature Components&lt;br/&gt;WAN, WiFi, Telemetry, Voice]\n    end\n\n    subgraph \"Middleware Layer\"\n        IPC[IPC Transport&lt;br/&gt;DBus/RBUS]\n        CcspPsm[\ud83d\udd27 CcspPsm&lt;br/&gt;Parameter Storage Manager]\n    end\n\n    subgraph \"Platform Layer\"\n        HAL[Hardware Abstraction Layer&lt;br/&gt;psm_hal_apis.c]\n        CFM[Configuration Manager&lt;br/&gt;Policy &amp; Coordination]\n        SysRAM[System Memory&lt;br/&gt;psm_sysro_sysramif.c]\n    end\n\n    subgraph \"System Layer\"\n        FileSystem[File System&lt;br/&gt;Persistent Storage]\n        OS[Operating System&lt;br/&gt;Linux/RDK-B Runtime]\n    end\n\n    Management --&gt; IPC\n    Features --&gt; IPC\n    IPC --&gt; CcspPsm\n    CcspPsm --&gt; HAL\n    CcspPsm --&gt; CFM\n    CcspPsm --&gt; SysRAM\n    CcspPsm --&gt; FileSystem\n    FileSystem --&gt; OS\n    HAL --&gt; OS\n\n    classDef app fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n    classDef middleware fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef platform fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;\n    classDef system fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n\n    class Management,Features app;\n    class IPC,CcspPsm middleware;\n    class HAL,CFM,SysRAM platform;\n    class FileSystem,OS system;</code></pre>"},{"location":"docu/raheen/psm_claude/#6-ipc-mechanism","title":"6. IPC Mechanism","text":"<ul> <li> <p>Type of IPC: Dual transport support with DBus (via <code>ssp_dbus.c</code>) and RBUS (via <code>ssp_rbus.c</code>) for backward compatibility and migration scenarios. Both transports provide method call semantics for parameter operations.</p> </li> <li> <p>Message Format: Method calls follow standard DBus/RBUS patterns with parameter name strings, typed values (string, integer, boolean), and operation types (get, set, commit, validate). Response messages include status codes, return values, and error descriptions. Schema validation occurs before persistence operations.</p> </li> <li> <p>Flow: Synchronous request/response pattern for most operations. Clients invoke methods through the bus, Ssp layer dispatches to registry operations, registry manages in\u2011memory state and optionally triggers file loader persistence, then status propagates back through the transport layer to the caller.</p> </li> </ul>"},{"location":"docu/raheen/psm_claude/#61-ipc-flow-diagram","title":"6.1 IPC Flow Diagram","text":"<p>The following sequence diagram illustrates the complete flow for both parameter retrieval and modification operations, showing how requests traverse the IPC layer, internal subsystems, and optional persistence boundaries. Read operations terminate efficiently in the registry without file system access, while write operations extend through the File Loader subsystem only when persistent storage is required.</p> <pre><code>sequenceDiagram\n    participant Client as RDK-B Component\n    participant Transport as DBus/RBUS Transport&lt;br/&gt;(ssp_dbus.c / ssp_rbus.c)\n    participant Ssp as Ssp Dispatch&lt;br/&gt;(ssp_main.c)\n    participant Registry as SysRegistry&lt;br/&gt;(psm_sysro_interface.c)\n    participant Loader as FileLoader&lt;br/&gt;(psm_flo_control.c)\n    participant Storage as Persistent Storage\n\n    note over Client,Transport: Parameter Set Operation\n    Client-&gt;&gt;Transport: MethodCall(SetParameter, name, value)\n    Transport-&gt;&gt;Ssp: Dispatch Request\n    Ssp-&gt;&gt;Registry: Parameter Update\n    Registry-&gt;&gt;Registry: Validate &amp; Apply In-Memory\n\n    alt Persistence Required\n        Registry-&gt;&gt;Loader: Commit Request\n        Loader-&gt;&gt;Loader: State Transition Check\n        Loader-&gt;&gt;Storage: Atomic Write\n        Storage--&gt;&gt;Loader: Write Status\n        Loader--&gt;&gt;Registry: Commit Result\n    end\n\n    Registry--&gt;&gt;Ssp: Operation Status\n    Ssp--&gt;&gt;Transport: Format Response\n    Transport--&gt;&gt;Client: Method Response\n\n    note over Client,Transport: Parameter Get Operation\n    Client-&gt;&gt;Transport: MethodCall(GetParameter, name)\n    Transport-&gt;&gt;Ssp: Dispatch Request\n    Ssp-&gt;&gt;Registry: Retrieve Value\n    Registry--&gt;&gt;Ssp: Parameter Value\n    Ssp--&gt;&gt;Transport: Format Response\n    Transport--&gt;&gt;Client: Value Response</code></pre>"},{"location":"docu/raheen/psm_claude/#7-tr181-data-models","title":"7. TR\u2011181 Data Models","text":"<ul> <li> <p>Implemented Parameters: CcspPsm acts as the persistence engine for TR\u2011181 parameters rather than defining specific parameter semantics. The schema file <code>config/bbhm_def_cfg_qemu.xml</code> establishes the structural framework and default values parsed at initialization.</p> </li> <li> <p>Parameter Registration: Parameters are registered through the schema definition and accessed via exported APIs (<code>psm_flo_exported_api.h</code>, <code>psm_sysro_exported_api.h</code>). Other components interact with parameters through DBus/RBUS method calls that map to internal registry operations.</p> </li> <li> <p>Custom Extensions: Schema evolution and custom parameters are supported by modifying the XML configuration file and applying controlled migrations through <code>scripts/bbhm_patch.sh</code> to maintain compatibility with existing stored data.</p> </li> </ul>"},{"location":"docu/raheen/psm_claude/#71-tr181-parameter-table","title":"7.1 TR\u2011181 Parameter Table","text":"Parameter Category Schema Source Access Method Persistence Notes Device Configuration <code>bbhm_def_cfg_qemu.xml</code> Registry API File\u2011based Schema\u2011validated Network Interface Settings Schema\u2011defined DBus/RBUS Atomic commits State machine protected Service Parameters XML configuration Internal API Transactional Migration supported Custom Extensions Schema extensions Standard API Schema\u2011governed Patch script enabled <p>Note: Specific parameter names and values are defined in the XML schema file rather than hard\u2011coded in the component logic, enabling flexible platform adaptation and controlled evolution through external configuration management.</p>"},{"location":"docu/raheen/psm_claude/#8-implementation-details","title":"8. Implementation Details","text":"<ul> <li> <p>Key Algorithms or Logic: Dual state machine architecture governs both FileLoader and SysRegistry subsystems with explicit state transitions enforced through dedicated states modules. Schema parsing employs XML validation with type checking and structural verification. Atomic persistence operations use staging and commit semantics to ensure transactional integrity. In\u2011memory parameter caching optimizes read operations while lazy persistence minimizes unnecessary file I/O.</p> </li> <li> <p>Error Handling Strategy: Hierarchical error propagation through well\u2011defined return codes from operation modules up through interface layers to IPC transport. Parse errors are isolated early in the FileLoader, while registry operation failures are contained within state machine boundaries. State transition validation prevents inconsistent partial updates. Comprehensive error logging aids in diagnostic troubleshooting.</p> </li> <li> <p>Logging &amp; Debugging: Structured logging integrated throughout all modules with configurable verbosity levels. Each subsystem provides detailed trace information for state transitions, parameter operations, and persistence activities. Unit tests validate both success and failure paths for all major functional modules. Mock frameworks enable isolated testing of individual components.</p> </li> </ul>"},{"location":"docu/raheen/psm_claude/#9-key-configuration-files","title":"9. Key Configuration Files","text":"Configuration File Purpose Key Parameters Default Values Override Mechanisms <code>config/bbhm_def_cfg_qemu.xml</code> Primary schema definition for QEMU target Parameter structure, types, defaults Schema\u2011specified Replace file or apply patch script <code>scripts/bbhm_patch.sh</code> Migration and upgrade script Schema transformations N/A Execute during upgrade window <p>Configuration files are minimal by design\u2014the XML schema serves as the single source of truth for parameter definitions and structure.</p>"},{"location":"docu/raheen/psm_claude/#91-configuration-file-details","title":"9.1 Configuration File Details","text":"<p>Schema Configuration (bbhm_def_cfg_qemu.xml): This XML file serves as the foundational configuration artifact that defines the complete parameter topology, type constraints, validation rules, and default values used during system initialization. The File Loader subsystem parses this schema during startup to construct the internal parameter representation that the System Registry maintains throughout the service lifecycle. Schema modifications enable platform\u2011specific customization, parameter addition or removal, and default value adjustments without requiring code changes, supporting flexible deployment across different hardware platforms and configuration requirements.</p> <p>Migration Script (bbhm_patch.sh): The patch script provides controlled schema evolution capabilities by enabling transformation of existing stored parameter data to remain compatible with updated parsing logic and structural expectations. This mechanism is essential during firmware upgrades or configuration migrations where the parameter schema has evolved but existing stored data must be preserved and adapted. The script operates during maintenance windows prior to service restart, ensuring that schema mismatches are resolved before the parsing logic encounters incompatible data structures.</p> <p>Configuration files are minimal by design\u2014the XML schema serves as the single source of truth for parameter definitions and structure, while the migration script provides the controlled evolution pathway necessary for long\u2011term maintainability and platform adaptation.</p>"},{"location":"docu/raheen/psm_claude/#10-api-endpoints-if-applicable","title":"10. API Endpoints (if applicable)","text":"<p>CcspPsm exposes its functionality through IPC methods rather than REST endpoints. Key operations include:</p> Operation DBus/RBUS Method Description Parameters Returns GetParameter <code>GetParameterValue</code> Retrieve parameter value from in\u2011memory registry Parameter name (string) Value and type information SetParameter <code>SetParameterValue</code> Update parameter value with validation Name (string), Value (typed) Status code and error details CommitParameters <code>CommitChanges</code> Persist pending changes to storage None Success/failure status ValidateParameter <code>ValidateParameter</code> Check parameter against schema constraints Name (string), Value (typed) Validation result and errors GetParameterNames <code>GetParameterNames</code> Enumerate available parameter names Filter pattern (optional) Parameter name list BulkSet <code>SetMultipleParameters</code> Atomic multi\u2011parameter update Parameter array Aggregate status ResetToDefaults <code>ResetParameters</code> Restore default values Parameter list (optional) Reset status"},{"location":"docu/raheen/psm_claude/#11-deployment-runtime-environment","title":"11. Deployment &amp; Runtime Environment","text":"<p>CcspPsm operates as a native Linux process within the RDK\u2011B middleware ecosystem, designed for deployment on broadband gateway hardware with persistent storage capabilities. The component integrates seamlessly with systemd\u2011based service management, providing controlled startup sequencing, dependency resolution, and graceful shutdown handling. Resource requirements are optimized for embedded environments while maintaining sufficient performance for high\u2011frequency parameter operations and bulk configuration management scenarios typical in broadband router deployments.</p> <ul> <li>Container Runtime: Native Linux process within RDK\u2011B middleware stack, managed by systemd</li> <li>Orchestration: Systemd service management with explicit dependency ordering and restart policies</li> <li>Resource Requirements: </li> <li>Memory: ~2\u20114MB for in\u2011memory parameter registry (varies with schema size)</li> <li>CPU: Minimal baseline with brief spikes during schema parsing and file I/O operations</li> <li>Storage: Persistent configuration files, typically &lt;1MB depending on parameter scope</li> <li>Supported Platforms: RDK\u2011B compatible hardware with persistent storage capability (eMMC, flash, etc.)</li> <li>Startup Parameters: </li> <li>Schema file path configuration</li> <li>HAL interface selection and configuration</li> <li>IPC transport selection (DBus/RBUS or both)</li> <li>Logging verbosity and output destination</li> <li>Network Dependencies: None (local IPC only)</li> <li>Security Context: Runs with appropriate privileges for filesystem access and IPC registration</li> </ul>"},{"location":"docu/raheen/psm_gpt5/","title":"CcspPsm","text":""},{"location":"docu/raheen/psm_gpt5/#1-overview","title":"1. Overview","text":"<p>CcspPsm (Platform Storage Manager) is a core persistence and configuration state service in the RDK\u2011B middleware stack. Its responsibility, as evidenced by the repository contents, is to provide reliable storage, retrieval, validation, and life\u2011cycle management of configuration and operational parameters used by other CCSP/RDK\u2011B components. It achieves this through two tightly integrated subsystems: a file\u2011oriented loader (PsmFileLoader) that parses, validates, serializes, and atomically writes persistent state, and a system registry layer (PsmSysRegistry) that maintains an in\u2011memory representation, mediates access, enforces state machine transitions, and coordinates storage updates. Surrounding these subsystems is a service shell (Ssp) that exposes inter\u2011process interfaces over DBus and RBUS, integrates with platform/HAL abstractions, and orchestrates initialization and shutdown workflows. A configuration schema (bbhm_def_cfg_qemu.xml) establishes structural and default value definitions, while patch tooling (bbhm_patch.sh) supports controlled upgrade or migration. Comprehensive unit tests spanning almost every internal module underscore a design emphasis on correctness, modularity, and maintainability.</p>"},{"location":"docu/raheen/psm_gpt5/#purpose-in-the-rdkb-stack","title":"Purpose in the RDK\u2011B Stack","text":"<p>CcspPsm exists to ensure that device configuration and selected operational parameters survive restarts, firmware upgrades, and controlled recovery scenarios. Other RDK\u2011B managers rely on it to read or commit TR\u2011181 aligned property values via standardized IPC pathways instead of implementing bespoke persistence logic. This removes duplication, enforces schema validation consistently, and centralizes transactional safeguards. It thereby underpins reliability, determinism of boot behavior, and integrity of device management operations across the platform.</p>"},{"location":"docu/raheen/psm_gpt5/#key-features-and-responsibilities","title":"Key Features and Responsibilities","text":"<p>CcspPsm provides schema\u2011driven configuration loading, parameter storage with atomic update semantics, state machine governance for both the file loader and registry subsystems, HAL integration points, IPC exposure over DBus and RBUS, structured exported APIs (clearly demarcated in interface and exported header pairs), controlled migration via patch scripting, and extensive test coverage validating base, control, operation, parse, state transition, storage, and system RAM interface behaviors. It mediates the lifecycle from initial parsing through steady\u2011state runtime and subsequent mutation or synchronization operations. Error categorization, status propagation, and robustness are implied by discrete modules for base, control, operation, parse, storage, and states in both major subsystems.</p>"},{"location":"docu/raheen/psm_gpt5/#role-in-broadband-router-architecture","title":"Role in Broadband Router Architecture","text":"<p>Architecturally CcspPsm occupies the persistence tier immediately beneath higher\u2011level management agents and above platform storage (filesystem / flash / NVRAM abstractions). It forms a horizontal service consumed by multiple vertical functional domains (telemetry, WAN, Wi\u2011Fi, provisioning, diagnostics) through bus interfaces. It acts neither as a HAL nor a business logic orchestrator; instead it supplies the durable substrate and access discipline other components depend upon for configuration fidelity.</p>"},{"location":"docu/raheen/psm_gpt5/#2-architecture-design","title":"2. Architecture / Design","text":""},{"location":"docu/raheen/psm_gpt5/#21-highlevel-design-principles","title":"2.1 High\u2011Level Design Principles","text":"<p>The code organization manifests principles of modular separation (distinct directories for file loader and system registry), interface clarity (each subsystem has both interface and exported API headers), layered responsibility (file parsing vs runtime registry vs service shell), explicit state modeling (dedicated states.c modules), portability (schema file detached from logic), controlled evolution (ChangeLog, Version.txt), testability (granular unit tests per internal concern), and IPC abstraction (dual DBus/RBUS support). Schema\u2011driven operation reduces hard\u2011coded structural assumptions. Atomicity and consistency are implied by operation modules separate from control/state logic, suggesting purposeful sequencing and commit semantics. Encapsulation of HAL calls (psm_hal_apis.[ch]) prevents leakage of platform specifics into core logic.</p>"},{"location":"docu/raheen/psm_gpt5/#22-component-boundaries-responsibilities","title":"2.2 Component Boundaries &amp; Responsibilities","text":"<ul> <li>PsmFileLoader: Responsible for ingesting XML schema and/or persisted data, validating structure and types (parse), orchestrating state transitions (states), coordinating higher\u2011level control flows (control), executing concrete file operations including commits and atomic write patterns (operation), and furnishing a consolidated external interface (interface / exported_api headers). Global and internal headers centralize shared constants and internal function contracts.</li> <li>PsmSysRegistry: Maintains in\u2011memory parameter registry, mediates configuration manager interface functions (cfmif), implements runtime control logic (control), provides storage interfacing (storage) behind a system RAM abstraction (sysramif), and parallels the file loader with analogous base, operation, states, interface, and exported API segmentation.</li> <li>Ssp Layer: Acts as the service shell handling process entry (ssp_main.c), DBus transport (ssp_dbus.c), RBUS transport (ssp_rbus.c), configuration manager integration (ssp_cfmif.c), and HAL bridging (psm_hal_apis.c). It decouples transport and environment from persistence logic.</li> <li>Include Headers: Provide stable API boundaries (psm_flo_exported_api.h, psm_sysro_exported_api.h), internal extensibility points (internal_api headers), property definitions (psm_properties.h), type metadata (psm_co_type.h), naming and OID indexing (psm_co_name.h, psm_co_oid.h), and HAL/CFM interfaces (psm_hal_apis.h, psm_ifo_cfm.h).</li> <li>Scripts: bbhm_patch.sh enables orchestrated patching or migration, ensuring compatibility when schema or structural changes occur.</li> <li>Tests: Mirror each functional concern, enabling focused verification and regression detection across base/control/operation/parse/states/storage/integration layers for both subsystems.</li> </ul>"},{"location":"docu/raheen/psm_gpt5/#23-threading-model","title":"2.3 Threading Model","text":"<p>No explicit threading primitives or concurrency layer files are present. The design appears single\u2011threaded per process for core state transitions, relying on the bus layer to serialize inbound operations or external synchronization to prevent concurrent mutation. The presence of separate operation and control modules suggests deterministic sequencing rather than concurrent scheduling. Absent concurrency artifacts the system should be documented as a single\u2011threaded service core with potential external reentrancy mitigation handled at IPC layer boundaries.</p>"},{"location":"docu/raheen/psm_gpt5/#24-component-architecture-diagram","title":"2.4 Component Architecture Diagram","text":"<p>The following diagram summarizes subsystem relationships based solely on source directory structure and interface layering. It illustrates how IPC endpoints route into the service shell, which coordinates both the file loader and system registry, with the registry interacting with storage through loader orchestration.</p> <p>In this representation the Ssp layer brokers incoming bus calls, dispatching to registry operations for runtime get/set semantics. Persistent commits or recovery sequences invoke PsmFileLoader parsing and write logic. State machines in both subsystems constrain lifecycle transitions. A patch script and schema file act as static or operational inputs, while HAL integration provides platform hooks.</p> <pre><code>flowchart TB\n    Client[\"RDK-B Components\\n(DBus/RBUS Clients)\"]\n    subgraph Ssp[\"Ssp Layer\"]\n        SspMain[\"ssp_main.c\"]\n        SspDBus[\"ssp_dbus.c\"]\n        SspRBUS[\"ssp_rbus.c\"]\n        SspCFM[\"ssp_cfmif.c\"]\n        SspHAL[\"psm_hal_apis.c\"]\n    end\n    subgraph FileLoader[\"PsmFileLoader\"]\n        FLOInt[\"psm_flo_interface.c\"]\n        FLOParse[\"psm_flo_parse.c\"]\n        FLOOp[\"psm_flo_operation.c\"]\n        FLOCtrl[\"psm_flo_control.c\"]\n        FLOStates[\"psm_flo_states.c\"]\n        FLOBase[\"psm_flo_base.c\"]\n    end\n    subgraph SysRegistry[\"PsmSysRegistry\"]\n        SROInt[\"psm_sysro_interface.c\"]\n        SROBase[\"psm_sysro_base.c\"]\n        SROCtrl[\"psm_sysro_control.c\"]\n        SROOp[\"psm_sysro_operation.c\"]\n        SROStates[\"psm_sysro_states.c\"]\n        SROStore[\"psm_sysro_storage.c\"]\n        SROSysRAM[\"psm_sysro_sysramif.c\"]\n        SROCFMIF[\"psm_sysro_cfmif.c\"]\n    end\n    Schema[\"config/bbhm_def_cfg_qemu.xml\"]\n    Patch[\"scripts/bbhm_patch.sh\"]\n\n    Client --&gt; Ssp\n    Ssp --&gt; SysRegistry\n    SysRegistry --&gt; FileLoader\n    FileLoader --&gt; Schema\n    Patch -.-&gt; FileLoader\n    SspHAL --&gt; SysRegistry</code></pre>"},{"location":"docu/raheen/psm_gpt5/#25-design-explanation-lifecycle-flow","title":"2.5 Design Explanation &amp; Lifecycle Flow","text":"<p>Initialization begins in ssp_main.c, which selects and initializes IPC transports (ssp_dbus.c or ssp_rbus.c), binds configuration manager interfaces (ssp_cfmif.c), and prepares HAL interaction stubs (psm_hal_apis.c). During startup SysRegistry logic (psm_sysro_base/control/states) initializes in\u2011memory structures and may request the FileLoader to parse and load persisted data (psm_flo_parse.c). The FileLoader state machine advances through parsing, validation, and ready stages before handing control back. Runtime get/set operations enter through registry interface APIs (psm_sysro_interface.c / exported headers) invoking operation modules which coordinate atomic changes and, when necessary, trigger commit sequences through FileLoader operation/control modules. Shutdown or migration triggers controlled state transitions culminating in final synchronization to persistent storage.</p>"},{"location":"docu/raheen/psm_gpt5/#3-internal-modules","title":"3. Internal Modules","text":"Subsystem / Module Role (Derived from Naming &amp; Placement) Key Files File Loader Base Core foundational routines and shared context for file loader psm_flo_base.c File Loader Parse Schema and data parsing, structural and type validation psm_flo_parse.c File Loader Operation Concrete file I/O, atomic write/commit actions psm_flo_operation.c File Loader Control High-level orchestration, sequencing parse/load/save phases psm_flo_control.c File Loader States State machine definitions &amp; transition handling psm_flo_states.c File Loader Interface External callable boundary, API indirection layer psm_flo_interface.c / psm_flo_interface.h File Loader Exported API Public header surface for consumers psm_flo_exported_api.h Sys Registry Base Foundational registry context and initialization routines psm_sysro_base.c Sys Registry Operation Parameter access/mutation logic psm_sysro_operation.c Sys Registry Control Lifecycle orchestration for registry psm_sysro_control.c Sys Registry States Registry state machine transitions psm_sysro_states.c Sys Registry Storage Persistent storage mediation / staging psm_sysro_storage.c Sys Registry SysRAM IF System RAM interface abstraction psm_sysro_sysramif.c Sys Registry CFM IF Configuration Manager interface adapter psm_sysro_cfmif.c Sys Registry Interface Public callable registry surface psm_sysro_interface.c / psm_sysro_interface.h Sys Registry Exported API Exported API header for registry users psm_sysro_exported_api.h HAL APIs Platform hook stubs or abstractions psm_hal_apis.c / psm_hal_apis.h Ssp Main Process entry / master initialization ssp_main.c Ssp DBus Transport DBus endpoint &amp; marshaling ssp_dbus.c Ssp RBUS Transport RBUS endpoint &amp; marshaling ssp_rbus.c Ssp CFM Interface Service-level CFM integration glue ssp_cfmif.c Properties &amp; Metadata Type, name, OID, property constants psm_co_type.h, psm_co_name.h, psm_co_oid.h, psm_properties.h CFM Interface Header Configuration manager interface contract psm_ifo_cfm.h Patch Script Upgrade/migration patch logic scripts/bbhm_patch.sh Schema Configuration definition &amp; defaults config/bbhm_def_cfg_qemu.xml Tests (File Loader) Unit tests per functional slice psm_flo_*_test.cpp Tests (Sys Registry) Registry functional verification psm_sysro_*_test.cpp Tests (Integration) Combined or exported API tests CcspPsmTest.cpp"},{"location":"docu/raheen/psm_gpt5/#31-module-breakdown-diagram","title":"3.1 Module Breakdown Diagram","text":"<p>The breakdown diagram clusters modules by subsystem while showing directional dependencies\u2014registry depends on loader for persistence, Ssp depends on both subsystems, tests reference all layers.</p> <pre><code>flowchart TB\n    subgraph Ssp[\"Ssp Layer\"]\n        SMain[\"ssp_main\"]\n        SDBus[\"ssp_dbus\"]\n        SRBus[\"ssp_rbus\"]\n        SCFM[\"ssp_cfmif\"]\n        SHAL[\"psm_hal_apis\"]\n    end\n    subgraph Loader[\"PsmFileLoader\"]\n        FLOBase\n        FLOParse\n        FLOOp\n        FLOCtrl\n        FLOStates\n        FLOInt\n    end\n    subgraph Registry[\"PsmSysRegistry\"]\n        SROBase\n        SROOp\n        SROCtrl\n        SROStates\n        SROStore\n        SROSram\n        SROCFMIF\n        SROInt\n    end\n    Tests[\"Unit Tests\"]\n    Schema[\"Schema XML\"]\n    Patch[\"Patch Script\"]\n\n    Ssp --&gt; Registry\n    Registry --&gt; Loader\n    Loader --&gt; Schema\n    Patch -.-&gt; Loader\n    Tests -.-&gt; Registry\n    Tests -.-&gt; Loader\n    Tests -.-&gt; Ssp</code></pre>"},{"location":"docu/raheen/psm_gpt5/#4-interaction-with-other-middleware-components","title":"4. Interaction with Other Middleware Components","text":"<p>CcspPsm interacts indirectly with the broader RDK\u2011B ecosystem through its DBus and RBUS interfaces (ssp_dbus.c and ssp_rbus.c). Other CCSP agents issue configuration get/set operations or commit/refresh style calls that traverse the Ssp layer into SysRegistry logical operations. There is also an integration path with a configuration manager (CFM) via ssp_cfmif.c and psm_sysro_cfmif.c enabling coordinated or policy\u2011driven configuration flows. HAL interaction is abstracted and localized, preventing leakage of platform specifics into higher layers. The design centralizes persistence so that upstream components rely on a canonical store rather than bespoke file usage, promoting consistency and reducing defect surfaces.</p>"},{"location":"docu/raheen/psm_gpt5/#41-middleware-interaction-flow-diagram","title":"4.1 Middleware Interaction Flow Diagram","text":"<p>The diagram shows other RDK\u2011B components invoking bus calls resolved by Ssp into registry queries or updates which optionally trigger loader persistence.</p> <pre><code>flowchart LR\n    CompA[\"Mgmt / Feature Component A\"]\n    CompB[\"Feature Component B\"]\n    Bus[\"DBus / RBUS\"]\n    SspLayer[\"Ssp Layer\"]\n    Registry[\"SysRegistry\"]\n    Loader[\"FileLoader\"]\n    Storage[\"Persistent File System\"]\n\n    CompA --&gt; Bus\n    CompB --&gt; Bus\n    Bus --&gt; SspLayer\n    SspLayer --&gt; Registry\n    Registry --&gt; Loader\n    Loader --&gt; Storage</code></pre>"},{"location":"docu/raheen/psm_gpt5/#5-interaction-with-other-layers","title":"5. Interaction with Other Layers","text":"<p>CcspPsm sits above the platform\u2019s persistent storage medium (filesystem/NVRAM) and below logical management agents. The HAL APIs file (psm_hal_apis.c/.h) suggests optional access to platform functionality (timers, low-level storage hints, or environmental data) abstracted away from core persistence logic. The patch script and schema tie deployment and upgrade activities to controlled transitions without exposing internal structural details to dependent components. Abstraction is enforced by clear interface/exported header pairs that segregate public contracts from internal state machine or operation routines.</p>"},{"location":"docu/raheen/psm_gpt5/#51-layered-architecture-view","title":"5.1 Layered Architecture View","text":"<p>This layered view places PSM within the vertical stack from HAL and storage upward to management and orchestration agents.</p> <pre><code>flowchart TB\n    Mgmt[\"Mgmt / Control Agents\"]\n    IPC[\"DBus / RBUS\"]\n    PSM[\"CcspPsm (Ssp + SysRegistry + FileLoader)\"]\n    HAL[\"HAL / Platform Adapters\"]\n    FS[\"Persistent Storage (File System / Flash)\"]\n\n    Mgmt --&gt; IPC\n    IPC --&gt; PSM\n    PSM --&gt; HAL\n    PSM --&gt; FS</code></pre>"},{"location":"docu/raheen/psm_gpt5/#6-ipc-mechanism","title":"6. IPC Mechanism","text":"<p>Two IPC transports are explicitly supported: DBus (ssp_dbus.c) and RBUS (ssp_rbus.c). The Ssp layer encapsulates connection initialization, registration, method dispatch, and response handling. Message formats themselves are not enumerated in the source listing provided, but given standard RDK\u2011B patterns these would map to method calls corresponding to exported APIs (psm_flo_exported_api.h and psm_sysro_exported_api.h). The flow of a request (e.g., a parameter set) begins with a bus method invocation, is marshaled by Ssp transport code into internal API calls on SysRegistry, which may modify in\u2011memory state and optionally invoke FileLoader commit logic. Completion returns a status code communicated back across the chosen bus transport. RBUS and DBus parity ensures migration or dual operation scenarios can be supported without altering core persistence routines.</p>"},{"location":"docu/raheen/psm_gpt5/#61-ipc-flow-sequence","title":"6.1 IPC Flow Sequence","text":"<p>The diagram follows a single set operation from client invocation through commit and response.</p> <pre><code>sequenceDiagram\n    participant Client as RDK-B Component\n    participant Bus as DBus/RBUS\n    participant Ssp as Ssp Layer\n    participant Registry as SysRegistry\n    participant Loader as FileLoader\n    participant Storage as Persistent Store\n\n    Client-&gt;&gt;Bus: Method Call (SetParam, Value)\n    Bus-&gt;&gt;Ssp: Dispatch\n    Ssp-&gt;&gt;Registry: Apply In-Memory Update\n    alt Requires Commit\n        Registry-&gt;&gt;Loader: Persist Request\n        Loader-&gt;&gt;Storage: Atomic Write\n        Storage--&gt;&gt;Loader: Write Status\n        Loader--&gt;&gt;Registry: Commit Result\n    end\n    Registry--&gt;&gt;Ssp: Operation Status\n    Ssp--&gt;&gt;Bus: Return Code\n    Bus--&gt;&gt;Client: Response</code></pre>"},{"location":"docu/raheen/psm_gpt5/#7-tr181-data-models","title":"7. TR\u2011181 Data Models","text":"<p>While CcspPsm underpins persistence of TR\u2011181 aligned parameters, the repository snapshot includes only a single schema file (bbhm_def_cfg_qemu.xml) without enumerated TR\u2011181 object names in view here. Thus parameter specifics cannot be listed without inspecting the XML contents. Registration mechanics are inferred: external components register or request parameter operations over bus interfaces; SysRegistry mediates logical representation; FileLoader ensures durable reflection of validated schema\u2011compliant state. No custom TR\u2011181 extension objects are directly derivable from the file listing alone; the design instead supplies the foundational persistence service consumed by those that define and own specific TR\u2011181 parameters elsewhere. Any parameter mapping or customization would be governed by schema content plus exported APIs rather than hard\u2011coded logic in public headers.</p>"},{"location":"docu/raheen/psm_gpt5/#8-implementation-details","title":"8. Implementation Details","text":""},{"location":"docu/raheen/psm_gpt5/#81-core-logic-and-state-machines","title":"8.1 Core Logic and State Machines","text":"<p>The duplicated pattern of base/control/operation/parse/states modules in both PsmFileLoader and PsmSysRegistry reveals a state machine centric architecture. The states modules encapsulate permissible transitions (e.g., uninitialized \u2192 parsing \u2192 validated \u2192 ready \u2192 committing \u2192 idle). Control modules orchestrate transitions by invoking operation modules to perform discrete atomic actions (e.g., read file, validate structure, write commit, update registry). Parsing is isolated to reduce coupling between format concerns and operational sequencing. Interface modules unify the externally callable surface while exported headers publish stable symbols to clients. Storage separation (psm_sysro_storage.c) signals a staging model: in\u2011memory mutation followed by explicit persistence trigger rather than implicit write\u2011through, enabling batching or atomic multi\u2011parameter updates.</p>"},{"location":"docu/raheen/psm_gpt5/#82-error-handling-strategy","title":"8.2 Error Handling Strategy","text":"<p>Error isolation is implied by segmentation: parse routines can fail early feeding control logic with failure statuses, operation modules produce granular return codes that propagate upward through interface layers, and state modules enforce legal transitions preventing inconsistent half\u2011applied states. Tests exist for each major functional piece (parse, operation, control, states) verifying branch behaviors and ensuring regression detection for failure pathways. The likely model is hierarchical return codes with distinct enumerations for parse errors, I/O failures, invalid transitions, and storage anomalies\u2014supported by modular decomposition.</p>"},{"location":"docu/raheen/psm_gpt5/#83-logging-and-debugging-hooks","title":"8.3 Logging and Debugging Hooks","text":"<p>Although logging implementations are not explicitly visible in file names, typical RDK\u2011B conventions integrate logging macros inside each functional module. The granularity of unit tests allows targeted validation of both success and failure cases, often accompanied by logging assertions in extended form. The separation of HAL, CFM, and bus layers aids diagnostic scoping: transport vs registry vs loader issues become traceable to their respective modules.</p>"},{"location":"docu/raheen/psm_gpt5/#84-upgrade-migration-support","title":"8.4 Upgrade / Migration Support","text":"<p>bbhm_patch.sh indicates controlled schema or structural evolution via scripted transformations, avoiding ad hoc manual edits. Running patches external to core runtime ensures minimal disruption and preserves integrity by preparing data before the service attempts to parse it under new rules.</p>"},{"location":"docu/raheen/psm_gpt5/#9-key-configuration-files","title":"9. Key Configuration Files","text":"File Purpose Functional Scope Override Mechanism config/bbhm_def_cfg_qemu.xml Defines schema, structure, and default values for persisted parameters (QEMU target context). Establishes baseline parameter topology and defaults used at initialization. Replace or extend schema per platform build; adjust with migration script before service restart."},{"location":"docu/raheen/psm_gpt5/#91-patch-and-migration-assets","title":"9.1 Patch and Migration Assets","text":"<p>The patch script enables forward schema evolution by transforming or normalizing existing stored data so it remains compatible with updated parsing and validation logic, reducing startup failure risk during upgrades.</p> Script Role Application Phase scripts/bbhm_patch.sh Applies schema or data format adjustments during upgrade/migration to keep persisted store compatible with current parsing logic. Pre\u2011startup (upgrade) or maintenance window prior to service relaunch."},{"location":"docu/templateOct10/ccsppnm/","title":"CcspPsm (Persistent Storage Manager) Documentation","text":"<p>CcspPsm is the RDK-B middleware component that provides persistent configuration storage and retrieval services for the entire CCSP  ecosystem. As the central repository for device configuration data, it ensures configuration persistence across device reboots and provides structured access to configuration parameters through both DBus and RBus interfaces. The component serves as the backbone for configuration management, enabling other RDK-B components to store, retrieve, and manage persistent settings in a centralized, reliable manner.</p> <p>The Persistent Storage Manager acts as a bridge between volatile runtime configurations and non-volatile storage, implementing sophisticated backup and recovery mechanisms to ensure data integrity. It supports XML-based configuration files with compression, provides real-time configuration access through standardized IPC mechanisms, and maintains compatibility with TR-181 data model specifications.</p> <pre><code>graph TD\n    subgraph \"External Systems\"\n        WUI[Web UI]\n        TR069[TR-069 ACS]\n        Cloud[Cloud Management]\n    end\n\n    subgraph \"RDK-B Middleware\"\n        PSM[CcspPsm&lt;br/&gt;Persistent Storage Manager]\n        PAM[CcspPandM]\n        WiFi[CcspWifiAgent]\n        WAN[WAN Manager]\n        CM[CcspCMAgent]\n        TR069PA[CcspTr069Pa]\n    end\n\n    subgraph \"HAL/Platform Layer\"\n        HAL[(Platform HAL)]\n        FS[(File System)]\n        NVRAM[(NVRAM Storage)]\n    end\n\n    WUI --&gt;|HTTPS/TR-181| PAM\n    TR069 --&gt;|TR-069/CWMP| TR069PA\n    Cloud --&gt;|HTTPS/REST| PAM\n\n    PAM --&gt;|DBus/RBus Get/Set| PSM\n    WiFi --&gt;|DBus/RBus Config| PSM\n    WAN --&gt;|DBus/RBus Parameters| PSM\n    CM --&gt;|DBus/RBus Settings| PSM\n    TR069PA --&gt;|DBus/RBus Data Model| PSM\n\n    PSM --&gt;|File I/O| FS\n    PSM --&gt;|HAL APIs| HAL\n    PSM --&gt;|Direct Access| NVRAM\n\n    classDef user fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n    classDef component fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef external fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n    classDef storage fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;\n\n    class WUI,TR069,Cloud user;\n    class PSM,PAM,WiFi,WAN,CM,TR069PA component;\n    class HAL external;\n    class FS,NVRAM storage;</code></pre> <p>Key Features &amp; Responsibilities: </p> <ul> <li>Configuration Persistence: Provides reliable storage and retrieval of device configuration parameters with atomic write operations and data integrity validation</li> <li>Multi-format Support: Handles various data types including strings, integers, booleans, base64, and complex nested structures with automatic type conversion</li> <li>Backup &amp; Recovery: Implements sophisticated backup mechanisms with multiple configuration file versions (default, current, backup, temporary) and rollback capabilities</li> <li>IPC Integration: Exposes configuration services through both DBus and RBus interfaces enabling seamless integration with other RDK-B middleware components</li> <li>XML Processing: Manages XML-based configuration files with compression support and efficient parsing for large configuration datasets</li> <li>Platform Abstraction: Provides hardware abstraction layer integration for platform-specific persistent storage access and NVRAM operations</li> </ul>"},{"location":"docu/templateOct10/ccsppnm/#design","title":"Design","text":"<p>The CcspPsm component implements a layered architecture designed around reliability, performance, and extensibility principles. The core design follows a modular approach with clear separation between file operations, system registry management, and IPC communication layers. The architecture ensures data consistency through atomic operations, maintains backward compatibility with legacy CCSP interfaces, and provides robust error handling with automatic recovery mechanisms.</p> <p>The component's design emphasizes fail-safe operations where configuration integrity is paramount. Multiple configuration file versions are maintained simultaneously, enabling instant rollback capabilities during failed updates. The system registry acts as an in-memory cache with lazy loading and intelligent flushing strategies to optimize performance while ensuring data persistence. The dual IPC support (DBus and RBus) ensures compatibility across different RDK-B deployments and migration scenarios.</p> <p>Configuration data flows through a carefully orchestrated pipeline: incoming requests are validated, cached in the system registry, batched for efficiency, and periodically flushed to persistent storage. The design incorporates platform-specific HAL integration for low-level storage operations while maintaining a consistent high-level API. Error detection, logging, and recovery mechanisms are integrated at every layer to ensure system resilience and debugging capabilities.</p> <pre><code>graph TD\n    subgraph \"CcspPsm Container (C/Linux Process)\"\n        subgraph \"IPC Layer\"\n            DBusIF[DBus Interface&lt;br/&gt;ssp_dbus.c]\n            RBusIF[RBus Interface&lt;br/&gt;ssp_rbus.c]\n        end\n\n        subgraph \"Core Engine\"\n            SysReg[System Registry&lt;br/&gt;PsmSysRegistry/]\n            FileLoader[File Loader&lt;br/&gt;PsmFileLoader/]\n            CFMIf[Config Management Interface&lt;br/&gt;psm_ifo_cfm.h]\n        end\n\n        subgraph \"Storage Layer\"\n            HALApi[HAL APIs&lt;br/&gt;psm_hal_apis.c]\n            FileOps[File Operations&lt;br/&gt;XML Processing]\n        end\n\n        subgraph \"Configuration\"\n            XMLConf[XML Config Files&lt;br/&gt;bbhm_def_cfg_qemu.xml]\n            Props[Properties&lt;br/&gt;psm_properties.h]\n        end\n    end\n\n    subgraph \"External Dependencies\"\n        CCSPMsg[CCSP Message Bus]\n        RBus[RBus Framework]\n        HAL[(Platform HAL)]\n        FileSystem[(File System)]\n    end\n\n    DBusIF --&gt;|Parameter Access| SysReg\n    RBusIF --&gt;|Parameter Access| SysReg\n    SysReg --&gt;|Load/Parse| FileLoader\n    SysReg --&gt;|Config Operations| CFMIf\n    FileLoader --&gt;|File I/O| FileOps\n    CFMIf --&gt;|Platform Access| HALApi\n\n    DBusIF &lt;--&gt;|Message Bus| CCSPMsg\n    RBusIF &lt;--&gt;|RBus Protocol| RBus\n    HALApi &lt;--&gt;|HAL Calls| HAL\n    FileOps &lt;--&gt;|Read/Write| FileSystem\n\n    Props -.-&gt;|Configuration| SysReg\n    XMLConf -.-&gt;|Default Config| FileLoader\n\n    classDef interface fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef core fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;\n    classDef storage fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n    classDef config fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n    classDef external fill:#ffebee,stroke:#c62828,stroke-width:2px;\n\n    class DBusIF,RBusIF interface;\n    class SysReg,FileLoader,CFMIf core;\n    class HALApi,FileOps storage;\n    class XMLConf,Props config;\n    class CCSPMsg,RBus,HAL,FileSystem external;</code></pre>"},{"location":"docu/templateOct10/ccsppnm/#prerequisites-and-dependencies","title":"Prerequisites and Dependencies","text":"<p>MUST Requirements: - CCSP Common Library: Required for base CCSP framework functionality, message bus integration, and common utility functions - DBus Message Bus: Essential for inter-component communication with other RDK-B middleware components - RBus Framework: Required for modern RBus-based IPC communication and event handling - File System Access: Writable persistent storage for configuration files (typically <code>/nvram/</code> or <code>/opt/</code>) - libxml2: XML parsing and generation library for configuration file processing - zlib: Compression library for XML configuration file compression/decompression</p> <p>SHOULD Requirements: - systemd Integration: For proper service lifecycle management and dependency ordering - Platform HAL: Enhanced platform-specific storage access and NVRAM operations - Security Libraries: SafeC and secure_wrapper for memory-safe operations - Logging Framework: RDK Logger integration for centralized logging and debugging</p> <p>Dependent Components: - CcspPandM: Depends on PSM for TR-181 parameter storage and device configuration management - CcspWifiAgent: Requires PSM for WiFi configuration persistence across reboots - CcspTr069Pa: Uses PSM for TR-069 parameter storage and ACS configuration data - CcspCMAgent: Depends on PSM for cable modem configuration and statistics persistence - WAN Manager: Relies on PSM for WAN interface configuration and connection profiles</p> <p>Threading Model</p> <ul> <li>Threading Architecture: Single-threaded with event-driven architecture</li> <li>Main Thread: Handles all IPC requests, file operations, and configuration management through an event loop mechanism. The single-threaded design eliminates synchronization complexity while ensuring atomic configuration operations</li> <li>Synchronization: Uses semaphores for process initialization synchronization and file locking mechanisms for concurrent access protection</li> <li>Event Processing: Asynchronous event handling for DBus/RBus messages with queued request processing to maintain responsiveness</li> </ul> <p>The single-threaded design is intentional to avoid race conditions in configuration management and ensure data consistency. All operations are processed sequentially through the main event loop, with blocking operations handled efficiently through non-blocking I/O patterns where possible.</p>"},{"location":"docu/templateOct10/ccsppnm/#component-state-flow","title":"Component State Flow","text":""},{"location":"docu/templateOct10/ccsppnm/#initialization-to-active-state","title":"Initialization to Active State","text":"<p>The CcspPsm component follows a carefully orchestrated initialization sequence designed to ensure system stability and data integrity. The process begins with basic resource allocation, progresses through configuration loading and validation, establishes IPC connections, and finally enters an active state ready to serve configuration requests. Each phase includes comprehensive error checking and rollback capabilities to handle initialization failures gracefully.</p> <pre><code>stateDiagram-v2\n    [*] --&gt; Initializing\n    Initializing --&gt; LoadingDefaults: Parse Arguments &amp; Setup Logging\n    LoadingDefaults --&gt; CreatingRegistry: Load Default XML Configuration\n    CreatingRegistry --&gt; RegisteringIPC: Create System Registry Object\n    RegisteringIPC --&gt; LoadingCurrentConfig: Register DBus/RBus Interfaces\n    LoadingCurrentConfig --&gt; ValidatingConfig: Load Current Configuration\n    ValidatingConfig --&gt; Active: Validate Configuration Integrity\n    Active --&gt; ProcessingRequests: Ready to Handle IPC Requests\n    ProcessingRequests --&gt; Active: Request Completed\n    Active --&gt; BackupOperation: Periodic Backup Trigger\n    BackupOperation --&gt; Active: Backup Completed\n    Active --&gt; Shutdown: Stop Signal Received\n    Shutdown --&gt; [*]\n\n    note right of Initializing\n        - Parse command line arguments\n        - Initialize logging framework\n        - Setup signal handlers\n        - Allocate core resources\n    end note\n\n    note right of LoadingDefaults\n        - Parse bbhm_def_cfg_qemu.xml\n        - Validate default parameters\n        - Setup file paths and permissions\n    end note\n\n    note right of Active\n        - Process Get/Set parameter requests\n        - Handle backup/restore operations\n        - Monitor configuration changes\n        - Maintain data integrity\n    end note</code></pre>"},{"location":"docu/templateOct10/ccsppnm/#runtime-state-changes-and-context-switching","title":"Runtime State Changes and Context Switching","text":"<p>During normal operation, CcspPsm handles various runtime state transitions triggered by external events, configuration changes, and system maintenance operations. The component maintains configuration consistency while supporting dynamic updates, backup operations, and error recovery scenarios.</p> <p>State Change Triggers: - Configuration Updates: Parameter set operations trigger immediate in-memory updates with delayed persistent storage to optimize performance - Backup Operations: Timer-based automatic backups and explicit backup requests maintain multiple configuration file versions - Error Recovery: File corruption detection triggers automatic rollback to previous valid configuration versions - IPC Connection Changes: DBus/RBus connection events trigger interface re-registration and service availability updates</p> <p>Context Switching Scenarios: - Configuration Validation: Switch between permissive and strict validation modes based on parameter criticality and system state - Storage Backend Selection: Dynamic selection between file system and NVRAM storage based on parameter persistence requirements - IPC Protocol Selection: Automatic fallback between RBus and DBus based on component compatibility and availability</p>"},{"location":"docu/templateOct10/ccsppnm/#call-flow","title":"Call Flow","text":""},{"location":"docu/templateOct10/ccsppnm/#primary-call-flows","title":"Primary Call Flows","text":"<p>Initialization Call Flow:</p> <pre><code>sequenceDiagram\n    participant System as System Init\n    participant Main as PSM Main Process\n    participant SysReg as System Registry\n    participant FileLoader as File Loader\n    participant IPC as IPC Interfaces\n\n    System-&gt;&gt;Main: Start PSM Process\n    Main-&gt;&gt;Main: Parse Arguments &amp; Setup Logging\n    Main-&gt;&gt;FileLoader: Load Default Configuration\n    FileLoader-&gt;&gt;FileLoader: Parse XML &amp; Validate\n    FileLoader--&gt;&gt;Main: Default Config Loaded\n    Main-&gt;&gt;SysReg: Create Registry Object\n    SysReg-&gt;&gt;SysReg: Initialize Memory Structures\n    SysReg--&gt;&gt;Main: Registry Created\n    Main-&gt;&gt;IPC: Register DBus/RBus Interfaces\n    IPC-&gt;&gt;IPC: Connect to Message Bus\n    IPC--&gt;&gt;Main: IPC Registration Complete\n    Main-&gt;&gt;SysReg: Load Current Configuration\n    SysReg-&gt;&gt;FileLoader: Read Current Config File\n    FileLoader--&gt;&gt;SysReg: Configuration Data\n    SysReg--&gt;&gt;Main: System Ready\n    Main-&gt;&gt;System: Signal Initialization Complete</code></pre> <p>Parameter Get Operation Call Flow:</p> <pre><code>sequenceDiagram\n    participant Client as RDK-B Component\n    participant IPC as DBus/RBus Interface\n    participant SysReg as System Registry\n    participant FileLoader as File Loader\n    participant Storage as File System\n\n    Client-&gt;&gt;IPC: GetParameterValues(paramList)\n    IPC-&gt;&gt;IPC: Validate Request &amp; Parse Parameters\n    IPC-&gt;&gt;SysReg: Get Parameter Values\n    SysReg-&gt;&gt;SysReg: Check Memory Cache\n    alt Parameter in Cache\n        SysReg--&gt;&gt;IPC: Return Cached Values\n    else Parameter Not Cached\n        SysReg-&gt;&gt;FileLoader: Load Parameter from Storage\n        FileLoader-&gt;&gt;Storage: Read Configuration File\n        Storage--&gt;&gt;FileLoader: File Data\n        FileLoader-&gt;&gt;FileLoader: Parse &amp; Extract Parameter\n        FileLoader--&gt;&gt;SysReg: Parameter Value\n        SysReg-&gt;&gt;SysReg: Update Cache\n        SysReg--&gt;&gt;IPC: Return Parameter Values\n    end\n    IPC-&gt;&gt;IPC: Format Response Message\n    IPC--&gt;&gt;Client: Parameter Values Response</code></pre> <p>Parameter Set Operation Call Flow:</p> <pre><code>sequenceDiagram\n    participant Client as RDK-B Component\n    participant IPC as DBus/RBus Interface\n    participant SysReg as System Registry\n    participant FileLoader as File Loader\n    participant Storage as File System\n\n    Client-&gt;&gt;IPC: SetParameterValues(paramList)\n    IPC-&gt;&gt;IPC: Validate Request &amp; Parameters\n    IPC-&gt;&gt;SysReg: Set Parameter Values\n    SysReg-&gt;&gt;SysReg: Validate Parameter Types &amp; Ranges\n    SysReg-&gt;&gt;SysReg: Update Memory Cache\n    SysReg-&gt;&gt;SysReg: Mark for Persistent Storage\n    SysReg--&gt;&gt;IPC: Operation Status\n    IPC--&gt;&gt;Client: Set Response (Success/Error)\n\n    Note over SysReg: Delayed Write Operation\n    SysReg-&gt;&gt;FileLoader: Flush to Persistent Storage\n    FileLoader-&gt;&gt;Storage: Write Updated Configuration\n    Storage--&gt;&gt;FileLoader: Write Complete\n    FileLoader--&gt;&gt;SysReg: Flush Complete</code></pre>"},{"location":"docu/templateOct10/ccsppnm/#tr181-data-models","title":"TR\u2011181 Data Models","text":""},{"location":"docu/templateOct10/ccsppnm/#supported-tr-181-parameters","title":"Supported TR-181 Parameters","text":"<p>CcspPsm acts as the storage backend for TR-181 parameters rather than implementing specific data model objects directly. It provides the persistent storage infrastructure that other RDK-B components use to store their TR-181 parameter values. The component supports the complete range of TR-181 data types and maintains parameter metadata including validation rules, default values, and access permissions.</p>"},{"location":"docu/templateOct10/ccsppnm/#object-hierarchy","title":"Object Hierarchy","text":"<pre><code>Device.\n\u2514\u2500\u2500 [All TR-181 Objects Stored by Other Components]\n    \u251c\u2500\u2500 WiFi.*                    (Stored by CcspWifiAgent)\n    \u251c\u2500\u2500 DeviceInfo.*              (Stored by CcspPandM)\n    \u251c\u2500\u2500 ManagementServer.*        (Stored by CcspTr069Pa)\n    \u251c\u2500\u2500 GatewayInfo.*             (Stored by CcspCMAgent)\n    \u2514\u2500\u2500 Custom Extensions.*       (Various Components)\n</code></pre>"},{"location":"docu/templateOct10/ccsppnm/#parameter-definitions","title":"Parameter Definitions","text":"<p>Core PSM Management Parameters:</p> Parameter Path Data Type Access Default Value Description BBF Compliance Internal PSM Parameters PSM uses internal parameter naming conventions <code>eRT.com.cisco.spvtg.ccsp.*</code> various R/W varies Internal CCSP component parameters with subsystem prefixes Custom Extension <code>Device.DeviceInfo.X_RDKCENTRAL-COM_*</code> various R/W varies RDK Central custom extensions for device information Custom Extension <code>Device.X_RDK_*</code> various R/W varies RDK-specific parameter extensions beyond BBF specification Custom Extension <p>Custom Extensions:</p> <ul> <li>Subsystem Prefixing: PSM uses subsystem prefixes (eRT, eMG, etc.) to organize parameters by target platform and component responsibility</li> <li>Platform-Specific Parameters: Custom parameters for hardware-specific configurations, vendor extensions, and platform optimization settings</li> <li>RDK Extensions: RDK-specific TR-181 extensions for features not covered in standard BBF specifications</li> </ul>"},{"location":"docu/templateOct10/ccsppnm/#parameter-registration-and-access","title":"Parameter Registration and Access","text":"<ul> <li>Implemented Parameters: PSM stores parameters for all RDK-B components but does not directly implement TR-181 objects. Instead, it provides storage services for components that do implement specific TR-181 branches</li> <li>Parameter Registration: Components register their parameters with PSM through DBus/RBus interfaces. PSM handles the storage, retrieval, and persistence of these parameter values</li> <li>Access Mechanism: Other components access stored parameters via <code>GetParameterValues</code> and <code>SetParameterValues</code> operations through DBus or RBus interfaces</li> <li>Validation Rules: PSM enforces data type validation, range checking, and access permissions as configured by the parameter-owning components</li> </ul>"},{"location":"docu/templateOct10/ccsppnm/#internal-modules","title":"Internal Modules","text":"<p>The CcspPsm component is organized into distinct modules that handle specific aspects of persistent storage management. Each module has clearly defined responsibilities and interfaces to ensure maintainable and scalable architecture.</p> Module/Class Description Key Files System Registry Core configuration management engine that maintains in-memory parameter cache, handles persistence operations, and manages configuration validation <code>psm_sysro_base.c</code>, <code>psm_sysro_operation.c</code>, <code>psm_sysro_interface.c</code> File Loader XML configuration file parser and generator responsible for reading/writing compressed XML files and handling multiple configuration versions <code>psm_flo_base.c</code>, <code>psm_flo_parse.c</code>, <code>psm_flo_operation.c</code> IPC Interfaces Dual communication layer providing both DBus and RBus protocol support for component integration <code>ssp_dbus.c</code>, <code>ssp_rbus.c</code> HAL Integration Platform abstraction layer for hardware-specific storage operations and NVRAM access <code>psm_hal_apis.c</code>, <code>psm_hal_apis.h</code> Configuration Management Interface layer for backup, restore, and configuration file management operations <code>ssp_cfmif.c</code>, <code>psm_ifo_cfm.h</code> <pre><code>flowchart TD\n    subgraph CcspPsm[\"CcspPsm Component\"]\n        subgraph IPC[\"IPC Layer\"]\n            DBus[DBus Interface]\n            RBus[RBus Interface]\n        end\n\n        subgraph Core[\"Core Engine\"]\n            SysReg[System Registry&lt;br/&gt;Parameter Cache &amp; Management]\n            FileLoader[File Loader&lt;br/&gt;XML Processing]\n        end\n\n        subgraph Platform[\"Platform Layer\"]\n            HAL[HAL Integration&lt;br/&gt;Hardware Storage]\n            CFM[Config Management&lt;br/&gt;Backup/Restore]\n        end\n    end\n\n    IPC --&gt; Core\n    Core --&gt; Platform\n\n    classDef ipc fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef core fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;\n    classDef platform fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n\n    class DBus,RBus ipc;\n    class SysReg,FileLoader core;\n    class HAL,CFM platform;</code></pre>"},{"location":"docu/templateOct10/ccsppnm/#component-interactions","title":"Component Interactions","text":""},{"location":"docu/templateOct10/ccsppnm/#middleware-components-system-layers","title":"Middleware Components &amp; System Layers","text":"<p>CcspPsm serves as the central configuration storage hub for the entire RDK-B middleware ecosystem. It maintains persistent storage relationships with virtually all CCSP components, providing them with reliable configuration persistence services. The component abstracts the complexity of file system operations, backup management, and data integrity from client components while ensuring consistent data access patterns across the platform.</p> <pre><code>flowchart TD\n    subgraph \"Management Layer\"\n        WebUI[Web UI]\n        TR069[TR-069 ACS]\n        Cloud[Cloud Services]\n    end\n\n    subgraph \"RDK-B Middleware\"\n        PSM[CcspPsm&lt;br/&gt;Persistent Storage Manager]\n        PAM[CcspPandM&lt;br/&gt;Parameter &amp; Management]\n        WiFi[CcspWifiAgent&lt;br/&gt;WiFi Management]\n        CM[CcspCMAgent&lt;br/&gt;Cable Modem]\n        TR069PA[CcspTr069Pa&lt;br/&gt;TR-069 Agent]\n        WAN[WAN Manager]\n        LM[CcspLMLite&lt;br/&gt;LAN Manager]\n    end\n\n    subgraph \"Platform Layer\"\n        HAL[Hardware Abstraction Layer]\n        NVRAM[(NVRAM Storage)]\n        FileSystem[(File System)]\n        Syscfg[System Config]\n    end\n\n    PSM &lt;--&gt;|DBus/RBus Get/Set Parameters| PAM\n    PSM &lt;--&gt;|DBus/RBus WiFi Config| WiFi\n    PSM &lt;--&gt;|DBus/RBus Device Config| CM\n    PSM &lt;--&gt;|DBus/RBus TR-069 Parameters| TR069PA\n    PSM &lt;--&gt;|DBus/RBus WAN Settings| WAN\n    PSM &lt;--&gt;|DBus/RBus LAN Configuration| LM\n\n    PSM --&gt;|HAL API Calls| HAL\n    PSM --&gt;|File I/O Operations| FileSystem\n    PSM --&gt;|Direct Access| NVRAM\n    PSM --&gt;|System Configuration| Syscfg\n\n    classDef management fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n    classDef middleware fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef platform fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n\n    class WebUI,TR069,Cloud management;\n    class PSM,PAM,WiFi,CM,TR069PA,WAN,LM middleware;\n    class HAL,NVRAM,FileSystem,Syscfg platform;</code></pre> <p>Component Interactions:</p> Component/Layer Purpose of Interaction Protocols/Mechanisms Middleware Components CcspPandM Device parameter management and TR-181 object storage DBus/RBus Get/SetParameterValues CcspWifiAgent WiFi configuration persistence and radio settings DBus/RBus parameter operations CcspTr069Pa TR-069 parameter storage and ACS configuration data DBus/RBus parameter management CcspCMAgent Cable modem configuration and statistics storage DBus/RBus device parameter access WAN Manager WAN interface configuration and connection profiles DBus/RBus configuration persistence System Layers Hardware Abstraction Layer Platform-specific storage operations and NVRAM access HAL API function calls File System Configuration file storage, backup, and retrieval Standard file I/O operations System Config Integration with platform configuration utilities Syscfg library interface <p>Published Events:</p> <p>The CcspPsm publishes several key events that other components can subscribe to for coordination and monitoring purposes:</p> Event Purpose of Event Reason for trigger Configuration Loaded Notify components that persistent configuration is available Completed startup initialization and configuration file parsing Parameter Changed Broadcast parameter value changes to interested subscribers External parameter modification through Set operations Backup Completed Signal successful configuration backup operation Automatic or manual backup operation completion Storage Error Alert system about persistent storage failures File system errors, corruption detection, or write failures"},{"location":"docu/templateOct10/ccsppnm/#ipc-mechanism","title":"IPC Mechanism","text":"<p>CcspPsm implements a dual IPC architecture supporting both legacy DBus and modern RBus communication protocols. This design ensures backward compatibility while enabling migration to more efficient RBus-based communication. The component automatically detects available protocols and provides seamless parameter access regardless of the client's communication preference.</p> Type of IPC Message Format Mechanism DBus XML-based message serialization with CCSP-specific parameter structures including parameterValStruct_t and parameterInfoStruct_t CCSP Message Bus with GetParameterValues/SetParameterValues method calls RBus Binary message format with efficient serialization supporting native data types and automatic type conversion RBus framework with Get/Set operations and event subscription support Configuration Interface Internal C function calls with direct memory access for configuration management operations Direct API calls for backup, restore, and configuration validation <pre><code>sequenceDiagram\n    participant Client as RDK-B Component\n    participant PSM as CcspPsm\n    participant SysReg as System Registry\n    participant Storage as File System\n\n    Note over Client,Storage: Parameter Set Operation via RBus\n\n    Client-&gt;&gt;PSM: RBus Set(paramName, value, type)\n    PSM-&gt;&gt;PSM: Validate Parameter &amp; Type\n    PSM-&gt;&gt;SysReg: Update Parameter in Cache\n    SysReg-&gt;&gt;SysReg: Validate &amp; Store in Memory\n    SysReg--&gt;&gt;PSM: Update Status\n    PSM--&gt;&gt;Client: RBus Response (Success/Error)\n\n    Note over PSM,Storage: Asynchronous Persistence\n    PSM-&gt;&gt;Storage: Write Updated Configuration\n    Storage--&gt;&gt;PSM: Write Confirmation\n\n    Note over Client,Storage: Parameter Get Operation via DBus\n\n    Client-&gt;&gt;PSM: DBus GetParameterValues(paramList)\n    PSM-&gt;&gt;SysReg: Retrieve Parameters\n    alt Parameter in Cache\n        SysReg--&gt;&gt;PSM: Return Cached Value\n    else Load from Storage\n        SysReg-&gt;&gt;Storage: Read Configuration File\n        Storage--&gt;&gt;SysReg: Parameter Data\n        SysReg-&gt;&gt;SysReg: Update Cache\n        SysReg--&gt;&gt;PSM: Return Parameter\n    end\n    PSM--&gt;&gt;Client: DBus Response with Parameter Values</code></pre>"},{"location":"docu/templateOct10/ccsppnm/#implementation-details","title":"Implementation Details","text":""},{"location":"docu/templateOct10/ccsppnm/#major-hal-apis-integration","title":"Major HAL APIs Integration","text":"<p>CcspPsm integrates with the Hardware Abstraction Layer to provide platform-specific storage capabilities and access to non-volatile memory resources. The HAL integration enables the component to work across different hardware platforms while maintaining consistent high-level interfaces.</p> <p>Core HAL APIs:</p> HAL API Purpose Parameters Return Values Implementation File <code>platform_hal_GetDeviceConfigStatus</code> Retrieve platform-specific device configuration status and capabilities <code>status</code> (output buffer) <code>0</code> on success, error codes on failure <code>psm_hal_apis.c</code> <code>platform_hal_SetDeviceConfigParameter</code> Set platform-specific configuration parameters in hardware <code>paramName</code>, <code>paramValue</code> <code>0</code> on success, error codes on failure <code>psm_hal_apis.c</code> <code>platform_hal_GetPlatformConfiguration</code> Retrieve platform-specific persistent configuration parameters <code>configArray</code> (output), <code>count</code> (array size) <code>0</code> on success, error codes on failure <code>psm_hal_apis.c</code> <code>platform_hal_DocsisParamsDBInit</code> Initialize platform-specific DOCSIS parameter database None <code>0</code> on success, error codes on failure <code>psm_hal_apis.c</code>"},{"location":"docu/templateOct10/ccsppnm/#key-implementation-logic","title":"Key Implementation Logic","text":"<ul> <li> <p>Configuration State Machine: The core state machine is implemented in <code>psm_sysro_states.c</code> with state transition handlers in <code>psm_sysro_control.c</code>. The system maintains distinct states for initialization, active operation, backup operations, and shutdown sequences</p> </li> <li> <p>XML Processing Engine: Configuration file parsing and generation logic resides in <code>psm_flo_parse.c</code> with support for compressed XML files, parameter validation, and multiple file version management</p> </li> <li> <p>Memory Management: The component uses a sophisticated caching strategy implemented in <code>psm_sysro_storage.c</code> with lazy loading, intelligent cache invalidation, and memory optimization for large configuration datasets</p> </li> <li> <p>Error Handling Strategy: Comprehensive error detection and recovery mechanisms throughout the codebase with automatic fallback to backup configurations, detailed error logging, and graceful degradation capabilities</p> </li> <li>Configuration file corruption detection with automatic rollback</li> <li>IPC connection failure handling with automatic reconnection</li> <li> <p>Memory allocation failure recovery with resource cleanup</p> </li> <li> <p>Logging &amp; Debugging: Multi-level logging system with component-specific trace categories, parameter operation tracing, and debug hooks for troubleshooting configuration issues</p> </li> <li>Parameter access logging with caller identification</li> <li>Configuration file operation tracing</li> <li>Performance monitoring for large parameter operations</li> </ul>"},{"location":"docu/templateOct10/ccsppnm/#key-configuration-files","title":"Key Configuration Files","text":"<p>The CcspPsm component relies on several critical configuration files that define default parameters, runtime behavior, and platform-specific settings. These files are essential for proper component initialization and operation.</p> Configuration File Purpose Key Parameters Default Values Override Mechanisms <code>bbhm_def_cfg_qemu.xml</code> Default system configuration with pre-configured TR-181 parameters <code>Device.WiFi.*</code>, <code>Device.DeviceInfo.*</code>, <code>Device.ManagementServer.*</code> Platform-specific defaults Platform-specific XML files <code>psm_cur_cfg.xml.gz</code> Current active configuration (compressed) All active parameter values Runtime-modified values Direct parameter Set operations <code>psm_bak_cfg.xml.gz</code> Backup configuration for rollback Previous stable configuration Last known good config Automatic backup triggers <code>psm_tmp_cfg.xml.gz</code> Temporary configuration during updates Staging area for configuration changes Transient during operations Automatic cleanup <p>The configuration files use a hierarchical XML structure with parameter records containing name, type, and value attributes. The compression mechanism reduces storage footprint while maintaining fast access through intelligent caching strategies.</p>"},{"location":"docu/templateOct10/gponmanager/","title":"GPON Manager Documentation","text":"<p>GPON Manager is the RDK-B middleware component responsible for managing and controlling GPON interfaces in RDK-B enabled devices. It serves as the primary orchestrator for GPON operations, providing standardized management and monitoring capabilities for fiber optic network connections. The component acts as a bridge between the RDK-B middleware stack and the underlying GPON hardware abstraction layer (HAL), enabling unified management of PON technologies including GPON, XG-PON, NG-PON2, and XGS-PON.</p> <p>The GPON Manager provides essential services to the RDK-B device ecosystem by managing physical media interfaces, optical network termination (ONT) operations, and PON-specific protocols. It enables service providers to remotely configure, monitor, and troubleshoot GPON connections while ensuring compliance with ITU-T G.984 and related PON standards.</p> <pre><code>graph LR\n    subgraph \"External Systems\"\n        ACS[ACS/TR-069 Server]\n        NMS[Network Management System]\n        OLT[Optical Line Terminal]\n    end\n\n    subgraph \"RDK-B Middleware\"\n        WM[WAN Manager]\n        TR069[TR-069 PA]\n        GPON[GPON Manager]\n        PSM[PSM]\n        CCSP[CCSP Common Library]\n    end\n\n    subgraph \"Platform Layer\"\n        HAL[(GPON HAL)]\n        Kernel[(Linux Kernel)]\n        HW[(GPON Hardware)]\n    end\n\n    ACS --&gt;|TR-069/CWMP| TR069\n    NMS --&gt;|SNMP/HTTP| WM\n    TR069 --&gt;|DBus| GPON\n    WM --&gt;|DBus| GPON\n    GPON --&gt;|DBus| PSM\n    GPON --&gt;|JSON RPC| HAL\n    HAL --&gt;|Drivers| Kernel\n    Kernel --&gt;|Device Interface| HW\n    OLT &lt;--&gt;|Optical Signal| HW\n\n    classDef external fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n    classDef middleware fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef platform fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n\n    class ACS,NMS,OLT external;\n    class WM,TR069,GPON,PSM,CCSP middleware;\n    class HAL,Kernel,HW platform;</code></pre> <p>Key Features &amp; Responsibilities: </p> <ul> <li>GPON Interface Management: Manages physical GPON interfaces including status monitoring, configuration, and operational state control for multiple PON technologies (GPON, XG-PON, NG-PON2, XGS-PON)</li> <li>TR-181 Data Model Implementation: Implements comprehensive TR-181 data models for X_RDK_ONT objects including PhysicalMedia, GTC, PLOAM, OMCI, GEM, and VEIP parameters with full read/write access control</li> <li>HAL Abstraction &amp; Integration: Provides JSON-based HAL interface abstraction for vendor-specific GPON implementations, enabling standardized communication between middleware and hardware layers</li> <li>State Machine Management: Orchestrates GPON link state machines for connection establishment, maintenance, and recovery operations with event-driven state transitions</li> <li>Performance Monitoring: Collects and reports GPON performance metrics, optical power levels, and link quality statistics for network optimization and troubleshooting</li> <li>Event-Driven Architecture: Publishes real-time events for GPON state changes, alarms, and performance thresholds to enable responsive network management</li> </ul>"},{"location":"docu/templateOct10/gponmanager/#design","title":"Design","text":"<p>The GPON Manager follows a modular, event-driven architecture designed to provide scalable and maintainable GPON management capabilities. The design emphasizes separation of concerns with distinct layers for TR-181 data model handling, controller logic, and HAL abstraction. The component implements a publisher-subscriber pattern for real-time event handling and maintains persistent state through the PSM component. The architecture supports multiple concurrent GPON interfaces while ensuring thread-safe operations and efficient resource utilization.</p> <p>The design integrates northbound interfaces through DBus messaging for TR-069 PA and WAN Manager interactions, enabling seamless integration with RDK-B middleware components. Southbound integration utilizes a JSON-based RPC mechanism for HAL communication, providing vendor-agnostic hardware abstraction. The component implements comprehensive data persistence through PSM integration for configuration storage and retrieval, ensuring state consistency across system reboots and providing rapid recovery capabilities.</p> <p>The IPC architecture leverages DBus for middleware communication and JSON RPC for HAL interactions, supporting both synchronous and asynchronous messaging patterns. Event publishing utilizes RBus where supported, falling back to DBus for broader compatibility. The design includes robust error handling with graceful degradation, comprehensive logging for debugging, and configurable telemetry reporting for operational visibility.</p> <pre><code>graph TD\n    subgraph \"GPON Manager Process\"\n        subgraph \"SSP Layer\"\n            SSP[SSP Main Process]\n            MsgBus[Message Bus Interface]\n        end\n\n        subgraph \"TR-181 Layer\"\n            DMLPlugin[DML Plugin Main]\n            BackendMgr[Backend Manager]\n            DataModel[Data Model Objects]\n            HALParam[HAL Parameter Handler]\n        end\n\n        subgraph \"Controller Layer\"\n            Controller[GPON Controller]\n            StateMachine[Link State Machine]\n        end\n\n        subgraph \"Data Management\"\n            DataStore[Internal Data Store]\n            ConfigMgr[Configuration Manager]\n        end\n    end\n\n    subgraph \"External Interfaces\"\n        DBusIF[DBus Interface]\n        HALInterface[JSON HAL Interface]\n        PSMInterface[PSM Interface]\n    end\n\n    SSP --&gt; MsgBus\n    MsgBus --&gt; DMLPlugin\n    DMLPlugin --&gt; BackendMgr\n    BackendMgr --&gt; DataModel\n    DataModel --&gt; HALParam\n    HALParam --&gt; Controller\n    Controller --&gt; StateMachine\n    Controller --&gt; DataStore\n    DataStore --&gt; ConfigMgr\n\n    MsgBus &lt;--&gt;|DBus| DBusIF\n    HALParam &lt;--&gt;|JSON RPC| HALInterface\n    ConfigMgr &lt;--&gt;|DBus| PSMInterface\n\n    classDef ssp fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n    classDef tr181 fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef controller fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;\n    classDef data fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n    classDef interface fill:#fce4ec,stroke:#c2185b,stroke-width:2px;\n\n    class SSP,MsgBus ssp;\n    class DMLPlugin,BackendMgr,DataModel,HALParam tr181;\n    class Controller,StateMachine controller;\n    class DataStore,ConfigMgr data;\n    class DBusIF,HALInterface,PSMInterface interface;</code></pre>"},{"location":"docu/templateOct10/gponmanager/#prerequisites-and-dependencies","title":"Prerequisites and Dependencies","text":"<p>MUST Requirements: - RDK-B Common Component Software Platform (CCSP) framework for DBus messaging and component lifecycle management - GPON HAL implementation supporting JSON RPC schema version 0.0.1 or compatible for hardware abstraction - Parameter Storage Manager (PSM) for persistent configuration storage and retrieval capabilities - Linux kernel with GPON device driver support and appropriate device node access permissions - SystemD service management for component lifecycle and dependency resolution</p> <p>SHOULD Requirements: - RBus messaging framework for enhanced event publishing and subscription capabilities - WAN Manager component for integrated interface management and unified WAN orchestration - TR-069 Protocol Adapter for remote management and configuration synchronization - SNMP Protocol Adapter for SNMP-based monitoring and management capabilities - Telemetry component for performance metrics collection and reporting</p> <p>Dependent Components: - WAN Manager relies on GPON Manager for GPON interface status, configuration, and event notifications - TR-069 PA depends on GPON Manager for TR-181 parameter access and modification capabilities - SNMP PA requires GPON Manager for SNMP MIB data population and trap generation - System Health Monitor depends on GPON Manager for interface health status and alarm reporting</p> <p>Threading Model</p> <p>The GPON Manager implements a hybrid threading architecture combining event-driven main thread processing with dedicated worker threads for specific operations. The design ensures thread-safe access to shared resources while maintaining responsive real-time event handling and efficient resource utilization across multiple GPON interfaces.</p> <ul> <li>Threading Architecture: Multi-threaded with event-driven main thread and specialized worker threads</li> <li>Main Thread: Handles DBus message processing, TR-181 parameter operations, event dispatching, and component lifecycle management including initialization and shutdown sequences</li> <li>Worker Threads (created on demand):</li> <li>HAL Communication Thread: Manages JSON RPC communication with GPON HAL, handles asynchronous responses, and processes hardware events with configurable timeout handling</li> <li>State Machine Thread: Executes GPON link state machine transitions, processes optical link events, and manages connection establishment and recovery procedures</li> <li>Telemetry Thread: Collects performance metrics, processes statistical data, and publishes telemetry events at configurable intervals</li> <li>Synchronization: Utilizes pthread mutexes for shared data protection, condition variables for thread coordination, and atomic operations for performance counters</li> </ul>"},{"location":"docu/templateOct10/gponmanager/#component-state-flow","title":"Component State Flow","text":""},{"location":"docu/templateOct10/gponmanager/#initialization-to-active-state","title":"Initialization to Active State","text":"<p>The GPON Manager follows a structured initialization sequence progressing through distinct states from component startup to full operational readiness. The initialization process ensures all dependencies are established, configuration is loaded, and hardware interfaces are properly initialized before entering active service mode.</p> <pre><code>stateDiagram-v2\n    [*] --&gt; Initializing\n    Initializing --&gt; LoadingConfig: Load Configuration Files\n    LoadingConfig --&gt; RegisteringTR181: Configuration Validated\n    RegisteringTR181 --&gt; ConnectingHAL: TR-181 Parameters Registered\n    ConnectingHAL --&gt; InitializingHW: HAL Connection Established\n    InitializingHW --&gt; Active: Hardware Initialized\n    Active --&gt; ProcessingEvents: Event Received\n    ProcessingEvents --&gt; Active: Event Processed\n    Active --&gt; UpdatingConfig: Configuration Change\n    UpdatingConfig --&gt; Active: Config Applied\n    Active --&gt; ErrorState: Critical Error\n    ErrorState --&gt; Recovering: Recovery Initiated\n    Recovering --&gt; Active: Recovery Successful\n    Recovering --&gt; [*]: Recovery Failed\n    Active --&gt; Shutdown: Stop Request\n    Shutdown --&gt; [*]\n\n    note right of Initializing\n        - Initialize logging subsystem\n        - Allocate memory resources\n        - Setup DBus connections\n        - Initialize mutexes and conditions\n    end note\n\n    note right of Active\n        - Process TR-181 requests\n        - Handle HAL events\n        - Monitor interface status\n        - Publish state changes\n    end note\n\n    note right of ErrorState\n        - Log critical errors\n        - Attempt graceful recovery\n        - Notify dependent components\n        - Preserve configuration state\n    end note</code></pre>"},{"location":"docu/templateOct10/gponmanager/#runtime-state-changes-and-context-switching","title":"Runtime State Changes and Context Switching","text":"<p>During normal operation, the GPON Manager responds to various triggers that initiate state changes affecting GPON interface management, configuration updates, and operational mode transitions. These state changes ensure the component adapts to network conditions, hardware events, and administrative commands while maintaining service continuity.</p> <p>State Change Triggers: - Hardware Events: Optical signal detection, loss of signal (LOS), loss of frame (LOF), and transceiver insertion/removal events trigger interface state updates and recovery procedures - Configuration Updates: TR-181 parameter modifications, PSM configuration changes, and administrative enable/disable commands initiate configuration validation and application sequences - Network Events: OLT registration status changes, PLOAM message reception, and OMCI communication events trigger protocol state machine transitions - Performance Thresholds: Optical power level violations, bit error rate thresholds, and performance monitoring alerts trigger alarm generation and notification procedures</p> <p>Context Switching Scenarios: - Interface Mode Changes: Switching between GPON, XG-PON, NG-PON2, and XGS-PON modes requires hardware reconfiguration and state machine reinitialization - Redundancy Failover: Active/standby interface transitions for redundant GPON configurations with seamless service transfer - Maintenance Mode: Transitioning to maintenance mode for firmware updates, calibration procedures, and diagnostic operations while preserving service state</p>"},{"location":"docu/templateOct10/gponmanager/#call-flow","title":"Call Flow","text":""},{"location":"docu/templateOct10/gponmanager/#primary-call-flows","title":"Primary Call Flows","text":"<p>Initialization Call Flow:</p> <pre><code>sequenceDiagram\n    participant SystemD as SystemD\n    participant GPON as GPON Manager\n    participant CCSP as CCSP Framework\n    participant PSM as PSM\n    participant HAL as GPON HAL\n\n    SystemD-&gt;&gt;GPON: Start Service\n    GPON-&gt;&gt;GPON: Initialize Logging &amp; Resources\n    GPON-&gt;&gt;CCSP: Register Component\n    CCSP--&gt;&gt;GPON: Registration Complete\n    GPON-&gt;&gt;PSM: Load Configuration\n    PSM--&gt;&gt;GPON: Configuration Data\n    GPON-&gt;&gt;HAL: Initialize HAL Interface\n    HAL--&gt;&gt;GPON: HAL Ready\n    GPON-&gt;&gt;CCSP: Register TR-181 Parameters\n    CCSP--&gt;&gt;GPON: Parameter Registration Complete\n    GPON-&gt;&gt;SystemD: Service Ready (Active State)</code></pre> <p>TR-181 Parameter Get Request Call Flow:</p> <pre><code>sequenceDiagram\n    participant TR069 as TR-069 PA\n    participant GPON as GPON Manager\n    participant DataModel as Data Model Layer\n    participant HAL as GPON HAL\n\n    TR069-&gt;&gt;GPON: DBus Get Parameter Request\n    GPON-&gt;&gt;DataModel: Validate Parameter Path\n    DataModel-&gt;&gt;HAL: JSON RPC Get Request\n    HAL--&gt;&gt;DataModel: JSON Response with Value\n    DataModel--&gt;&gt;GPON: Formatted Parameter Value\n    GPON--&gt;&gt;TR069: DBus Response with Value</code></pre> <p>GPON Link State Change Event Flow:</p> <pre><code>sequenceDiagram\n    participant HW as GPON Hardware\n    participant HAL as GPON HAL\n    participant GPON as GPON Manager\n    participant StateMachine as State Machine\n    participant WM as WAN Manager\n\n    HW-&gt;&gt;HAL: Optical Signal Event\n    HAL-&gt;&gt;GPON: JSON Event Notification\n    GPON-&gt;&gt;StateMachine: Process State Change\n    StateMachine-&gt;&gt;StateMachine: Update Link State\n    StateMachine-&gt;&gt;GPON: State Transition Complete\n    GPON-&gt;&gt;WM: DBus Interface Status Event\n    GPON-&gt;&gt;GPON: Update TR-181 Parameters</code></pre>"},{"location":"docu/templateOct10/gponmanager/#tr181-data-models","title":"TR\u2011181 Data Models","text":""},{"location":"docu/templateOct10/gponmanager/#supported-tr-181-parameters","title":"Supported TR-181 Parameters","text":"<p>The GPON Manager implements comprehensive TR-181 data models following BBF specification guidelines for X_RDK_ONT objects. The implementation provides standardized access to GPON interface parameters, optical network termination settings, and performance monitoring data through a hierarchical object structure that supports dynamic instance creation and management.</p>"},{"location":"docu/templateOct10/gponmanager/#object-hierarchy","title":"Object Hierarchy","text":"<pre><code>Device.\n\u2514\u2500\u2500 X_RDK_ONT.\n    \u251c\u2500\u2500 PhysicalMedia.{i}.\n    \u2502   \u251c\u2500\u2500 Enable (boolean, R/W)\n    \u2502   \u251c\u2500\u2500 Status (string, R)\n    \u2502   \u251c\u2500\u2500 Cage (string, R)\n    \u2502   \u251c\u2500\u2500 ModuleVendor (string, R)\n    \u2502   \u251c\u2500\u2500 ModuleName (string, R)\n    \u2502   \u251c\u2500\u2500 PonMode (string, R)\n    \u2502   \u251c\u2500\u2500 Connector (string, R)\n    \u2502   \u251c\u2500\u2500 NominalBitRateDownstream (uint32, R)\n    \u2502   \u251c\u2500\u2500 NominalBitRateUpstream (uint32, R)\n    \u2502   \u2514\u2500\u2500 RedundancyState (string, R)\n    \u251c\u2500\u2500 Gtc.\n    \u2502   \u251c\u2500\u2500 Enable (boolean, R/W)\n    \u2502   \u251c\u2500\u2500 Status (string, R)\n    \u2502   \u251c\u2500\u2500 BerInterval (uint32, R/W)\n    \u2502   \u2514\u2500\u2500 MissedKeepAliveMessages (uint32, R)\n    \u251c\u2500\u2500 Ploam.\n    \u2502   \u251c\u2500\u2500 Enable (boolean, R/W)\n    \u2502   \u251c\u2500\u2500 Status (string, R)\n    \u2502   \u2514\u2500\u2500 MicReceivedSuccessfully (uint32, R)\n    \u251c\u2500\u2500 Omci.\n    \u2502   \u251c\u2500\u2500 Enable (boolean, R/W)\n    \u2502   \u251c\u2500\u2500 Status (string, R)\n    \u2502   \u2514\u2500\u2500 IgnoreStdOmciFunction (boolean, R/W)\n    \u251c\u2500\u2500 Gem.{i}.\n    \u2502   \u251c\u2500\u2500 Enable (boolean, R/W)\n    \u2502   \u251c\u2500\u2500 Status (string, R)\n    \u2502   \u251c\u2500\u2500 GemPortId (uint32, R/W)\n    \u2502   \u251c\u2500\u2500 Direction (string, R/W)\n    \u2502   \u2514\u2500\u2500 TrafficType (string, R/W)\n    \u2514\u2500\u2500 Veip.{i}.\n        \u251c\u2500\u2500 Enable (boolean, R/W)\n        \u251c\u2500\u2500 Status (string, R)\n        \u251c\u2500\u2500 VeipId (uint32, R/W)\n        \u2514\u2500\u2500 AdminState (string, R/W)\n</code></pre>"},{"location":"docu/templateOct10/gponmanager/#parameter-definitions","title":"Parameter Definitions","text":"<p>Core Parameters:</p> Parameter Path Data Type Access Default Value Description BBF Compliance <code>Device.X_RDK_ONT.PhysicalMedia.{i}.Enable</code> boolean R/W <code>true</code> Enable or disable the GPON physical media interface. When disabled, the interface is administratively down and does not participate in GPON operations. Custom Extension <code>Device.X_RDK_ONT.PhysicalMedia.{i}.Status</code> string R <code>\"Down\"</code> Current operational status of the physical media interface. Enumerated values: Up(0), Down(1), Unknown(2), Dormant(3), NotPresent(4), LowerLayerDown(5), Error(6) Custom Extension <code>Device.X_RDK_ONT.PhysicalMedia.{i}.Cage</code> string R <code>\"BoB\"</code> Type of physical cage housing the optical module. Enumerated values: BoB(0) for Board-on-Board, SFP(1) for Small Form-factor Pluggable Custom Extension <code>Device.X_RDK_ONT.PhysicalMedia.{i}.PonMode</code> string R <code>\"GPON\"</code> PON technology mode supported by the interface. Enumerated values: GPON(0), XG-PON(1), NG-PON2(2), XGS-PON2(3) Custom Extension <code>Device.X_RDK_ONT.PhysicalMedia.{i}.NominalBitRateDownstream</code> uint32 R <code>2488320</code> Nominal downstream bit rate in kbps supported by the PON interface based on the configured PON mode Custom Extension <code>Device.X_RDK_ONT.PhysicalMedia.{i}.NominalBitRateUpstream</code> uint32 R <code>1244160</code> Nominal upstream bit rate in kbps supported by the PON interface based on the configured PON mode Custom Extension <code>Device.X_RDK_ONT.Gtc.Enable</code> boolean R/W <code>true</code> Enable or disable GPON Transmission Convergence (GTC) layer functionality for frame processing and bandwidth allocation Custom Extension <code>Device.X_RDK_ONT.Gtc.Status</code> string R <code>\"Disabled\"</code> Current operational status of the GTC layer. Values: Disabled, Enabled, Error indicate the functional state of GTC processing Custom Extension <code>Device.X_RDK_ONT.Ploam.Enable</code> boolean R/W <code>true</code> Enable or disable Physical Layer Operations, Administration and Maintenance (PLOAM) message processing for OLT communication Custom Extension <code>Device.X_RDK_ONT.Omci.Enable</code> boolean R/W <code>true</code> Enable or disable ONT Management and Control Interface (OMCI) for service provisioning and configuration management Custom Extension <p>Custom Extensions:</p> <ul> <li>X_RDK_ONT Object Tree: Complete custom extension providing comprehensive GPON management capabilities not defined in standard BBF TR-181 specifications</li> <li>Physical Media Dynamic Table: Supports multiple GPON interfaces with dynamic instance creation for multi-port ONT devices</li> <li>GEM Port Management: Custom parameters for GPON Encapsulation Method (GEM) port configuration and traffic management</li> <li>VEIP Interface Control: Virtual Ethernet Interface Point parameters for Ethernet service mapping and control</li> </ul>"},{"location":"docu/templateOct10/gponmanager/#parameter-registration-and-access","title":"Parameter Registration and Access","text":"<ul> <li>Implemented Parameters: The GPON Manager implements over 50 TR-181 parameters across 6 major object categories, providing comprehensive coverage of GPON interface management, protocol control, and performance monitoring capabilities</li> <li>Parameter Registration: Parameters are registered through the CCSP DML framework using DBus messaging for component discovery and parameter tree publication to enable remote access</li> <li>Access Mechanism: Other RDK-B components access parameters via DBus method calls with standardized get/set operations, parameter validation, and atomic transaction support for configuration changes</li> <li>Validation Rules: Parameter values undergo strict validation including range checking for numeric values, enumeration validation for string parameters, and dependency checking for inter-parameter relationships</li> </ul>"},{"location":"docu/templateOct10/gponmanager/#internal-modules","title":"Internal Modules","text":"<p>The GPON Manager is structured as a modular component with clear separation of concerns across multiple functional layers. Each module has specific responsibilities and well-defined interfaces, enabling maintainable code organization and efficient resource utilization while supporting concurrent operations across multiple GPON interfaces.</p> Module/Class Description Key Files SSP Main Process Core service startup and lifecycle management including initialization, shutdown, and process control <code>ssp_main.c</code>, <code>ssp_global.h</code>, <code>ssp_internal.h</code> Message Bus Interface DBus communication handler for inter-component messaging and TR-181 parameter access <code>ssp_messagebus_interface.c</code>, <code>ssp_messagebus_interface.h</code> DML Plugin Main TR-181 data model plugin entry point and parameter tree registration <code>gponmgr_dml_plugin_main.c</code>, <code>gponmgr_dml_plugin_main.h</code> Backend Manager Central coordinator for data model operations and HAL interaction <code>gponmgr_dml_backendmgr.c</code>, <code>gponmgr_dml_backendmgr.h</code> Data Model Objects TR-181 object implementations for PhysicalMedia, GTC, PLOAM, OMCI, GEM, and VEIP <code>gponmgr_dml_obj.c</code>, <code>gponmgr_dml_obj.h</code> HAL Parameter Handler JSON RPC interface for GPON HAL communication and parameter translation <code>gponmgr_dml_hal_param.c</code>, <code>gponmgr_dml_hal.c</code> GPON Controller Main control logic for GPON operations and state management <code>gponmgr_controller.c</code>, <code>gponmgr_controller.h</code> Link State Machine State machine engine for GPON link establishment and maintenance <code>gponmgr_link_state_machine.c</code>, <code>gponmgr_link_state_machine.h</code> Data Management Internal data structures and caching for GPON interface information <code>gponmgr_dml_data.c</code>, <code>gponmgr_dml_data.h</code> <pre><code>flowchart LR\n    subgraph GPON_Manager[\"GPON Manager Process\"]\n        SSP([SSP Main Process])\n        MsgBus([Message Bus Interface])\n        DMLPlugin([DML Plugin Main])\n        BackendMgr([Backend Manager])\n        DataObjects([Data Model Objects])\n        HALHandler([HAL Parameter Handler])\n        Controller([GPON Controller])\n        StateMachine([Link State Machine])\n        DataMgmt([Data Management])\n    end\n\n    SSP --&gt; MsgBus\n    MsgBus --&gt; DMLPlugin\n    DMLPlugin --&gt; BackendMgr\n    BackendMgr --&gt; DataObjects\n    DataObjects --&gt; HALHandler\n    HALHandler --&gt; Controller\n    Controller --&gt; StateMachine\n    Controller --&gt; DataMgmt\n    DataMgmt --&gt; DataObjects\n\n    classDef core fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef tr181 fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;\n    classDef control fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n\n    class SSP,MsgBus core;\n    class DMLPlugin,BackendMgr,DataObjects,HALHandler tr181;\n    class Controller,StateMachine,DataMgmt control;</code></pre>"},{"location":"docu/templateOct10/gponmanager/#component-interactions","title":"Component Interactions","text":""},{"location":"docu/templateOct10/gponmanager/#middleware-components-system-layers","title":"Middleware Components &amp; System Layers","text":"<p>The GPON Manager integrates with multiple RDK-B middleware components and system layers to provide comprehensive GPON management capabilities. The component serves as a central orchestrator for GPON operations while maintaining standardized interfaces for configuration management, performance monitoring, and event notification across the RDK-B ecosystem.</p> <pre><code>flowchart LR\n    subgraph \"External Services\"\n        ACS[ACS/TR-069 Server]\n        NMS[Network Management System]\n        OLT[Optical Line Terminal]\n    end\n\n    subgraph \"Middleware Layer\"\n        GPON[GPON Manager]\n        WM[WAN Manager]\n        TR069[TR-069 PA]\n        SNMP[SNMP PA]\n        PSM[PSM]\n        TM[Telemetry]\n    end\n\n    subgraph \"HAL/Platform Layer\"\n        HAL[(GPON HAL)]\n        Platform[(Platform Services)]\n        Kernel[(Linux Kernel)]\n    end\n\n    GPON --&gt;|DBus/TR-181| TR069\n    GPON --&gt;|DBus Events| WM\n    GPON --&gt;|DBus MIB Data| SNMP\n    GPON --&gt;|DBus Config| PSM\n    GPON --&gt;|RBus Metrics| TM\n    GPON --&gt;|JSON RPC| HAL\n    HAL --&gt;|Device Drivers| Platform\n    Platform --&gt;|System Calls| Kernel\n\n    ACS --&gt;|CWMP| TR069\n    NMS --&gt;|SNMP| SNMP\n    OLT &lt;--&gt;|Optical Protocol| HAL\n\n    classDef external fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n    classDef middleware fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef platform fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n\n    class ACS,NMS,OLT external;\n    class GPON,WM,TR069,SNMP,PSM,TM middleware;\n    class HAL,Platform,Kernel platform;</code></pre> <p>Component Interactions:</p> Component/Layer Purpose of Interaction Protocols/Mechanisms Middleware Components WAN Manager Interface status reporting, configuration coordination, and WAN connection management DBus events, parameter notifications TR-069 PA Remote parameter management, configuration updates, and device provisioning DBus method calls, TR-181 parameter access SNMP PA SNMP MIB data population, performance counter access, and trap generation DBus data requests, structured parameter queries PSM Persistent configuration storage, default parameter values, and configuration recovery DBus parameter storage/retrieval operations Telemetry Performance metrics collection, operational statistics, and monitoring data RBus telemetry events, JSON data structures System Layers GPON HAL Hardware abstraction, vendor-specific operations, and low-level GPON control JSON RPC over Unix domain sockets Platform Services System logging, resource management, and service coordination Standard system APIs, file system operations External Services ACS/TR-069 Server Remote device management, configuration provisioning, and firmware management CWMP over HTTP/HTTPS via TR-069 PA OLT GPON protocol communication, optical signal management, and service provisioning ITU-T G.984 GPON protocols via HAL <p>Published Events:</p> <p>The GPON Manager publishes several key events that other components can subscribe to for coordination and monitoring purposes:</p> Event Purpose of Event Reason for Trigger GPON_INTERFACE_STATUS_CHANGE Interface operational status updates Physical layer state changes, optical signal detection/loss, administrative enable/disable GPON_LINK_ESTABLISHED GPON link establishment notification Successful OLT registration, PLOAM messaging establishment, OMCI communication ready GPON_ALARM_GENERATED Critical alarm and threshold notifications Optical power violations, bit error rate thresholds, hardware failures GPON_PERFORMANCE_UPDATE Performance monitoring data updates Periodic statistics collection, performance counter updates, quality metrics"},{"location":"docu/templateOct10/gponmanager/#ipc-mechanism","title":"IPC Mechanism","text":"<p>The GPON Manager implements a hybrid IPC architecture utilizing multiple communication mechanisms optimized for different interaction patterns and performance requirements. The design ensures reliable communication with middleware components while providing efficient hardware abstraction for vendor-specific GPON implementations.</p> Type of IPC Message Format Mechanism DBus Method Calls Structured parameter objects with type safety, error codes, and transaction IDs for TR-181 operations DBus with CCSP framework integration for component discovery and parameter tree management JSON RPC over Unix Sockets JSON-structured messages conforming to GPON HAL schema v0.0.1 with request/response correlation and event notifications Unix domain sockets with configurable timeout and retry mechanisms RBus Event Publishing JSON telemetry objects with timestamp, source identification, and structured performance data RBus messaging framework for high-performance event distribution Configuration Storage Key-value pairs with namespace isolation, atomic transactions, and backup/restore capabilities DBus communication with PSM for persistent storage operations <pre><code>sequenceDiagram\n    participant WM as WAN Manager\n    participant GPON as GPON Manager\n    participant HAL as GPON HAL\n    participant PSM as PSM\n\n    Note over WM,PSM: TR-181 Parameter Get Operation\n    WM-&gt;&gt;GPON: DBus GetParameterValues(X_RDK_ONT.PhysicalMedia.1.Status)\n    GPON-&gt;&gt;HAL: JSON RPC {\"action\":\"getParameters\",\"params\":{\"name\":\"PhysicalMedia.Status\"}}\n    HAL--&gt;&gt;GPON: JSON Response {\"result\":{\"value\":\"Up\",\"type\":\"string\"}}\n    GPON--&gt;&gt;WM: DBus Response with validated parameter value\n\n    Note over WM,PSM: Configuration Update Flow\n    WM-&gt;&gt;GPON: DBus SetParameterValues(X_RDK_ONT.PhysicalMedia.1.Enable=false)\n    GPON-&gt;&gt;HAL: JSON RPC {\"action\":\"setParameters\",\"params\":{\"name\":\"PhysicalMedia.Enable\",\"value\":false}}\n    HAL--&gt;&gt;GPON: JSON Response {\"result\":{\"Status\":\"Success\"}}\n    GPON-&gt;&gt;PSM: DBus Store Configuration\n    PSM--&gt;&gt;GPON: Storage Confirmation\n    GPON--&gt;&gt;WM: DBus SetParameterValues Response\n\n    Note over WM,PSM: Event Notification Flow\n    HAL-&gt;&gt;GPON: JSON Event {\"action\":\"publishEvent\",\"event\":\"LinkStatusChange\",\"data\":{\"status\":\"Down\"}}\n    GPON-&gt;&gt;GPON: Update Internal State\n    GPON-&gt;&gt;WM: DBus Event Notification\n    GPON-&gt;&gt;PSM: Update Persistent State</code></pre>"},{"location":"docu/templateOct10/gponmanager/#implementation-details","title":"Implementation Details","text":""},{"location":"docu/templateOct10/gponmanager/#major-hal-apis-integration","title":"Major HAL APIs Integration","text":"<p>The GPON Manager integrates with the GPON HAL through a comprehensive JSON RPC interface that provides vendor-agnostic access to GPON hardware functionality. The HAL integration supports multiple concurrent operations, asynchronous event handling, and robust error recovery mechanisms to ensure reliable hardware abstraction across different vendor implementations.</p> <p>Core HAL APIs:</p> HAL API Purpose Parameters Return Values Implementation File <code>getParameters</code> Retrieve GPON hardware parameters and status information Parameter name, instance identifier, data type specification JSON object with parameter value, type, and validation status <code>gponmgr_dml_hal_param.c</code> <code>setParameters</code> Configure GPON hardware settings and operational parameters Parameter name, value, type, validation flags Success/failure status with error details and rollback information <code>gponmgr_dml_hal_param.c</code> <code>subscribeEvent</code> Register for hardware event notifications and state changes Event name, notification type, callback configuration Subscription handle and confirmation status <code>gponmgr_dml_hal.c</code> <code>publishEvent</code> Receive asynchronous hardware events and alarm notifications Event data, timestamp, severity level, source identification Event processing acknowledgment <code>gponmgr_dml_hal.c</code> <code>getSchema</code> Retrieve HAL schema version and supported parameter definitions Schema version request, parameter category filter Schema file path and version compatibility information <code>gponmgr_dml_hal.c</code>"},{"location":"docu/templateOct10/gponmanager/#key-implementation-logic","title":"Key Implementation Logic","text":"<ul> <li>State Machine Engine: The core state machine implementation provides deterministic GPON link management with configurable timeout handling and automatic recovery procedures</li> <li>Main implementation in <code>gponmgr_link_state_machine.c</code> with event-driven state transitions and comprehensive error handling</li> <li> <p>State transition handlers in <code>gponmgr_controller.c</code> with validation logic and rollback capabilities for failed operations</p> </li> <li> <p>Event Processing: Hardware events are processed through an asynchronous event queue with priority-based scheduling and guaranteed delivery mechanisms</p> </li> <li>Hardware interrupt handling through HAL event subscription with configurable timeout and retry parameters</li> <li>Event queue management with circular buffer implementation and overflow protection mechanisms</li> <li> <p>Asynchronous event processing with worker thread pool and load balancing for optimal performance</p> </li> <li> <p>Error Handling Strategy: Comprehensive error detection and recovery mechanisms ensure system stability and service continuity during hardware failures and network disruptions</p> </li> <li>HAL error code mapping with vendor-specific error translation and standardized error reporting</li> <li>Recovery mechanisms for failed transitions including automatic retry with exponential backoff and manual intervention triggers</li> <li> <p>Timeout handling and retry logic with configurable parameters and escalation procedures for persistent failures</p> </li> <li> <p>Logging &amp; Debugging: Multi-level logging system provides comprehensive visibility into GPON operations with configurable verbosity and filtering capabilities</p> </li> <li>State transition logging with detailed parameter tracking and performance measurement</li> <li>HAL API call tracing with request/response correlation and timing analysis</li> <li>Debug hooks for troubleshooting connectivity issues including packet capture and protocol analysis tools</li> </ul>"},{"location":"docu/templateOct10/gponmanager/#key-configuration-files","title":"Key Configuration Files","text":"<p>The GPON Manager utilizes several configuration files that control component behavior, HAL integration parameters, and TR-181 data model definitions. These files enable flexible deployment across different hardware platforms while maintaining standardized operational interfaces.</p> Configuration File Purpose Key Parameters Default Values Override Mechanisms <code>gpon_manager_conf.json</code> Main component configuration for HAL integration and service parameters <code>hal_schema_path</code>, <code>server_port</code> <code>/etc/rdk/schemas/gpon_hal_schema.json</code>, <code>40100</code> Environment variables, command line arguments <code>gpon_manager_wan_unify_conf.json</code> WAN Manager integration configuration for unified interface management <code>wan_unify_enabled</code>, <code>interface_priority</code> <code>true</code>, <code>1</code> PSM parameter override, runtime configuration <code>RdkGponManager.xml</code> TR-181 data model definitions and parameter specifications Object hierarchy, parameter types, access permissions, function bindings See XML specification Compile-time conditional compilation flags <code>gpon_hal_schema.json</code> HAL interface schema definition and validation rules Parameter definitions, data types, validation constraints Version 0.0.1 schema HAL vendor-specific schema extensions <code>gpon_wan_unify_hal_schema.json</code> Unified WAN HAL schema for integrated WAN management Extended parameter set, unified operations Enhanced schema with WAN unification support WAN Manager configuration integration"},{"location":"docu/templateOct10/onewifi/","title":"OneWifi Documentation","text":"<p>OneWifi is a unified software architecture for managing Wi-Fi parameters, statistics, telemetry, steering and optimization, capable of running on both Gateways and Extenders. It provides a centralized Wi-Fi management solution within the RDK-B middleware stack that abstracts Wi-Fi hardware complexities and delivers consistent Wi-Fi functionality across different platforms and device types.</p> <p>The component serves as the primary interface between RDK-B middleware layers and Wi-Fi hardware abstraction layers (HAL), enabling standardized Wi-Fi configuration, monitoring, and control. It consolidates various Wi-Fi management functionalities that were previously distributed across multiple components, providing a unified approach to Wi-Fi operations in RDK-B devices.</p> <pre><code>graph TD\n    subgraph \"External Systems\"\n        WebUI[WebUI/Management Portal]\n        Cloud[Cloud Management Server]\n        TR069[TR-069 ACS Server]\n        MeshNodes[Mesh Extender Nodes]\n    end\n\n    subgraph \"RDK-B Middleware\"\n        OneWifi[OneWifi]\n        TR181[TR-181 Data Model]\n        WebConfig[WebConfig Service]\n        Telemetry[Telemetry Service]\n        PSM[Persistent Storage Manager]\n    end\n\n    subgraph \"Platform Layer\"\n        WiFiHAL[WiFi HAL]\n        NetworkHAL[Network HAL]\n        Platform[Platform Services]\n    end\n\n    subgraph \"Hardware Layer\"\n        WiFiChips[WiFi Radio Hardware]\n        NetworkIf[Network Interfaces]\n    end\n\n    WebUI --&gt;|HTTP/HTTPS| OneWifi\n    Cloud --&gt;|WebConfig/JSON| WebConfig\n    TR069 --&gt;|TR-181 Parameters| TR181\n    MeshNodes --&gt;|EasyMesh Protocol| OneWifi\n\n    OneWifi --&gt;|RBus/DBus| TR181\n    OneWifi --&gt;|RBus Events| Telemetry\n    OneWifi --&gt;|RBus Parameters| PSM\n    OneWifi --&gt;|JSON Config| WebConfig\n\n    OneWifi --&gt;|HAL API Calls| WiFiHAL\n    OneWifi --&gt;|HAL API Calls| NetworkHAL\n    OneWifi --&gt;|System Calls| Platform\n\n    WiFiHAL --&gt;|Device Drivers| WiFiChips\n    NetworkHAL --&gt;|Kernel APIs| NetworkIf\n\n    classDef external fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n    classDef middleware fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef platform fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n    classDef hardware fill:#fce4ec,stroke:#c2185b,stroke-width:2px;\n\n    class WebUI,Cloud,TR069,MeshNodes external;\n    class OneWifi,TR181,WebConfig,Telemetry,PSM middleware;\n    class WiFiHAL,NetworkHAL,Platform platform;\n    class WiFiChips,NetworkIf hardware;</code></pre> <p>Key Features &amp; Responsibilities: </p> <ul> <li>Unified Wi-Fi Management: Centralized management of all Wi-Fi related operations including radio configuration, access point management, station management, and security policies across multiple radio interfaces</li> <li>TR-181 Parameter Management: Complete implementation of Wi-Fi related TR-181 data model parameters providing standardized configuration and monitoring interfaces for external management systems</li> <li>Multi-Platform Support: Platform abstraction layer supporting multiple hardware platforms (Linux, OpenWrt, RDKB) with consistent API interfaces regardless of underlying hardware implementation</li> <li>WebConfig Integration: Native support for WebConfig-based bulk configuration updates enabling efficient configuration synchronization with cloud management systems</li> <li>EasyMesh Support: Comprehensive IEEE 1905.1 EasyMesh controller and agent functionality for seamless mesh networking across multiple devices and vendors</li> <li>Advanced Statistics &amp; Telemetry: Real-time Wi-Fi performance monitoring, client statistics collection, and telemetry data generation for network optimization and troubleshooting</li> <li>Band Steering &amp; Optimization: Intelligent client steering algorithms, load balancing, and radio resource optimization to maximize network performance and user experience</li> </ul>"},{"location":"docu/templateOct10/onewifi/#design","title":"Design","text":"<p>OneWifi employs a layered architectural design that separates Wi-Fi management concerns into distinct functional layers while maintaining platform independence through abstraction interfaces. The core design principle centers around a unified Wi-Fi manager that coordinates all Wi-Fi operations through a centralized state machine, ensuring consistent behavior across different hardware platforms and deployment scenarios. The architecture follows a service-oriented approach where each major Wi-Fi functionality is encapsulated as a distinct service module that can operate independently while coordinating through the central manager.</p> <p>The northbound interfaces are designed to support multiple IPC mechanisms including RBus (preferred) and DBus for legacy compatibility, enabling seamless integration with other RDK-B middleware components and external management systems. The southbound interfaces utilize platform-specific HAL APIs that abstract hardware differences, allowing the same OneWifi codebase to operate across different Wi-Fi chipsets and platforms. Data persistence is achieved through integration with the Platform Storage Manager (PSM) component for configuration data, while runtime state and statistics are maintained in optimized in-memory structures with selective persistence based on criticality.</p> <p>The IPC mechanism design supports both synchronous and asynchronous communication patterns, with RBus providing the primary message bus for parameter access, event notifications, and method invocations. Event-driven architecture ensures responsive handling of hardware events, configuration changes, and external requests while maintaining system stability through comprehensive error handling and recovery mechanisms.</p> <p>A Component diagram showing the component's internal structure and dependencies is given below:</p> <pre><code>graph TD\n    subgraph OneWifiContainer [\"OneWifi Manager (C/C++)\"]\n        subgraph CoreModule [\"Core Management Layer\"]\n            WifiMgr[WiFi Manager]\n            StateEngine[State Machine Engine]\n            EventHandler[Event Handler]\n        end\n\n        subgraph ServiceModules [\"Service Layer\"]\n            ConfigMgmt[Configuration Management]\n            StatsMgmt[Statistics Management] \n            SecurityMgmt[Security Management]\n            MeshMgmt[EasyMesh Management]\n            ClientMgmt[Client Management]\n        end\n\n        subgraph DataLayer [\"Data Management Layer\"]\n            TR181Impl[TR-181 Implementation]\n            WebConfigImpl[WebConfig Handler]\n            DataStore[Runtime Data Store]\n        end\n\n        subgraph PlatformLayer [\"Platform Abstraction Layer\"]\n            BusInterface[Bus Interface RBus/DBus]\n            HALInterface[HAL Interface Layer]\n            PlatformAPI[Platform API Layer]\n        end\n    end\n\n    subgraph ExternalComponents [\"External RDK-B Components\"]\n        PSMComp[(PSM Component)]\n        TelemetryComp[Telemetry Component]\n        WebConfigComp[WebConfig Component]\n        TR069Comp[TR-069 PA Component]\n    end\n\n    subgraph HALLayer [\"Hardware Abstraction Layer\"]\n        WiFiHAL[(WiFi HAL)]\n        NetworkHAL[(Network HAL)]\n    end\n\n    WifiMgr --&gt;|Controls| StateEngine\n    WifiMgr --&gt;|Coordinates| ServiceModules\n    StateEngine --&gt;|Events| EventHandler\n    ServiceModules --&gt;|Data Access| DataLayer\n    DataLayer --&gt;|IPC Calls| BusInterface\n    PlatformLayer --&gt;|HAL Calls| HALLayer\n    BusInterface --&gt;|RBus/DBus| ExternalComponents\n    HALInterface --&gt;|API Calls| WiFiHAL\n    HALInterface --&gt;|API Calls| NetworkHAL\n\n    classDef core fill:#e3f2fd,stroke:#1976d2,stroke-width:2px;\n    classDef service fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;\n    classDef data fill:#e8f5e8,stroke:#388e3c,stroke-width:2px;\n    classDef platform fill:#fff3e0,stroke:#f57c00,stroke-width:2px;\n    classDef external fill:#ffebee,stroke:#d32f2f,stroke-width:2px;\n    classDef hal fill:#fafafa,stroke:#616161,stroke-width:2px;\n\n    class WifiMgr,StateEngine,EventHandler core;\n    class ConfigMgmt,StatsMgmt,SecurityMgmt,MeshMgmt,ClientMgmt service;\n    class TR181Impl,WebConfigImpl,DataStore data;\n    class BusInterface,HALInterface,PlatformAPI platform;\n    class PSMComp,TelemetryComp,WebConfigComp,TR069Comp external;\n    class WiFiHAL,NetworkHAL hal;</code></pre>"},{"location":"docu/templateOct10/onewifi/#prerequisites-and-dependencies","title":"Prerequisites and Dependencies","text":"<p>MUST Requirements: - RBus message bus framework (v1.0+) for inter-process communication with RDK-B components - WiFi HAL implementation (platform-specific) providing standardized Wi-Fi hardware abstraction APIs - PSM (Persistent Storage Manager) component for configuration data persistence and retrieval - CcspCommonLibrary for CCSP framework integration and common utility functions - Platform-specific build toolchain (GCC 7.0+ or compatible compiler with C99/C++11 support) - Linux kernel with cfg80211/nl80211 wireless subsystem support or equivalent platform wireless APIs</p> <p>SHOULD Requirements: - Telemetry component for performance metrics collection and reporting - WebConfig service for bulk configuration management and cloud synchronization - TR-069 PA component for TR-181 parameter access via ACS management - EasyMesh HAL extensions for advanced mesh networking capabilities (IEEE 1905.1 compliance) - OVSDB (Open vSwitch Database) for advanced network virtualization features</p> <p>Dependent Components: - CcspWifiAgent (legacy) - OneWifi serves as the modernized replacement providing enhanced functionality - Mesh Agent components - depend on OneWifi's EasyMesh implementation for mesh coordination - Network Manager components - rely on OneWifi for Wi-Fi interface status and configuration - Captive Portal services - depend on OneWifi for access point and client management - Parental Control services - utilize OneWifi's client management and filtering capabilities</p> <p>Threading Model</p> <p>OneWifi employs a hybrid multi-threaded architecture designed to handle concurrent Wi-Fi operations while maintaining system responsiveness and data consistency. The threading model separates concerns between different operational domains to prevent blocking operations from affecting critical real-time functions.</p> <ul> <li>Threading Architecture: Multi-threaded with specialized thread pools for different operational contexts</li> <li>Main Thread: Handles initialization, configuration management, state machine coordination, and primary event processing loop. Manages the central Wi-Fi manager state and coordinates between service modules</li> <li>Worker Threads:</li> <li>HAL Interface Thread: Dedicated thread for all HAL API calls to prevent blocking main operations during hardware interactions</li> <li>Statistics Collection Thread: Periodic statistics gathering from hardware and client monitoring with configurable collection intervals</li> <li>Event Processing Thread: Asynchronous event handling for hardware notifications, client connect/disconnect events, and external trigger processing</li> <li>WebConfig Processing Thread: Background processing of configuration updates, validation, and application to minimize impact on runtime operations</li> <li>EasyMesh Communication Thread: Dedicated thread for mesh protocol message handling and inter-node communication</li> <li>Synchronization: Uses mutex-protected shared data structures, condition variables for thread coordination, and lock-free queues for high-frequency event passing between threads</li> </ul>"},{"location":"docu/templateOct10/onewifi/#component-state-flow","title":"Component State Flow","text":""},{"location":"docu/templateOct10/onewifi/#initialization-to-active-state","title":"Initialization to Active State","text":"<p>OneWifi follows a structured initialization sequence that ensures all dependencies are available before transitioning to operational state. The initialization process validates platform capabilities, establishes IPC connections, registers data model parameters, and initializes hardware interfaces in a predetermined order to avoid race conditions and ensure system stability.</p> <pre><code>stateDiagram-v2\n    [*] --&gt; Initializing\n    Initializing --&gt; LoadingConfig: Load Configuration Files\n    LoadingConfig --&gt; PlatformInit: Platform Detection &amp; HAL Init\n    PlatformInit --&gt; BusRegistration: Register RBus/DBus Elements\n    BusRegistration --&gt; TR181Registration: Register TR-181 Parameters\n    TR181Registration --&gt; ServiceInit: Initialize Service Modules\n    ServiceInit --&gt; HardwareInit: Initialize WiFi Hardware\n    HardwareInit --&gt; Active: All Systems Ready\n    Active --&gt; RuntimeConfigUpdate: Config Change Event\n    RuntimeConfigUpdate --&gt; Active: Configuration Applied\n    Active --&gt; HardwareEvent: Hardware Status Change\n    HardwareEvent --&gt; Active: Event Processed\n    Active --&gt; ServiceMaintenance: Periodic Maintenance\n    ServiceMaintenance --&gt; Active: Maintenance Complete\n    Active --&gt; ErrorRecovery: Critical Error Detected\n    ErrorRecovery --&gt; Active: Recovery Successful\n    ErrorRecovery --&gt; Failed: Recovery Failed\n    Active --&gt; Shutdown: Stop Request\n    Failed --&gt; Shutdown: Force Shutdown\n    Shutdown --&gt; [*]\n\n    note right of Initializing\n        - Parse command line arguments\n        - Initialize logging subsystem\n        - Allocate core data structures\n        - Setup signal handlers\n    end note\n\n    note right of PlatformInit\n        - Detect platform type (Linux/OpenWrt/RDKB)\n        - Load platform-specific HAL libraries\n        - Verify HAL API compatibility\n        - Initialize platform abstraction layer\n    end note\n\n    note right of Active\n        - Process TR-181 get/set requests\n        - Handle client association events\n        - Monitor hardware status\n        - Execute periodic statistics collection\n        - Coordinate EasyMesh operations\n    end note</code></pre>"},{"location":"docu/templateOct10/onewifi/#runtime-state-changes-and-context-switching","title":"Runtime State Changes and Context Switching","text":"<p>During normal operation, OneWifi manages multiple concurrent state machines for different operational contexts including radio states, client association states, mesh networking states, and configuration synchronization states. Each context maintains independent state while coordinating through the central event dispatcher to ensure consistent system behavior.</p> <p>State Change Triggers: - Configuration Updates: WebConfig bulk updates, TR-181 parameter changes, or factory reset operations trigger configuration validation and application workflows - Hardware Events: Radio up/down events, client connect/disconnect notifications, and hardware error conditions trigger corresponding state transitions and recovery actions - Mesh Events: EasyMesh topology changes, multi-AP coordination messages, and steering decisions trigger mesh state updates and client management actions - External Control Events: Management system commands, diagnostic requests, and maintenance operations trigger controlled state transitions with rollback capabilities</p> <p>Context Switching Scenarios: - Platform Mode Switching: Dynamic switching between gateway and extender modes based on mesh role negotiation and topology detection - Radio Configuration Changes: Runtime switching between different channel configurations, bandwidth settings, and security modes with minimal service interruption - Failover Operations: Automatic failover to backup configurations during hardware failures or connectivity issues with restoration when conditions improve</p>"},{"location":"docu/templateOct10/onewifi/#call-flow","title":"Call Flow","text":""},{"location":"docu/templateOct10/onewifi/#primary-call-flows","title":"Primary Call Flows","text":"<p>Initialization Call Flow:</p> <pre><code>sequenceDiagram\n    participant SystemD as SystemD\n    participant OneWifi as OneWifi Manager\n    participant HAL as WiFi HAL\n    participant RBus as RBus Framework\n    participant PSM as PSM Component\n\n    SystemD-&gt;&gt;OneWifi: Start OneWifi Service\n    OneWifi-&gt;&gt;OneWifi: Load Configuration Files\n    OneWifi-&gt;&gt;HAL: Initialize WiFi HAL\n    HAL--&gt;&gt;OneWifi: HAL Initialization Complete\n    OneWifi-&gt;&gt;RBus: Connect to Message Bus\n    RBus--&gt;&gt;OneWifi: Bus Connection Established\n    OneWifi-&gt;&gt;RBus: Register TR-181 Data Elements\n    RBus--&gt;&gt;OneWifi: Registration Successful\n    OneWifi-&gt;&gt;PSM: Load Persistent Configuration\n    PSM--&gt;&gt;OneWifi: Configuration Data Retrieved\n    OneWifi-&gt;&gt;HAL: Configure WiFi Hardware\n    HAL--&gt;&gt;OneWifi: Hardware Configured\n    OneWifi-&gt;&gt;SystemD: Service Ready (Active State)</code></pre> <p>TR-181 Parameter Get Request Call Flow:</p> <pre><code>sequenceDiagram\n    participant Client as Management Client\n    participant RBus as RBus Framework\n    participant OneWifi as OneWifi Manager\n    participant DataStore as Runtime Data Store\n    participant HAL as WiFi HAL\n\n    Client-&gt;&gt;RBus: Get Device.WiFi.Radio.{i}.Channel\n    RBus-&gt;&gt;OneWifi: Parameter Get Request\n    OneWifi-&gt;&gt;DataStore: Check Cached Value\n    alt Cache Miss or Real-time Required\n        OneWifi-&gt;&gt;HAL: wifi_getRadioChannel()\n        HAL--&gt;&gt;OneWifi: Current Channel Value\n        OneWifi-&gt;&gt;DataStore: Update Cache\n    else Cache Hit\n        DataStore--&gt;&gt;OneWifi: Cached Value\n    end\n    OneWifi--&gt;&gt;RBus: Parameter Value Response\n    RBus--&gt;&gt;Client: Response with Channel Value</code></pre> <p>Client Association Event Call Flow:</p> <pre><code>sequenceDiagram\n    participant WiFiHW as WiFi Hardware\n    participant HAL as WiFi HAL\n    participant OneWifi as OneWifi Manager\n    participant Telemetry as Telemetry Service\n    participant EasyMesh as EasyMesh Module\n\n    WiFiHW-&gt;&gt;HAL: Client Association Event\n    HAL-&gt;&gt;OneWifi: wifi_steering_clientAssociate_callback()\n    OneWifi-&gt;&gt;OneWifi: Update Client Database\n    OneWifi-&gt;&gt;OneWifi: Apply Security Policies\n    OneWifi-&gt;&gt;Telemetry: Send Client Connect Event\n    OneWifi-&gt;&gt;EasyMesh: Notify Mesh Controller\n    EasyMesh-&gt;&gt;OneWifi: Apply Steering Policies\n    OneWifi-&gt;&gt;HAL: Update Client Configuration\n    HAL--&gt;&gt;OneWifi: Configuration Applied</code></pre>"},{"location":"docu/templateOct10/onewifi/#tr181-data-models","title":"TR\u2011181 Data Models","text":""},{"location":"docu/templateOct10/onewifi/#supported-tr-181-parameters","title":"Supported TR-181 Parameters","text":"<p>OneWifi implements comprehensive TR-181 Wi-Fi data model support following BBF TR-181 Issue 2 Amendment 15 specifications with additional RDK-specific extensions for enhanced functionality and platform-specific features.</p>"},{"location":"docu/templateOct10/onewifi/#object-hierarchy","title":"Object Hierarchy","text":"<pre><code>Device.\n\u2514\u2500\u2500 WiFi.\n    \u251c\u2500\u2500 RadioNumberOfEntries (uint32, R)\n    \u251c\u2500\u2500 SSIDNumberOfEntries (uint32, R)\n    \u251c\u2500\u2500 AccessPointNumberOfEntries (uint32, R)\n    \u251c\u2500\u2500 ApplyRadioSettings (boolean, R/W)\n    \u251c\u2500\u2500 ApplyAccessPointSettings (boolean, R/W)\n    \u251c\u2500\u2500 Radio.{i}.\n    \u2502   \u251c\u2500\u2500 Enable (boolean, R/W)\n    \u2502   \u251c\u2500\u2500 Status (string, R)\n    \u2502   \u251c\u2500\u2500 Name (string, R)\n    \u2502   \u251c\u2500\u2500 Channel (uint32, R/W)\n    \u2502   \u251c\u2500\u2500 AutoChannelEnable (boolean, R/W)\n    \u2502   \u251c\u2500\u2500 OperatingFrequencyBand (string, R/W)\n    \u2502   \u251c\u2500\u2500 OperatingChannelBandwidth (string, R/W)\n    \u2502   \u251c\u2500\u2500 TransmitPower (uint32, R/W)\n    \u2502   \u2514\u2500\u2500 Stats.\n    \u2502       \u251c\u2500\u2500 BytesSent (uint64, R)\n    \u2502       \u251c\u2500\u2500 BytesReceived (uint64, R)\n    \u2502       \u251c\u2500\u2500 PacketsSent (uint64, R)\n    \u2502       \u2514\u2500\u2500 PacketsReceived (uint64, R)\n    \u251c\u2500\u2500 SSID.{i}.\n    \u2502   \u251c\u2500\u2500 Enable (boolean, R/W)\n    \u2502   \u251c\u2500\u2500 Status (string, R)\n    \u2502   \u251c\u2500\u2500 Name (string, R/W)\n    \u2502   \u251c\u2500\u2500 SSID (string, R/W)\n    \u2502   \u251c\u2500\u2500 MACAddress (string, R)\n    \u2502   \u2514\u2500\u2500 Stats.\n    \u2502       \u251c\u2500\u2500 BytesSent (uint64, R)\n    \u2502       \u251c\u2500\u2500 BytesReceived (uint64, R)\n    \u2502       \u251c\u2500\u2500 AssociatedDeviceNumberOfEntries (uint32, R)\n    \u2502       \u2514\u2500\u2500 AssociatedDevice.{i}.\n    \u2502           \u251c\u2500\u2500 MACAddress (string, R)\n    \u2502           \u251c\u2500\u2500 AuthenticationState (boolean, R)\n    \u2502           \u251c\u2500\u2500 LastDataDownlinkRate (uint32, R)\n    \u2502           \u2514\u2500\u2500 SignalStrength (int32, R)\n    \u251c\u2500\u2500 AccessPoint.{i}.\n    \u2502   \u251c\u2500\u2500 Enable (boolean, R/W)\n    \u2502   \u251c\u2500\u2500 Status (string, R)\n    \u2502   \u251c\u2500\u2500 SSIDReference (string, R/W)\n    \u2502   \u251c\u2500\u2500 Security.\n    \u2502   \u2502   \u251c\u2500\u2500 ModesSupported (string, R)\n    \u2502   \u2502   \u251c\u2500\u2500 ModeEnabled (string, R/W)\n    \u2502   \u2502   \u251c\u2500\u2500 WEPKey (string, W)\n    \u2502   \u2502   \u251c\u2500\u2500 PreSharedKey (string, W)\n    \u2502   \u2502   \u2514\u2500\u2500 KeyPassphrase (string, W)\n    \u2502   \u2514\u2500\u2500 WPS.\n    \u2502       \u251c\u2500\u2500 Enable (boolean, R/W)\n    \u2502       \u251c\u2500\u2500 ConfigMethodsSupported (string, R)\n    \u2502       \u2514\u2500\u2500 ConfigMethodsEnabled (string, R/W)\n    \u2514\u2500\u2500 X_RDKCENTRAL-COM_BandSteering.\n        \u251c\u2500\u2500 Enable (boolean, R/W)\n        \u251c\u2500\u2500 APGroup (string, R/W)\n        \u251c\u2500\u2500 BandSteeringAlgorithm (string, R/W)\n        \u2514\u2500\u2500 History.{i}.\n            \u251c\u2500\u2500 MACAddress (string, R)\n            \u251c\u2500\u2500 SourceSSIDReference (string, R)\n            \u251c\u2500\u2500 TargetSSIDReference (string, R)\n            \u2514\u2500\u2500 Time (dateTime, R)\n</code></pre>"},{"location":"docu/templateOct10/onewifi/#parameter-definitions","title":"Parameter Definitions","text":"<p>Core Parameters:</p> Parameter Path Data Type Access Default Value Description BBF Compliance <code>Device.WiFi.RadioNumberOfEntries</code> uint32 R <code>0</code> Total number of Wi-Fi radio entries in the Radio table. Automatically calculated based on detected hardware interfaces. TR-181 Issue 2 <code>Device.WiFi.SSIDNumberOfEntries</code> uint32 R <code>0</code> Total number of SSID entries in the SSID table. Reflects all configured virtual access points across all radios. TR-181 Issue 2 <code>Device.WiFi.Radio.{i}.Enable</code> boolean R/W <code>false</code> Enables or disables the radio interface. When disabled, all associated SSIDs and Access Points are automatically disabled. TR-181 Issue 2 <code>Device.WiFi.Radio.{i}.Status</code> string R <code>\"Down\"</code> Current operational status of the radio. Enumerated values: \"Up\", \"Down\", \"Unknown\", \"Dormant\", \"NotPresent\", \"LowerLayerDown\", \"Error\". TR-181 Issue 2 <code>Device.WiFi.Radio.{i}.Channel</code> uint32 R/W <code>6</code> Current operating channel number. Valid values depend on regulatory domain and operating frequency band. Auto-channel selection when AutoChannelEnable is true. TR-181 Issue 2 <code>Device.WiFi.SSID.{i}.SSID</code> string(32) R/W <code>\"\"</code> Service Set Identifier (network name) for the wireless network. Maximum 32 octets as per IEEE 802.11 standard. UTF-8 encoding supported. TR-181 Issue 2 <code>Device.WiFi.AccessPoint.{i}.Security.ModeEnabled</code> string R/W <code>\"None\"</code> Security mode for the access point. Enumerated values: \"None\", \"WEP-64\", \"WEP-128\", \"WPA-Personal\", \"WPA2-Personal\", \"WPA-WPA2-Personal\", \"WPA2-Enterprise\", \"WPA3-Personal\", \"WPA3-Enterprise\". TR-181 Issue 2 <p>Custom Extensions:</p> <ul> <li>X_RDKCENTRAL-COM_BandSteering: RDK-specific extension providing intelligent band steering capabilities for dual-band and tri-band configurations with historical tracking and algorithm selection</li> <li>X_RDKCENTRAL-COM_WiFiMesh: EasyMesh implementation extensions including controller/agent role management, topology discovery, and multi-AP coordination parameters</li> <li>X_RDKCENTRAL-COM_ClientSteering: Advanced client steering controls beyond standard band steering including RSSI thresholds, steering policies, and client blacklisting capabilities</li> </ul>"},{"location":"docu/templateOct10/onewifi/#parameter-registration-and-access","title":"Parameter Registration and Access","text":"<ul> <li>Implemented Parameters: OneWifi implements over 200 TR-181 parameters covering complete Wi-Fi radio management, SSID configuration, access point security, client statistics, and RDK-specific extensions for mesh networking and advanced features</li> <li>Parameter Registration: Parameters are registered via RBus data element registration during component initialization. Each parameter includes metadata for data type validation, access control, and change notification subscriptions</li> <li>Access Mechanism: External components access parameters through RBus get/set method calls with automatic parameter validation, caching for performance optimization, and event notification for parameter changes</li> <li>Validation Rules: All parameter sets undergo validation including range checking for numeric values, enumeration validation for string parameters, cross-parameter dependency validation, and platform capability verification before hardware application</li> </ul>"},{"location":"docu/templateOct10/onewifi/#internal-modules","title":"Internal Modules","text":"<p>OneWifi is architected with modular design principles where each functional area is encapsulated in dedicated modules that maintain clear interfaces and responsibilities. The core modules coordinate through a central management layer while maintaining independence for testing, maintenance, and platform-specific customization.</p> Module/Class Description Key Files WiFi Manager Central coordination module managing overall Wi-Fi operations, state machine, and inter-module communication <code>wifi_mgr.c</code>, <code>wifi_mgr.h</code> Control Layer Request processing and command coordination including TR-181 handlers, WebConfig processing, and API request routing <code>wifi_ctrl.c</code>, <code>wifi_ctrl_rbus_handlers.c</code>, <code>wifi_ctrl_webconfig.c</code> Data Plane Manager Network data path management, traffic monitoring, and packet processing coordination <code>wifi_data_plane.c</code>, <code>wifi_data_plane.h</code> Event Management Centralized event processing for hardware notifications, client events, and system triggers <code>wifi_events.c</code> Security Management Authentication, encryption, access control, and security policy enforcement <code>wifi_passpoint.c</code>, <code>wifi_8021x.c</code> EasyConnect Support Wi-Fi Easy Connect (DPP) implementation for simplified device onboarding <code>wifi_easy_connect.c</code>, <code>wifi_easy_connect.h</code> Statistics Collection Performance metrics gathering, client monitoring, and telemetry data preparation <code>source/stats/</code> WebConfig Integration Bulk configuration management and cloud synchronization support <code>source/webconfig/</code> Platform Abstraction Hardware abstraction layer providing consistent APIs across different platforms <code>source/platform/</code> Database Management Runtime data storage, configuration persistence, and data model maintenance <code>source/db/</code> <pre><code>flowchart TD\n    subgraph OneWifiModules[\"OneWifi Internal Modules\"]\n        WifiMgr([WiFi Manager])\n        CtrlLayer([Control Layer])\n        EventMgmt([Event Management])\n        DataPlane([Data Plane Manager])\n        SecurityMgmt([Security Management])\n        StatsMgmt([Statistics Collection])\n        WebConfigMgmt([WebConfig Integration])\n        PlatformAbs([Platform Abstraction])\n        DatabaseMgmt([Database Management])\n    end\n\n    WifiMgr --&gt; CtrlLayer\n    WifiMgr --&gt; EventMgmt\n    CtrlLayer --&gt; DataPlane\n    CtrlLayer --&gt; SecurityMgmt\n    EventMgmt --&gt; StatsMgmt\n    StatsMgmt --&gt; WebConfigMgmt\n    SecurityMgmt --&gt; PlatformAbs\n    DataPlane --&gt; DatabaseMgmt\n    PlatformAbs --&gt; DatabaseMgmt\n\n    classDef core fill:#e3f2fd,stroke:#1976d2,stroke-width:2px;\n    classDef service fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;\n    classDef platform fill:#fff3e0,stroke:#f57c00,stroke-width:2px;\n\n    class WifiMgr,CtrlLayer,EventMgmt core;\n    class DataPlane,SecurityMgmt,StatsMgmt,WebConfigMgmt service;\n    class PlatformAbs,DatabaseMgmt platform;</code></pre>"},{"location":"docu/templateOct10/onewifi/#component-interactions","title":"Component Interactions","text":""},{"location":"docu/templateOct10/onewifi/#middleware-components-system-layers","title":"Middleware Components &amp; System Layers","text":"<p>OneWifi serves as a central hub within the RDK-B middleware ecosystem, coordinating Wi-Fi operations with multiple system components while abstracting hardware complexities. The component maintains active communication channels with data model services, telemetry systems, configuration management services, and platform-specific layers to deliver comprehensive Wi-Fi management capabilities.</p> <pre><code>flowchart TD\n    subgraph \"External Management\"\n        WebUI[Web UI Portal]\n        CloudMgmt[Cloud Management System]\n        TR069ACS[TR-069 ACS Server]\n    end\n\n    subgraph \"RDK-B Middleware Layer\"\n        OneWifi[OneWifi Manager]\n        PSMComp[PSM Component]\n        TelemetryComp[Telemetry Service]\n        WebConfigComp[WebConfig Service]\n        TR181DM[TR-181 Data Model]\n        MeshAgent[Mesh Agent Components]\n        CaptivePortal[Captive Portal Service]\n    end\n\n    subgraph \"Platform Layer\"\n        WiFiHAL[WiFi HAL]\n        NetworkHAL[Network HAL]\n        OVSDB[OVSDB Service]\n        PlatformServices[Platform Services]\n    end\n\n    subgraph \"Hardware Layer\"\n        WiFiRadios[WiFi Radio Hardware]\n        NetworkInterfaces[Network Interfaces]\n    end\n\n    WebUI --&gt;|HTTPS/WebSocket| OneWifi\n    CloudMgmt --&gt;|WebConfig/HTTPS| WebConfigComp\n    TR069ACS --&gt;|TR-069/CWMP| TR181DM\n\n    OneWifi &lt;--&gt;|RBus Parameters| PSMComp\n    OneWifi --&gt;|RBus Events| TelemetryComp\n    OneWifi &lt;--&gt;|JSON Config| WebConfigComp\n    OneWifi &lt;--&gt;|RBus Get/Set| TR181DM\n    OneWifi --&gt;|EasyMesh Events| MeshAgent\n    OneWifi --&gt;|Client Events| CaptivePortal\n\n    OneWifi --&gt;|HAL API Calls| WiFiHAL\n    OneWifi --&gt;|HAL API Calls| NetworkHAL\n    OneWifi &lt;--&gt;|OVSDB Protocol| OVSDB\n    OneWifi --&gt;|System APIs| PlatformServices\n\n    WiFiHAL --&gt;|Driver APIs| WiFiRadios\n    NetworkHAL --&gt;|Kernel APIs| NetworkInterfaces\n\n    classDef external fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n    classDef middleware fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef platform fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n    classDef hardware fill:#fce4ec,stroke:#c2185b,stroke-width:2px;\n\n    class WebUI,CloudMgmt,TR069ACS external;\n    class OneWifi,PSMComp,TelemetryComp,WebConfigComp,TR181DM,MeshAgent,CaptivePortal middleware;\n    class WiFiHAL,NetworkHAL,OVSDB,PlatformServices platform;\n    class WiFiRadios,NetworkInterfaces hardware;</code></pre> <p>Component Interactions:</p> Component/Layer Purpose of Interaction Protocols/Mechanisms Middleware Components PSM Component Persistent storage of Wi-Fi configuration parameters, factory defaults, and runtime settings RBus parameter get/set, bulk configuration operations Telemetry Service Real-time Wi-Fi performance metrics, client statistics, and operational event reporting RBus events, JSON telemetry messages WebConfig Service Bulk configuration management, cloud synchronization, and configuration validation JSON configuration documents, RBus notifications TR-181 Data Model Standardized parameter access for external management systems and diagnostic tools RBus get/set operations, parameter change notifications Mesh Agent Components EasyMesh coordination, multi-AP management, and inter-device communication Custom mesh protocols, RBus events System Layers WiFi HAL Hardware-specific Wi-Fi operations including radio control, client management, and statistics collection Standard HAL API calls, callback registrations Network HAL Network interface management, bridge operations, and VLAN configuration HAL API calls, network configuration APIs OVSDB Service Advanced networking features, flow control, and network virtualization OVSDB JSON-RPC protocol External Systems Cloud Management Remote Wi-Fi configuration, firmware updates, and centralized network monitoring HTTPS/TLS, WebConfig JSON format <p>Published Events:</p> <p>OneWifi publishes comprehensive event notifications that enable other RDK-B components to respond to Wi-Fi state changes and coordinate system-wide operations:</p> Event Purpose of Event Reason for Trigger <code>wifi.client.connect</code> Client device association notification New wireless client successfully authenticates and associates with access point <code>wifi.client.disconnect</code> Client device disassociation notification Wireless client disconnects voluntarily or due to timeout/error conditions <code>wifi.radio.statuschange</code> Radio operational status change Radio interface transitions between Up/Down/Error states due to configuration or hardware changes <code>wifi.config.changed</code> Configuration update notification Wi-Fi configuration parameters modified via TR-181, WebConfig, or direct API calls <code>wifi.mesh.topology.change</code> EasyMesh topology modification Mesh network topology changes including node additions, removals, or role changes <code>wifi.security.violation</code> Security policy breach detection Authentication failures, intrusion attempts, or policy violations detected <code>wifi.performance.threshold</code> Performance threshold crossed Network performance metrics exceed configured warning or error thresholds"},{"location":"docu/templateOct10/onewifi/#ipc-mechanism","title":"IPC Mechanism","text":"<p>OneWifi employs a flexible IPC architecture supporting multiple message bus implementations to ensure compatibility across different RDK-B deployment scenarios while optimizing for performance and reliability.</p> Type of IPC Message Format Mechanism RBus (Primary) Binary-encoded messages with structured data types including integers, strings, objects, and arrays. Supports parameter metadata and type validation RBus framework with direct method calls, parameter registration, and event subscriptions DBus (Legacy Support) D-Bus message format with XML introspection and standard D-Bus data types. Maintains backward compatibility with legacy RDK-B components DBus system bus with standardized CCSP interfaces and object path registration JSON over RBus JSON-encoded configuration documents and telemetry data for complex structured information exchange RBus transport with JSON payload encoding for WebConfig and bulk operations HAL Function Calls Direct C function calls with structured parameters and callback registrations for hardware interaction Synchronous API calls with asynchronous callback notifications for events <pre><code>sequenceDiagram\n    participant ExtMgmt as External Management\n    participant RBusFramework as RBus Framework\n    participant OneWifi as OneWifi Manager\n    participant HAL as WiFi HAL\n    participant Hardware as WiFi Hardware\n\n    ExtMgmt-&gt;&gt;RBusFramework: Set Device.WiFi.Radio.1.Channel\n    RBusFramework-&gt;&gt;OneWifi: RBus Set Request (channel=11)\n    OneWifi-&gt;&gt;OneWifi: Validate Channel Value\n    OneWifi-&gt;&gt;HAL: wifi_setRadioChannel(1, 11)\n    HAL-&gt;&gt;Hardware: Configure Radio Channel\n    Hardware--&gt;&gt;HAL: Channel Set Confirmation\n    HAL--&gt;&gt;OneWifi: HAL_SUCCESS\n    OneWifi-&gt;&gt;OneWifi: Update Runtime Data Store\n    OneWifi-&gt;&gt;RBusFramework: Publish Channel Changed Event\n    OneWifi--&gt;&gt;RBusFramework: RBus Set Response (SUCCESS)\n    RBusFramework--&gt;&gt;ExtMgmt: Parameter Set Successful\n\n    Note over OneWifi,RBusFramework: Event Notification Flow\n    RBusFramework-&gt;&gt;OneWifi: Event Subscription Request\n    OneWifi-&gt;&gt;RBusFramework: Acknowledge Subscription\n    OneWifi-&gt;&gt;RBusFramework: Publish Event (async)\n    RBusFramework-&gt;&gt;ExtMgmt: Event Notification</code></pre>"},{"location":"docu/templateOct10/onewifi/#implementation-details","title":"Implementation Details","text":""},{"location":"docu/templateOct10/onewifi/#major-hal-apis-integration","title":"Major HAL APIs Integration","text":"<p>OneWifi integrates with comprehensive WiFi HAL APIs providing standardized hardware abstraction across different chipset vendors and platform implementations. The HAL integration layer handles platform-specific variations while presenting consistent interfaces to the upper-level management functions.</p> <p>Core HAL APIs:</p> HAL API Purpose Parameters Return Values Implementation File <code>wifi_init()</code> Initialize WiFi HAL subsystem and detect available radios <code>void</code> <code>WIFI_HAL_SUCCESS</code>, <code>WIFI_HAL_ERROR</code> <code>wifi_ctrl.c</code> <code>wifi_getRadioNumberOfEntries()</code> Query total number of WiFi radio interfaces <code>unsigned long *output</code> <code>WIFI_HAL_SUCCESS</code>, <code>WIFI_HAL_ERROR</code> <code>wifi_ctrl_rbus_handlers.c</code> <code>wifi_setRadioEnable()</code> Enable or disable specific radio interface <code>int radioIndex, BOOL enable</code> <code>WIFI_HAL_SUCCESS</code>, <code>WIFI_HAL_ERROR</code> <code>wifi_ctrl_wifiapi_handlers.c</code> <code>wifi_getRadioChannel()</code> Retrieve current operating channel for radio <code>int radioIndex, unsigned long *output_ulong</code> <code>WIFI_HAL_SUCCESS</code>, <code>WIFI_HAL_ERROR</code> <code>wifi_ctrl.c</code> <code>wifi_setRadioChannel()</code> Configure operating channel for radio <code>int radioIndex, unsigned long channel</code> <code>WIFI_HAL_SUCCESS</code>, <code>WIFI_HAL_ERROR</code> <code>wifi_ctrl.c</code> <code>wifi_getSSIDName()</code> Get SSID name for specified SSID index <code>int ssidIndex, char *output_string</code> <code>WIFI_HAL_SUCCESS</code>, <code>WIFI_HAL_ERROR</code> <code>wifi_ctrl_rbus_handlers.c</code> <code>wifi_setSSIDName()</code> Configure SSID name for specified index <code>int ssidIndex, char *ssid_string</code> <code>WIFI_HAL_SUCCESS</code>, <code>WIFI_HAL_ERROR</code> <code>wifi_ctrl_wifiapi_handlers.c</code> <code>wifi_getApAssociatedDevicesCount()</code> Get count of associated client devices <code>int apIndex, unsigned long *output_ulong</code> <code>WIFI_HAL_SUCCESS</code>, <code>WIFI_HAL_ERROR</code> <code>wifi_data_plane.c</code>"},{"location":"docu/templateOct10/onewifi/#key-implementation-logic","title":"Key Implementation Logic","text":"<ul> <li>State Machine Engine: Core state management implemented in <code>wifi_mgr.c</code> with centralized state coordination across all WiFi operations. State transitions are managed through event-driven architecture with comprehensive error handling and recovery mechanisms.</li> <li>Main implementation in <code>wifi_mgr.c</code> with <code>wifi_mgr_state_machine_process()</code> function coordinating all state transitions</li> <li> <p>State transition handlers in <code>wifi_ctrl_queue_handlers.c</code> managing request queuing and processing workflows</p> </li> <li> <p>Event Processing: Hardware and software events are processed through asynchronous event handling system with priority-based queuing and parallel processing capabilities.</p> </li> <li>Hardware interrupt handling via HAL callback registration system</li> <li>Event queue management with circular buffers and overflow protection</li> <li> <p>Asynchronous event processing with dedicated worker threads for time-critical operations</p> </li> <li> <p>Error Handling Strategy: Comprehensive error detection and recovery system with multi-level error classification and appropriate response strategies for different failure scenarios.</p> </li> <li>HAL error code mapping with standardized error classification and logging</li> <li>Recovery mechanisms including automatic retry logic, configuration rollback, and hardware reset procedures</li> <li> <p>Timeout handling with configurable timeout values and exponential backoff for hardware operations</p> </li> <li> <p>Logging &amp; Debugging: Multi-level logging system with runtime configurable log levels, component-specific log categories, and integration with system logging infrastructure.</p> </li> <li>Component-specific logging with categories for WIFI_MGR, WIFI_CTRL, WIFI_HAL, and WIFI_EVENTS</li> <li>HAL API call tracing with parameter logging and return value tracking</li> <li>Debug hooks including runtime configuration dump, state machine visualization, and performance profiling</li> </ul>"},{"location":"docu/templateOct10/onewifi/#key-configuration-files","title":"Key Configuration Files","text":"<p>OneWifi utilizes multiple configuration files to support different deployment scenarios, platform requirements, and operational modes while maintaining consistent behavior across different hardware platforms.</p> Configuration File Purpose Key Parameters Default Values Override Mechanisms <code>CcspWifi.cfg</code> CCSP component registration and DBus configuration <code>ID</code>, <code>Name</code>, <code>Version</code>, <code>DbusPath</code> <code>com.cisco.spvtg.ccsp.wifi</code> Environment variables <code>TR181-WiFi-USGv2.XML</code> TR-181 data model definitions and parameter mappings WiFi object hierarchy, parameter types, access permissions Standard BBF definitions Platform-specific XML overlays <code>CcspDmLib.cfg</code> Data model library configuration and module loading Library paths, initialization functions, memory management Platform defaults Runtime configuration files <code>rdkb-wifi.ovsschema</code> OVSDB schema definitions for advanced networking features Table definitions, column types, constraints OpenWrt networking schema Custom schema extensions <code>bus_dml_config.json</code> Bus interface and data model element configuration RBus element registration, callback mappings Auto-generated mappings Runtime JSON updates <code>home.schema</code> / <code>private.schema</code> WebConfig schema definitions for configuration validation Parameter validation rules, configuration structure BBF-compliant structure Custom validation extensions <code>WifiSingleClient.avsc</code> Avro schema for telemetry data serialization Client statistics structure, data types Standard telemetry format Custom telemetry schemas"},{"location":"docu/templateOct10/rbus/","title":"RBus Documentation","text":"<p>RBus (RDK Bus) is a lightweight, fast and efficient bus messaging system that enables interprocess communication (IPC) and remote procedure calls (RPC) between multiple processes running on RDK-B devices. It provides a hierarchical data model framework supporting TR-181 parameter management, event-driven communication, and distributed object management across the RDK-B middleware stack.</p> <p>RBus serves as the foundational IPC layer for RDK-B components, replacing traditional DBus implementations with a more efficient, purpose-built messaging system. It enables components to register data models, publish events, expose methods, and manage hierarchical object trees in a distributed environment. The system supports both provider and consumer patterns, allowing components to simultaneously expose services and consume services from other components.</p> <pre><code>graph TD\n    subgraph \"External Management\"\n        WebUI[\"Web UI&lt;br/&gt;(TR-069/181 Interface)\"]\n        Cloud[\"Cloud Management&lt;br/&gt;(ACS/HeadEnd)\"]\n        CLI[\"CLI Tools&lt;br/&gt;(dmcli, rbuscli)\"]\n    end\n\n    subgraph \"RDK-B Middleware\"\n        RBus[\"RBus&lt;br/&gt;(IPC Framework)\"]\n        WanMgr[\"WAN Manager\"]\n        WiFiAgent[\"WiFi Agent\"] \n        CcspCM[\"CCSP CM Agent\"]\n        LMLite[\"LM Lite\"]\n        TR069[\"TR-069 PA\"]\n    end\n\n    subgraph \"Platform Layer\"\n        HAL[\"Hardware Abstraction Layer\"]\n        Kernel[\"Linux Kernel\"]\n        Hardware[\"Network Hardware\"]\n    end\n\n    WebUI --&gt;|HTTP/HTTPS| RBus\n    Cloud --&gt;|TR-069/CWMP| TR069\n    CLI --&gt;|Command Line| RBus\n\n    RBus &lt;--&gt;|RBus IPC| WanMgr\n    RBus &lt;--&gt;|RBus IPC| WiFiAgent\n    RBus &lt;--&gt;|RBus IPC| CcspCM\n    RBus &lt;--&gt;|RBus IPC| LMLite\n    RBus &lt;--&gt;|RBus IPC| TR069\n\n    WanMgr --&gt;|HAL Calls| HAL\n    WiFiAgent --&gt;|HAL Calls| HAL\n    HAL --&gt;|System Calls| Kernel\n    Kernel --&gt;|Drivers| Hardware\n\n    classDef external fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n    classDef rbus fill:#e3f2fd,stroke:#1976d2,stroke-width:3px;\n    classDef middleware fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef platform fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n\n    class WebUI,Cloud,CLI external;\n    class RBus rbus;\n    class WanMgr,WiFiAgent,CcspCM,LMLite,TR069 middleware;\n    class HAL,Kernel,Hardware platform;</code></pre> <p>Key Features &amp; Responsibilities: </p> <ul> <li>Hierarchical Data Model Management: Provides TR-181 compliant data model registration, access, and manipulation with support for objects, properties, events, and methods in a hierarchical namespace structure</li> <li>Event-Driven Communication: Enables publish-subscribe messaging patterns with value-change events, general events, and custom event types for real-time component coordination</li> <li>Remote Method Invocation: Supports synchronous and asynchronous method calls between components with parameter marshalling and result handling</li> <li>High-Performance IPC: Optimized message routing and serialization using custom binary protocols and memory-mapped communication for minimal latency</li> <li>Session Management: Handles component lifecycle, connection management, and automatic cleanup when processes terminate or disconnect</li> <li>Discovery and Routing: Automatic service discovery and intelligent message routing between distributed components using the rtrouted daemon</li> </ul>"},{"location":"docu/templateOct10/rbus/#design","title":"Design","text":"<p>RBus implements a broker-based messaging architecture centered around the rtrouted daemon that provides centralized message routing, service discovery, and session management. The design separates the messaging transport layer (rtmessage) from the higher-level data model abstraction (rbus API), enabling both low-level message passing and high-level object-oriented interactions. Components register with rtrouted to publish data models and subscribe to events, with the broker handling intelligent routing, caching, and delivery guarantees.</p> <p>The architecture supports both provider and consumer patterns within the same process, allowing components to simultaneously expose TR-181 parameters while consuming parameters from other components. The design emphasizes zero-copy message passing where possible, uses memory-mapped files for large data transfers, and implements connection pooling to minimize resource overhead. Event propagation follows a hierarchical subscription model where wildcards and filtering enable efficient targeted delivery.</p> <p>The IPC mechanism integrates through direct API calls to the rbus library, which internally manages connections to rtrouted via Unix domain sockets. Message serialization uses a custom binary format optimized for TR-181 data types, with automatic type conversion and validation. Data persistence is handled by individual components rather than RBus itself, though RBus provides mechanisms for components to coordinate data synchronization and backup operations.</p> <pre><code>graph TD\n    subgraph \"RBus Runtime Environment (Linux Processes)\"\n        subgraph \"rtrouted Daemon Process\"\n            Router[\"Message Router&lt;br/&gt;(C)\"]\n            Discovery[\"Service Discovery&lt;br/&gt;(C)\"]\n            SessionMgr[\"Session Manager&lt;br/&gt;(C)\"]\n            RouteCache[\"Routing Cache&lt;br/&gt;(C)\"]\n        end\n\n        subgraph \"Provider Process (e.g., WiFi Agent)\"\n            ProviderAPI[\"RBus Provider API&lt;br/&gt;(C)\"]\n            DataModel[\"TR-181 Data Model&lt;br/&gt;(C)\"]\n            EventPub[\"Event Publisher&lt;br/&gt;(C)\"]\n            MethodHandler[\"Method Handlers&lt;br/&gt;(C)\"]\n        end\n\n        subgraph \"Consumer Process (e.g., Web UI Backend)\"\n            ConsumerAPI[\"RBus Consumer API&lt;br/&gt;(C)\"]\n            EventSub[\"Event Subscriber&lt;br/&gt;(C)\"]\n            MethodClient[\"Method Client&lt;br/&gt;(C)\"]\n            ParamCache[\"Parameter Cache&lt;br/&gt;(C)\"]\n        end\n\n        subgraph \"Utilities\"\n            CLI[\"rbuscli&lt;br/&gt;(C)\"]\n            SessionMgrProc[\"rbus_session_mgr&lt;br/&gt;(C)\"]\n        end\n    end\n\n    subgraph \"Shared Resources\"\n        UnixSockets[(\"Unix Domain Sockets&lt;br/&gt;/tmp/rtroute*\")]\n        SharedMem[(\"Shared Memory&lt;br/&gt;mmap regions\")]\n        ConfigFiles[(\"Configuration&lt;br/&gt;rbus*.conf\")]\n    end\n\n    ProviderAPI --&gt;|Unix Socket| Router\n    ConsumerAPI --&gt;|Unix Socket| Router\n    CLI --&gt;|Unix Socket| Router\n\n    Router --&gt;|Route Discovery| Discovery\n    Router --&gt;|Session Tracking| SessionMgr\n    Router --&gt;|Cache Lookup| RouteCache\n\n    ProviderAPI -.-&gt;|Memory Mapping| SharedMem\n    ConsumerAPI -.-&gt;|Memory Mapping| SharedMem\n\n    SessionMgrProc --&gt;|Monitor| UnixSockets\n    Router -.-&gt;|Load Config| ConfigFiles\n\n    note1[\"Note: rtrouted must be started first&lt;br/&gt;All components connect via Unix sockets&lt;br/&gt;Large payloads use shared memory\"]\n\n    classDef daemon fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n    classDef provider fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n    classDef consumer fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef utility fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;\n    classDef resource fill:#fce4ec,stroke:#c2185b,stroke-width:2px;\n\n    class Router,Discovery,SessionMgr,RouteCache daemon;\n    class ProviderAPI,DataModel,EventPub,MethodHandler provider;\n    class ConsumerAPI,EventSub,MethodClient,ParamCache consumer;\n    class CLI,SessionMgrProc utility;\n    class UnixSockets,SharedMem,ConfigFiles resource;</code></pre>"},{"location":"docu/templateOct10/rbus/#prerequisites-and-dependencies","title":"Prerequisites and Dependencies","text":"<p>MUST Requirements:</p> <ul> <li>Linux operating system with systemd support for service management</li> <li>C99 compiler toolchain (gcc 4.8+ or clang 3.5+) for building native components</li> <li>CMake 2.8.12+ for build system configuration and dependency management</li> <li>Unix domain socket support in kernel for local IPC communication</li> <li>Memory mapping (mmap) support for large message handling and shared memory regions</li> <li>pthreads library for multi-threaded component support</li> </ul> <p>SHOULD Requirements:</p> <ul> <li>msgpack-c library for enhanced message serialization performance</li> <li>cJSON library for JSON message format support in utility applications</li> <li>rdklogger integration for centralized logging across RDK-B components</li> <li>linenoise library for enhanced CLI experience in rbuscli utility</li> <li>Breakpad library for crash reporting and debugging support</li> </ul> <p>Dependent Components:</p> <ul> <li>WAN Manager: Depends on RBus for TR-181 Device.X_RDK_WanManager parameter exposure and event notifications</li> <li>WiFi Agent: Uses RBus for Device.WiFi.* parameter management and client connection events</li> <li>CCSP Components: Legacy CCSP components transitioning to RBus from DBus for improved performance</li> <li>TR-069 PA: Leverages RBus for parameter value retrieval and modification during ACS interactions</li> <li>LM Lite: Utilizes RBus for device presence detection and network topology events</li> <li>Web UI Backend: Consumes RBus APIs for real-time device status and configuration management</li> </ul> <p>Threading Model</p> <p>RBus implements a hybrid threading architecture combining event-driven I/O with worker thread pools for optimal performance and responsiveness. The core rtrouted daemon operates on a single-threaded event loop using epoll for efficient socket multiplexing, while client libraries can operate in both single-threaded and multi-threaded modes depending on application requirements.</p> <ul> <li>Threading Architecture: Hybrid Event-Driven with Optional Multi-Threading</li> <li>Main Thread: Handles RBus API calls, connection management, and coordinates with rtrouted daemon</li> <li>Worker Threads (if applicable):</li> <li>Event Thread: Processes incoming events and dispatches callbacks to registered handlers</li> <li>Method Thread: Handles synchronous method invocations to prevent blocking main application logic</li> <li>Timer Thread: Manages subscription intervals and timeout handling for periodic events</li> <li>Synchronization: Uses mutexes for critical sections, condition variables for thread coordination, and lock-free queues for high-frequency message passing</li> </ul> <p>The rtrouted daemon maintains a single-threaded design for simplicity and performance, using an event loop to handle multiple client connections concurrently. Client applications can choose their threading model based on their specific requirements, with RBus providing thread-safe APIs when multi-threading is enabled.</p>"},{"location":"docu/templateOct10/rbus/#component-state-flow","title":"Component State Flow","text":""},{"location":"docu/templateOct10/rbus/#initialization-to-active-state","title":"Initialization to Active State","text":"<p>RBus follows a multi-phase initialization sequence starting with rtrouted daemon startup, followed by component registration and data model publication. The system transitions through distinct states including service discovery, connection establishment, and full operational readiness with automatic recovery mechanisms for failed connections.</p> <pre><code>stateDiagram-v2\n    [*] --&gt; StartingRtrouted\n    StartingRtrouted --&gt; RtroutedReady: Daemon Launch Complete\n    RtroutedReady --&gt; ComponentInit: Component Startup\n    ComponentInit --&gt; ConnectingToBus: rbus_open() Call\n    ConnectingToBus --&gt; RegisteringElements: Connection Established\n    RegisteringElements --&gt; PublishingDataModel: Element Registration\n    PublishingDataModel --&gt; SubscribingEvents: Data Model Active\n    SubscribingEvents --&gt; OperationalReady: Event Subscriptions Active\n    OperationalReady --&gt; ProcessingRequests: Normal Operation\n    ProcessingRequests --&gt; ProcessingRequests: Handle Get/Set/Method/Event\n    ProcessingRequests --&gt; ComponentShutdown: rbus_close() or Process Exit\n    ComponentShutdown --&gt; CleanupResources: Unregister Elements\n    CleanupResources --&gt; [*]\n\n    ConnectingToBus --&gt; ConnectionFailed: Socket Error\n    ConnectionFailed --&gt; RetryConnection: Backoff Timer\n    RetryConnection --&gt; ConnectingToBus: Retry Attempt\n\n    OperationalReady --&gt; ConnectionLost: Network/Daemon Failure\n    ConnectionLost --&gt; ReconnectingToBus: Auto Recovery\n    ReconnectingToBus --&gt; RegisteringElements: Connection Restored\n\n    note right of StartingRtrouted\n        - Start rtrouted daemon\n        - Initialize Unix sockets\n        - Load configuration\n        - Setup routing tables\n    end note\n\n    note right of OperationalReady\n        - Process TR-181 requests\n        - Handle events/methods\n        - Monitor connections\n        - Route messages\n    end note</code></pre>"},{"location":"docu/templateOct10/rbus/#runtime-state-changes-and-context-switching","title":"Runtime State Changes and Context Switching","text":"<p>RBus maintains operational state through dynamic service discovery and automatic reconnection handling. Components can dynamically register and unregister data model elements during runtime, with the system automatically updating routing tables and notifying dependent components of availability changes.</p> <p>State Change Triggers:</p> <ul> <li>Component Registration/Deregistration: Triggers routing table updates and service availability notifications to dependent components</li> <li>Connection Loss/Recovery: Activates automatic reconnection logic with exponential backoff and state restoration</li> <li>Data Model Changes: Dynamic addition or removal of TR-181 parameters triggers discovery updates and subscription re-evaluation</li> <li>Event Subscription Changes: Modifies event routing and filtering rules for optimal message delivery performance</li> </ul> <p>Context Switching Scenarios: - Provider Mode to Consumer Mode: Components can dynamically switch roles within the same process for bidirectional communication - Online to Offline Mode: Handles graceful degradation when rtrouted daemon becomes unavailable with local caching - Debug Mode Switching: Runtime log level changes and diagnostic mode activation without service interruption</p>"},{"location":"docu/templateOct10/rbus/#call-flow","title":"Call Flow","text":""},{"location":"docu/templateOct10/rbus/#primary-call-flows","title":"Primary Call Flows","text":"<p>Initialization Call Flow:</p> <pre><code>sequenceDiagram\n    participant App as Application Process\n    participant RBus as RBus Library\n    participant Rtrouted as rtrouted Daemon\n    participant Registry as Service Registry\n\n    App-&gt;&gt;RBus: rbus_open(\"component_name\")\n    RBus-&gt;&gt;RBus: Initialize local structures\n    RBus-&gt;&gt;Rtrouted: Connect via Unix socket\n    Rtrouted--&gt;&gt;RBus: Connection established\n    RBus-&gt;&gt;Rtrouted: Register component name\n    Rtrouted-&gt;&gt;Registry: Add component to registry\n    Registry--&gt;&gt;Rtrouted: Registration complete\n    Rtrouted--&gt;&gt;RBus: Component registered\n    RBus--&gt;&gt;App: RBUS_ERROR_SUCCESS\n\n    App-&gt;&gt;RBus: rbusElement_register(elements[])\n    RBus-&gt;&gt;Rtrouted: Register data model elements\n    Rtrouted-&gt;&gt;Registry: Update routing table\n    Registry--&gt;&gt;Rtrouted: Routes updated\n    Rtrouted--&gt;&gt;RBus: Elements registered\n    RBus--&gt;&gt;App: RBUS_ERROR_SUCCESS</code></pre> <p>Parameter Get/Set Call Flow:</p> <pre><code>sequenceDiagram\n    participant Consumer as Consumer Process\n    participant RBusC as RBus Consumer API\n    participant Rtrouted as rtrouted Daemon\n    participant RBusP as RBus Provider API\n    participant Provider as Provider Process\n\n    Consumer-&gt;&gt;RBusC: rbus_get(\"Device.WiFi.Radio.1.Enable\")\n    RBusC-&gt;&gt;Rtrouted: Route lookup request\n    Rtrouted-&gt;&gt;Rtrouted: Find provider in routing table\n    Rtrouted-&gt;&gt;RBusP: Forward get request\n    RBusP-&gt;&gt;Provider: Invoke get handler callback\n    Provider-&gt;&gt;Provider: Read current value\n    Provider--&gt;&gt;RBusP: Return rbusValue_t\n    RBusP--&gt;&gt;Rtrouted: Response with value\n    Rtrouted--&gt;&gt;RBusC: Forward response\n    RBusC--&gt;&gt;Consumer: rbusProperty_t with value\n\n    Note over Consumer,Provider: Set operation follows similar pattern&lt;br/&gt;with validation and change events</code></pre> <p>Event Subscription and Publishing Call Flow:</p> <pre><code>sequenceDiagram\n    participant Subscriber as Event Subscriber\n    participant RBusS as RBus Subscriber API\n    participant Rtrouted as rtrouted Daemon\n    participant RBusP as RBus Publisher API\n    participant Publisher as Event Publisher\n\n    Subscriber-&gt;&gt;RBusS: rbusEvent_Subscribe(\"Device.WiFi.Radio.*.Enable\")\n    RBusS-&gt;&gt;Rtrouted: Subscribe to event pattern\n    Rtrouted-&gt;&gt;Rtrouted: Add to subscription table\n    Rtrouted--&gt;&gt;RBusS: Subscription confirmed\n    RBusS--&gt;&gt;Subscriber: RBUS_ERROR_SUCCESS\n\n    Note over Subscriber,Publisher: Later, when value changes...\n\n    Publisher-&gt;&gt;RBusP: rbusEvent_Publish(event_data)\n    RBusP-&gt;&gt;Rtrouted: Publish event message\n    Rtrouted-&gt;&gt;Rtrouted: Match subscribers using pattern\n    Rtrouted-&gt;&gt;RBusS: Deliver event to matching subscribers\n    RBusS-&gt;&gt;Subscriber: Invoke event callback with data\n    Subscriber-&gt;&gt;Subscriber: Process event in application</code></pre>"},{"location":"docu/templateOct10/rbus/#tr181-data-models","title":"TR\u2011181 Data Models","text":""},{"location":"docu/templateOct10/rbus/#supported-tr-181-parameters","title":"Supported TR-181 Parameters","text":"<p>RBus provides comprehensive support for TR-181 data model implementation following BBF-262 specification guidelines. The framework enables any component to register TR-181 compliant parameters with full support for the hierarchical object model, parameter validation, and standard access controls.</p>"},{"location":"docu/templateOct10/rbus/#object-hierarchy","title":"Object Hierarchy","text":"<pre><code>Device.\n\u2514\u2500\u2500 RBus.\n    \u251c\u2500\u2500 Enable (boolean, R/W)\n    \u251c\u2500\u2500 Status (string, R)\n    \u251c\u2500\u2500 ComponentList.{i}.\n    \u2502   \u251c\u2500\u2500 Name (string, R)\n    \u2502   \u251c\u2500\u2500 ConnectionStatus (string, R)\n    \u2502   \u251c\u2500\u2500 LastActivity (dateTime, R)\n    \u2502   \u2514\u2500\u2500 MessageCount (unsignedInt, R)\n    \u2514\u2500\u2500 Statistics.\n        \u251c\u2500\u2500 TotalMessages (unsignedInt, R)\n        \u251c\u2500\u2500 ActiveConnections (unsignedInt, R)\n        \u251c\u2500\u2500 ErrorCount (unsignedInt, R)\n        \u2514\u2500\u2500 UptimeSeconds (unsignedInt, R)\n</code></pre>"},{"location":"docu/templateOct10/rbus/#parameter-definitions","title":"Parameter Definitions","text":"<p>Core Parameters:</p> Parameter Path Data Type Access Default Value Description BBF Compliance <code>Device.RBus.Enable</code> boolean R/W <code>true</code> Enables or disables the RBus messaging system. When disabled, all IPC communication is suspended and components must use alternative mechanisms. Custom Extension <code>Device.RBus.Status</code> string R <code>\"Up\"</code> Current operational status of RBus system. Enumerated values: \"Up\", \"Down\", \"Error\", \"Starting\", \"Stopping\". Reflects the rtrouted daemon state. Custom Extension <code>Device.RBus.ComponentList.{i}.Name</code> string R <code>\"\"</code> Unique name identifier of the registered component as specified during rbus_open() call. Maximum length 256 characters following TR-181 naming conventions. Custom Extension <code>Device.RBus.ComponentList.{i}.ConnectionStatus</code> string R <code>\"Connected\"</code> Connection state of the component. Values: \"Connected\", \"Disconnected\", \"Reconnecting\", \"Failed\". Updated automatically by session manager. Custom Extension <code>Device.RBus.Statistics.TotalMessages</code> unsignedInt R <code>0</code> Cumulative count of all messages processed by rtrouted daemon since startup, including get/set operations, events, and method calls. Custom Extension <p>Custom Extensions:</p> <ul> <li>Device.RBus.*: Complete custom namespace for RBus-specific monitoring and control parameters not defined in standard BBF specifications</li> <li>Event Subscription Patterns: Support for wildcard subscriptions using TR-181 hierarchical notation with \"*\" and \".\" pattern matching</li> <li>Method Invocation Framework: Custom extension enabling remote procedure calls within TR-181 namespace structure</li> </ul>"},{"location":"docu/templateOct10/rbus/#parameter-registration-and-access","title":"Parameter Registration and Access","text":"<ul> <li>Implemented Parameters: Components register TR-181 parameters using rbusElement_register() with callbacks for get/set operations. RBus core itself exposes monitoring parameters under Device.RBus.* namespace.</li> <li>Parameter Registration: Registration occurs through rbus library API calls with automatic routing table updates in rtrouted daemon. Each parameter includes type information, access permissions, and callback handlers.</li> <li>Access Mechanism: Other components access parameters via rbus_get()/rbus_set() API calls which route through rtrouted daemon to the appropriate provider component via Unix domain sockets.</li> <li>Validation Rules: Type validation enforced at API level with custom validation callbacks supported for complex business rules. String length limits, numeric ranges, and enumerated value checking performed automatically.</li> </ul>"},{"location":"docu/templateOct10/rbus/#internal-modules","title":"Internal Modules","text":"<p>RBus consists of several layered modules providing abstraction from low-level messaging to high-level data model management. The core modules handle message routing and connection management, while higher-level modules provide TR-181 compliant APIs and event processing capabilities.</p> Module/Class Description Key Files rtmessage Low-level message transport layer providing socket management, routing, and serialization <code>rtMessage.c</code>, <code>rtrouted.c</code>, <code>rtConnection.c</code> rbuscore Core RBus API implementation handling component registration and message routing <code>rbuscore.c</code>, <code>rbuscore_message.c</code> rbus High-level TR-181 compatible API providing object/property abstraction <code>rbus.c</code>, <code>rbus_element.c</code>, <code>rbus_object.c</code> session_manager Component lifecycle management and connection monitoring <code>session_manager.c</code>, <code>rbus_session_mgr.h</code> utilities Command-line tools and diagnostic utilities for system interaction <code>rbuscli/</code>, <code>dataProvider/</code> <pre><code>flowchart TD\n    subgraph \"RBus Architecture\"\n        subgraph \"Application Layer\"\n            App1[\"Provider Apps&lt;br/&gt;(WiFi, WAN, etc.)\"]\n            App2[\"Consumer Apps&lt;br/&gt;(Web UI, CLI)\"]\n        end\n\n        subgraph \"RBus High-Level API\"\n            RBusAPI[\"rbus.c&lt;br/&gt;TR-181 API\"]\n            Elements[\"rbus_element.c&lt;br/&gt;Data Model Mgmt\"]\n            Objects[\"rbus_object.c&lt;br/&gt;Object Operations\"]\n            Properties[\"rbus_property.c&lt;br/&gt;Property Handling\"]\n            Events[\"rbus_valuechange.c&lt;br/&gt;Event Processing\"]\n        end\n\n        subgraph \"RBus Core Layer\"\n            Core[\"rbuscore.c&lt;br/&gt;Core Messaging\"]\n            Message[\"rbuscore_message.c&lt;br/&gt;Message Processing\"]\n            Handle[\"rbus_handle.c&lt;br/&gt;Connection Mgmt\"]\n        end\n\n        subgraph \"Transport Layer\"\n            RTMessage[\"rtMessage.c&lt;br/&gt;Message Transport\"]\n            Router[\"rtrouted.c&lt;br/&gt;Message Router\"]\n            Connection[\"rtConnection.c&lt;br/&gt;Socket Management\"]\n        end\n\n        subgraph \"Session Management\"\n            SessionMgr[\"session_manager.c&lt;br/&gt;Lifecycle Mgmt\"]\n        end\n    end\n\n    App1 --&gt; RBusAPI\n    App2 --&gt; RBusAPI\n\n    RBusAPI --&gt; Elements\n    RBusAPI --&gt; Objects\n    RBusAPI --&gt; Properties\n    RBusAPI --&gt; Events\n\n    Elements --&gt; Core\n    Objects --&gt; Core\n    Properties --&gt; Core\n    Events --&gt; Core\n\n    Core --&gt; Message\n    Core --&gt; Handle\n\n    Message --&gt; RTMessage\n    Handle --&gt; RTMessage\n\n    RTMessage --&gt; Router\n    RTMessage --&gt; Connection\n\n    SessionMgr -.-&gt; Router\n\n    classDef app fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n    classDef api fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef core fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n    classDef transport fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;\n    classDef session fill:#fce4ec,stroke:#c2185b,stroke-width:2px;\n\n    class App1,App2 app;\n    class RBusAPI,Elements,Objects,Properties,Events api;\n    class Core,Message,Handle core;\n    class RTMessage,Router,Connection transport;\n    class SessionMgr session;</code></pre>"},{"location":"docu/templateOct10/rbus/#component-interactions","title":"Component Interactions","text":""},{"location":"docu/templateOct10/rbus/#middleware-components-system-layers","title":"Middleware Components &amp; System Layers","text":"<p>RBus serves as the central IPC backbone connecting all RDK-B middleware components through standardized messaging patterns. Components interact through TR-181 parameter get/set operations, event subscriptions, and method invocations. The system abstracts the underlying transport mechanism while providing high-performance message routing and automatic service discovery.</p> <pre><code>flowchart TD\n    subgraph \"Management Interfaces\"\n        WebUI[\"Web UI&lt;br/&gt;Management Portal\"]\n        ACS[\"ACS/HeadEnd&lt;br/&gt;TR-069 Server\"]\n        CLI[\"dmcli/rbuscli&lt;br/&gt;Command Line\"]\n    end\n\n    subgraph \"RDK-B Middleware Components\"\n        RBus[\"RBus&lt;br/&gt;IPC Framework\"]\n        WanMgr[\"WAN Manager&lt;br/&gt;Connection Mgmt\"]\n        WiFiAgent[\"WiFi Agent&lt;br/&gt;Wireless Mgmt\"]\n        CcspCM[\"CCSP CM Agent&lt;br/&gt;Cable Modem\"]\n        LMLite[\"LM Lite&lt;br/&gt;Device Discovery\"]\n        TR069PA[\"TR-069 PA&lt;br/&gt;Parameter Agent\"]\n        PSM[\"Persistent Storage&lt;br/&gt;Manager\"]\n    end\n\n    subgraph \"Platform &amp; HAL Layer\"\n        HAL[\"Hardware Abstraction&lt;br/&gt;Layer (HAL)\"]\n        NetworkStack[\"Linux Network&lt;br/&gt;Stack\"]\n        FileSystem[\"Configuration&lt;br/&gt;Storage\"]\n    end\n\n    WebUI --&gt;|HTTP REST API| TR069PA\n    ACS --&gt;|TR-069 CWMP| TR069PA\n    CLI --&gt;|RBus Direct| RBus\n\n    TR069PA &lt;--&gt;|RBus Get/Set| RBus\n    WanMgr &lt;--&gt;|RBus Events/Params| RBus\n    WiFiAgent &lt;--&gt;|RBus Events/Params| RBus\n    CcspCM &lt;--&gt;|RBus Events/Params| RBus\n    LMLite &lt;--&gt;|RBus Events/Params| RBus\n    PSM &lt;--&gt;|RBus Persistence| RBus\n\n    WanMgr --&gt;|HAL API Calls| HAL\n    WiFiAgent --&gt;|HAL API Calls| HAL\n    PSM --&gt;|File I/O| FileSystem\n    HAL --&gt;|System Calls| NetworkStack\n\n    classDef management fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n    classDef rbus fill:#e3f2fd,stroke:#1976d2,stroke-width:3px;\n    classDef middleware fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef platform fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n\n    class WebUI,ACS,CLI management;\n    class RBus rbus;\n    class WanMgr,WiFiAgent,CcspCM,LMLite,TR069PA,PSM middleware;\n    class HAL,NetworkStack,FileSystem platform;</code></pre> <p>Component Interactions:</p> Component/Layer Purpose of Interaction Protocols/Mechanisms Middleware Components WAN Manager TR-181 Device.X_RDK_WanManager.* parameter exposure and WAN interface events RBus IPC, Event subscriptions WiFi Agent Device.WiFi.* parameter management, client association/disassociation events RBus IPC, Value-change events CCSP CM Agent Cable modem status reporting, upstream/downstream parameter management RBus IPC, Legacy DBus bridge LM Lite Device presence detection, network topology change notifications RBus IPC, General events TR-069 PA Parameter value retrieval for ACS interactions, bulk configuration updates RBus IPC, Synchronous get/set PSM Persistent parameter storage, configuration backup and restore operations RBus IPC, Method calls System Layers HAL Layer Hardware-specific parameter retrieval and configuration via standardized APIs Direct API calls, No RBus involvement Platform Services System configuration, network stack interaction, file system operations System calls, Configuration files Management Interfaces Web UI/ACS Remote device management, configuration updates, status monitoring HTTP/HTTPS, TR-069 CWMP, RBus proxy <p>Published Events:</p> <p>RBus facilitates cross-component coordination through a comprehensive event system enabling real-time notifications and state synchronization across the RDK-B middleware stack:</p> Event Purpose of Event Reason for trigger <code>Device.*.ValueChange</code> Parameter value modification notification Any TR-181 parameter change triggers event to notify subscribers of state updates <code>Device.RBus.ComponentList.*.ConnectionChange</code> Component connectivity status updates Component registration/deregistration or connection loss detection for dependency management <code>Device.WiFi.Radio.*.ClientConnect</code> WiFi client association events New device connection to wireless network for network topology tracking <code>Device.X_RDK_WanManager.InterfaceStatusChange</code> WAN interface state transitions Interface up/down events for connection failover and load balancing decisions <code>Device.DeviceInfo.SystemRestart</code> System reboot notification Device restart event for component coordination during shutdown/startup sequences"},{"location":"docu/templateOct10/rbus/#ipc-mechanism","title":"IPC Mechanism","text":"<p>RBus implements a high-performance IPC mechanism using Unix domain sockets for control messaging combined with shared memory regions for large data transfers. The system uses a custom binary serialization format optimized for TR-181 data types with automatic endianness handling and type validation.</p> Type of IPC Message Format Mechanism Parameter Get/Set Binary-encoded rbusMessage with type-tagged rbusValue payload containing parameter path, data type, and value Unix domain sockets to rtrouted with automatic routing to provider component Event Publishing Custom event message format with event name, source component, timestamp, and typed payload data Unix domain sockets with subscription-based routing and pattern matching Method Invocation RPC-style message with method name, input parameters as rbusObject, and response handling Synchronous Unix socket communication with timeout handling and error propagation Large Data Transfer Memory-mapped regions with header containing size, type, and access permissions Shared memory (mmap) for messages exceeding 64KB threshold with socket-based coordination <pre><code>sequenceDiagram\n    participant ConsumerApp as Consumer App\n    participant RBusLib as RBus Library\n    participant UnixSocket as Unix Socket\n    participant Rtrouted as rtrouted Daemon\n    participant ProviderSocket as Provider Socket  \n    participant ProviderLib as Provider RBus Lib\n    participant ProviderApp as Provider App\n\n    ConsumerApp-&gt;&gt;RBusLib: rbus_get(\"Device.WiFi.Radio.1.Enable\")\n    RBusLib-&gt;&gt;RBusLib: Serialize request to binary message\n    RBusLib-&gt;&gt;UnixSocket: Send message to rtrouted\n    UnixSocket-&gt;&gt;Rtrouted: Forward binary message\n    Rtrouted-&gt;&gt;Rtrouted: Route lookup in table\n    Rtrouted-&gt;&gt;ProviderSocket: Forward to provider socket\n    ProviderSocket-&gt;&gt;ProviderLib: Deliver message\n    ProviderLib-&gt;&gt;ProviderLib: Deserialize message\n    ProviderLib-&gt;&gt;ProviderApp: Invoke get callback handler\n    ProviderApp-&gt;&gt;ProviderApp: Read parameter value\n    ProviderApp--&gt;&gt;ProviderLib: Return rbusValue_t\n    ProviderLib-&gt;&gt;ProviderLib: Serialize response\n    ProviderLib--&gt;&gt;ProviderSocket: Send response message\n    ProviderSocket--&gt;&gt;Rtrouted: Return via socket\n    Rtrouted--&gt;&gt;UnixSocket: Route response back\n    UnixSocket--&gt;&gt;RBusLib: Deliver response\n    RBusLib-&gt;&gt;RBusLib: Deserialize response\n    RBusLib--&gt;&gt;ConsumerApp: Return rbusProperty_t\n\n    Note over ConsumerApp,ProviderApp: Large payloads (&gt;64KB) automatically&lt;br/&gt;use shared memory with socket coordination</code></pre>"},{"location":"docu/templateOct10/rbus/#implementation-details","title":"Implementation Details","text":""},{"location":"docu/templateOct10/rbus/#major-hal-apis-integration","title":"Major HAL APIs Integration","text":"<p>RBus operates as a middleware-layer IPC framework and does not directly integrate with HAL APIs. Instead, it provides the communication mechanism for RDK-B components that do interact with HAL layers. The framework enables components to expose HAL-derived data through TR-181 parameters and coordinate HAL operations through event notifications.</p> <p>HAL Integration Pattern:</p> Integration Pattern Purpose Implementation Approach RBus Role Parameter Bridging Expose HAL data as TR-181 parameters Component registers HAL-backed parameters with RBus Provides get/set callback routing to HAL-aware component Event Forwarding Convert HAL callbacks to RBus events HAL callbacks trigger RBus event publication Enables cross-component notification of hardware state changes Method Delegation Remote HAL operation invocation RBus methods invoke HAL APIs in designated components Provides RPC mechanism for coordinated HAL access Status Aggregation Combine multiple HAL sources Components use RBus to share HAL status information Facilitates status correlation across hardware subsystems"},{"location":"docu/templateOct10/rbus/#key-implementation-logic","title":"Key Implementation Logic","text":"<ul> <li>Message Routing Engine: Core routing logic implemented in <code>rtrouted.c</code> using hash tables for O(1) component lookup and radix trees for efficient wildcard pattern matching in event subscriptions</li> <li>Main implementation in <code>src/rtmessage/rtrouted.c</code> with routing table management and connection tracking</li> <li> <p>Route optimization logic in <code>src/rtmessage/rtRoutingTree.c</code> for hierarchical namespace pattern matching</p> </li> <li> <p>Event Processing: Asynchronous event handling with priority queues and configurable delivery guarantees ensuring reliable cross-component communication</p> </li> <li>Event queue management and subscription filtering</li> <li>Callback thread pool for non-blocking event delivery</li> <li> <p>Automatic retry logic for failed event deliveries</p> </li> <li> <p>Error Handling Strategy: Comprehensive error detection with automatic recovery mechanisms and detailed error propagation through standardized error codes</p> </li> <li>Connection failure detection with exponential backoff retry logic</li> <li>Message validation and type checking with detailed error reporting</li> <li> <p>Graceful degradation when rtrouted daemon becomes unavailable</p> </li> <li> <p>Logging &amp; Debugging: Multi-level logging with component-specific categories and real-time log level adjustment for production debugging</p> </li> <li>Structured logging with component identification and message tracing</li> <li>Performance metrics collection for message latency and throughput analysis</li> <li>Debug hooks enabling runtime inspection of routing tables and subscription lists</li> </ul>"},{"location":"docu/templateOct10/rbus/#key-configuration-files","title":"Key Configuration Files","text":"<p>RBus configuration management centers around systemd service files and runtime configuration that controls daemon behavior, logging, and component registration policies.</p> Configuration File Purpose Key Parameters Default Values Override Mechanisms <code>rbus.service</code> Systemd service definition for rtrouted daemon <code>ExecStart</code>, <code>TimeoutSec</code>, <code>Restart</code> <code>/usr/bin/rtrouted</code>, <code>300s</code>, <code>no</code> Environment variables, systemd overrides <code>rbus_session_mgr.service</code> Session manager service configuration <code>ExecStart</code>, <code>User</code>, <code>Group</code> <code>/usr/bin/rbus_session_mgr</code> Systemd drop-in files <code>rbus_rdkv.conf</code> RDK-V specific runtime configuration Log levels, socket paths, timeouts <code>INFO</code>, <code>/tmp/rtroute*</code>, <code>30s</code> Runtime environment variables <code>rbus_client_rdkc.conf</code> RDK-C client configuration parameters Connection limits, retry counts <code>max_connections=100</code>, <code>retry=3</code> Client-specific config files <p>The configuration system supports dynamic parameter updates through environment variables and systemd service overrides, enabling deployment-specific customization without modifying core configuration files. Runtime parameters can be adjusted via RBus's own TR-181 interface for live system tuning.</p>"},{"location":"docu/templateOct10/wanmanager/","title":"WAN Manager Documentation","text":"<p>WAN Manager is the RDK-B middleware component responsible for managing WAN connectivity and interface orchestration. It serves as the central coordinator for WAN interface selection, failover management, and connectivity validation across multiple interface types including DOCSIS, Ethernet, Cellular (LTE), DSL (xDSL), and GPON. The component implements intelligent policy-driven selection algorithms and provides comprehensive WAN interface lifecycle management to ensure optimal internet connectivity for CPE devices.</p> <p>WAN Manager abstracts the complexity of multi-WAN configurations from upper-layer applications while providing seamless failover capabilities and centralized WAN policy enforcement. As a core middleware service, it coordinates with various interface managers (DOCSIS Manager, Cellular Manager, etc.) and handles both link-layer and IP-layer configuration through integration with DHCP, VLAN Manager, and other RDK-B components.</p> <pre><code>graph LR\n    subgraph \"External Systems\"\n        Cloud[Cloud/Head-end Services]\n        ISP[(ISP Networks)]\n        WebUI[Web Management UI]\n    end\n\n    subgraph \"RDK-B Middleware Layer\"\n        WanMgr[WAN Manager]\n        CcspDM[CCSP Data Model]\n        DHCPMgr[DHCP Manager]\n        VLANMgr[VLAN Manager]\n        TelMgr[Telemetry Manager]\n        WebConfig[WebConfig Framework]\n    end\n\n    subgraph \"Interface Managers\"\n        DocsisMgr[DOCSIS Manager]\n        CellMgr[Cellular Manager]\n        EthMgr[Ethernet Manager]\n        DSLMgr[DSL Manager]\n        GPONMgr[GPON Manager]\n    end\n\n    subgraph \"HAL/Platform Layer\"\n        HAL[(HAL Interfaces)]\n        NetStack[Linux Network Stack]\n        SysEvents[System Events]\n    end\n\n    Cloud --&gt;|WebConfig/TR-069| WanMgr\n    WebUI --&gt;|HTTP/HTTPS| WanMgr\n    WanMgr --&gt;|RBus/DBus| CcspDM\n    WanMgr --&gt;|RBus Messages| DHCPMgr\n    WanMgr --&gt;|RBus Events| VLANMgr\n    WanMgr --&gt;|Telemetry Events| TelMgr\n    WanMgr --&gt;|Configuration| WebConfig\n    WanMgr --&gt;|RBus/DBus| DocsisMgr\n    WanMgr --&gt;|RBus/DBus| CellMgr\n    WanMgr --&gt;|RBus/DBus| EthMgr\n    WanMgr --&gt;|RBus/DBus| DSLMgr\n    WanMgr --&gt;|RBus/DBus| GPONMgr\n    WanMgr --&gt;|System Calls| HAL\n    WanMgr --&gt;|Network Commands| NetStack\n    WanMgr --&gt;|Event Publishing| SysEvents\n\n    ISP -.-&gt;|Internet Connectivity| DocsisMgr\n    ISP -.-&gt;|Internet Connectivity| CellMgr\n    ISP -.-&gt;|Internet Connectivity| EthMgr\n\n    classDef external fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n    classDef middleware fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef hal fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n    classDef interface fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;\n\n    class Cloud,ISP,WebUI external;\n    class WanMgr,CcspDM,DHCPMgr,VLANMgr,TelMgr,WebConfig middleware;\n    class DocsisMgr,CellMgr,EthMgr,DSLMgr,GPONMgr interface;\n    class HAL,NetStack,SysEvents hal;</code></pre> <p>Key Features &amp; Responsibilities: </p> <ul> <li>Multi-WAN Interface Management: Coordinates multiple WAN interface types (DOCSIS, Ethernet, Cellular, DSL, GPON) with intelligent selection and failover policies for optimal connectivity</li> <li>Policy-Driven Selection: Implements various selection algorithms including AutoWAN, Parallel Scan, Fixed Mode, and Primary Priority to determine the best available WAN interface</li> <li>Failover and Redundancy: Provides automatic failover between interface groups with configurable restoration delays and health monitoring for continuous internet connectivity</li> <li>Interface State Machine: Manages complete WAN interface lifecycle from physical layer validation through IP configuration with proper error handling and recovery mechanisms</li> <li>DHCP Integration: Handles DHCPv4 and DHCPv6 client operations including lease management, DNS configuration, and IPv6 prefix delegation for WAN interfaces</li> <li>TR-181 Data Model: Implements comprehensive TR-181 parameter tree for WAN management configuration, status reporting, and remote management capabilities</li> <li>Telemetry and Monitoring: Provides extensive telemetry data collection, system event publishing, and connectivity validation for network performance monitoring</li> <li>WebConfig Support: Enables cloud-based configuration management with bulk configuration updates and validation for simplified remote device management</li> </ul>"},{"location":"docu/templateOct10/wanmanager/#design","title":"Design","text":"<p>WAN Manager employs a modular, event-driven architecture built around multiple state machines and policy engines that coordinate to provide intelligent WAN connectivity management. The design centers on three core operational components: a global Failover Policy managing interface group selection, per-group Selection Policies handling interface choice within groups, and per-interface State Machines managing individual interface lifecycle. This multi-layered approach enables flexible configuration scenarios from simple single-WAN setups to complex multi-group failover with diverse interface types.</p> <p>The architecture separates concerns between physical interface management (handled by dedicated Interface Managers) and logical WAN configuration (managed by WAN Manager), allowing clean abstraction and simplified interface integration. WAN Manager coordinates with DHCP Manager for IP configuration, VLAN Manager for link-layer setup, and Telemetry systems for monitoring, while maintaining direct control over network stack configuration through Linux utilities. The design supports both RBus and DBus IPC mechanisms for backward compatibility and provides comprehensive TR-181 parameter exposure for standards-compliant management.</p> <p>The north-bound interface provides TR-181 parameter access via RBus/DBus for remote management systems and WebConfig integration for cloud-based configuration, while south-bound interactions handle physical interface coordination through standardized RBus messaging with Interface Managers and direct HAL/system integration for network configuration. Data persistence is managed through syscfg for configuration storage and PSM (Persistent Storage Manager) for runtime state, ensuring configuration persistence across reboots and proper state recovery during system initialization.</p> <pre><code>graph TD\n    subgraph ContainerBoundary [\"WAN Manager Process (C/RDK-B Runtime)\"]\n        subgraph MainController [\"Main Controller\"]\n            Controller[WAN Controller]\n            noteController[\"Purpose: Orchestrates overall WAN management policy and coordinates state machines.\"]\n        end\n\n        subgraph PolicyEngines [\"Policy Engines\"]\n            FailoverPolicy[Failover Policy Engine]\n            SelectionPolicy[Selection Policy Engine] \n            StateMachine[Interface State Machines]\n            notePolicies[\"Purpose: Implements selection algorithms (AutoWAN, Parallel Scan, Fixed Mode) and interface lifecycle management.\"]\n        end\n\n        subgraph DataModel [\"TR-181 Data Model Layer\"]\n            DMLLayer[DML Implementation]\n            RBusHandler[RBus Handler]\n            DBusCompat[DBus Compatibility]\n            noteDataModel[\"Purpose: Provides TR-181 parameter tree implementation and IPC communication handling.\"]\n        end\n\n        subgraph NetworkServices [\"Network Services\"]\n            DHCPHandler[DHCP Client Handler]\n            IPConfig[IP Configuration]\n            NetworkUtils[Network Utilities]\n            noteNetwork[\"Purpose: Manages IP layer configuration, DHCP operations, and network stack interaction.\"]\n        end\n\n        subgraph IntegrationLayer [\"Integration Layer\"]\n            WebConfigAPI[WebConfig APIs]\n            TelemetryAPI[Telemetry APIs]\n            SysEvents[System Events]\n            IPCServer[IPC Server]\n            noteIntegration[\"Purpose: Handles external system integration, events, and configuration management.\"]\n        end\n    end\n\n    subgraph ExternalServices [\"External Services &amp; Components\"]\n        InterfaceManagers[\"Interface Managers (DOCSIS, Cellular, etc.)\"]\n        DHCPManager[DHCP Manager]\n        VLANManager[VLAN Manager]\n        TelemetryManager[Telemetry Manager]\n        PSM[Persistent Storage Manager]\n    end\n\n    Controller --&gt;|Coordinates| PolicyEngines\n    Controller --&gt;|Configures| DataModel\n    PolicyEngines --&gt;|Updates State| DataModel\n    PolicyEngines --&gt;|Configures| NetworkServices\n    DataModel --&gt;|Events/Requests| IntegrationLayer\n    NetworkServices --&gt;|System Calls| IntegrationLayer\n    IntegrationLayer --&gt;|RBus/DBus| InterfaceManagers\n    IntegrationLayer --&gt;|RBus Messages| DHCPManager\n    IntegrationLayer --&gt;|RBus Events| VLANManager\n    IntegrationLayer --&gt;|Telemetry Data| TelemetryManager\n    IntegrationLayer --&gt;|Configuration Storage| PSM</code></pre>"},{"location":"docu/templateOct10/wanmanager/#prerequisites-and-dependencies","title":"Prerequisites and Dependencies","text":"<p>WAN Manager has several critical dependencies that must be satisfied for proper operation. The component requires RBus infrastructure for modern IPC communication, though it maintains DBus compatibility for legacy integration. The underlying Linux network stack must support standard networking utilities (ip, ifconfig, route) and provide netlink socket access for network interface monitoring.</p> <p>MUST Requirements:</p> <ul> <li>RDK-B Common Library (ccsp-common-library) for base RDK-B infrastructure and logging</li> <li>RBus library (rbus &gt;= 1.0) for primary IPC communication or DBus for legacy support  </li> <li>Syscfg library for persistent configuration storage and retrieval</li> <li>PSM (Persistent Storage Manager) for runtime parameter persistence</li> <li>Linux kernel with netlink socket support and standard networking utilities</li> <li>System Events (sysevent) infrastructure for event publishing and subscription</li> <li>WebConfig Framework for cloud-based configuration management support</li> </ul> <p>SHOULD Requirements:</p> <ul> <li>Telemetry 2.0 framework for enhanced monitoring and data collection capabilities</li> <li>DHCP Manager component for centralized DHCP client operations management</li> <li>VLAN Manager component for 802.1Q VLAN configuration on WAN interfaces</li> <li>Interface Manager components (DOCSIS Manager, Cellular Manager) for physical interface control</li> <li>HAL libraries specific to the platform's WAN interface hardware</li> </ul> <p>Dependent Components:</p> <ul> <li>Network Monitor (netmonitor): Depends on WAN Manager for interface status and connectivity validation</li> <li>Firewall Manager: Relies on WAN Manager for active interface information and routing decisions</li> <li>Quality of Service (QoS) Manager: Uses WAN interface selection data for traffic prioritization</li> <li>Captive Portal Detection: Depends on WAN connectivity validation and internet access status</li> <li>Device Management (TR-069/USPAgent): Requires WAN Manager TR-181 parameters for device configuration</li> <li>Diagnostic Tools: Use WAN interface state and connectivity information for network troubleshooting</li> </ul> <p>Threading Model</p> <p>WAN Manager implements a multi-threaded architecture designed to handle concurrent operations across multiple WAN interfaces while maintaining responsive system behavior. The component uses a combination of event-driven processing and dedicated worker threads to manage the complexity of simultaneous interface state machines and policy execution.</p> <ul> <li>Threading Architecture: Multi-threaded with event-driven main loop</li> <li>Main Thread: Handles initialization, RBus/DBus message processing, TR-181 parameter operations, and coordinates overall component lifecycle</li> <li>Controller Thread: Runs the main WAN Controller state machine, manages policy engine coordination, and processes interface selection algorithms with 500ms processing cycles</li> <li>Interface State Machine Threads: Individual worker threads for each configured WAN interface (up to 128 supported), managing interface-specific lifecycle, DHCP operations, and connectivity validation</li> <li>IPC Server Thread: Dedicated thread for handling IPC message processing from Interface Managers, including status updates and configuration requests</li> <li>WebConfig Thread: Handles WebConfig framework integration, processing bulk configuration updates and validation operations</li> <li>Telemetry Thread: Manages telemetry data collection and event publishing to Telemetry 2.0 framework</li> <li>Synchronization: Uses mutex locks for shared data structures (WAN configuration database), condition variables for thread coordination, and RBus/DBus thread-safe APIs for inter-component communication</li> </ul>"},{"location":"docu/templateOct10/wanmanager/#component-state-flow","title":"Component State Flow","text":""},{"location":"docu/templateOct10/wanmanager/#initialization-to-active-state","title":"Initialization to Active State","text":"<p>WAN Manager follows a structured initialization sequence that establishes IPC connectivity, loads configuration, registers TR-181 parameters, and initializes all internal state machines before entering active operation. The component waits for system readiness signals and dependent service availability before beginning WAN interface management operations.</p> <pre><code>stateDiagram-v2\n    [*] --&gt; Initializing\n    Initializing --&gt; LoadingConfig: Load Configuration\n    LoadingConfig --&gt; RegisteringTR181: Register Data Models\n    RegisteringTR181 --&gt; InitializingIPC: Setup IPC (RBus/DBus)\n    InitializingIPC --&gt; WaitingSystemReady: Wait for System Ready\n    WaitingSystemReady --&gt; StartingServices: Start Core Services\n    StartingServices --&gt; InitializingPolicies: Initialize Policy Engines\n    InitializingPolicies --&gt; Active: All Systems Ready\n    Active --&gt; PolicyExecution: Interface Selection\n    PolicyExecution --&gt; Active: Continue Monitoring\n    Active --&gt; InterfaceFailover: Failover Event\n    InterfaceFailover --&gt; Active: Failover Complete\n    Active --&gt; ConfigUpdate: Configuration Change\n    ConfigUpdate --&gt; Active: Config Applied\n    Active --&gt; Shutdown: Stop Request\n    Shutdown --&gt; [*]\n\n    note right of Initializing\n        - Initialize logging system\n        - Allocate core data structures\n        - Setup signal handlers\n    end note\n\n    note right of LoadingConfig\n        - Load syscfg parameters\n        - Initialize WAN interface database\n        - Load policy configurations\n    end note\n\n    note right of RegisteringTR181\n        - Register TR-181 parameter tree\n        - Setup RBus/DBus handlers\n        - Initialize WebConfig support\n    end note\n\n    note right of Active\n        - Process TR-181 requests\n        - Monitor interface states\n        - Execute failover policies\n        - Handle telemetry events\n    end note</code></pre>"},{"location":"docu/templateOct10/wanmanager/#runtime-state-changes-and-context-switching","title":"Runtime State Changes and Context Switching","text":"<p>WAN Manager continuously monitors and responds to various runtime events that trigger state changes in interface selection, policy execution, and network configuration. The component maintains separate state contexts for each interface while coordinating global policies that affect interface group selection and failover behavior.</p> <p>State Change Triggers: - Physical Interface Events: Interface up/down notifications from Interface Managers trigger state machine transitions and policy re-evaluation - Connectivity Validation: Internet connectivity test results (DNS resolution, ping tests) trigger interface selection changes and failover decisions - Configuration Updates: TR-181 parameter changes,or policy modifications trigger configuration reload and state machine restart - DHCP Events: DHCP lease acquisition, renewal failures, or IP address changes trigger interface state updates and connectivity re-validation - System Events: Network stack changes, routing table updates, or hardware events trigger interface monitoring and validation cycles</p> <p>Context Switching Scenarios: - Interface Group Failover: When the active interface group fails connectivity validation, WAN Manager switches to backup groups with configurable restoration delay - Policy Changes: Runtime policy updates (AutoWAN to Fixed Mode) trigger complete state machine restart with new selection criteria - Interface Priority Updates: Changes to interface priority rankings trigger re-evaluation of current selections without disrupting active connections - Emergency Fallback: Critical interface failures trigger immediate fallback to any available interface regardless of policy constraints</p>"},{"location":"docu/templateOct10/wanmanager/#call-flow","title":"Call Flow","text":""},{"location":"docu/templateOct10/wanmanager/#primary-call-flows","title":"Primary Call Flows","text":"<p>Initialization Call Flow:</p> <pre><code>sequenceDiagram\n    participant Init as System Init\n    participant WanMgr as WAN Manager\n    participant RBus as RBus Infrastructure\n    participant PSM as PSM Storage\n    participant SysEvents as System Events\n\n    Init-&gt;&gt;WanMgr: Start WAN Manager Process\n    WanMgr-&gt;&gt;WanMgr: Initialize Core Structures\n    WanMgr-&gt;&gt;PSM: Load Persistent Configuration\n    PSM--&gt;&gt;WanMgr: Configuration Data\n    WanMgr-&gt;&gt;RBus: Register Component &amp; Parameters\n    RBus--&gt;&gt;WanMgr: Registration Complete\n    WanMgr-&gt;&gt;SysEvents: Subscribe to System Events\n    SysEvents--&gt;&gt;WanMgr: Subscription Confirmed\n    WanMgr-&gt;&gt;WanMgr: Start Controller Thread\n    WanMgr-&gt;&gt;WanMgr: Initialize Interface State Machines\n    WanMgr-&gt;&gt;Init: Initialization Complete (Active State)\n\n    Note over WanMgr: Ready to process interface events and TR-181 requests</code></pre> <p>Interface Selection Call Flow:</p> <pre><code>sequenceDiagram\n    participant InterfaceMgr as Interface Manager\n    participant WanMgr as WAN Manager\n    participant PolicyEngine as Policy Engine\n    participant NetworkStack as Network Stack\n    participant DHCPMgr as DHCP Manager\n\n    InterfaceMgr-&gt;&gt;WanMgr: Interface Status Update (RBus)\n    WanMgr-&gt;&gt;PolicyEngine: Evaluate Interface Change\n    PolicyEngine-&gt;&gt;PolicyEngine: Run Selection Algorithm\n    PolicyEngine--&gt;&gt;WanMgr: Interface Selection Decision\n    WanMgr-&gt;&gt;DHCPMgr: Configure IP (RBus Message)\n    DHCPMgr--&gt;&gt;WanMgr: IP Configuration Status\n    WanMgr-&gt;&gt;NetworkStack: Apply Network Configuration\n    NetworkStack--&gt;&gt;WanMgr: Configuration Applied\n    WanMgr-&gt;&gt;WanMgr: Validate Internet Connectivity\n    WanMgr-&gt;&gt;InterfaceMgr: Interface Selection Complete\n\n    Note over WanMgr: Interface active and monitoring connectivity</code></pre> <p>Failover Call Flow:</p> <pre><code>sequenceDiagram\n    participant Monitor as Connectivity Monitor\n    participant WanMgr as WAN Manager\n    participant FailoverPolicy as Failover Policy\n    participant BackupIntf as Backup Interface\n    participant TelemetryMgr as Telemetry Manager\n\n    Monitor-&gt;&gt;WanMgr: Connectivity Failure Detected\n    WanMgr-&gt;&gt;FailoverPolicy: Trigger Failover Evaluation\n    FailoverPolicy-&gt;&gt;FailoverPolicy: Select Backup Interface Group\n    FailoverPolicy--&gt;&gt;WanMgr: Backup Interface Decision\n    WanMgr-&gt;&gt;BackupIntf: Activate Backup Interface\n    BackupIntf--&gt;&gt;WanMgr: Interface Activation Status\n    WanMgr-&gt;&gt;WanMgr: Validate Backup Connectivity\n    WanMgr-&gt;&gt;TelemetryMgr: Report Failover Event\n    TelemetryMgr--&gt;&gt;WanMgr: Event Logged\n\n    Note over WanMgr: Backup interface active, monitoring for restoration</code></pre>"},{"location":"docu/templateOct10/wanmanager/#tr181-data-models","title":"TR\u2011181 Data Models","text":""},{"location":"docu/templateOct10/wanmanager/#supported-tr-181-parameters","title":"Supported TR-181 Parameters","text":"<p>WAN Manager implements a comprehensive TR-181 parameter tree under the <code>Device.X_RDK_WanManager</code> namespace, providing complete configuration and status information for WAN interface management. The implementation follows BBF TR-181 specification guidelines while including RDK-specific extensions for advanced WAN management capabilities.</p>"},{"location":"docu/templateOct10/wanmanager/#object-hierarchy","title":"Object Hierarchy","text":"<pre><code>Device.\n\u2514\u2500\u2500 X_RDK_WanManager.\n    \u251c\u2500\u2500 Enable (boolean, R/W)\n    \u251c\u2500\u2500 Policy (string, R/W) \n    \u251c\u2500\u2500 AllowRemoteInterfaces (boolean, R/W)\n    \u251c\u2500\u2500 RestorationDelay (unsignedInt, R/W)\n    \u251c\u2500\u2500 Data (string, R/W)\n    \u251c\u2500\u2500 WanFailoverData (string, R/W)\n    \u251c\u2500\u2500 ResetActiveInterface (boolean, R/W)\n    \u251c\u2500\u2500 ResetDefaultConfig (boolean, R/W)\n    \u251c\u2500\u2500 DnsConnectivityCheck.\n    \u2502   \u2514\u2500\u2500 Enable (boolean, R/W)\n    \u2514\u2500\u2500 CPEInterface.{i}.\n        \u251c\u2500\u2500 Name (string, R/W)\n        \u251c\u2500\u2500 DisplayName (string, R/W)\n        \u251c\u2500\u2500 ConfigureWanEnable (boolean, R/W)\n        \u251c\u2500\u2500 EnableOperStatusMonitor (boolean, R/W)\n        \u251c\u2500\u2500 EnableCustomConfig (boolean, R/W)\n        \u251c\u2500\u2500 CustomConfigPath (string, R/W)\n        \u251c\u2500\u2500 Phy.\n        \u2502   \u251c\u2500\u2500 Path (string, R/W)\n        \u2502   \u2514\u2500\u2500 Status (string, R/W)\n        \u251c\u2500\u2500 Wan.\n        \u2502   \u251c\u2500\u2500 Type (string, R/W)\n        \u2502   \u251c\u2500\u2500 Priority (unsignedInt, R/W) \n        \u2502   \u251c\u2500\u2500 SelectionTimeOut (unsignedInt, R/W)\n        \u2502   \u251c\u2500\u2500 Group (unsignedInt, R/W)\n        \u2502   \u2514\u2500\u2500 ActiveLink (boolean, R)\n        \u251c\u2500\u2500 PPP.\n        \u2502   \u251c\u2500\u2500 Enable (boolean, R/W)\n        \u2502   \u251c\u2500\u2500 Username (string, R/W)\n        \u2502   \u2514\u2500\u2500 Password (string, R/W)\n        \u2514\u2500\u2500 VirtualInterface.{i}.\n            \u251c\u2500\u2500 Name (string, R/W)\n            \u251c\u2500\u2500 Alias (string, R/W)\n            \u251c\u2500\u2500 Enable (boolean, R/W)\n            \u251c\u2500\u2500 Status (string, R)\n            \u251c\u2500\u2500 VLANID (int, R/W)\n            \u251c\u2500\u2500 Priority (unsignedInt, R/W)\n            \u2514\u2500\u2500 Marking.\n                \u251c\u2500\u2500 SKBPort (unsignedInt, R/W)\n                \u2514\u2500\u2500 EthernetPriorityMark (int, R/W)\n</code></pre>"},{"location":"docu/templateOct10/wanmanager/#parameter-definitions","title":"Parameter Definitions","text":"<p>Core Parameters:</p> Parameter Path Data Type Access Default Value Description BBF Compliance <code>Device.X_RDK_WanManager.Enable</code> boolean R/W <code>true</code> Enables or disables the WAN Manager component. When false, all WAN interface management is suspended and no interface selection policies are executed. Custom Extension <code>Device.X_RDK_WanManager.Policy</code> string R/W <code>\"AUTOWAN_MODE\"</code> Specifies the WAN interface selection policy. Valid values: FIXED_MODE_ON_BOOTUP(1), FIXED_MODE(2), PRIMARY_PRIORITY_ON_BOOTUP(3), PRIMARY_PRIORITY(4), MULTIWAN_MODE(5), AUTOWAN_MODE(6), PARALLEL_SCAN(7). Controls the algorithm used for interface selection and failover behavior. Custom Extension <code>Device.X_RDK_WanManager.RestorationDelay</code> unsignedInt R/W <code>60</code> Time in seconds to wait before attempting to restore a previously failed interface. Prevents rapid interface oscillation during intermittent connectivity issues. Range: 0-3600 seconds. Custom Extension <code>Device.X_RDK_WanManager.AllowRemoteInterfaces</code> boolean R/W <code>false</code> Enables support for remote WAN interfaces (e.g., bridge interfaces for remote connectivity). When enabled, allows configuration of interfaces not physically present on the local device. Custom Extension <code>Device.X_RDK_WanManager.CPEInterface.{i}.Name</code> string R/W <code>\"\"</code> The interface name as known to the system (e.g., \"erouter0\", \"eth0\"). Must match the actual system interface name for proper operation. Maximum length: 64 characters. Custom Extension <code>Device.X_RDK_WanManager.CPEInterface.{i}.Wan.Priority</code> unsignedInt R/W <code>1</code> Interface selection priority within its group. Lower values indicate higher priority. Used by priority-based selection policies to determine interface precedence. Range: 1-255. Custom Extension <code>Device.X_RDK_WanManager.CPEInterface.{i}.Wan.Group</code> unsignedInt R/W <code>1</code> Interface group assignment for failover policy management. Interfaces in the same group are managed by the same selection policy. Range: 1-2. Custom Extension <code>Device.X_RDK_WanManager.CPEInterface.{i}.Wan.Type</code> string R/W <code>\"UNKNOWN\"</code> WAN interface type specification. Valid values: DOCSIS, ETHERNET_WAN, DSL, GPON, CELLULAR. Used for interface-specific configuration and management policies. Custom Extension <p>Custom Extensions:</p> <p>WAN Manager includes several RDK-specific TR-181 extensions that provide advanced functionality beyond standard BBF specifications:</p> <ul> <li>WebConfig Integration Parameters: Support for bulk configuration updates via WebConfig framework with <code>Data</code> and <code>WanFailoverData</code> parameters for JSON-encoded configuration</li> <li>Interface Grouping and Policies: Multi-group interface management with configurable selection policies for complex failover scenarios not covered by standard TR-181</li> <li>Virtual Interface Support: Advanced VLAN and virtual interface configuration with QoS marking capabilities for service provider requirements</li> <li>Connectivity Validation: DNS-based connectivity checking with configurable validation parameters for robust internet connectivity detection</li> </ul>"},{"location":"docu/templateOct10/wanmanager/#parameter-registration-and-access","title":"Parameter Registration and Access","text":"<p>WAN Manager registers its complete TR-181 parameter tree during component initialization and provides both RBus and DBus access mechanisms for backward compatibility. Parameters are dynamically updated based on interface state changes and policy decisions, with immediate notification to subscribed management systems.</p> <ul> <li>Implemented Parameters: Complete implementation of X_RDK_WanManager namespace with 100+ parameters covering interface configuration, policy management, and status reporting</li> <li>Parameter Registration: Uses RBus data model registration for modern platforms with fallback to DBus Component Cache (CCSP) for legacy support</li> <li>Access Mechanism: RBus provides primary access path with optimized performance, while DBus maintains compatibility with existing management systems and components</li> <li>Validation Rules: Comprehensive parameter validation including range checking for numeric values, enumeration validation for policy strings, and dependency validation between related parameters</li> <li>Event Notifications: Automatic parameter change notifications via RBus events and DBus signals for real-time management system updates</li> </ul>"},{"location":"docu/templateOct10/wanmanager/#internal-modules","title":"Internal Modules","text":"<p>WAN Manager is organized into several specialized modules that handle different aspects of WAN connectivity management. The modular design allows for clear separation of concerns while enabling coordinated operation across all WAN management functions.</p> Module/Class Description Key Files WAN Controller Main orchestration engine that coordinates policy execution and state machine management <code>wanmgr_controller.c</code>, <code>wanmgr_controller.h</code> Policy Engines Implements various selection algorithms (AutoWAN, Parallel Scan, Fixed Mode) for interface selection <code>wanmgr_policy_*_impl.c</code> files Interface State Machine Manages individual WAN interface lifecycle from initialization through active connectivity <code>wanmgr_interface_sm.c</code>, <code>wanmgr_interface_sm.h</code> Data Management Central data store for WAN configuration and runtime state with thread-safe access <code>wanmgr_data.c</code>, <code>wanmgr_data.h</code> TR-181 DML Layer Implements complete TR-181 parameter tree with RBus/DBus integration <code>TR-181/middle_layer_src/wanmgr_dml_*.c</code> DHCP Integration Handles DHCPv4/DHCPv6 client operations and IP configuration management <code>wanmgr_dhcpv4_*.c</code>, <code>wanmgr_dhcpv6_*.c</code> Network Utilities Provides network stack interaction and system command execution <code>wanmgr_net_utils.c</code>, <code>wanmgr_net_utils.h</code> IPC Management Handles inter-process communication with Interface Managers and other components <code>wanmgr_ipc.c</code>, <code>wanmgr_ipc.h</code> Telemetry Integration Manages telemetry data collection and event publishing for monitoring <code>wanmgr_telemetry.c</code>, <code>wanmgr_t2_telemetry.c</code> WebConfig APIs Provides WebConfig framework integration for cloud-based configuration <code>wanmgr_webconfig.c</code>, <code>wanmgr_webconfig_apis.c</code> <pre><code>flowchart TD\n    subgraph WAN Manager Component\n        Controller([WAN Controller])\n        PolicyEngine([Policy Engines])\n        StateMachine([Interface State Machines])\n        DataMgmt([Data Management])\n        TR181([TR-181 DML Layer])\n        DHCP([DHCP Integration])\n        NetUtils([Network Utilities])\n        IPC([IPC Management])\n        Telemetry([Telemetry Integration])\n        WebConfig([WebConfig APIs])\n    end\n\n    Controller --&gt; PolicyEngine\n    Controller --&gt; StateMachine\n    Controller --&gt; DataMgmt\n    TR181 --&gt; DataMgmt\n    PolicyEngine --&gt; StateMachine\n    StateMachine --&gt; DHCP\n    StateMachine --&gt; NetUtils\n    IPC --&gt; DataMgmt\n    IPC --&gt; StateMachine\n    Telemetry --&gt; DataMgmt\n    WebConfig --&gt; TR181\n    DHCP --&gt; NetUtils</code></pre>"},{"location":"docu/templateOct10/wanmanager/#component-interactions","title":"Component Interactions","text":""},{"location":"docu/templateOct10/wanmanager/#middleware-components-system-layers","title":"Middleware Components &amp; System Layers","text":"<p>WAN Manager serves as a central coordination point in the RDK-B middleware stack, interacting with multiple components to provide comprehensive WAN connectivity management. The component maintains both control-plane interactions for configuration and management, and data-plane coordination for network traffic handling.</p> <pre><code>flowchart TD\n    subgraph \"External Services\"\n        CloudMgmt[Cloud Management]\n        HeadEnd[Head-end Services]\n        WebUI[Web Management UI]\n    end\n\n    subgraph \"RDK-B Middleware Layer\"\n        WanManager[WAN Manager]\n        CcspDM[CCSP Data Model]\n        DHCPManager[DHCP Manager]\n        VLANManager[VLAN Manager]\n        TelemetryMgr[Telemetry Manager]\n        TR069Agent[TR-069 Agent]\n        WebConfigFW[WebConfig Framework]\n        FirewallMgr[Firewall Manager]\n    end\n\n    subgraph \"Interface Management Layer\"\n        DOCSISMgr[DOCSIS Manager]\n        CellularMgr[Cellular Manager]\n        EthernetMgr[Ethernet Manager]\n        DSLMgr[DSL Manager]\n        GPONMgr[GPON Manager]\n    end\n\n    subgraph \"HAL/Platform Layer\"\n        HALLayer[(HAL Interfaces)]\n        NetworkStack[Linux Network Stack]\n        SysEvents[System Events]\n        PSM[(PSM Storage)]\n    end\n\n    CloudMgmt --&gt;|WebConfig JSON/HTTPS| WanManager\n    HeadEnd --&gt;|TR-069 Parameters| TR069Agent\n    WebUI --&gt;|HTTP Management| WanManager\n    WanManager --&gt;|RBus Parameters| CcspDM\n    WanManager --&gt;|RBus Messages| DHCPManager\n    WanManager --&gt;|RBus Events| VLANManager\n    WanManager --&gt;|Telemetry Data| TelemetryMgr\n    WanManager --&gt;|Parameter Updates| TR069Agent\n    WanManager --&gt;|Configuration API| WebConfigFW\n    WanManager --&gt;|Interface Events| FirewallMgr\n    WanManager --&gt;|RBus Status| DOCSISMgr\n    WanManager --&gt;|RBus Control| CellularMgr\n    WanManager --&gt;|RBus Events| EthernetMgr\n    WanManager --&gt;|RBus Messages| DSLMgr\n    WanManager --&gt;|RBus Interface| GPONMgr\n    WanManager --&gt;|System Calls| HALLayer\n    WanManager --&gt;|Network Commands| NetworkStack\n    WanManager --&gt;|Event Publishing| SysEvents\n    WanManager --&gt;|Configuration Storage| PSM\n\n    classDef external fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n    classDef middleware fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef interface fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;\n    classDef hal fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n\n    class CloudMgmt,HeadEnd,WebUI external;\n    class WanManager,CcspDM,DHCPManager,VLANManager,TelemetryMgr,TR069Agent,WebConfigFW,FirewallMgr middleware;\n    class DOCSISMgr,CellularMgr,EthernetMgr,DSLMgr,GPONMgr interface;\n    class HALLayer,NetworkStack,SysEvents,PSM hal;</code></pre> <p>Component Interactions:</p> Component/Layer Purpose of Interaction Protocols/Mechanisms Middleware Components CCSP Data Model TR-181 parameter registration and management RBus data model APIs, parameter notifications DHCP Manager IP address configuration and lease management RBus messaging for DHCP requests and status VLAN Manager 802.1Q VLAN configuration on WAN interfaces RBus events for VLAN setup and teardown Telemetry Manager System metrics and performance data collection Telemetry 2.0 APIs for event publishing TR-069 Agent Remote device management and configuration Parameter value updates via RBus WebConfig Framework Bulk configuration management from cloud WebConfig APIs with JSON configuration Firewall Manager WAN interface status for routing decisions RBus events for active interface changes Interface Management Layer DOCSIS Manager Physical DOCSIS interface control and status RBus status subscriptions and control messages Cellular Manager LTE/5G interface management and connectivity RBus interface control and event notifications Ethernet Manager Ethernet WAN interface configuration RBus status monitoring and configuration System Layers HAL Interfaces Low-level hardware abstraction Direct function calls to HAL APIs Linux Network Stack Network interface and routing configuration System calls (ip, ifconfig, route commands) System Events System-wide event notification Sysevent publish/subscribe mechanisms PSM Storage Persistent configuration and state storage PSM APIs for parameter storage and retrieval External Services Cloud Management Remote configuration and monitoring HTTPS/WebConfig, encrypted communication Head-end Services Service provider management systems TR-069 over TLS, standardized protocols <p>Published Events:</p> <p>WAN Manager publishes several critical events that other RDK-B components subscribe to for coordination and system-wide awareness of WAN connectivity status:</p> Event Purpose of Event Reason for Trigger <code>wan-interface-active</code> Notify system of active WAN interface change Interface selection policy determines new active interface <code>wan-connectivity-established</code> Signal successful internet connectivity validation DNS connectivity check and internet validation complete <code>wan-connectivity-lost</code> Alert system to loss of internet connectivity Connectivity validation failure or interface down event <code>wan-failover-initiated</code> Indicate start of failover process to backup interface Primary interface failure triggers failover policy <code>wan-failover-completed</code> Confirm successful failover to backup interface Backup interface established and connectivity validated <code>wan-interface-config-changed</code> Notify of WAN interface configuration updates TR-181 parameter changes or WebConfig updates applied <code>wan-dhcp-lease-acquired</code> Signal successful DHCP IP address acquisition DHCPv4/DHCPv6 lease obtained on WAN interface <code>wan-dhcp-lease-lost</code> Alert to DHCP lease expiration or loss DHCP lease renewal failure or interface reset"},{"location":"docu/templateOct10/wanmanager/#ipc-mechanism","title":"IPC Mechanism","text":"<p>WAN Manager employs a dual IPC architecture supporting both RBus (modern) and DBus (legacy) protocols to ensure compatibility across different RDK-B platform generations while providing optimal performance for real-time WAN management operations.</p> Type of IPC Message Format Mechanism RBus (Primary) JSON-structured messages with typed parameters, event subscriptions, and method invocations RBus library with direct method calls, event publishing, and parameter get/set operations DBus (Legacy) CCSP-formatted XML messages with parameter trees and component registration DBus message bus with CCSP protocol for TR-181 parameter access System Events Key-value string pairs with event names and data payloads Sysevent publish/subscribe for system-wide notifications IPC Server (Internal) Custom binary protocol for Interface Manager communication Unix domain sockets with message queuing and acknowledgment <p>WAN Manager implements a comprehensive IPC framework that handles both synchronous request-response patterns for configuration operations and asynchronous event-driven communication for real-time status updates and coordination with other RDK-B components.</p> <pre><code>sequenceDiagram\n    participant InterfaceMgr as Interface Manager\n    participant WanMgr as WAN Manager\n    participant RBusInfra as RBus Infrastructure\n    participant DHCPMgr as DHCP Manager\n    participant SysEvents as System Events\n\n    Note over InterfaceMgr,SysEvents: Interface Status Update Flow\n\n    InterfaceMgr-&gt;&gt;RBusInfra: Publish Interface Event\n    RBusInfra-&gt;&gt;WanMgr: Event Notification (RBus)\n    WanMgr-&gt;&gt;WanMgr: Process Interface Change\n    WanMgr-&gt;&gt;DHCPMgr: Request IP Configuration (RBus)\n    DHCPMgr--&gt;&gt;WanMgr: Configuration Status (RBus)\n    WanMgr-&gt;&gt;SysEvents: Publish WAN Status Change\n    SysEvents--&gt;&gt;InterfaceMgr: System Event Notification\n\n    Note over WanMgr,DHCPMgr: Configuration Request Flow\n\n    WanMgr-&gt;&gt;RBusInfra: Set Parameter Request\n    RBusInfra-&gt;&gt;DHCPMgr: Parameter Update (RBus)\n    DHCPMgr-&gt;&gt;DHCPMgr: Apply Configuration\n    DHCPMgr--&gt;&gt;RBusInfra: Response Status\n    RBusInfra--&gt;&gt;WanMgr: Configuration Complete\n\n    Note over WanMgr,SysEvents: Event Publishing Flow\n\n    WanMgr-&gt;&gt;SysEvents: Publish Event (key-value)\n    SysEvents-&gt;&gt;SysEvents: Distribute to Subscribers\n    SysEvents--&gt;&gt;WanMgr: Publish Acknowledgment</code></pre>"},{"location":"docu/templateOct10/wanmanager/#implementation-details","title":"Implementation Details","text":""},{"location":"docu/templateOct10/wanmanager/#major-hal-apis-integration","title":"Major HAL APIs Integration","text":"<p>WAN Manager integrates with several key HAL APIs to provide low-level network interface control and hardware abstraction. The component primarily relies on standard Linux networking APIs but also interfaces with platform-specific HAL implementations for advanced features.</p> <p>Core HAL APIs:</p> HAL API Purpose Parameters Return Values Implementation File <code>platform_hal_GetBaseMacAddress</code> Retrieve device base MAC address for interface configuration <code>char *pValue</code> (output buffer) <code>RETURN_OK</code>/<code>RETURN_ERR</code> <code>wanmgr_net_utils.c</code> <code>platform_hal_setLED</code> Control WAN connectivity LED indicators <code>PLATFORM_LED led</code>, <code>PLATFORM_LED_STATE state</code> <code>RETURN_OK</code>/<code>RETURN_ERR</code> <code>wanmgr_interface_sm.c</code> <code>docsis_hal_GetNumOfActiveTxChannels</code> Get DOCSIS active channel count for interface validation <code>ULONG *pValue</code> (output) <code>RETURN_OK</code>/<code>RETURN_ERR</code> <code>wanmgr_policy_autowan_impl.c</code> <code>mta_hal_GetDHCPInfo</code> Retrieve MTA DHCP configuration for telephony interfaces <code>PMTAMGMT_MTA_DHCP_INFO pInfo</code> <code>RETURN_OK</code>/<code>RETURN_ERR</code> <code>wanmgr_dhcpv4_apis.c</code> <code>ethernet_hal_getEthWanLinkStatus</code> Check Ethernet WAN physical link status <code>BOOLEAN *pLinkStatus</code> <code>RETURN_OK</code>/<code>RETURN_ERR</code> <code>wanmgr_interface_sm.c</code>"},{"location":"docu/templateOct10/wanmanager/#key-implementation-logic","title":"Key Implementation Logic","text":"<p>WAN Manager implements a sophisticated multi-layered state management system that coordinates interface selection policies, individual interface state machines, and system-wide connectivity validation to provide reliable WAN connectivity management.</p> <ul> <li> <p>Policy Engine Architecture: Core policy implementation resides in <code>wanmgr_controller.c</code> with specialized policy algorithms in dedicated files (<code>wanmgr_policy_autowan_impl.c</code>, <code>wanmgr_policy_parallel_scan_impl.c</code>). Each policy engine maintains its own state and coordinates with the central controller for interface selection decisions.</p> </li> <li> <p>Interface State Machine: Individual interface lifecycle management implemented in <code>wanmgr_interface_sm.c</code> with comprehensive state transitions covering physical validation, IP configuration, connectivity testing, and active monitoring. Each interface maintains independent state while coordinating through shared data structures.</p> </li> <li> <p>Event Processing: Asynchronous event handling system processes hardware interface changes, DHCP events, and connectivity validation results through event queues with priority-based processing to ensure responsive system behavior during network transitions.</p> </li> <li> <p>Error Handling Strategy: Multi-level error handling with graceful degradation includes interface-specific error recovery, policy-level fallback mechanisms, and system-wide error reporting. Failed interface attempts are tracked and temporarily blacklisted to prevent rapid retry cycles.</p> </li> <li> <p>Connectivity Validation: Internet connectivity validation implemented through DNS resolution tests, HTTP connectivity checks, and ping-based reachability tests with configurable validation parameters and timeout handling for reliable connectivity detection.</p> </li> <li> <p>Logging &amp; Debugging: Comprehensive logging system with categorized log levels (ERROR, WARNING, INFO, DEBUG) and component-specific prefixes. Debug mode provides detailed state machine transitions, policy decision logging, and IPC message tracing for troubleshooting connectivity issues.</p> </li> </ul>"},{"location":"docu/templateOct10/wanmanager/#key-configuration-files","title":"Key Configuration Files","text":"<p>WAN Manager utilizes several configuration files and data sources to manage its operation, from compile-time parameter definitions to runtime configuration storage and persistent state management.</p> Configuration File Purpose Key Parameters Default Values Override Mechanisms RdkWanManager.xml TR-181 data model definitions Parameter tree structure, access permissions, function mappings N/A (schema definition) Compile-time customization with preprocessor directives RdkWanManager_v2.xml Enhanced TR-181 model with extended features Virtual interface support, advanced VLAN configuration N/A (schema definition) Feature flags and platform-specific builds syscfg database Persistent WAN configuration storage <code>wan_policy</code>, <code>wan_interface_priority</code>, <code>restoration_delay</code> <code>AUTOWAN_MODE</code>, <code>1</code>, <code>60</code> TR-181 parameter updates, WebConfig PSM storage Runtime parameter persistence Interface states, DHCP configurations, connectivity status Component defaults Dynamic updates via RBus/DBus /etc/debug.ini Debug logging configuration Log levels, component-specific debugging <code>INFO</code> level Runtime modification via file edits WebConfig JSON Cloud-based bulk configuration Complete WAN policy and interface configuration Platform defaults Cloud management system updates <p>The configuration system supports hierarchical override mechanisms where cloud-based WebConfig takes precedence over local TR-181 settings, which in turn override compiled defaults, ensuring flexible deployment while maintaining configuration consistency across device lifecycles.</p>"},{"location":"entertainment/docs/","title":"Home","text":"Getting Started with RDK for Entertainment architecture Architecture <p>The latest release of RDK7 comes with major changes in its architecture, including Firebolt and the vendor porting kit.</p> Read More arrow_forward list Apps <p>A defining strength of any modern platform lies in the robust facilities it offers for seamless app development and integration</p> Read More arrow_forward devices Device Profiles <p>From the fundamental RDK IP STB to RDK TV, RDK offers a variety of device profiles.</p> Read More arrow_forward try Try Out RDK <p>The best way to experience RDK is to try out RDK youself in a platform. Get yourself started in exploring RDK.</p> Read More arrow_forward book Vendor Porting Guide <p>Understand the various HAL APIs that need to be implemented in order to complete the RDK Porting.</p> Read More arrow_forward layers RDK Components <p>Understand the architecture of each RDK component,the component interfaces as well as other layers of RDK.</p> Read More arrow_forward"},{"location":"entertainment/docs/Apps/","title":"Application Support in RDK","text":"<p>Applications are a core part of the RDK experience, acting as a bridge between service providers and end users. The RDK app ecosystem enables operators and developers to deliver rich, secure, and high-performance applications, leveraging platform services, device capabilities, and standardized APIs for video devices.</p> <ul> <li>OTT &amp; Entertainment: Streaming services, live TV, interactive content.</li> <li>Gaming &amp; Interactive: Lightweight games and interactive user interfaces.</li> <li>Operator Services: Exclusive apps and third-party service integrations.</li> </ul>"},{"location":"entertainment/docs/Apps/#supported-application-types","title":"Supported Application Types","text":"<p>RDK supports multiple app types tailored to different needs, ranging from lightweight UIs to high-performance native tools:</p> App Type Key Benefits Lightning\u2122 Apps Optimized for TVs/STBs, smooth performance, Thunder API support HTML5 / Web Apps Built on standard web tech, easy to deploy, flexible integration Native Apps Direct hardware access, maximum performance Firebolt\u2122 Apps Secure runtime, standardized APIs, source-independent development"},{"location":"entertainment/docs/Apps/#rdk-application-frameworks","title":"RDK Application Frameworks","text":"<p>To enable application development, lifecycle management, and integration, RDK provides two major frameworks:</p>"},{"location":"entertainment/docs/Apps/#firebolttm","title":"Firebolt\u2122","text":"<p>Firebolt\u2122 enables developers to create Lightning\u2122, HTML5, or native applications without needing direct access to the RDK source code. It offers a standardized set of interfaces for accessing system resources and services, along with a comprehensive runtime environment for testing and executing applications during development. Designed to simplify onboarding, the framework empowers developers with the flexibility to implement solutions independently of the underlying platform https://rdkcentral.github.io/firebolt/</p>"},{"location":"entertainment/docs/Apps/#lightningtm","title":"Lightning\u2122","text":"<p>Lightning\u2122 - the JavaScript based app development language - provides a lightweight, highly-efficient UI framework for app developers. https://www.lightningjs.io/</p>"},{"location":"entertainment/docs/architecture/","title":"Architecture","text":"<p>RDK Video (RDK-V ) Architecture is designed to enable service providers and device manufacturers to develop and deploy innovative video applications, services, and user experiences. It consists of several key components that work together seamlessly to provide a robust video platform.</p> <p>By leveraging the pluggable architecture of RDK-V, a variety of target device profiles can be supported, ranging from a basic IP streaming video platform to a full-fledged TV.</p> <ul> <li>IP provides a common method to manage video playback functions. The IP client device serves as an interface and receives video content from an in-home gateway device or from an external media server.</li> <li>Hybrid is an IP video platform device with capabilities such as tuning and conditional access for its video delivery to manage hybrid video functions.</li> <li>TV is an open-source smart TV profile that allows manufacturers and operations to build RDK-based TV and video solutions.</li> <li>RDK Hybrid TV is a combination of TV plus Hybrid capabilities such as tuning, conditional access, etc.</li> </ul>"},{"location":"entertainment/docs/architecture/#evolution-of-rdk","title":"Evolution of RDK","text":"<p>From RDK6, RDK-V shifted from quarterly to annual release cycles. This annual RDK release aims to synchronize RDK-V with standard industry release practices while comprehensively addressing shared challenges within the community. This approach facilitates the smoother and more consistent adoption of newly contributed features, utilizing the latest releases from technology partners. By aligning with SoC partners, the release enables better resource planning to support core RDK-V platforms. Furthermore, the RDK-V release aligns with SoC, OEM, and app releases, fostering a more cohesive and efficient ecosystem. The first annual release is RDK6, and its release notes can be accessed from RDK6 Release Notes.</p> <p></p>"},{"location":"entertainment/docs/architecture/#architecture-details","title":"Architecture Details","text":"<p>Below is an illustrative representation of the RDK-V software stack, depicting the various components and their interactions.</p> <p></p> <p>At its core, RDK-V consists of five main stack levels, each serving a specific purpose in the overall architecture. These levels are as follows:</p>"},{"location":"entertainment/docs/architecture/#applications","title":"Applications","text":"<p>The application layer primarily focuses on the end-user experience. This layer contains applications that provide various services, content, and features to the users. While the RDK-V ecosystem is continuously evolving, supported applications typically include popular OTT services like Netflix, Amazon Prime Video, and YouTube, alongside native broadcaster applications and other services.</p>"},{"location":"entertainment/docs/architecture/#application-platform","title":"Application Platform","text":"<p>The Application Platform Layer in the RDK-V ecosystem offers essential tools for developers to create applications. It includes components like a UI framework , HTML5 rendering engine, and a JavaScript runtime . This layer acts as a communication channel, serving as a middleware between applications and core RDK-V services. In the RDK-V framework, Firebolt\u00ae handles UI rendering and user input, enabling extensive customization. Lightning\u2122, an open-source JavaScript platform, manages the application lifecycle and integrates components using WebGL for rendering. Together, Firebolt\u00ae and Lightning\u2122 form a robust foundation for seamless and efficient application development in the RDK-V ecosystem.</p> <p>Firebolt\u00ae 1.0 (Ripple) - Firebol\u00ae 1.0 (Ripple) streamlines RDK-V app integration with standardized rules. Ripple, its open-source Rust-based Application gateway, facilitates dynamic extensions and serves as a Firebolt\u00ae gateway. RDK 6 is Firebolt\u00ae 1.0-certified, with a comprehensive test suite for compliance.</p> <p>Security - The Application Platform Layer ensures robust security with Dobby-managed containerization, leveraging Linux kernel features for process isolation. Downloadable Application Containers (DAC) enable the secure running of binary applications on\u00a0video platforms without modification, ensuring compatibility across RDK 6 devices. Access control is enforced through AppArmor, a proactive Linux security system. RDKM's open-sourced AppArmor profile generator tool for RDK 6 provides fine-grained control over process resources, contributing to a secure environment.</p>"},{"location":"entertainment/docs/architecture/#rdk-middleware","title":"RDK Middleware","text":"<p>Serving as a vital bridge between the Application Platform Layer and the hardware (HAL), the RDK Middleware Layer incorporates essential components that are pivotal for the seamless operation of the RDK-V platform. Core to this layer are RDK services, providing JSON-RPC services for interactive applications. In the realm of security, iCrypto handles critical cryptographic operations, ensuring secure communication and data protection. Rialto offers a secure solution for AV pipelines in containerized applications, and the Window Manager orchestrates GUI layout. Device management enables streamlined operations in RDK deployments, including bulk operations and firmware downloads. XCONF integration revolutionizes code downloads for a smoother deployment experience. Log uploads aid in comprehensive debugging, offering insights into system performance. RDK Feature Control (RFC) enables dynamic feature management for enhanced flexibility. Telemetry systematically collects essential data insights, while WebPA ensures secure communication between cloud servers and RDK devices. The Media Player, crucial for local rendering devices, manages various pipeline functions, supporting IP and QAM playback. The Open Content Decryption Module(OCDM) enforces Digital Rights Management (DRM) policies. Together with other RDK-V elements, these components ensure the efficient and secure functioning of the RDK-V platform.</p>"},{"location":"entertainment/docs/architecture/#rdk-hal-hardware-abstraction-layer","title":"RDK HAL (Hardware Abstraction Layer)","text":"<p>In the RDK-V stack, the HAL layer plays a vital role in facilitating communication between the video application software and hardware components like the GPU, video encoding/decoding hardware, and audio devices. It provides a standardized framework for functions, data structures, and protocols, enabling efficient hardware resource utilization. The HAL layer manages hardware initialization, input/output operations, and hardware-specific events, shielding software developers from hardware complexities and allowing them to prioritize user experience and functionality.</p> <p>RDK-V provides a set of HAL APIs that abstract the platform from RDK. Vendors need to implement the HAL APIs to meet the HAL specifications. With the help of the HAL API specification for different RDK-V components, vendors can successfully port RDK-V to their platform. Depending on the device profile (IP, TV, Hybrid, etc.), vendors may choose the relevant components and perform the port by implementing the HAL layer. For more details on the vendor porting process, refer to the Vendor Porting Guide.</p>"},{"location":"entertainment/docs/architecture/#soc","title":"SOC","text":"<p>The System on Chip (SOC) layer forms the foundational interface between hardware components, ensuring system security and reliability. It incorporates various crucial elements, such as DRM Libraries, which manage digital rights and secure content delivery to prevent unauthorized access and distribution. Trusted Applications (Apps TA) guarantee the secure execution of sensitive operations and protect critical data from unauthorized access. The Secure Store oversees the storage of DRM keys and apps triplets, maintaining the confidentiality and integrity of vital data. Additionally, MFR Libraries manage hardware functionality, providing access to specific hardware features and capabilities, thereby contributing to the overall security and functionality of the system.</p>"},{"location":"entertainment/docs/architecture/#application-scenario","title":"Application Scenario","text":"<p>Consider the use case of a user accessing a streaming application like Youtube on an RDK Video-supported device. The user interacts with the application through the Application Layer, selecting content and initiating playback. The Application Platform Layer, utilizing the Firebolt\u00ae and Lightning\u2122 frameworks, manages the user interface and application lifecycle. The RDK-V Layer ensures seamless communication between the application and the hardware, managing services, cryptographic operations, inter-component communication, window management, and content decryption through OpenCDM. The RDK HAL Layer then utilizes the Gstreamer media pipeline to decode and render the video content, ensuring a smooth and high-quality viewing experience. Finally, the SOC Layer provides a secure environment for the entire system, safeguarding the hardware, managing DRM policies, and securing sensitive data, ensuring a secure and reliable video streaming experience for the user.</p>"},{"location":"entertainment/docs/architecture/#useful-links","title":"Useful Links","text":"<p>RDK-V:</p> <p>You can find an overview of the RDK-V platform, detailing its key features and functionalities at RDK Video Documentation.</p> <p>Applications:</p> <p>To get the information about various applications supported by the RDK-V, aiding in understanding the diverse application landscape refer RDK Video Accelerator - Applications.</p> <p>Application Development:</p> <p>Developers interested in RDK-V application development using Firebolt \u00ae can refer Firebolt\u00ae Overview,</p> <p>Developers interested in RDK-V application development using Lightning\u2122 the inhouse JavaScript framework - can refer Lightning\u2122 Framework.</p> <p>Security:</p> <p>Understanding the concept of containerization in RDK-V is crucial for ensuring secure and efficient application deployment, and the 'Containerization in RDK' document provides in-depth insights into this aspect.</p> <p>To learn about the implementation and benefits of Downloadable Application Containers (DAC) within the RDK-V ecosystem, the 'DAC Documentation' offers comprehensive guidance for developers.</p> <p>For insight into the Access Control Mechanism in RDK-V using AppArmor, developers can refer to the 'AppArmor Documentation' to understand how to enforce security policies and restrict application access within the RDK-V environment.</p>"},{"location":"entertainment/docs/rdk6-architecture/","title":"Architecture","text":"<p>RDK Video (RDK-V) Architecture is designed to enable service providers and device manufacturers to develop and deploy innovative video applications, services, and user experiences. It consists of several key components that work together seamlessly to provide a robust video platform.</p> <p>By leveraging the pluggable architecture of RDK-V, a variety of target device profiles can be supported, ranging from a basic IP streaming video platform to a full-fledged TV.</p> <ul> <li>IP provides a common method to manage video playback functions. The IP client device serves as an interface and receives video content from an in-home gateway device or from an external media server.</li> <li>Hybrid is an IP video platform device with capabilities such as tuning and conditional access for its video delivery to manage hybrid video functions.</li> <li>TV is an open-source smart TV profile that allows manufacturers and operations to build RDK-based TV and video solutions.</li> </ul> <p>Note</p> <p>RDK Hybrid TV is a combination of TV plus Hybrid capabilities such as tuning, conditional access, etc.</p>"},{"location":"entertainment/docs/rdk6-architecture/#evolution-of-rdk","title":"Evolution of RDK","text":"<p>Info</p> <p>From RDK6, RDK-V shifted from quarterly to annual release cycles. </p> <p>The annual RDK release aims to synchronize RDK-V with standard industry release practices while comprehensively addressing shared challenges within the community. This approach facilitates the smoother and more consistent adoption of newly contributed features, utilizing the latest releases from technology partners. By aligning with SoC partners, the release enables better resource planning to support core RDK-V platforms. Furthermore, the RDK-V release aligns with SoC, OEM, and app releases, fostering a more cohesive and efficient ecosystem. The first annual release is RDK6, and its release notes can be accessed from RDK6 Release Notes.</p> <p></p>"},{"location":"entertainment/docs/rdk6-architecture/#architecture-details","title":"Architecture Details","text":"<p>Below is an illustrative representation of the RDK-V software stack, depicting the various components and their interactions.</p> <p></p> <p>At its core, RDK-V consists of five main stack levels, each serving a specific purpose in the overall architecture. These levels are as follows:</p>"},{"location":"entertainment/docs/rdk6-architecture/#applications","title":"Applications","text":"<p>The application layer primarily focuses on the end-user experience. This layer contains applications that provide various services, content, and features to the users. While the RDK-V ecosystem is continuously evolving, supported applications typically include popular   OTT services like Netflix, Amazon Prime Video, and YouTube, alongside native broadcaster applications and other services</p>"},{"location":"entertainment/docs/rdk6-architecture/#application-platform","title":"Application Platform","text":"<p>The Application Platform Layer in the RDK-V ecosystem offers essential tools for developers to create applications. It includes components like a  UI framework, HTML5 rendering engine, and a JavaScript runtime.This layer acts as a communication channel, serving as a middleware between applications and core RDK-V services. In the RDK-V framework, Firebolt\u00ae handles UI rendering and user input, enabling extensive customization.  Lightning\u2122, an open-source JavaScript platform, manages the application lifecycle and integrates components using WebGL for rendering. Together, Firebolt\u00ae and Lightning\u2122 form a robust foundation for seamless and efficient application development in the RDK-V ecosystem. Firebolt\u00ae 1.0 (Ripple) - Firebol\u00ae 1.0 (Ripple) streamlines RDK-V app integration with standardized rules. Ripple, its open-source Rust-based Application gateway, facilitates dynamic extensions and serves as a Firebolt\u00ae gateway. RDK 6 is Firebolt\u00ae 1.0-certified, with a comprehensive test suite for compliance. Security - The Application Platform Layer ensures robust security with Dobby-managed containerization, leveraging Linux kernel features for process isolation. Downloadable Application Containers (DAC) enable the secure running of binary applications on\u00a0video platforms without modification, ensuring compatibility across RDK 6 devices. Access control is enforced through AppArmor, a proactive Linux security system. RDKM's open-sourced AppArmor profile generator tool for RDK 6 provides fine-grained control over process resources, contributing to a secure environment.</p>"},{"location":"entertainment/docs/rdk6-architecture/#rdk-middleware","title":"RDK Middleware","text":"<p>Serving as a vital bridge between the Application Platform Layer and the hardware (HAL), the RDK Middleware Layer incorporates essential components that are pivotal for the seamless operation of the RDK-V platform. Core to this layer are RDK services, providing JSON-RPC services for interactive applications. In the realm of security,  iCrypto handles critical cryptographic operations, ensuring secure communication and data protection.  Rialto offers a secure solution for AV pipelines in containerized applications, and the Window Manager orchestrates GUI layout. Device management enables streamlined operations in RDK deployments, including bulk operations and firmware downloads. XCONF integration revolutionizes code downloads for a smoother deployment experience. Log uploads aid in comprehensive debugging, offering insights into system performance. RDK Feature Control (RFC) enables dynamic feature management for enhanced flexibility. Telemetry systematically collects essential data insights, while WebPA ensures secure communication between cloud servers and RDK devices. The Media Player, crucial for local rendering devices, manages various pipeline functions, supporting IP and QAM playback. The Open Content Decryption Module(OCDM) enforces Digital Rights Management (DRM) policies. Together with other RDK-V elements, these components ensure the efficient and secure functioning of the RDK-V platform.</p>"},{"location":"entertainment/docs/rdk6-architecture/#rdk-hal-hardware-abstraction-layer","title":"RDK HAL (Hardware Abstraction Layer)","text":"<p>In the RDK-V stack, the HAL layer plays a vital role in facilitating communication between the video application software and hardware components like the GPU, video encoding/decoding hardware, and audio devices. It provides a standardized framework for functions, data structures, and protocols, enabling efficient hardware resource utilization. The HAL layer manages hardware initialization, input/output operations, and  hardware-specific events, shielding software developers from hardware complexities and allowing them to prioritize user experience and functionality.</p> <p>RDK-V provides a set of HAL APIs that abstract the platform from RDK. Vendors need to implement the HAL APIs to meet the HAL specifications. With the help of the HAL API specification for different RDK-V components, vendors can successfully port RDK-V to their platform. Depending on the device profile (IP, TV, Hybrid, etc.), vendors may choose the relevant components and perform the port by implementing the HAL layer. For more details on the vendor porting process, refer to the Vendor Porting Guide.</p>"},{"location":"entertainment/docs/rdk6-architecture/#soc","title":"SOC","text":"<p>The System on Chip (SOC) layer forms the foundational interface between hardware components, ensuring system security and reliability. It incorporates various crucial elements, such as DRM Libraries, which manage digital rights and secure content delivery to prevent unauthorized access and distribution. Trusted Applications (Apps TA) guarantee the secure execution of sensitive operations and protect critical data from unauthorized access. The  Secure Store oversees the storage of DRM keys and apps triplets, maintaining the confidentiality and integrity of vital data. Additionally, MFR Libraries manage hardware functionality, providing access to specific hardware features and capabilities, thereby contributing to the overall security and functionality of the system.</p>"},{"location":"entertainment/docs/rdk6-architecture/#application-scenario","title":"Application Scenario","text":"<p>Consider the use case of a user accessing a streaming application like Youtube on an RDK Video-supported device. The user interacts with the application through the Application Layer, selecting content and initiating playback. The Application Platform Layer, utilizing the Firebolt\u00ae and Lightning\u2122 frameworks, manages the user interface and application lifecycle. The RDK-V Layer ensures seamless communication between the application and the hardware, managing services, cryptographic operations, inter-component communication, window management, and content decryption through OpenCDM. The RDK HAL Layer then utilizes the Gstreamer media pipeline to decode and render the video content, ensuring a smooth and high-quality viewing experience. Finally, the SOC Layer provides a secure environment for the entire system, safeguarding the hardware, managing DRM policies, and securing sensitive data, ensuring a secure and reliable video streaming experience for the user.</p>"},{"location":"entertainment/docs/rdk6-architecture/#useful-links","title":"Useful Links","text":"<p>Access Restriction</p> <p>Some links on this page may be restricted. For the best experience, please make sure you are logged in. If you do not have an account, you can sign up at https://wiki.rdkcentral.com/signup.action. If you are logged in but still cannot access certain content, please contact support@rdkcentral.com for assistance.</p> <p>RDK-V:</p> <p>You can find an overview of the RDK-V platform, detailing its key features and functionalities at RDK Video Documentation.</p> <p>Application Development:</p> <p>Developers interested in RDK-V application development using Firebolt \u00ae can refer Firebolt\u00ae Overview,</p> <p>Developers interested in RDK-V application development using Lightning\u2122 the inhouse JavaScript framework - can refer Lightning\u2122 Framework.</p> <p>Security:</p> <p>Understanding the concept of containerization in RDK-V is crucial for ensuring secure and efficient application deployment, and the 'Containerization in RDK' document provides in-depth insights into this aspect.</p> <p>To learn about the implementation and benefits of Downloadable Application Containers (DAC) within the RDK-V ecosystem, the 'DAC Documentation' offers comprehensive guidance for developers.</p> <p>For insight into the Access Control Mechanism in RDK-V using AppArmor, developers can refer to the 'AppArmor Documentation' to understand how to enforce security policies and restrict application access within the RDK-V environment.</p>"},{"location":"entertainment/docs/rdk6-features/","title":"RDK-V Features","text":"<p>RDK is a community-based project that enables developers, vendors, and cable operators to utilize a defined stack of software on one layer for provisioning set-top boxes and gateways. Unique features of RDK, such as its commitment to open source, the speed, and flexibility of RDK-based devices, set it apart from conventional set-top software stacks.</p> <p>The standardized RDK\u2010V stack provides a common method for managing complex video and management functions, including rendering, content, content security, device management, networking, and peripherals.</p> <p>The RDK\u2010V Feature List is categorized based on the following functions. Enhancements and new features are developed and contributed asynchronously by members of the RDK Community.</p> <p>Note</p> <p>The device dependency in this context meant that the feature is only available in some OEM devices and not generally available in raspberry pi like reference devices. </p> Category Feature Description Supported by IP/Hybrid/TV Dependency (If any) Conditional Access DRM PlayReady 4.4 IP STB, Hybrid STB, and TV Device Dependency Widevine 16 IP STB, Hybrid STB, and TV Device Dependency Common SVP IP STB, Hybrid STB, and TV Device Dependency Support HTML5 encrypted video via EME v3 for Widevine IP STB, Hybrid STB, and TV Device Dependency Conditional Access Verimatrix Hybrid Device Dependency AnyCAS Hybrid Device Dependency CommScope CableCard Decrypt, PPV Ready Hybrid Device Dependency Technicolor CableCard Decrypt, PPV Ready Hybrid Device Dependency DTCP DTCP integration Hybrid-media client No Device Security Input sanitization IP STB, Hybrid STB, and TV NO Upgrade to OpenSSL 1.1.1.l IP STB, Hybrid STB, and TV NO Upgrade to NTP 4.2.8.p11 IP STB, Hybrid STB, and TV NO Run applications in a secure container IP STB, Hybrid STB, and TV NO Secure bootloader IP STB, Hybrid STB, and TV Device Dependency Security DAC (Containerization) using Dobby IP STB, Hybrid STB, and TV NO Rialto IP STB, Hybrid STB, and TV NO Packager (Lisa) IP STB, Hybrid STB, and TV NO AppArmor IP STB, Hybrid STB, and TV NO Kernel Hardening IP STB, Hybrid STB, and TV Device Dependency Build &amp; Platform Yocto version Yocto 3.1 (Dunfell) IP STB, Hybrid STB, and TV NO Kernel Android common kernel IP STB, Hybrid STB, and TV NO Init system Systemd v244 (Yocto 3.1) IP STB, Hybrid STB, and TV NO Application Manager RDK Shell IP STB, Hybrid STB, and TV NO Video Player IP UVE (AAMP) IP STB, Hybrid STB, and TV NO QAM UVE via RMF (QAMSrc) Hybrid STB Device Dependency DVB (Mediarite) UVE via RMF Hybrid STB Device Dependency DVB (DTVKit) Sessionmanager via RMF Hybrid STB NO TSB Fog IP STB, Hybrid STB, and TV NO DAC Apps RIALTO NO Content Related Adaptive Bit Rate HLS (HLS v3 and HLS v4) IP STB, Hybrid STB, and TV NO MPEG-DASH IP STB, Hybrid STB, and TV NO HTML-5 Video (MSE/ESE) IP STB, Hybrid STB, and TV NO MPEG-DASH (Native) IP STB, Hybrid STB, and TV NO Audio Output Formats Stereo IP STB, Hybrid STB, and TV NO Dolby Digital IP STB, Hybrid STB, and TV Device Dependency Dolby ATMOS IP STB, Hybrid STB, and TV Device Dependency Dolby Digital Plus (7.1 Channels) IP STB, Hybrid STB, and TV Device Dependency Split HDMI and SPDIF audio outputs IP STB, Hybrid STB, and TV Device Dependency Bit stream Pass-through IP STB, Hybrid STB, and TV Device Dependency Dolby MS12 IP STB, Hybrid STB, and TV Device Dependency Audio Tracks SAP, DVS IP STB, Hybrid STB, and TV Device Dependency Codecs H264 IP STB, Hybrid STB, and TV NO MPEG2, VP8, VP9, High Efficiency Video Coding (HEVC) (H.265/MPEG-H Part 10) IP STB, Hybrid STB, and TV Device Dependency HDR 10 Bit (HEVC HLS) for IP settop IP STB, Hybrid STB, and TV Device Dependency Captions 608, 708, subtec VTT IP STB, Hybrid STB Region Dependency Delivery Broadcast, Video on Demand IP STB, Hybrid STB, and TV NO Video over Wi-Fi Ready IP STB, Hybrid STB, and TV Device Dependency Secondary Audio Output to Bluetooth devices IP STB, Hybrid STB, and TV Device Dependency IP Multiroom Music Playback (STB to Speakers) IP STB, Hybrid STB, and TV Device Dependency DVB Broadcast DVB support Hybrid STB, and TV Device Dependency Subtitles IP STB Device Dependency Teletext Hybrid STB, and TV Device Dependency In-Band System Information Hybrid STB Device Dependency EAS QAM EAS Hybrid STB NO IP EAS TV NO UHD/4K RDKServices for 4K and HDR capability information across devices IP STB, Hybrid STB, and TV Device Dependency Supports IP Time Shift Buffer for DASH Linear content IP STB, Hybrid STB, and TV NO Content Delivery Video Input Formats MPEG2, H.264, VP8 (h264 for RPI4) TV, IP STB NO Video Output Resolutions 480i (not in Amlogic), 480p, 720p, 1080i, 1080p IP STB, Hybrid STB, and TV NO Ultra HD/4K, Advanced High Dynamic Range (HDR) IP STB, Hybrid STB, and TV Device Dependency Dolby Vision Advanced HDR for VOD IP STB, Hybrid STB, and TV Device Dependency HDR 10 IP STB, Hybrid STB, and TV Device Dependency Video Over WiFi UPnP IP STB, Hybrid STB, and TV VOD IP VOD IP STB, Hybrid STB, and TV Ad Insertion Ad Insertion Client Side Ad Insertion (Linear Segmented Advertisement) Hybrid STB Device Dependency Server side Ad Insertion IP STB Cloud Dependency Ad Insertion \u2013 Linear Segmented Advertising LSA support for ad content read failure Hybrid STB Cloud Dependency LSA support for back-to-back ads Hybrid STB Cloud Dependency IP DAI Handle DASH IP VOD Dynamic Ad Insertion (DAI) Transitions IP STB and TV Cloud Dependency Rendering Framework Firebolt V1.0 IP STB, Hybrid STB, and TV NO Ripple IP STB, Hybrid STB, and TV NO Lightning V2.8 IP STB, Hybrid STB, and TV NO QT for BLE V5.1.1 OSS version IP STB, Hybrid STB, and TV NO Core Thunder framework Version R2 IP STB, Hybrid STB, and TV NO Browser - WPEWebkit V2.28 IP STB, Hybrid STB, and TV NO Browser Engine QT WebKit IP STB, Hybrid STB, and TV NO WebKit Pure Embedded integration IP STB, Hybrid STB, and TV NO Connection Security SSL/TLS IP STB, Hybrid STB, and TV NO Plugins WebRTC IP STB, Hybrid STB, and TV NO Graphics OpenGL ES IP STB, Hybrid STB, and TV NO Rendering ESSOS with Westeros IP STB, Hybrid STB, and TV NO Gstreamer Gstreamer 1.18 IP STB, Hybrid STB, and TV NO Device Management Feature Control Securing RFC parameters via encryption IP STB, Hybrid STB, and TV NO RFC with Xconf rules IP STB, Hybrid STB, and TV NO Firmware Download Enhancements Omit IP Address From Xconf Firmware Download Request IP STB, Hybrid STB, and TV NO Firmware Upgrade-SWUpdate with XConf and Webpa IP STB, Hybrid STB, and TV NO Logging TFTP Log Upload, HTTP Log Upload IP STB, Hybrid STB, and TV Cloud Dependency Distribute (smear) logging uploads (dependent on XCONF Server) IP STB, Hybrid STB, and TV Cloud Dependency Memory Optimization Use Flash/SD Card for Firmware Download Temporary Storage (CDL scratchpad) IP STB, Hybrid STB, and TV Device Dependency Platform Enhancements Common WiFi HAL for RDK Video IP STB, Hybrid STB, and TV NO Converge to GCC V9.3x for all Yocto versions IP STB, Hybrid STB, and TV NO Power Standby, Light Sleep IP STB, Hybrid STB, and TV NO Deep Sleep on IP Clients IP STB and TV Device Dependency Power Save Supports ability to enable HDMI port while in standby mode IP STB, Hybrid STB, and TV Device Dependency Remote Management TR-069 IP STB, Hybrid STB, and TV Cloud Dependency WebPA (IP Clients) IP STB NO WebPA (QAM Clients) Hybrid STB NO ssh (secure shell into the device)/ reverse ssh (send trigger to have device initiate ssh) IP STB, Hybrid STB, and TV Cloud Dependency Feature Control (Remotely enable/disable individual features on devices without new code deployment) IP STB, Hybrid STB, and TV Cloud Dependency Resource Optimization Improved handling of app termination/suspension conditions (based on available memory rather than concurrency) IP STB, Hybrid STB, and TV NO Revenant Persistent WiFi Enable/Disable IP STB, Hybrid STB, and TV NO Self Healing Supports hardware self test IP STB, Hybrid STB, and TV Device Dependency Thermal Monitoring and Shutdown | IP STB, Hybrid STB, and TV NO Telemetry Telemetry 2.0 (via WebPA) NO TR-181 Object Telemetry IP STB, Hybrid STB, and TV Cloud Dependency IP Video Telemetry IP STB, Hybrid STB, and TV NO WiFi Band &amp; AP Steering Dual Band WiFi IP STB and TV NO Networking WAN IP eSTB IPv4 IP STB, Hybrid STB, and TV NO IPv6 for IP clients IP STB, Hybrid STB, and TV NO LAN IP Auto IP, DHCP, Dual Virtual Hybrid STB NO Wi-Fi IP STB, Hybrid STB, and TV NO LAN IP STB, Hybrid STB, and TV NO Wi-Fi WPA Enterprise (IP settop to use Wi-Fi 802.1x authentication) Ready IP STB and TV Device Dependency Ports/Peripherals Audio Output Ports Bluetooth Audio Output Ready IP STB, Hybrid STB, and TV Device Dependency HDMI HDMI Out, HDCP Enforcement IP STB, Hybrid STB, and TV NO HDMI In TV Device Dependency HDMI Consumer Electronics Control (HDMI-CEC) Power Sync IP STB, Hybrid STB, and TV NO HDMI Switching (Combine CEC and HDMI Input features to enable advanced switching) TV Device Dependency USB WebRTC Camera Ready IP STB, Hybrid STB, and TV Device Dependency USB Port Detection and Control Ready IP STB, Hybrid STB, and TV Device Dependency USB Camera Support Ready IP STB, Hybrid STB, and TV Device Dependency WebRTC HW acceleration for encode/decode to enhance performance IP STB, Hybrid STB, and TV NO USB Filesystem Support IP STB, Hybrid STB, and TV NO USB Hot-plug IP STB, Hybrid STB, and TV NO User Input RF4CE remote IP STB, Hybrid STB, and TV Device and Cloud Dependency BLE voice remote IP STB, Hybrid STB, and TV NO External Audio support IP STB, Hybrid STB, and TV Device Dependency IR Remote IP STB, Hybrid STB, and TV Device Dependency Voice Remote (RF4CE based) Ready IP STB, Hybrid STB, and TV Video Output Ports HDMI IP STB, Hybrid STB, and TV NO Apps Streaming Apps YouTube V23 and Amazon Prime V4 IP STB, Hybrid STB, and TV Device Dependency TV Settings Power, Standby TV NO LED TV NO Zoom, aspect ratio TV NO AQ/PQ QoS TV NO Screen cast Application Casting &amp; control DIAL V2.2.1 IP STB, Hybrid STB, and TV NO UI/UX Reference App IP STB, Hybrid STB, and TV NO Gaming HDMI-CEC DAL - Dynamic Auto Lipsync TV NO Low Latency Game Mode for HDMI Input TV NO Game Mode, Auto Low Latency Mode TV NO AQ/PQ TV Device dependency Digital Assistant (Voice) Alexa (Push to talk) IP STB, Hybrid STB, and TV NO Voice enabled Bluetooth remote IP STB, Hybrid STB, and TV NO Voice Assistant IP STB, Hybrid STB, and TV Device dependency"},{"location":"entertainment/docs/rdk7-architecture/","title":"RDK7 Architecture","text":"<p>RDK7 is the newest open source software release, representing the first release of RDK-E (Entertainment), evolving from the previous RDK-V (Video) platform. It supports both IP and TV video platforms, integrating over-the-top (OTT) video apps through the Firebolt\u2122 framework, standardizing interfaces for video playback, digital rights management (DRM), graphics, and security. RDK7 builds upon previous RDK releases to further simplify app development, enhance security, and standardize functionality across diverse set-top box hardware.</p> <p>The following key principles of RDK7 illustrate the areas of change and focus from RDK-V previous releases:</p> <p></p> <p>The Layered Design provides clear separation of functional responsibilities through distinct vendor, middleware, and application layers with independent development and update cycles. Hardware Abstraction reduces the cost of SoC/OEM deliver &amp; platform through standardized hardware abstraction layer (HAL) and simplified platform adaptation. Application Community focuses on standardization of portable 3rd party apps, consistent APIs for application developers, and Firebolt framework for OTT integration. Quality &amp; Robustness involves major transformation of delivery process to ensure quality, independent testing of each layer, and consistent development environment. Rapid Innovation is achieved through utilization of common tooling and patterns. Broadcast Functionality enables separation of broadcast technology from IP platform.</p> <p></p> <p>The architecture consists of three main layers. The Application Layer contains Firebolt Apps, Lightning UI, and Firebolt Framework. The Middleware Layer contains Thunder Framework, ENT Services, Media Framework, DRM Systems, and Device Management. The Vendor Layer contains HAL Implementation, Drivers, BSP, and Hardware Adaptation. The Application Layer connects to the Middleware Layer, which connects to the Vendor Layer.</p>"},{"location":"entertainment/docs/rdk7-architecture/#vendor-layer","title":"Vendor Layer","text":"<p>The objective of the vendor layer is to minimize the amount of code required per hardware platform, thereby reducing development time to support scalability. All vendor layer implementations must be fully compliant with the HAL specification to ensure compatibility with a common middleware build and provide standardized interfaces to the middleware layer, abstracting hardware differences.</p> <p>The vendor layer contains hardware-specific drivers, BSPs, and platform-specific adaptations. Responsibility for build systems, updates, and security identification related to deliverables lies with the vendor implementer. To support management and cross-layer compatibility, a minimal subset of component implementations is specified, such as the Linux Kernel version, core libraries, and patches.</p> <p>Reference open-source software is provided to enable reuse of common components; however, usage of these components is not mandatory for the vendor implementer. Manufacturing and serialization requirements and processes are defined in the Entertainment OS device specifications and must be followed accordingly. The vendor layer can be updated independently without affecting other layers.</p>"},{"location":"entertainment/docs/rdk7-architecture/#middleware-layer","title":"Middleware Layer","text":"<p>The middleware layer aims to provide a single, consistent implementation of core Entertainment device functionality. Middleware components are expected to utilize the Thunder framework to implement functionality in a standardized manner with unified orchestration, providing standardized APIs for the application layer to access device capabilities.</p> <p>The middleware layer includes core RDK components, media playback, DRM systems, and device management. Middleware components are developed separately and delivered as binary packages (IPK), though all components should be delivered in source code unless agreed as an exception. The middleware layer owner holds responsibility for the quality of all components within the layer, including open-source and community contributions.</p> <p>The middleware is designed to have the most simple, robust and co-operative implementation of the core functionality while enabling rapid innovation through common tooling and patterns. Reference open-source software is provided to allow re-use of common components, but the middleware is not obligated to use any of these components.</p>"},{"location":"entertainment/docs/rdk7-architecture/#application-layer","title":"Application Layer","text":"<p>The application layer is distinct from the lower layers in that it doesn't have a single layer owner. Instead, it's a set of tools and applications that harness the underlying layers to provide customer features directly or indirectly. The layer contains user-facing applications and experiences and includes the Firebolt framework for standardizing OTT app integration.</p> <p>Third-party applications should use the Firebolt APIs, providing consistent APIs for application developers, and it is assumed all 3rd party applications are 'untrusted'. The layer supports various application types including native, web-based, and hybrid applications, and can be updated independently of the middleware and vendor layers.</p> <p>Examples of Applications include:</p> <ul> <li>Application Runtimes:     \u00a0     Browsers or runtimes that support execution of application code</li> <li>3rd Party applications:     \u00a0     Standardized portable apps for consistent user experience<ul> <li>Immersive Device Experience:\u00a0A trusted application that provides the UI and business logic to allow eOS managed devices to be configured by the user and host the operating system interactions (e.g., Voice overlays and application orchestration)</li> </ul> </li> </ul> <p>The application layer enables rapid development and deployment of new features and services while standardizing portable 3rd party apps for consistent user experience.</p>"},{"location":"entertainment/docs/rdk7-architecture/#detailed-architecture","title":"Detailed Architecture","text":"<p>The detailed architecture diagram illustrates the complete RDK7 software stack, showing the relationships between the different layers and components:</p> <p></p> <p>The RDK7 architecture includes key components across multiple layers. The Hardware Layer at the bottom is the physical hardware, which varies by device manufacturer. The Vendor Layer sits directly above the hardware, providing the necessary drivers and adaptations. The Middleware Layer serves as the core of the RDK7 platform, providing standardized services and APIs. The Application Layer forms the top layer, containing user-facing applications and experiences. The Thunder Framework provides a unified approach to component development and communication. The Firebolt Framework standardizes interfaces for OTT applications and services. The architecture emphasizes clear separation of concerns, standardized interfaces between layers, and modular component design to enable independent development and updates of different parts of the system.</p>"},{"location":"entertainment/docs/rdk7-architecture/#build-system","title":"Build System","text":"<p>RDK7 introduces a revolutionary layered build approach that significantly improves development efficiency. The build setup is divided into independent Stack layer projects, each comprising components that are developed separately and delivered as binary packages (IPK). These stack layers are then assembled into the final image using the Image Assembler tool.</p> <p></p> <p>The build system architecture includes the Reference OSS Layer that serves as a reference Yocto distribution layer with CVE patches, the Vendor Layer that contains vendor-specific code and hardware adaptations, the RDK Middleware Layer that contains core RDK middleware components, and the Application Layer that contains user-facing applications and services. The RDKE framework serves as the backbone of this layered architecture, designed to work seamlessly with Yocto without disrupting its normal functionalities while requiring minimal maintenance. It accommodates layering requirements without modifying Yocto's default tasks or variables.</p>"},{"location":"entertainment/docs/rdk7-architecture/#build-system-directory-structure","title":"Build System Directory Structure","text":"<pre><code>\u251c\u2500\u2500 application\n\u2502 \u2514\u2500\u2500 meta-application-release\n\u251c\u2500\u2500 common\n\u2502 \u251c\u2500\u2500 meta-openembedded\n\u2502 \u251c\u2500\u2500 meta-oss-reference-release\n\u2502 \u251c\u2500\u2500 meta-rdk-auxiliary\n\u2502 \u251c\u2500\u2500 meta-rdk-halif-headers\n\u2502 \u251c\u2500\u2500 meta-rdk-oss-reference\n\u2502 \u251c\u2500\u2500 meta-stack-layering-support\n\u2502 \u2514\u2500\u2500 poky\n\u251c\u2500\u2500 configs\n\u2502 \u2514\u2500\u2500 common\n\u2514\u2500\u2500 product-layer\n\u2514\u2500\u2500 meta-rdke\n</code></pre>"},{"location":"entertainment/docs/rdk7-architecture/#key-benefits-of-layered-builds","title":"Key Benefits of layered builds","text":"<p>The layered build approach offers several key benefits across multiple areas.\u00a0</p> <ul> <li>Scalability     is achieved as each layer can be updated independently without affecting or relying on other layers, and updating only the vendor layer can be achieved by using the latest tag from that layer and applying it to the stack.</li> <li>Quality     is ensured through each layer undergoing unit testing and layer-specific testing prior to release, with all requirements validated during this process and fully tested and tagged versions of the IPKs produced for quality assurance.</li> <li>Easy debugging     is facilitated as developers are required to compile only their own projects, IPKs from other components can be consumed directly eliminating the need to build the entire set of components, tagged versions of application cases can be used to verify individual components, and overall build time is significantly reduced.</li> <li>Less disk usage     is accomplished when working across multiple products as the middleware and application layers are designed to be as common as possible, the primary difference between products lies in the vendor layer, multiple vendor layers can be checked out and modified while using shared IPKs in the application layer, and this approach eliminates the need to check out the entire codebase for each product significantly saving disk space.</li> <li>Consistent development environment     is maintained as each developer builds components against tagged versions of other components, ensuring that regressions or issues in unrelated components do not affect development, and only tested and tagged versions are used.</li> </ul> <p>The RDKE framework accommodates specific requirements for the layered build system by resolving both direct and indirect interlayer build dependencies, generating proper packaging metadata for runtime dependencies, creating IPKs without disrupting layer and interlayer runtime dependency chains, supporting installation of specific release versions of layer packages, creating target rootfs using both development packages and release layer IPKs, and supporting prebuilt kernels and device trees.</p>"},{"location":"entertainment/docs/rdk7-architecture/#component-interaction-flow","title":"Component Interaction Flow","text":"<p>The typical flow of a request through the RDK7 stack:</p> <p></p> <p>The system follows a standardized request-response flow where the Application sends request to Firebolt Framework, Firebolt Framework translates request for ENT Services, ENT Services processes request and sends to Thunder Framework, Thunder Framework processes request and sends to Hardware Abstraction Layer, HAL executes command on Hardware, Hardware returns result to HAL, HAL processes result and sends to Thunder Framework, Thunder Framework formats response and sends to ENT Services, ENT Services translates response for Firebolt Framework, and Firebolt Framework returns result to Application. This standardized flow ensures consistent behavior across different hardware platforms and enables rapid innovation through common patterns.</p>"},{"location":"entertainment/docs/rdk7-architecture/#application-scenario","title":"Application Scenario","text":"<p>Consider the use case of a user accessing a streaming application like YouTube on an RDK7 Entertainment-supported device. The user interacts with the YouTube application through the Application Layer, selecting content and initiating playback, where the application utilizes the Firebolt Framework for standardized OTT app integration as a 3rd party 'untrusted' application. The Firebolt Framework translates the user's request into standardized API calls and sends them to the Thunder Framework, which processes the request using unified orchestration and coordinates between different middleware components with standardized communication patterns. The ENT Services within the Middleware Layer handle core Entertainment device functionality, including the Media Framework for video decoding and rendering, DRM Systems for content protection and digital rights management, and device management for optimal performance. The Hardware Abstraction Layer in the Vendor Layer executes commands on the hardware using standardized HAL specifications that abstract hardware differences across different SoC platforms, while the physical hardware processes the video content leveraging GPU, video encoding/decoding hardware, and audio devices. The response flows back through the same standardized path in reverse - hardware returns results to HAL, which processes and sends to ENT Services, then to Thunder Framework for translation, and finally the Firebolt Framework returns the result to the Application. This standardized request-response flow ensures consistent behavior across different hardware platforms while enabling rapid innovation through common patterns and modular component design, providing a seamless and secure YouTube streaming experience for the user with clear separation of concerns across the three-layer architecture.</p>"},{"location":"entertainment/docs/rdk7-features/","title":"RDK7 Features","text":"Category Sub-category Version details AV Player Gstreamer, AAMP AV Pipeline RIALTO Application Support / Prerequisites Container OCI Runtime + Dobby Firebolt Implementation Ripple DRM PlayReady 4.4, Widevine v16 Connectivity Ethernet &amp; Wi-Fi Bluetooth Bluetooth Bluez Remote Control Casting DIAL, Wi-Fi Direct (Miracast) Peripherals/Ports HDMI, USB, Optical Framework Thunder Thunder 4.4 Browser WPE Webkit 2.38 Interfaces /IPC Application Interfaces Firebolt Hardware / SOC interfaces RDK HAL Inter Process Communication IARM, RBUS, DBUS Protocol - Device Management TR69hostif AV Driver interface V4l2 Graphics and Rendering Graphics &amp; Rendering OpenGL 3.2 Composition Westeros / ESSOS, Wayland Build &amp; Platform Kernel ACK 5.15 64-bit Kernel SOC SDK BCM URSR25.1, RTK v1.2, AML 6.16 Silicon Broadcom, Amlogic, Realtek Build Framework Yocto 4.0 (Kirkstone) Logging support (Debugging) RDK Logger Firmware Upgrade Applications Native Apps / Runtimes Cobalt 25Amazon AVPK6 Application Management / Composition RDKShell Application Bundle LISA App checkpoint/restore MemCR Access Control AppArmor Casting Secure Time Manager Device management Device Management Web PA, XConf, Telemetry Debugging Gaming Support Game controller DAB Non root user support"},{"location":"entertainment/docs/rdk7-vendor-porting-guide/","title":"RDK7 Vendor Porting Guide","text":"<p>RDK License</p> <p>Vendors are advised to get into an agreement with RDK Management LLC to obtain the free license to use the complete RDK Code base in their platform.  </p> <p>More details about licenses are available at rdkcentral.com/licenses. Please email info@rdkcentral.com if you have additional questions about licenses or membership.</p> <p>This document helps vendors understand how to create a successful port of RDK on their platform with the help of the HAL API Specification for different RDK Components, as well as how the port can be successfully certified. Depending on the device profile ( IP STB or IP TV), vendors may choose the relevant components and perform the port by implementing the HAL layer.</p> <p>Note</p> <p>Details of how to port third-party software stacks or applications to a SoC platform are out of the scope of this porting guide.</p>"},{"location":"entertainment/docs/rdk7-vendor-porting-guide/#version-details","title":"Version details","text":"RDK Version Vendor Porting Kit Version Applicability RDK 7 1.4.5 IP STB, IP TV profiles"},{"location":"entertainment/docs/rdk7-vendor-porting-guide/#prerequisites","title":"Prerequisites","text":"<p>The vendor is expected to have certain prerequisites before proceeding to the porting process, which include:</p> <ul> <li> <p>RDK device profile:</p> <ul> <li>Decide on the profile by referring to the available RDK profiles ( IP STB or IP TV ) and have a platform with the expected capabilities for the chosen profile. Depending on the device profile selected, the components that are required to be ported are available in the HAL table below. </li> </ul> </li> <li> <p>RDK HAL API Source code access:</p> <ul> <li>The RDK source code is distributed across multiple source code repositories which are available in RDK Central GitHub</li> </ul> </li> <li> <p>Platform-specific Kernel:</p> <ul> <li>It is highly recommended to use ACK for the target platform as RDK7 is recommended to run on top of ACK 5.15 64-bit version</li> </ul> </li> </ul>"},{"location":"entertainment/docs/rdk7-vendor-porting-guide/#porting","title":"Porting","text":"<p>The Hardware Porting Kit ( HPK ) provide both Hardware Abstraction Layer (API) Header files, and software tests to ensure compatibility with the RDK Middleware Stack. HPK enables vendor to implement the required interfaces that will enable them to bring RDK on top of their platform. Once the HAL layer for each component is implemented, vendors can use the respective test component to certify their port.</p> <p>The elaborated documentation on HAL APIs, the test suites and how to build and execute them are all available at the HPK Documentation portal.</p> <p>Info</p> <p>For an exhaustive list of component versions, as well as test suite versions for each HAL component, please refer to the following table:</p> # Component Name HAL Interface Version Change Info Previous HAL Testing Suite Version Change Info Previous Current Change Info Previous Current Change Info Previous 1 Deep Sleep Manager No change 1.0.4 No change 1.3.0 2 Power Manager No change 1.0.3 No change 1.4.0 3 Device Settings 4.1.2 4.1.1...4.1.2 4.1.1 No change 3.5.0 4 HDMI CEC 1.3.10 1.3.9...1.3.10 1.3.9 No change 1.4.0 5 RMF Audio Capture No change 1.0.5 No change 1.4.0 6 RDK-V TVSettings No change 2.1.0 No change 2.1.3 7 RDK-V WiFi No change 2.0.0 No change 1.0.0 8 LibDRM No change 1.0.0 NYA 9 AvSync No change 1.0.0 NYA 10 V4L2 No change 1.0.0 NYA"},{"location":"entertainment/docs/rdk7-vendor-porting-guide/#certification","title":"Certification","text":"<p>While the test suite associated with the vendor porting kit helps to certify the port is working as expected, RDK certification program facilitates users to get their product certified as an RDK compliance device.</p> <p>RDKM provides the RDK Certification Suites RDK Certification suite\u00a0to verify the compliance of the RDK Video Accelerator device. The certification program includes testing that validates the RDK stack on the user platform with a defined test suite called the RDK Certification Test Suite. It is mandatory to go through this program in order to brand the user\u2019s platform as an RDK-compliant product.</p>"},{"location":"entertainment/docs/rdkv_components/","title":"Components List","text":"Component Name Documentation Source code RDK Shell RDK Shell GitHub Westeros Westeros GitHub"},{"location":"entertainment/docs/tryout_rdkv_rdk7/","title":"Try Out RDK7","text":"<p>This guide provides step-by-step instructions to create your own build and play around RDK using the popular open source platform Raspberry Pi 4 as the target device. The document covers the pre-requisites, build instructions , and detailed flashing instructions to get your Raspberry Pi up and running with RDK</p>"},{"location":"entertainment/docs/tryout_rdkv_rdk7/#before-you-begin","title":"Before you begin","text":"<p>If you prefer to use a pre-compiled image - so that you can proceed with flashing the image - please download a precompiled image for Raspberry Pi 4 from here and go to section flashing-instruction</p> <p>Access restrictions</p> <p>The download link requires you to have the free rdk licensee account. If you do not have, please signup here. If you already have an account, sign in here and then click on the above link of pre-compiled image</p> <p>If you prefer to compile an RDK image from scratch and then try it out, please proceed to next section</p>"},{"location":"entertainment/docs/tryout_rdkv_rdk7/#pre-requisites","title":"Pre requisites","text":""},{"location":"entertainment/docs/tryout_rdkv_rdk7/#host-setup","title":"Host Setup","text":"Requirement Yocto 4.0 (Kirkstone) Linux - 64 bit Ubuntu 20.04 LTS  - Shell BASH  System requirements Free HDD Space - RDKE OSS: 75GB  - RDKE Vendor: 50GB  - RDKE Middleware: 120GB  - RDKE Application: 50GB  - RDKE Image Assembler: 30GB Host Tools Versions - Git 1.8.3.1 or greater  - tar 1.28 or greater  - Python 3.9.0 or greater  - gcc 10.1 or greater  - GNU make 4.0 or greater Raspberry Pi Kit RPI4 <p>Python Path</p> <p>Ensure that python exists in <code>/usr/bin/python</code>. If not, create a softlink for <code>/usr/bin/python</code> to python executable. <pre><code>$ which python\n# should give\n/usr/bin/python\n</code></pre></p> <p>Host Setup</p> <p>The instructions provided below are meant to be executed via the command line on an Ubuntu machine.</p> <pre><code># essential package installation\n# super user mode is required\n# major essential packages\n$ sudo apt install ant build-essential chrpath cmake curl diffstat fd g++ g++-multilib gcc gcc-multilib \\\\\ngit git-flow git-man jq libbz2-dev libffi-dev libglib2.0-dev libldap2-dev liblzma-dev libncurses5-dev \\\\\nlibreadline-dev libsasl2-dev libsqlite3-dev libslang2-dev libssl-dev libxml2-dev libxmlsec1-dev \\\\\nllvm make nnn python3.8 ripgrep sysstat texinfo tk-dev tree wget \\\\\nxz-utils zip zlib1g-dev zstd\n</code></pre> <p>Locale Requirement</p> <p>You also need to ensure you have the en_US.UTF-8 locale enabled. bash locale --all-locales | grep en_US.utf8 <pre><code>$ bash locale --all-locales | grep en_US.utf8\n</code></pre></p>"},{"location":"entertainment/docs/tryout_rdkv_rdk7/#configure-repo","title":"Configure repo","text":"<p>In order to use Yocto build system, first you need to make sure that repo is properly installed on the machine:</p> <pre><code># create a bin directory\n$ mkdir ~/bin\n$ export PATH=~/bin:$PATH\n# Download the repo tool and ensure that it is executable\n$ curl http://commondatastorage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo\n$ chmod a+x ~/bin/repo\n</code></pre> <p>Credentials</p> <p>It is also recommended to put credentials in .netrc when interacting with the repo.</p> <p>A sample .netrc file is illustrated below. <pre><code># RDK Central Gerrit\nmachine code.rdkcentral.com\n    login &lt;RDK Central SSO email address&gt;\n    password &lt;PAT&gt;\n\n# RDK Central Github\nmachine github.com\n    login &lt;Public GitHub UserID&gt;\n    password &lt;PAT&gt;\n</code></pre></p>"},{"location":"entertainment/docs/tryout_rdkv_rdk7/#creating-your-pat","title":"Creating your PAT","text":"<p>PAT Requirement</p> <p>Without proper PATs, you will not be able to clone, push, or interact with RDK Gerrit/GitHub repositories.</p> <p>Gerrit</p> <p>Set your Gerrit PAT here: https://code.rdkcentral.com/r/settings/#HTTPCredentials</p> <p></p> <p>GitHub</p> <p>For GitHub to create a PAT navigate to Settings - Developer Settings - Personal access tokens - Tokens (classic)</p> <ul> <li>https://github.com/settings/profile     \u2190 click on     \"Developer settings\"     here</li> </ul> <p>GitHub PAT Scopes</p> <p>For Git actions (clone/push/pr) you need to select at least the following scopes:  - repo  - write:packages</p> <p></p>"},{"location":"entertainment/docs/tryout_rdkv_rdk7/#build-steps","title":"Build Steps","text":"<p>The following steps describe how to build each of the required layers and finally generate a full stack image by building the image assembler layer.</p> <p>Layer Dependency</p> <p>Each layer depends on the IPKs generated by the previous layer.  The IPK paths given are examples only \u2014 the actual path will depend on how you store your IPKs.</p>"},{"location":"entertainment/docs/tryout_rdkv_rdk7/#oss-layer","title":"OSS Layer","text":"<p><pre><code>$ repo init -u \"https://github.com/rdkcentral/rdke-oss-manifest/\" -b refs/tags/4.6.2-community -m rdk-arm.xml\n$ repo sync\n$ MACHINE=rdk-arm64 source ./scripts/setup-environment\n$ bitbake lib32-packagegroup-oss-layer\n</code></pre> This produces IPK objects that can be packaged into the OSS IPK feed. The OSS IPK feed is located in <code>build-rdk-arm64/tmp/deploy/ipk/rdk-arm64-oss/</code> </p> <ul> <li> <p>Locate the <code>opkg-make-index</code> utility that is part of the native built components. For OSS layer, this should be located in <code>build-rdk-arm64/tmp/work/x86_64-linux/opkg-utils-native/0.5.0-r0/git/opkg-make-index</code></p> </li> <li> <p>Run the opkg-make-index utility to create the IPK Package index <pre><code>$ ./build-rdk-arm64/tmp/work/x86_64-linux/opkg-utils-native/0.5.0-r0/git/opkg-make-index ./build-rdk-arm64/tmp/deploy/ipk/rdk-arm64-oss/ &gt; ./build-rdk-arm64/tmp/deploy/ipk/rdk-arm64-oss/Packages\n</code></pre></p> </li> <li> <p>Compress the package index <pre><code>$ cd build-rdk-arm64/tmp/deploy/ipk/rdk-arm64-oss/\n$ gzip -c9 Packages &gt; Packages.gz\n</code></pre></p> </li> <li> <p>Copy or rsync the IPK feed into a location in the local file system, e.g. Rsyncing from <code>./build-rdk-arm64/tmp/deploy/ipk/rdk-arm64-oss/*</code> to <code>${HOME}/community_shared/rdk-arm64-oss/4.6.2-community/ipk/</code></p> </li> </ul> <p>OSS layer is a common layer and not platform specific. The above-mentioned configuration is building OSS for arm64 machine and can be reused for any platforms with the same configuration.</p>"},{"location":"entertainment/docs/tryout_rdkv_rdk7/#vendor-layer","title":"Vendor Layer","text":"<p><pre><code>$ repo init -u \"https://github.com/rdkcentral/vendor-manifest-raspberrypi/\" -b refs/tags/RDK7-1.0.0 -m rdke-raspberrypi.xml\n$ repo sync\n</code></pre> Setup the IPK feed(s): Please note for local IPK feed in local file system, the <code>\"file:/\"</code> prefix and the <code>\"/\"</code> suffix are important.</p> <ul> <li>OSS IPK feed Modify this file: <code>rdke/common/meta-oss-reference-release/conf/machine/include/oss.inc</code> and set <code>OSS_IPK_SERVER_PATH</code> to the IPK feed location in the local file system, e.g: <pre><code>OSS_IPK_SERVER_PATH = \"file:/${HOME}/community_shared/rdk-arm64-oss/4.6.2-community/ipk/\"\n</code></pre></li> </ul> <p><pre><code>$ MACHINE=raspberrypi4-64-rdke source ./scripts/setup-environment\n$ echo 'DEPLOY_IPK_FEED = \"1\"' &gt;&gt; conf/local.conf\n$ bitbake lib32-packagegroup-vendor-layer (to build vendor layer IPK feed for other layers to consume)\nOR\n$ bitbake lib32-vendor-test-image (wrapper over packagegroup-vendor-layer to compile a bootable vendor layer test image)\n</code></pre> At least  one of packagegroup or test-image is required to be successful to produce the IPK feed for the next layer. The produced IPK objects that can be found at <code>./build-raspberrypi4-64-rdke/tmp/deploy/ipk/raspberrypi4-64-rdke-vendor/</code></p> <ul> <li>Copy or rsync the IPK feed into a location in the local file system, e.g. Rsyncing from <code>./build-raspberrypi4-64-rdke/tmp/deploy/ipk/raspberrypi4-64-rdke-vendor/*</code> to <code>${HOME}/community_shared/raspberrypi4-64-rdke-vendor/RDK7-1.0.0/ipk/</code></li> </ul>"},{"location":"entertainment/docs/tryout_rdkv_rdk7/#middleware-layer","title":"Middleware Layer","text":"<pre><code>$ repo init -u \"https://github.com/rdkcentral/middleware-manifest-rdke/\" -b refs/tags/RDK7-1.0.0 -m raspberrypi4-64.xml\n$ repo sync\n</code></pre> <p>Setup the IPK feed(s): Please note for local IPK feed in local file system, the <code>\"file:/\"</code> prefix and the <code>\"/\"</code> suffix are important</p> <ul> <li> <p>OSS IPK feed Modify the file <code>rdke/common/meta-oss-reference-release/conf/machine/include/oss.inc</code> and set <code>OSS_IPK_SERVER_PATH</code> to the IPK feed location in the local file system, e.g. <pre><code>OSS_IPK_SERVER_PATH = \"file:/${HOME}/community_shared/rdk-arm64-oss/4.6.2-community/ipk/\"\n</code></pre></p> </li> <li> <p>Vendor IPK feed Modify the file <code>rdke/vendor/meta-vendor-release/conf/machine/include/vendor.inc</code> and set <code>VENDOR_IPK_SERVER_PATH</code> to the IPK feed location in the local file system, e.g. <pre><code>VENDOR_IPK_SERVER_PATH = \"file:/${HOME}/community_shared/raspberrypi4-64-rdke-vendor/RDK7-1.0.0/ipk/\"\n</code></pre></p> </li> </ul> <pre><code>$ MACHINE=raspberrypi4-64-rdke source ./scripts/setup-environment\n$ echo 'DEPLOY_IPK_FEED = \"1\"' &gt;&gt; conf/local.conf\n$ bitbake lib32-packagegroup-middleware-layer (to build middleware layer IPK feed for other layers to consume)\nOR\n$ bitbake lib32-middleware-test-image (wrapper over packagegroup-middleware-layer to compile a bootable middleware layer test image)\n</code></pre> <p>At least  one of packagegroup or test-image  is required to be successful to produce the IPK feed for the next layer. The produced IPK objects that can be packaged into the Middleware IPK feed can be found at <code>./build-raspberrypi4-64-rdke/tmp/deploy/ipk/raspberrypi4-64-rdke-middleware/</code></p> <ul> <li>Copy or rsync the IPK feed into a location in the local file system, e.g. Rsyncing from <code>./build-raspberrypi4-64-rdke/tmp/deploy/ipk/raspberrypi4-64-rdke-middleware/*</code> to <code>${HOME}/community_shared/raspberrypi4-64-rdke-middleware/RDK7-1.0.0/ipk/</code></li> </ul>"},{"location":"entertainment/docs/tryout_rdkv_rdk7/#application-layer","title":"Application Layer","text":"<pre><code>$ repo init -u \"https://github.com/rdkcentral/application-manifest-rdke/\" -b refs/tags/RDK7-1.0.0 -m raspberrypi4-64.xml\n$ repo sync\n</code></pre> <p>Setup the IPK feed(s): Please note for local IPK feed in local file system, the <code>\"file:/\"</code> prefix and the <code>\"/\"</code> suffix are important</p> <ul> <li> <p>OSS IPK feed Modify the file <code>rdke/common/meta-oss-reference-release/conf/machine/include/oss.inc</code> and set <code>OSS_IPK_SERVER_PATH</code> to the IPK feed location in the local file system. e.g. <pre><code>OSS_IPK_SERVER_PATH = \"file:/${HOME}/community_shared/rdk-arm64-oss/4.6.2-community/ipk/\"\n</code></pre></p> </li> <li> <p>Vendor IPK feed Modify the file <code>rdke/vendor/meta-vendor-release/conf/machine/include/vendor.inc</code> and set <code>VENDOR_IPK_SERVER_PATH</code> to the IPK feed location in the local file system. e.g. <pre><code>VENDOR_IPK_SERVER_PATH = \"file:/${HOME}/community_shared/raspberrypi4-64-rdke-vendor/RDK7-1.0.0/ipk/\"\n</code></pre></p> </li> <li> <p>Middleware IPK feed Modify the file <code>rdke/middleware/meta-middleware-release/conf/machine/include/middleware.inc</code> and set <code>MW_IPK_SERVER_PATH</code> to the IPK feed location in the local file system. e.g. <code>MW_IPK_SERVER_PATH = \"file:/${HOME}/community_shared/raspberrypi4-64-rdke-middleware/RDK7-1.0.0/ipk/\"</code></p> </li> </ul> <pre><code>$ MACHINE=raspberrypi4-64-rdke source ./scripts/setup-environment\n$ echo 'DEPLOY_IPK_FEED = \"1\"' &gt;&gt; conf/local.conf\n$ bitbake lib32-packagegroup-application-layer (to build application layer IPK feed for other layers to consume)\nOR\n$ bitbake lib32-application-test-image (wrapper over packagegroup-application-layer to compile a bootable application layer test image)\n</code></pre> <p>At least  one of packagegroup or test-image is required to be successful to produce the IPK feed for the next layer. The produced IPK objects that can be packaged into the Application IPK feed can be found at <code>./build-raspberrypi4-64-rdke/tmp/deploy/ipk/raspberrypi4-64-rdke-application/</code></p> <ul> <li>Copy or rsync the IPK feed into a location in the local file system. e.g. Rsyncing from <code>./build-raspberrypi4-64-rdke/tmp/deploy/ipk/raspberrypi4-64-rdke-application/*</code> to <code>${HOME}/community_shared/raspberrypi4-64-rdke-application/RDK7-1.0.0/ipk/</code></li> </ul>"},{"location":"entertainment/docs/tryout_rdkv_rdk7/#image-assembler","title":"Image Assembler","text":"<pre><code>$ repo init -u \"https://github.com/rdkcentral/image-assembler-manifest-rdke/\" -b refs/tags/RDK7-1.0.0 -m raspberrypi4-64.xml\n$ repo sync\n</code></pre> <p>Setup the IPK feed(s): Please note for local IPK feed in local file system, the <code>\"file:/\"</code> prefix and the <code>\"/\"</code> suffix are important</p> <ul> <li> <p>OSS IPK feed Modify the file <code>rdke/common/meta-oss-reference-release/conf/machine/include/oss.inc</code> and set <code>OSS_IPK_SERVER_PATH</code> to the IPK feed location in the local file system. e.g. <pre><code>OSS_IPK_SERVER_PATH = \"file:/${HOME}/community_shared/rdk-arm64-oss/4.6.2-community/ipk/\"\n</code></pre></p> </li> <li> <p>Vendor IPK feed Modify the file <code>rdke/vendor/meta-vendor-release/conf/machine/include/vendor.inc</code> and set <code>VENDOR_IPK_SERVER_PATH</code> to the IPK feed location in the local file system. e.g. <pre><code>VENDOR_IPK_SERVER_PATH = \"file:/${HOME}/community_shared/raspberrypi4-64-rdke-vendor/RDK7-1.0.0/ipk/\"\n</code></pre></p> </li> <li> <p>Middleware IPK feed Modify the file <code>rdke/middleware/meta-middleware-release/conf/machine/include/middleware.inc</code> and set <code>MW_IPK_SERVER_PATH</code> to the IPK feed location in the local file system. e.g. <code>MW_IPK_SERVER_PATH = \"file:/${HOME}/community_shared/raspberrypi4-64-rdke-middleware/RDK7-1.0.0/ipk/\"</code></p> </li> <li> <p>Application IPK feed Modify the file <code>rdke/application/meta-application-release/conf/machine/include/application.inc</code> and set <code>APPLICATION_IPK_SERVER_PATH</code> to the IPK feed location in the local file system. e.g. <code>APPLICATION_IPK_SERVER_PATH = \"file:/${HOME}/community_shared/raspberrypi4-64-rdke-application/RDK7-1.0.0/ipk/\"</code></p> </li> </ul> <pre><code>$ MACHINE=raspberrypi4-64-rdke source ./scripts/setup-environment\n$ bitbake lib32-rdk-fullstack-image (for full stack image)\n#(Final flash'able image will be present in ./build-raspberrypi4-64-rdke/tmp/deploy/images/raspberrypi4-64-rdke/&lt;imagename&gt;.wic.bz2)\n</code></pre>"},{"location":"entertainment/docs/tryout_rdkv_rdk7/#flashing-instructions","title":"Flashing Instructions","text":"<p>The micro SD card should be formatted before writing the RPI image to it. After flashing,\u00a0remove the SD card and insert it to the Raspberry Pi 4 device' SD card slot.</p> <p>SD Card Requirement</p> <p>The minimum SD card size recommended is 8GB Prefer 16GB or 32GB for apps support in RDK</p>"},{"location":"entertainment/docs/tryout_rdkv_rdk7/#using-linux","title":"Using Linux","text":"<p>Using dd on linux/macOS:</p> <pre><code>bzcat &lt;IMAGE_NAME&gt;.wic.bz2 | sudo dd of=/dev/sdb bs=4M iflag=fullblock oflag=direct conv=fsync\n</code></pre>"},{"location":"entertainment/docs/tryout_rdkv_rdk7/#using-windows","title":"Using Windows","text":"<p>Using balenaEtcher:</p> <p>To flash the image on an SD card, you will need to download the balenaEtcher application - https://www.balena.io/etcher/</p> <p>Steps</p> <ul> <li>Open the application \u2192 Select the image from your download folder</li> <li>Select the drive containing your SD card</li> <li>Click Flash to copy the image</li> </ul> <p> </p> <p>BalenaEtcher Stuck at 7%</p> <p>In some cases, latest versions of BalenaEtcher freeze at 7% flashing If this happens, downgrade to version 1.18.11.</p> <p></p> <p>Power on the Raspberry Pi:</p> <ul> <li>TV screen will display the default RDK UI as shown below.</li> </ul> <p></p> <ul> <li>To view the     Raspberry Pi's IP address(referred as machineIP from now), Go to     'Settings \u2192 Network Configuration \u2192 Network Info \u2192 check for 'IP Address'' .</li> </ul> <p></p> <ul> <li>For ssh, we can use <code>ssh root@ip-address</code></li> <li>For verifying the image details, we can use <code>cat /version.txt</code> command</li> </ul>"},{"location":"entertainment/docs/video_profiles/","title":"Placeholder page for RDK Device Profiles","text":""},{"location":"entertainment/docs/components/rdkshell/","title":"RDK Shell","text":"<p>RDKShell is a native component that serves as the foundational application management, composition, and input handling system within the RDK  ecosystem. It functions as a sophisticated window manager and compositor that provides comprehensive control over application lifecycle, display composition, and advanced input event processing for RDK powered set top boxes and TVs. integrates deeply with the Wayland display server protocol through Westeros and leverages Essos for flexible windowing system connectivity, enabling it to work seamlessly across different hardware platforms and display configurations.</p> <p>Note</p> <p>Wayland + Westeros + Essos: RDKShell uses these to ensure cross-platform compatibility and modern graphics integration.</p>"},{"location":"entertainment/docs/components/rdkshell/#design","title":"Design","text":"<p>RDKShell follows a modular, event\u2011driven design with clear separation of concerns:</p> <pre><code>graph TB\n    A[Main Loop&lt;br/&gt;rdkshell.cpp] --&gt; B[Compositor Controller&lt;br/&gt;compositorcontroller.cpp]\n    A --&gt; C[Essos Instance&lt;br/&gt;essosinstance.cpp]\n    A --&gt; D[Input Management&lt;br/&gt;linuxinput.cpp]\n    A --&gt; E[Communication Layer]\n\n    B --&gt; F[RDK Compositor&lt;br/&gt;Surface Management]\n    B --&gt; G[Animation System&lt;br/&gt;animation.cpp]\n    B --&gt; H[Application Registry]\n\n    C --&gt; I[Wayland Integration&lt;br/&gt;Westeros]\n    C --&gt; J[OpenGL Context&lt;br/&gt;GLES2]\n\n    D --&gt; K[Linux Input Handler&lt;br/&gt;Device Management]\n    D --&gt; L[Key Mapping&lt;br/&gt;linuxkeys.cpp]\n    D --&gt; M[Event Router]\n\n    E --&gt; N[JSON-RPC Handler&lt;br/&gt;servermessagehandler.cpp]\n    E --&gt; O[WebSocket Handler&lt;br/&gt;messageHandler.cpp]\n\n    style A fill:#e1f5fe\n    style B fill:#f3e5f5\n    style C fill:#e8f5e8\n    style D fill:#fff3e0\n    style E fill:#fce4ec</code></pre> Key Architectural Principles <p>\u2022 Event\u2011Driven Design - Central main loop coordinates all subsystems through timed events and callbacks \u2022 Modular Components - Each subsystem (compositor, input, communication) operates independently with well\u2011defined interfaces \u2022 Performance\u2011Focused - 40 FPS rendering loop with frame rate limiting and efficient resource management \u2022 Cross\u2011Platform Compatibility - Abstraction layers (Essos/Westeros) enable deployment across different hardware platforms \u2022 Extensible Communication - Multiple IPC protocols (JSON\u2011RPC, WebSocket) support diverse integration scenarios</p>"},{"location":"entertainment/docs/components/rdkshell/#graphics-and-windowing-integration","title":"Graphics and Windowing Integration","text":"<p>RDKShell builds upon industry-standard graphics technologies including OpenGL ES 2.0 for hardware-accelerated rendering and the Wayland display server protocol for modern windowing system integration. Through its use of Westeros, it can create Wayland surfaces and displays that applications can connect to, while Essos provides the flexibility to connect to either native windowing systems or existing Wayland compositors depending on the deployment scenario.</p> <p>Note</p> <p>Rendering strategies are dynamically selected based on available GPU/CPU capabilities.</p> <p>The graphics integration is designed to work efficiently across a wide range of hardware capabilities, from high-end devices with dedicated GPUs to resource-constrained embedded systems. The system automatically detects available graphics capabilities and adjusts its rendering strategies accordingly to provide optimal performance while maintaining visual quality.</p>"},{"location":"entertainment/docs/components/rdkshell/#threading-and-performance","title":"Threading and Performance","text":"<p>The system is designed with performance as a primary consideration, implementing a carefully tuned main loop that maintains consistent frame rates while handling multiple concurrent operations. The default 40 FPS rendering loop can be adjusted based on system capabilities and requirements. Memory monitoring and other background operations are handled in separate threads to avoid impacting the critical rendering path.</p> <p>Note</p> <p>Uses separate threads for background tasks to ensure smooth UI performance.</p> <p>The threading architecture is designed to minimize contention and maximize parallelism where possible. Critical operations are prioritized to ensure responsive user interaction, while background tasks are scheduled to use available system resources without interfering with real-time requirements. The system includes sophisticated timing and synchronization mechanisms to coordinate between different subsystems.</p>"},{"location":"entertainment/docs/components/rdkshell/#extension-and-plugin-system","title":"Extension and Plugin System","text":"<p>RDKShell includes a sophisticated extension system that allows for platform-specific customizations and additional functionality. The system supports Westeros plugins and includes built-in extensions for client control and extended input handling. This extensibility ensures that RDKShell can be adapted to specific hardware platforms and use cases while maintaining a consistent core architecture.</p> <p>The plugin system is designed with security and stability in mind, providing isolation between different extensions and the core system. Extensions can be loaded and unloaded dynamically, enabling flexible deployment scenarios and reducing memory usage when specific functionality is not required. The system includes comprehensive APIs for extensions to interact with the core functionality while maintaining appropriate access controls.</p>"},{"location":"entertainment/docs/components/rdkshell/#configuration-and-deployment-flexibility","title":"Configuration and Deployment Flexibility","text":"<p>The component supports extensive configuration through environment variables, configuration files, and runtime parameters. This includes display resolution control, memory monitoring thresholds, input device mappings, and permission systems. The configuration system is designed to support both development scenarios with extensive debugging capabilities and production deployments with optimized performance characteristics.</p> <p>Note</p> <p>Configuration changes can be applied at runtime where possible \u2014 no reboot required.</p> <p>The configuration system supports hierarchical configuration sources, allowing for system-wide defaults, platform-specific overrides, and application-specific customizations. Configuration changes can be applied at runtime where appropriate, enabling dynamic adaptation to changing system conditions and requirements without requiring system restarts.</p>"},{"location":"entertainment/docs/components/rdkshell/#core-modules","title":"Core Modules","text":""},{"location":"entertainment/docs/components/rdkshell/#main-application-loop","title":"Main Application Loop","text":"<p>The central component of RDKShell is the main application loop, which orchestrates all system operations through a carefully timed rendering loop that maintains consistent frame rates while processing input events, updating application states, and managing system resources. The loop operates at a configurable frame rate (default 40 FPS) and coordinates between all other subsystems.</p> <p>The main loop implements sophisticated timing logic that adapts to system load while maintaining smooth visual output. It includes frame rate limiting to prevent excessive CPU usage and provides mechanisms for other subsystems to register for periodic callbacks. The loop also handles system shutdown procedures and ensures proper cleanup of all resources when the system terminates.</p>"},{"location":"entertainment/docs/components/rdkshell/#compositor-controller","title":"Compositor Controller","text":"<p>The CompositorController serves as the primary interface for all application management operations. It maintains the master list of active applications, manages their z-order relationships, handles focus management, and coordinates display composition operations. This component implements the core business logic for window management including bounds calculation, visibility control, opacity management, and animation coordination.</p> <p>The CompositorController provides a unified API that abstracts the complexity of the underlying graphics and windowing systems. It handles the translation between high-level application management operations and low-level graphics operations, ensuring that applications can be managed consistently regardless of the underlying hardware capabilities.</p>"},{"location":"entertainment/docs/components/rdkshell/#essos-instance-manager","title":"Essos Instance Manager","text":"<p>The EssosInstance component provides the abstraction layer between RDKShell and the underlying windowing system. It handles the creation and management of Wayland surfaces, manages OpenGL ES contexts, and provides the rendering surface for the compositor. This component enables RDKShell to work with different windowing systems and graphics hardware through a consistent interface.</p> <p>The EssosInstance manager handles the complex initialization sequences required for graphics systems and provides fallback mechanisms when specific capabilities are not available. It manages the relationship between logical displays and physical output devices, enabling support for multiple display configurations and dynamic display management.</p>"},{"location":"entertainment/docs/components/rdkshell/#rdk-compositor-system","title":"RDK Compositor System","text":"<p>The RdkCompositor hierarchy (RdkCompositor, RdkCompositorSurface, RdkCompositorNested) implements the actual display composition logic. These components handle the low-level details of surface management, texture handling, and rendering operations. They coordinate with the graphics hardware to ensure efficient composition of multiple application surfaces into the final display output.</p> <p>The compositor system includes sophisticated damage tracking to minimize unnecessary redraws and optimize performance. It supports both hardware-accelerated composition when available and software fallback modes for systems with limited graphics capabilities. The system can handle complex composition scenarios including transparency, scaling, and rotation effects.</p>"},{"location":"entertainment/docs/components/rdkshell/#input-management-system","title":"Input Management System","text":"<p>The input management system consists of multiple components working together to provide comprehensive input handling. The LinuxInput component handles low-level input device management, while LinuxKeys provides key code mapping and translation. The system supports both physical input devices and virtual input generation, with sophisticated routing capabilities that allow applications to register for specific key combinations regardless of focus state.</p> <p>The input system includes support for multiple input device types and provides configurable key mapping capabilities. It handles device hotplug events and can adapt to changing input device configurations at runtime. The system also provides input event filtering and transformation capabilities to support different application requirements.</p>"},{"location":"entertainment/docs/components/rdkshell/#communication-subsystem","title":"Communication Subsystem","text":"<p>RDKShell implements multiple communication protocols through a pluggable architecture. The ServerMessageHandler provides JSON-RPC over socket-based IPC, while the MessageHandler implements WebSocket-based communication. Both systems use the same underlying CompositorController APIs, ensuring consistent behavior across different communication methods.</p> <p>The communication subsystem is designed to be extensible, allowing for the addition of new protocols and communication methods. It includes built-in security mechanisms and access control to ensure that only authorized applications can access sensitive functionality. The system supports both synchronous and asynchronous communication patterns.</p>"},{"location":"entertainment/docs/components/rdkshell/#initialization-sequence","title":"Initialization Sequence","text":"<pre><code>sequenceDiagram\n    participant Main as Main Process\n    participant RDK as RdkShell Core\n    participant Essos as Essos Instance\n    participant Comp as Compositor Controller\n    participant Input as Input System\n    participant Comm as Communication\n\n    Main-&gt;&gt;RDK: initialize()\n    RDK-&gt;&gt;RDK: Load configuration\n    RDK-&gt;&gt;RDK: Setup key mappings\n    RDK-&gt;&gt;RDK: Configure memory monitoring\n    RDK-&gt;&gt;Essos: Initialize windowing system\n    Essos-&gt;&gt;Essos: Create OpenGL context\n    Essos-&gt;&gt;Essos: Setup Wayland surfaces\n    RDK-&gt;&gt;Comp: Initialize compositor\n    Comp-&gt;&gt;Comp: Setup application registry\n    RDK-&gt;&gt;Input: Initialize input handling\n    Input-&gt;&gt;Input: Configure input devices\n    Input-&gt;&gt;Input: Setup key routing\n    RDK-&gt;&gt;Comm: Start communication handlers\n    Comm-&gt;&gt;Comm: Initialize IPC channels\n    RDK-&gt;&gt;Main: Initialization complete\n    Main-&gt;&gt;RDK: run()\n    RDK-&gt;&gt;RDK: Enter main loop</code></pre>"},{"location":"entertainment/docs/components/rdkshell/#component-interaction-flow","title":"Component Interaction Flow","text":"<pre><code>graph TB\n    A[Main Application Loop] --&gt; B[Compositor Controller]\n    A --&gt; C[Essos Instance]\n    A --&gt; D[Input Manager]\n    A --&gt; E[Communication Handlers]\n\n    B --&gt; F[RDK Compositor]\n    B --&gt; G[Animation System]\n    B --&gt; H[Application Registry]\n\n    C --&gt; I[Wayland Surface Manager]\n    C --&gt; J[OpenGL Context]\n\n    D --&gt; K[Linux Input Handler]\n    D --&gt; L[Key Mapping System]\n    D --&gt; M[Event Router]\n\n    E --&gt; N[JSON-RPC Handler]\n    E --&gt; O[WebSocket Handler]\n    E --&gt; P[Socket Communication]\n\n    F --&gt; Q[Surface Composition]\n    F --&gt; R[Texture Management]\n\n    style A fill:#e1f5fe\n    style B fill:#f3e5f5\n    style C fill:#e8f5e8\n    style D fill:#fff3e0\n    style E fill:#fce4ec</code></pre>"},{"location":"entertainment/docs/components/rdkshell/#core-capabilities","title":"Core Capabilities","text":""},{"location":"entertainment/docs/components/rdkshell/#application-lifecycle-management","title":"Application Lifecycle Management","text":"<p>RDKShell provides comprehensive application lifecycle management capabilities that extend beyond simple process control. It manages the complete lifecycle from application launch through suspension, resumption, and termination. The system maintains detailed state information for each managed application, including their display properties, input event subscriptions, and resource allocations. This enables sophisticated power management scenarios where applications can be suspended to conserve resources while maintaining their visual state for quick resumption.</p> <p>Note</p> <p>Applications can register for lifecycle events to preserve state and perform cleanup during transitions.</p> <p>The lifecycle management system supports both traditional application models where applications run continuously and modern power-efficient models where applications can be dynamically suspended and resumed based on user interaction patterns and system resource availability. Applications can register for lifecycle events to perform appropriate cleanup and state preservation operations during transitions.</p>"},{"location":"entertainment/docs/components/rdkshell/#advanced-display-composition","title":"Advanced Display Composition","text":"<p>The composition engine within RDKShell handles complex multi-application display scenarios with pixel-perfect precision. It supports arbitrary positioning, scaling, rotation, and opacity control for each application window. The system can handle both traditional rectangular windows and more complex shapes through its integration with OpenGL ES 2.0 rendering pipelines. Advanced features include support for virtual displays, where applications can render to off-screen buffers for scenarios like picture-in-picture or thumbnail generation.</p> <p>Note</p> <p>Supports both hardware-accelerated and software rendering, with fallback to software when hardware isn't available.</p> <p>The compositor supports hardware-accelerated composition when available, automatically falling back to software rendering when necessary. It includes sophisticated damage tracking to minimize unnecessary redraws and optimize performance on resource-constrained devices. The system can handle multiple display outputs simultaneously, enabling scenarios where different applications are displayed on different screens or display zones.</p>"},{"location":"entertainment/docs/components/rdkshell/#sophisticated-input-event-management","title":"Sophisticated Input Event Management","text":"<p>RDKShell implements a highly configurable input event management system that goes far beyond simple key forwarding. Applications can register for specific key combinations even when they are not in focus, enabling global hotkey functionality and complex input routing scenarios. The system supports both physical key events from various input devices and virtual key generation for programmatic input simulation. Input event metadata is preserved and can be used for advanced input processing scenarios.</p> <p>Note</p> <p>Global hotkeys and key remapping are supported across devices including remote controls and touch interfaces.</p> <p>The input management system includes support for multiple input device types including traditional keyboards, remote controls, game controllers, and touch interfaces. It provides sophisticated key mapping capabilities that can translate between different input device protocols and key code formats. The system supports configurable key repeat rates, modifier key combinations, and complex input event filtering based on application requirements and system policies.</p>"},{"location":"entertainment/docs/components/rdkshell/#memory-and-resource-monitoring","title":"Memory and Resource Monitoring","text":"<p>The component includes comprehensive system resource monitoring capabilities with configurable thresholds and automatic notification systems. It continuously monitors RAM usage, swap utilization, and can trigger low-memory notifications to applications and system components. This enables proactive resource management and helps prevent system instability due to resource exhaustion.</p> <p>Note</p> <p>Applications should respond to low-memory warnings by reducing cache or suspending non-critical features.</p> <p>The monitoring system operates in a separate thread to avoid impacting the main rendering loop performance. It provides both immediate notifications for critical resource conditions and periodic reports for trend analysis. Applications can register for different types of resource notifications and adjust their behavior accordingly, such as reducing cache sizes or suspending non-essential operations during low-memory conditions.</p>"},{"location":"entertainment/docs/components/rdkshell/#multi-protocol-communication","title":"Multi-Protocol Communication","text":"<p>RDKShell supports multiple communication protocols to accommodate different integration scenarios. It provides JSON-RPC APIs over both traditional socket-based IPC and modern WebSocket connections. Additionally, it offers direct C++ APIs for native code integration. This flexibility allows it to integrate with various system architectures and application frameworks commonly used in the RDK ecosystem.</p> <p>Note</p> <p>RDKShell supports both synchronous and asynchronous APIs for efficient system communication.</p> <p>The communication system is designed to be extensible, allowing for the addition of new protocols and communication methods as requirements evolve. It includes built-in security mechanisms to ensure that only authorized applications can access sensitive functionality. The system supports both synchronous and asynchronous communication patterns, enabling efficient integration with different application architectures.</p>"},{"location":"entertainment/docs/components/rdkshell/#data-flow","title":"Data Flow","text":""},{"location":"entertainment/docs/components/rdkshell/#application-lifecycle","title":"Application Lifecycle","text":"<p>When an application is launched, the request flows through the communication layer to the CompositorController, which coordinates with the EssosInstance to create the necessary Wayland surfaces. The RdkCompositor system then manages the ongoing rendering and composition of the application's visual output. State changes are propagated back through the system to update client applications and maintain consistency.</p>"},{"location":"entertainment/docs/components/rdkshell/#input-event-processing","title":"Input Event Processing","text":"<p>Input events originate from the LinuxInput system, which captures raw input from various devices. These events are processed through the key mapping system to translate hardware-specific codes into standardized key codes. The CompositorController then applies the configured input routing rules to determine which applications should receive each event, supporting both focused application delivery and global key intercepts.</p>"},{"location":"entertainment/docs/components/rdkshell/#rendering-and-composition","title":"Rendering and Composition","text":"<p>The rendering pipeline begins with the main application loop triggering a frame update. The CompositorController coordinates with all active RdkCompositor instances to update their visual state, including position, size, opacity, and any active animations. The EssosInstance provides the OpenGL context and manages the final composition to the display surface.</p>"},{"location":"entertainment/docs/components/rdkshell/#system-integration","title":"System Integration","text":"<p>RDKShell integrates with multiple layers of the RDK stack, from low-level graphics drivers through high-level application frameworks. It communicates with the Thunder framework for system-level coordination, integrates with various input subsystems for comprehensive input handling, and provides the foundation for application frameworks to build upon. The component's design ensures that it can adapt to different hardware capabilities while providing consistent APIs and behavior across different RDK implementations.</p> <p>Note</p> <p>Integration interfaces are consistent across platforms, even with different display/input backends.</p> <p>The integration architecture is designed to be modular and extensible, allowing for easy adaptation to new hardware platforms and software frameworks. The system provides well-defined interfaces for integration with external components while maintaining appropriate abstraction layers to ensure compatibility across different deployment scenarios.</p>"},{"location":"entertainment/docs/components/rdkshell/#use-cases-and-applications","title":"Use Cases and Applications","text":"<p>RDKShell is designed to support a wide range of use cases common in modern entertainment and smart home devices. These include traditional set-top box scenarios with multiple video applications, smart TV interfaces with app stores and content discovery, and advanced scenarios like multi-room audio/video distribution and home automation integration.</p> Scenario Description Set-top boxes Multi-app video playback, z-order management Smart TVs App store navigation, content discovery, responsive UI Multi-room AV Render to off-screen buffers, distributed playback Home automation integration Input event routing, control overlay apps, support for virtual assistants and voice <p>The system's flexibility enables it to support both simple single-application scenarios and complex multi-application environments with sophisticated user interfaces. It can handle everything from basic remote control navigation to advanced touch-based interactions and voice control integration, making it suitable for a wide range of device types and user interaction models.</p>"},{"location":"entertainment/docs/components/rdkshell/#performance-considerations","title":"Performance Considerations","text":"<p>Frame Rate Management: The architecture is designed around maintaining consistent frame rates through careful timing and resource management. The main loop includes sophisticated timing logic that adapts to system load while maintaining smooth visual output. The system can dynamically adjust frame rates based on system capabilities and current load conditions.</p> <p>Efficient Event Processing: Input event processing is optimized to minimize latency while supporting complex routing scenarios. The system uses efficient data structures and algorithms to ensure that input responsiveness is maintained even with multiple applications and complex key intercept configurations.</p> <p>Graphics Pipeline Optimization: The rendering pipeline is optimized for the specific requirements of set-top box and smart TV applications, with careful attention to memory bandwidth and GPU utilization patterns typical in these environments. The system includes sophisticated optimization techniques to maximize performance while maintaining visual quality.</p>"},{"location":"entertainment/docs/components/rdkshell/#configuration","title":"Configuration","text":"<p>RDKShell provides extensive configuration capabilities through environment variables, configuration files, and compile-time options. The configuration system is designed to support both development scenarios with detailed debugging capabilities and production deployments with optimized performance characteristics. The system supports hierarchical configuration sources, allowing for system-wide defaults, platform-specific overrides, and application-specific customizations.</p>"},{"location":"entertainment/docs/components/rdkshell/#environment-variables","title":"Environment Variables","text":""},{"location":"entertainment/docs/components/rdkshell/#core-system","title":"Core System","text":"Variable Type Default Description <code>RDKSHELL_LOG_LEVEL</code> string \"Information\" Sets the verbosity level for logging output. Valid values are \"Debug\", \"Information\", \"Warn\", \"Error\", and \"Fatal\". When set to \"Debug\", detailed runtime information is printed to help with development and troubleshooting. <code>RDKSHELL_FRAMERATE</code> integer 40 Controls the target frame rate for the main rendering loop. Higher values provide smoother animation but consume more CPU resources. The system will attempt to maintain this frame rate while processing input events and updating application states. <code>RDKSHELL_ENABLE_IPC</code> boolean \"0\" Enables the socket-based IPC communication system when set to \"1\". This allows external applications to communicate with RDKShell through JSON-RPC over Unix domain sockets. <code>RDKSHELL_ENABLE_WS_IPC</code> boolean \"0\" Enables the WebSocket-based IPC communication system when set to \"1\". This provides real-time bidirectional communication capabilities for web-based applications and modern client frameworks."},{"location":"entertainment/docs/components/rdkshell/#memory-management","title":"Memory Management","text":"Variable Type Default Description <code>RDKSHELL_LOW_MEMORY_THRESHOLD</code> double 200.0 Sets the threshold in megabytes for low memory notifications. When available system memory falls below this threshold, RDKShell will send low memory notifications to registered applications, allowing them to free up resources proactively. <code>RDKSHELL_CRITICALLY_LOW_MEMORY_THRESHOLD</code> double 100.0 Defines the critically low memory threshold in megabytes. When system memory falls below this level, RDKShell will send critical memory notifications and may take more aggressive resource management actions. This value must be less than or equal to the low memory threshold. <code>RDKSHELL_SWAP_MEMORY_INCREASE_THRESHOLD</code> double 50.0 Sets the threshold in megabytes for swap memory increase notifications. When swap usage increases by more than this amount, applications will be notified of potential memory pressure conditions."},{"location":"entertainment/docs/components/rdkshell/#input-system","title":"Input System","text":"Variable Type Default Description <code>RDKSHELL_KEY_INITIAL_DELAY</code> integer 500 Configures the initial delay in milliseconds before key repeat events begin. This affects how long a user must hold a key before it starts repeating, providing control over input responsiveness and preventing accidental repeated inputs. <code>RDKSHELL_KEY_REPEAT_INTERVAL</code> integer 100 Sets the interval in milliseconds between key repeat events once repeating has started. Lower values result in faster key repetition, while higher values provide more controlled input for navigation scenarios."},{"location":"entertainment/docs/components/rdkshell/#display","title":"Display","text":"Variable Type Default Description <code>RDKSHELL_SET_GRAPHICS_720</code> boolean \"0\" Forces the graphics system to initialize in 720p mode (1280x720) when set to \"1\". This is useful for devices with limited graphics capabilities or when 720p output is specifically required. The system will initialize with these dimensions regardless of the display's native resolution. <code>RDKSHELL_SHOW_SPLASH_SCREEN</code> string undefined When defined, enables the splash screen functionality. The splash screen provides visual feedback during system initialization and can be customized with specific images or animations. <code>RDKSHELL_DISABLE_SPLASH_SCREEN_FILE</code> string undefined Specifies a file path that, when present, will disable the splash screen even if <code>RDKSHELL_SHOW_SPLASH_SCREEN</code> is set. This provides a mechanism for runtime control of splash screen behavior."},{"location":"entertainment/docs/components/rdkshell/#plugin-and-extension","title":"Plugin and Extension","text":"Variable Type Default Description <code>RDKSHELL_WESTEROS_PLUGIN_DIRECTORY</code> string \"/usr/lib/plugins/westeros/\" Specifies the directory path where Westeros plugins are located. RDKShell will search this directory for compatible plugins that extend the core functionality with platform-specific features."},{"location":"entertainment/docs/components/rdkshell/#configuration-files","title":"Configuration Files","text":""},{"location":"entertainment/docs/components/rdkshell/#input-device","title":"Input Device","text":"<p>File :<code>inputdevices.conf</code></p> <pre><code>{\n    \"inputDevices\": [\n        {\n            \"vendor\": \"0x119b\",\n            \"product\": \"0x2101\", \n            \"deviceType\": \"0x00\",\n            \"deviceMode\": \"0x00\"\n        },\n        {\n            \"vendor\": \"0x119b\",\n            \"product\": \"0x212b\",\n            \"deviceType\": \"0x01\", \n            \"deviceMode\": \"0x0f\"\n        },\n        {\n            \"vendor\": \"0x06e7\",\n            \"product\": \"0x8038\",\n            \"deviceType\": \"0x02\",\n            \"deviceMode\": \"0x03\"\n        }\n    ],\n    \"irInputDeviceTypeMapping\": [\n        {\n            \"filterCode\": 19,\n            \"deviceType\": \"0xf2\"\n        },\n        {\n            \"filterCode\": 20,\n            \"deviceType\": \"0xf1\"\n        },\n        {\n            \"filterCode\": 21,\n            \"deviceType\": \"0xf3\"\n        }\n    ]\n}\n</code></pre>"},{"location":"entertainment/docs/components/rdkshell/#input-device-parameters","title":"Input Device Parameters","text":"Parameter Type Description <code>vendor</code> string USB vendor ID in hexadecimal format. This identifies the manufacturer of the input device and is used for device-specific handling and configuration. <code>product</code> string USB product ID in hexadecimal format. Combined with the vendor ID, this uniquely identifies the specific device model and determines appropriate input handling behavior. <code>deviceType</code> string Device type classification in hexadecimal format. This determines how the device's input events are processed and which input handling routines are applied. <code>deviceMode</code> string Device mode configuration in hexadecimal format. This controls specific operational characteristics of the device, such as key repeat behavior and input event filtering."},{"location":"entertainment/docs/components/rdkshell/#ir-input-device-mapping","title":"IR Input Device Mapping","text":"Parameter Type Description <code>filterCode</code> integer IR filter code that identifies specific IR signal patterns. This allows the system to distinguish between different types of IR input devices and remote controls. <code>deviceType</code> string Device type mapping for IR devices in hexadecimal format. This determines how IR input events are translated into standard input events within the system."},{"location":"entertainment/docs/components/rdkshell/#permissions","title":"Permissions","text":"<p>File : <code>rdkshellPermissions.conf</code></p> <pre><code>{\n    \"clients\": [\n        {\n            \"client\": \"trusted_application\",\n            \"extensions\": [\"libwesteros_plugin_rdkshell_client_control.so\"]\n        },\n        {\n            \"client\": \"system_service\",\n            \"extensions\": [\n                \"libwesteros_plugin_rdkshell_client_control.so\",\n                \"libwesteros_plugin_rdkshell_extended_input.so\"\n            ]\n        }\n    ],\n    \"default\": {\n        \"extensions\": []\n    }\n}\n</code></pre>"},{"location":"entertainment/docs/components/rdkshell/#permission-parameters","title":"Permission Parameters","text":"Parameter Type Description <code>client</code> string Application identifier that matches the client name used in API calls. <code>extensions</code> array List of extension library names that the client is permitted to use. <code>default.extensions</code> array Default extension permissions applied to clients not explicitly listed in the configuration."},{"location":"entertainment/docs/components/rdkshell/#compile-time-configuration-options","title":"Compile-Time Configuration Options","text":""},{"location":"entertainment/docs/components/rdkshell/#build-configuration-flags","title":"Build Configuration Flags","text":"Option Default Description <code>RDKSHELL_BUILD_APP</code> ON Controls whether the main RDKShell executable is built. <code>RDKSHELL_BUILD_WEBSOCKET_IPC</code> OFF Enables WebSocket-based IPC communication support. <code>RDKSHELL_BUILD_KEY_METADATA</code> OFF Enables extended key metadata support that provides additional information about input events. <code>RDKSHELL_BUILD_IPC</code> ON Enables traditional socket-based IPC communication. <code>RDKSHELL_BUILD_CLIENT</code> ON Controls whether the RDKShell client library is built. <code>RDKSHELL_BUILD_FORCE_1080</code> OFF Enables compile-time support for forcing 1080p resolution. <code>RDKSHELL_BUILD_ENABLE_KEYREPEATS</code> OFF Enables advanced key repeat functionality with configurable timing and behavior."},{"location":"entertainment/docs/components/rdkshell/#advanced-build-options","title":"Advanced Build Options","text":"Option Default Description <code>RDKSHELL_BUILD_HIDDEN_SUPPORT</code> OFF Enables support for hidden application states. <code>RDKSHELL_BUILD_EXTERNAL_APPLICATION_SURFACE_COMPOSITION</code> ON Enables support for compositing surfaces from external applications. <code>RDKSHELL_BUILD_KEYBUBBING_TOP_MODE</code> ON Enables key bubbling to topmost applications. <code>RDKSHELL_BUILD_KEY_METADATA_EXTENDED_SUPPORT_FOR_IR</code> OFF Enables extended IR support that provides additional metadata for infrared input devices."},{"location":"entertainment/docs/components/rdkshell/#runtime-configuration","title":"Runtime Configuration","text":""},{"location":"entertainment/docs/components/rdkshell/#memory-monitor","title":"Memory Monitor","text":"<pre><code>// Configure memory monitoring with specific parameters\nstd::map&lt;std::string, RdkShellData&gt; config;\nconfig[\"enable\"] = true;\nconfig[\"interval\"] = 2.0;  // Check every 2 seconds\nconfig[\"lowRam\"] = 150.0;  // 150MB threshold\nconfig[\"criticallyLowRam\"] = 75.0;  // 75MB critical threshold\nconfig[\"swapIncreaseLimit\"] = 25.0;  // 25MB swap increase limit\nRdkShell::setMemoryMonitor(config);\n</code></pre>"},{"location":"entertainment/docs/components/rdkshell/#dynamic-display","title":"Dynamic Display","text":"<p>Display parameters can be adjusted at runtime through the API system, allowing applications to adapt to changing display conditions or user preferences. This includes resolution changes, display mode adjustments, and multi-display configuration management.</p>"},{"location":"entertainment/docs/components/rdkshell/#input-device-runtime","title":"Input Device Runtime","text":"<p>Input device behavior can be modified at runtime through the input management APIs, enabling dynamic adaptation to different input scenarios and user preferences. This includes key mapping changes, device enable/disable operations, and input routing configuration.</p>"},{"location":"entertainment/docs/components/rdkshell/#key-mappings-and-input-management","title":"Key Mappings and Input Management","text":"<p>RDKShell implements a comprehensive key mapping system that translates between different key code formats and provides sophisticated input event routing capabilities. The system supports both Wayland key codes for low-level input handling and RDKShell virtual key codes for application-level input processing. This dual-layer approach ensures compatibility with various input devices while providing a consistent interface for applications.</p> <p>The key mapping system is designed to handle the diverse input requirements of set-top box and smart TV environments, where applications must work with various remote controls, keyboards, and specialized input devices. The system provides flexible mapping capabilities that can be configured for different device types and user preferences.</p>"},{"location":"entertainment/docs/components/rdkshell/#key-code-translation-system","title":"Key Code Translation System","text":"<ul> <li>Wayland Key Codes: RDKShell uses Wayland key codes as the foundation for low-level input processing. These codes correspond directly to Linux input event codes and provide the interface between hardware input devices and the RDKShell input processing system. Wayland key codes are hardware-specific and may vary between different input devices and platforms.</li> <li>RDKShell Virtual Key Codes: The virtual key code system provides a standardized interface for applications, abstracting away hardware-specific details and ensuring consistent behavior across different input devices and platforms. Virtual key codes are designed to be stable across different hardware configurations and provide a consistent programming interface for application developers.</li> </ul>"},{"location":"entertainment/docs/components/rdkshell/#standard-key-mappings","title":"Standard Key Mappings","text":""},{"location":"entertainment/docs/components/rdkshell/#alphanumeric-keys","title":"Alphanumeric Keys","text":"Key Wayland Code RDKShell Code Description 0 11 48 Number zero key 1 2 49 Number one key 2 3 50 Number two key 3 4 51 Number three key 4 5 52 Number four key 5 6 53 Number five key 6 7 54 Number six key 7 8 55 Number seven key 8 9 56 Number eight key 9 10 57 Number nine key A 30 65 Letter A key B 48 66 Letter B key C 46 67 Letter C key D 32 68 Letter D key E 18 69 Letter E key F 33 70 Letter F key G 34 71 Letter G key H 35 72 Letter H key I 23 73 Letter I key J 36 74 Letter J key K 37 75 Letter K key L 38 76 Letter L key M 50 77 Letter M key N 49 78 Letter N key O 24 79 Letter O key P 25 80 Letter P key Q 16 81 Letter Q key R 19 82 Letter R key S 31 83 Letter S key T 20 84 Letter T key U 22 85 Letter U key V 47 86 Letter V key W 17 87 Letter W key X 45 88 Letter X key Y 21 89 Letter Y key Z 44 90 Letter Z key"},{"location":"entertainment/docs/components/rdkshell/#function-keys","title":"Function Keys","text":"Key Wayland Code RDKShell Code Description F1 59 112 Function key F1 F2 60 113 Function key F2 F3 61 114 Function key F3 F4 62 115 Function key F4 F5 63 116 Function key F5 F6 64 117 Function key F6 F7 65 118 Function key F7 F8 66 119 Function key F8 F9 67 120 Function key F9 F10 68 121 Function key F10 F11 87 122 Function key F11 F12 88 123 Function key F12 F13 183 124 Function key F13 F14 184 125 Function key F14 F15 185 126 Function key F15 F16 186 127 Function key F16 F17 187 129 Function key F17 F18 188 130 Function key F18 F19 189 131 Function key F19 F20 190 132 Function key F20 F21 191 133 Function key F21 F22 192 134 Function key F22 F23 193 135 Function key F23 F24 194 136 Function key F24"},{"location":"entertainment/docs/components/rdkshell/#navigation-keys","title":"Navigation Keys","text":"Key Wayland Code RDKShell Code Description Up Arrow 103 38 Directional up navigation key Down Arrow 108 40 Directional down navigation key Left Arrow 105 37 Directional left navigation key Right Arrow 106 39 Directional right navigation key Home 102 36 Home navigation key End 107 35 End navigation key Page Up 104 33 Page up navigation key Page Down 109 34 Page down navigation key Insert 110 45 Insert key Delete 111 46 Delete key"},{"location":"entertainment/docs/components/rdkshell/#control-and-modifier-keys","title":"Control and Modifier Keys","text":"Key Wayland Code RDKShell Code Flag Value Description Escape 1 27 - Escape key for canceling operations Tab 15 9 - Tab key for navigation and focus control Enter 28 13 - Enter key for confirmation and line breaks Space 57 32 - Space bar for text input and selection Backspace 14 8 - Backspace key for deleting characters Left Shift 42 16 8 Left shift modifier key Right Shift 54 16 8 Right shift modifier key Left Ctrl 29 17 16 Left control modifier key Right Ctrl 97 17 16 Right control modifier key Left Alt 56 18 32 Left alt modifier key Right Alt 100 18 32 Right alt modifier key Caps Lock 58 20 - Caps lock toggle key Num Lock 69 144 - Numeric keypad lock toggle Scroll Lock 70 145 - Scroll lock toggle key Pause 119 19 - Pause/break key"},{"location":"entertainment/docs/components/rdkshell/#special-media-and-remote-control-keys","title":"Special Media and Remote Control Keys","text":"Key Wayland Code RDKShell Code Description Red 0x190 405 Red colored key typically found on remote controls Green 0x191 406 Green colored key typically found on remote controls Yellow 0x18e 403 Yellow colored key typically found on remote controls Blue 0x18f 404 Blue colored key typically found on remote controls Back 158 407 Back navigation key for returning to previous screens Menu 139 408 Menu key for accessing application menus Home Page 172 409 Home page key for returning to main interface Volume Up 115 175 Volume increase key Volume Down 114 174 Volume decrease key Mute 113 173 Audio mute toggle key Play/Pause 164 227 Media play/pause toggle key Play 207 226 Media play key Fast Forward 208 223 Media fast forward key Rewind 168 224 Media rewind key"},{"location":"entertainment/docs/components/rdkshell/#numeric-keypad","title":"Numeric Keypad","text":"Key Wayland Code RDKShell Code Description Keypad 0 82 96 Numeric keypad zero Keypad 1 79 97 Numeric keypad one Keypad 2 80 98 Numeric keypad two Keypad 3 81 99 Numeric keypad three Keypad 4 75 100 Numeric keypad four Keypad 5 76 101 Numeric keypad five Keypad 6 77 102 Numeric keypad six Keypad 7 71 103 Numeric keypad seven Keypad 8 72 104 Numeric keypad eight Keypad 9 73 105 Numeric keypad nine Keypad Plus 78 107 Numeric keypad addition operator Keypad Minus 74 109 Numeric keypad subtraction operator Keypad Multiply 55 106 Numeric keypad multiplication operator Keypad Divide 98 111 Numeric keypad division operator Keypad Decimal 83 110 Numeric keypad decimal point Keypad Enter 96 13 Numeric keypad enter key"},{"location":"entertainment/docs/components/rdkshell/#modifier-key-flags","title":"Modifier Key Flags","text":"<p>RDKShell uses flag values to represent modifier key states that can be combined with regular key codes to create complex key combinations. These flags can be combined using bitwise OR operations to represent multiple simultaneous modifier keys.</p> Modifier Flag Value Description Shift 8 Shift key modifier for uppercase letters and symbol access Control 16 Control key modifier for keyboard shortcuts and commands Alt 32 Alt key modifier for alternative character input and shortcuts Command 64 Command/Windows key modifier for system-level shortcuts"},{"location":"entertainment/docs/components/rdkshell/#modifier-combination-examples","title":"Modifier Combination Examples","text":"<pre><code>// Ctrl+C combination\nuint32_t keyCode = 67;  // C key\nuint32_t flags = 16;    // Control modifier\n\n// Ctrl+Shift+F combination  \nuint32_t keyCode = 70;  // F key\nuint32_t flags = 24;    // Control (16) + Shift (8)\n\n// Alt+Tab combination\nuint32_t keyCode = 9;   // Tab key\nuint32_t flags = 32;    // Alt modifier\n\n// Ctrl+Alt+Delete combination\nuint32_t keyCode = 46;  // Delete key\nuint32_t flags = 48;    // Control (16) + Alt (32)\n</code></pre>"},{"location":"entertainment/docs/components/rdkshell/#input-event-processing_1","title":"Input Event Processing","text":"<ul> <li>Key Event Types: RDKShell processes two primary types of key events: key press events and key release events. Each event includes the key code, modifier flags, and timing metadata. The system maintains state information about which keys are currently pressed to support complex input scenarios and modifier key combinations.</li> <li>Key Repeat Handling: The system supports configurable key repeat functionality with separate settings for initial delay and repeat interval. Key repeat events are marked with a special flag to distinguish them from initial key press events. The repeat behavior can be configured globally or on a per-application basis. <pre><code>#define RDKSHELL_KEYDOWN_REPEAT 128\n</code></pre> The key repeat system includes sophisticated logic to handle modifier keys correctly and ensure that repeat events are only generated for appropriate key types. Navigation keys and character keys typically support repeat, while modifier keys and special function keys do not.</li> <li>Event Routing and Interception: Applications can register to intercept specific key combinations even when they are not in focus. This enables global hotkey functionality and allows background applications to respond to specific input events. The interception system supports complex routing scenarios where multiple applications may be interested in the same key events. The event routing system includes priority mechanisms to ensure that critical system functions can always access required key combinations. Applications can register for different types of key interception, including exclusive access, shared access, and monitoring-only access.</li> </ul>"},{"location":"entertainment/docs/components/rdkshell/#mouse-and-pointer-input","title":"Mouse and Pointer Input","text":""},{"location":"entertainment/docs/components/rdkshell/#mouse-button-mappings","title":"Mouse Button Mappings","text":"Button Flag Value Description Left Button 1 Primary mouse button for selection and activation Middle Button 2 Middle mouse button typically used for scrolling Right Button 4 Secondary mouse button for context menus"},{"location":"entertainment/docs/components/rdkshell/#pointer-event-processing","title":"Pointer Event Processing","text":"<p>RDKShell processes pointer motion events and button press/release events, providing applications with precise cursor position information and button state changes. The system supports both absolute and relative pointer positioning and can handle multiple pointer devices simultaneously.</p> <p>The pointer event system includes support for touch interfaces and gesture recognition when available. It provides coordinate transformation capabilities to support different display resolutions and scaling factors.</p>"},{"location":"entertainment/docs/components/rdkshell/#virtual-key-support","title":"Virtual Key Support","text":"<ul> <li>Virtual Key Generation: The system supports programmatic generation of virtual key events, enabling applications to simulate user input for automation and testing scenarios. Virtual key events are processed through the same routing and interception mechanisms as physical key events.</li> <li>Virtual Key Mapping: Virtual keys can be mapped to physical key codes through string-based identifiers, providing a flexible interface for dynamic key mapping scenarios. This enables applications to define custom key mappings that can be configured at runtime.</li> </ul>"},{"location":"entertainment/docs/components/rdkshell/#apis","title":"APIs","text":"<p>RDKShell provides multiple API interfaces to accommodate different integration scenarios and programming languages. The system supports JSON-RPC over both traditional socket-based IPC and modern WebSocket connections, as well as direct C++ APIs for native code integration. All APIs provide access to the same underlying functionality through the CompositorController interface.</p>"},{"location":"entertainment/docs/components/rdkshell/#json-rpc-api","title":"JSON-RPC API","text":""},{"location":"entertainment/docs/components/rdkshell/#application-management","title":"Application Management","text":"<ul> <li>createDisplay</li> </ul> <p>Method: <code>org.rdk.RDKShell.1.createDisplay</code></p> <p>Parameters: - <code>client</code> (string, required): Unique identifier for the application - <code>displayName</code> (string, optional): Custom name for the display surface - <code>displayWidth</code> (uint32, optional): Width of the display surface - <code>displayHeight</code> (uint32, optional): Height of the display surface - <code>virtualDisplayEnabled</code> (boolean, optional): Enable virtual display mode - <code>virtualWidth</code> (uint32, optional): Virtual display width - <code>virtualHeight</code> (uint32, optional): Virtual display height - <code>topmost</code> (boolean, optional): Create display in topmost layer - <code>focus</code> (boolean, optional): Give focus to the new display - <code>autodestroy</code> (boolean, optional): Automatically destroy when client disconnects</p> <p>Response: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"3\",\n  \"result\": {\n    \"success\": true\n  }\n}\n</code></pre></p> <p>Example Request: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"3\",\n  \"method\": \"org.rdk.RDKShell.1.createDisplay\",\n  \"params\": {\n    \"client\": \"netflix\",\n    \"displayWidth\": 1920,\n    \"displayHeight\": 1080,\n    \"topmost\": true,\n    \"focus\": true\n  }\n}\n</code></pre></p> <ul> <li>launchApplication</li> </ul> <p>Method: <code>org.rdk.RDKShell.1.launchApplication</code></p> <p>Parameters: - <code>client</code> (string, required): Application identifier - <code>uri</code> (string, required): Application URI or path - <code>mimeType</code> (string, required): MIME type of the application - <code>topmost</code> (boolean, optional): Launch in topmost layer - <code>focus</code> (boolean, optional): Give focus to launched application</p> <p>Response: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"4\",\n  \"result\": {\n    \"success\": true\n  }\n}\n</code></pre></p> <ul> <li>kill</li> </ul> <p>Method: <code>org.rdk.RDKShell.1.kill</code></p> <p>Parameters: - <code>client</code> (string, required): Application identifier to terminate</p> <p>Response: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"5\",\n  \"result\": {\n    \"success\": true\n  }\n}\n</code></pre></p>"},{"location":"entertainment/docs/components/rdkshell/#display-management","title":"Display Management","text":"<ul> <li>getScreenResolution Method: <code>org.rdk.RDKShell.1.getScreenResolution</code></li> </ul> <p>Parameters: None</p> <p>Response: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"6\",\n  \"result\": {\n    \"w\": 1920,\n    \"h\": 1080,\n    \"success\": true\n  }\n}\n</code></pre></p> <ul> <li>setScreenResolution Method: <code>org.rdk.RDKShell.1.setScreenResolution</code></li> </ul> <p>Parameters: - <code>w</code> (uint32, required): Screen width in pixels - <code>h</code> (uint32, required): Screen height in pixels</p> <p>Response: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"7\",\n  \"result\": {\n    \"success\": true\n  }\n}\n</code></pre></p> <ul> <li>getBounds</li> </ul> <p>Method: <code>org.rdk.RDKShell.1.getBounds</code></p> <p>Parameters: - <code>client</code> (string, required): Application identifier</p> <p>Response: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"8\",\n  \"result\": {\n    \"bounds\": {\n      \"x\": 100,\n      \"y\": 50,\n      \"w\": 800,\n      \"h\": 600\n    },\n    \"success\": true\n  }\n}\n</code></pre></p> <ul> <li>setBounds</li> </ul> <p>Method: <code>org.rdk.RDKShell.1.setBounds</code></p> <p>Parameters: - <code>client</code> (string, required): Application identifier - <code>x</code> (int32, required): X coordinate - <code>y</code> (int32, required): Y coordinate - <code>w</code> (uint32, required): Width in pixels - <code>h</code> (uint32, required): Height in pixels</p> <p>Response: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"9\",\n  \"result\": {\n    \"success\": true\n  }\n}\n</code></pre></p>"},{"location":"entertainment/docs/components/rdkshell/#visibility-and-appearance","title":"Visibility and Appearance","text":"<ul> <li>getVisibility</li> </ul> <p>Method: <code>org.rdk.RDKShell.1.getVisibility</code></p> <p>Parameters: - <code>client</code> (string, required): Application identifier</p> <p>Response: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"10\",\n  \"result\": {\n    \"visible\": true,\n    \"success\": true\n  }\n}\n</code></pre></p> <ul> <li>setVisibility</li> </ul> <p>Method: <code>org.rdk.RDKShell.1.setVisibility</code></p> <p>Parameters: - <code>client</code> (string, required): Application identifier - <code>visible</code> (boolean, required): Visibility state</p> <p>Response: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"11\",\n  \"result\": {\n    \"success\": true\n  }\n}\n</code></pre></p> <ul> <li>getOpacity</li> </ul> <p>Method: <code>org.rdk.RDKShell.1.getOpacity</code></p> <p>Parameters: - <code>client</code> (string, required): Application identifier</p> <p>Response: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"12\",\n  \"result\": {\n    \"opacity\": 255,\n    \"success\": true\n  }\n}\n</code></pre></p> <ul> <li>setOpacity</li> </ul> <p>Method: <code>org.rdk.RDKShell.1.setOpacity</code></p> <p>Parameters: - <code>client</code> (string, required): Application identifier - <code>opacity</code> (uint32, required): Opacity value (0-255)</p> <p>Response: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"13\",\n  \"result\": {\n    \"success\": true\n  }\n}\n</code></pre></p>"},{"location":"entertainment/docs/components/rdkshell/#z-order-management","title":"Z-Order Management","text":"<ul> <li>moveToFront</li> </ul> <p>Method: <code>org.rdk.RDKShell.1.moveToFront</code></p> <p>Parameters: - <code>client</code> (string, required): Application identifier</p> <p>Response: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"14\",\n  \"result\": {\n    \"success\": true\n  }\n}\n</code></pre></p> <ul> <li>moveToBack</li> </ul> <p>Method: <code>org.rdk.RDKShell.1.moveToBack</code></p> <p>Parameters: - <code>client</code> (string, required): Application identifier</p> <p>Response: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"15\",\n  \"result\": {\n    \"success\": true\n  }\n}\n</code></pre></p> <ul> <li>moveBehind</li> </ul> <p>Method: <code>org.rdk.RDKShell.1.moveBehind</code></p> <p>Parameters: - <code>client</code> (string, required): Application to move - <code>target</code> (string, required): Application to move behind</p> <p>Response: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"16\",\n  \"result\": {\n    \"success\": true\n  }\n}\n</code></pre></p> <ul> <li>getZOrder</li> </ul> <p>Method: <code>org.rdk.RDKShell.1.getZOrder</code></p> <p>Parameters: None</p> <p>Response: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"17\",\n  \"result\": {\n    \"clients\": [\"app1\", \"app2\", \"app3\"],\n    \"success\": true\n  }\n}\n</code></pre></p>"},{"location":"entertainment/docs/components/rdkshell/#focus-management","title":"Focus Management","text":"<ul> <li>setFocus</li> </ul> <p>Method: <code>org.rdk.RDKShell.1.setFocus</code></p> <p>Parameters: - <code>client</code> (string, required): Application identifier</p> <p>Response: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"18\",\n  \"result\": {\n    \"success\": true\n  }\n}\n</code></pre></p> <ul> <li>getFocused</li> </ul> <p>Method: <code>org.rdk.RDKShell.1.getFocused</code></p> <p>Parameters: None</p> <p>Response: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"19\",\n  \"result\": {\n    \"client\": \"netflix\",\n    \"success\": true\n  }\n}\n</code></pre></p>"},{"location":"entertainment/docs/components/rdkshell/#input-management","title":"Input Management","text":"<ul> <li>addKeyIntercept</li> </ul> <p>Method: <code>org.rdk.RDKShell.1.addKeyIntercept</code></p> <p>Parameters: - <code>client</code> (string, required): Application identifier - <code>keyCode</code> (uint32, required): Key code to intercept - <code>modifiers</code> (array, optional): Modifier keys (ctrl, shift, alt)</p> <p>Response: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"20\",\n  \"result\": {\n    \"success\": true\n  }\n}\n</code></pre></p> <p>Example Request: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"20\",\n  \"method\": \"org.rdk.RDKShell.1.addKeyIntercept\",\n  \"params\": {\n    \"client\": \"netflix\",\n    \"keyCode\": 48,\n    \"modifiers\": [\"ctrl\", \"shift\"]\n  }\n}\n</code></pre></p> <ul> <li>removeKeyIntercept</li> </ul> <p>Method: <code>org.rdk.RDKShell.1.removeKeyIntercept</code></p> <p>Parameters: - <code>client</code> (string, required): Application identifier - <code>keyCode</code> (uint32, required): Key code to remove - <code>modifiers</code> (array, optional): Modifier keys</p> <p>Response: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"21\",\n  \"result\": {\n    \"success\": true\n  }\n}\n</code></pre></p>"},{"location":"entertainment/docs/components/rdkshell/#system-information","title":"System Information","text":"<ul> <li>getClients</li> </ul> <p>Method: <code>org.rdk.RDKShell.1.getClients</code></p> <p>Parameters: None</p> <p>Response: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"22\",\n  \"result\": {\n    \"clients\": [\"netflix\", \"youtube\", \"settings\"],\n    \"success\": true\n  }\n}\n</code></pre></p>"},{"location":"entertainment/docs/components/rdkshell/#websocket-api","title":"WebSocket API","text":"<p>RDKShell supports WebSocket-based communication for real-time interaction. The WebSocket API uses the same method names and parameters as the JSON-RPC API but operates over WebSocket connections for lower latency and bidirectional communication.</p> <p>Connection Endpoint: <code>ws://localhost:3000</code></p> <p>Message Format: <pre><code>{\n  \"msg\": \"methodName\",\n  \"params\": {\n    \"parameter1\": \"value1\",\n    \"parameter2\": \"value2\"\n  }\n}\n</code></pre></p>"},{"location":"entertainment/docs/components/rdkshell/#error-handling","title":"Error Handling","text":"<p>All APIs return success/failure indicators and provide detailed error information when operations fail. Common error conditions include:</p> <ul> <li>Invalid client identifier: Specified application does not exist</li> <li>Resource constraints: Insufficient memory or graphics resources</li> <li>Permission denied: Application lacks required permissions</li> <li>Invalid parameters: Malformed or out-of-range parameter values</li> <li>System state conflicts: Operation conflicts with current system state</li> </ul> <p>Error responses follow the JSON-RPC error format: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"23\",\n  \"error\": {\n    \"code\": -32602,\n    \"message\": \"Invalid params\",\n    \"data\": \"Client 'invalid_app' not found\"\n  }\n}\n</code></pre></p>"},{"location":"entertainment/docs/components/rdkshell/#best-practices","title":"Best Practices","text":""},{"location":"entertainment/docs/components/rdkshell/#development","title":"Development","text":"<ul> <li>Enable debug logging and extended metadata collection to facilitate troubleshooting and performance analysis.</li> <li>Use higher frame rates for smoother development experience but be aware of increased resource consumption.</li> <li>Enable additional build options that provide debugging capabilities and detailed system information.</li> </ul>"},{"location":"entertainment/docs/components/rdkshell/#production","title":"Production","text":"<ul> <li>Use optimized logging levels and carefully tuned memory thresholds based on the specific hardware platform and application requirements.</li> <li>Disable unnecessary features to minimize resource usage and potential security exposure.</li> <li>Use conservative memory thresholds to ensure system stability under varying load conditions.</li> </ul>"},{"location":"entertainment/docs/components/rdkshell/#security","title":"Security","text":"<ul> <li>Carefully configure the permissions system to ensure that only trusted applications have access to sensitive extensions and capabilities.</li> <li>Regularly review and update permission configurations as applications are added or removed from the system.</li> <li>Use the principle of least privilege when granting extension access to applications.</li> </ul>"},{"location":"entertainment/docs/components/rdkshell/#performance","title":"Performance","text":"<ul> <li>Configure frame rates and memory thresholds based on the specific hardware capabilities and performance requirements of the target deployment.</li> <li>Monitor system performance under typical usage scenarios and adjust configuration parameters to optimize for the specific use case and hardware platform</li> </ul>"},{"location":"entertainment/docs/components/rdkshell/#key-mapping","title":"Key mapping","text":"<ul> <li>Key Intercept Registration: Applications should register for key intercepts only for the specific key combinations they need to handle globally. Excessive key intercept registrations can impact system performance and interfere with other applications. Applications should also properly remove their key intercept registrations when they are suspended or terminated.</li> <li>Modifier Key Handling: When processing key events with modifiers, applications should check for the specific modifier combinations they support and ignore unexpected modifier states to ensure robust input handling. Applications should also be prepared to handle cases where modifier keys are pressed or released independently of other keys.</li> <li>Input Event Cleanup: Applications should properly remove their key intercept registrations when they are suspended or terminated to prevent resource leaks and ensure proper input routing for other applications. The system includes automatic cleanup mechanisms, but applications should not rely solely on these mechanisms.</li> <li>Performance Considerations: Input event processing should be optimized to minimize latency and ensure responsive user interaction. Applications should avoid performing heavy processing in input event handlers and should use efficient data structures for key mapping and event routing operations.</li> </ul>"},{"location":"entertainment/docs/components/westeros/","title":"Westeros Wayland Compositor","text":"<p>Westeros is a lightweight Wayland compositor library designed for embedded systems , including set-top boxes. It provides a flexible framework for creating normal, nested, and embedded Wayland compositors with support for hardware-accelerated video rendering and multiple backend platforms. The compositor implements the Wayland protocol and is designed to be compatible with applications built to use Wayland compositors. It enables applications to create one or more Wayland displays and supports three distinct compositor types: normal compositors that display output directly to the screen, nested compositors that send output to another compositor as a client surface, and embedded compositors that allow applications to incorporate composited output into their UI for seamless integration of third-party applications.</p>"},{"location":"entertainment/docs/components/westeros/#design","title":"Design","text":"<pre><code>graph TB\n    subgraph \"Application Layer\"\n        A[Client Applications]\n        B[GStreamer Pipeline]\n    end\n\n    subgraph \"Westeros Core\"\n        C[westeros-compositor.cpp]\n        D[Wayland Protocol Handler]\n        E[Surface Management]\n        F[Output Management]\n    end\n\n    subgraph \"Protocol Extensions\"\n        G[XDG Shell v4/v5/stable]\n        H[Simple Shell]\n        I[Simple Buffer]\n        J[VPC Protocol]\n    end\n\n    subgraph \"Sink Modules\"\n        K[westeros-sink-drm]\n        L[westeros-sink-v4l2]\n    end\n\n    subgraph \"Render Backends\"\n        M[GL Renderer]\n        N[Embedded Renderer]\n    end\n\n    subgraph \"Platform Abstraction\"\n        O[DRM/KMS]\n        P[V4L2]\n    end\n\n    A --&gt; D\n    B --&gt; K\n    B --&gt; L\n    C --&gt; E\n    C --&gt; F\n    D --&gt; G\n    D --&gt; H\n    D --&gt; I\n    D --&gt; J\n    K --&gt; O\n    L --&gt; P\n    M --&gt; O\n    N --&gt; O</code></pre>"},{"location":"entertainment/docs/components/westeros/#module-interface-specifications","title":"Module Interface Specifications","text":"Interface Purpose Key Methods <code>WstModuleInit</code> Primary initialization function Resource allocation, hardware initialization, capability registration <code>WstModuleTerm</code> Cleanup functionality Resource deallocation, system state restoration <code>WstOutput</code> Display output configuration Resolution setting, refresh rate control, multi-display management <code>WstCompositor</code> Main compositor context Primary API for application integration <p>The Westeros module system provides standardized entry points for platform-specific implementations. The <code>WstOutput</code> interface abstracts display output configuration across different platforms, providing consistent methods for resolution setting, refresh rate control, and multi-display management.</p>"},{"location":"entertainment/docs/components/westeros/#protocol-binding-generation","title":"Protocol Binding Generation","text":"<p>Protocol bindings are automatically generated from XML specifications using the Wayland scanner tool. The generated headers in <code>protocol/</code> directories provide both client and server implementations for each supported protocol extension.</p> <pre><code>flowchart LR\n    A[XML Protocol Specs] --&gt; B[Wayland Scanner]\n    B --&gt; C[Generated Headers]\n    C --&gt; D[Client Implementation]\n    C --&gt; E[Server Implementation]\n    D --&gt; F[Application Integration]\n    E --&gt; F</code></pre> <p>The build system integrates Wayland scanner tool execution, automatically regenerating protocol bindings when XML specifications are updated. This ensures that protocol implementations remain synchronized with specification changes and maintain compatibility with standard Wayland applications.</p>"},{"location":"entertainment/docs/components/westeros/#core-modules","title":"Core modules","text":""},{"location":"entertainment/docs/components/westeros/#compositor-core","title":"Compositor Core","text":"<ul> <li>File: <code>westeros-compositor.cpp</code></li> <li>Purpose: Main compositor implementation handling Wayland protocol, surface management, and client coordination</li> <li>Key Structures:</li> <li><code>WstCompositor</code>: Represents the main compositor context, managing state, client connections, and coordinating Wayland displays and subsystems</li> <li><code>WstOutput</code>: Manages display output configurations like resolution and refresh rate, abstracting hardware differences for a consistent application interface.</li> <li><code>WstModule</code>: Enables runtime loading of platform-specific modules, allowing the compositor to support multiple hardware platforms with a single build.</li> </ul>"},{"location":"entertainment/docs/components/westeros/#sink-modules","title":"Sink Modules","text":"<p>The sink modules are hardware-specific GStreamer sink elements that handle video rendering on different platforms. Each sink module is tailored to leverage the specific capabilities and APIs of its target platform while providing a consistent GStreamer interface.</p>"},{"location":"entertainment/docs/components/westeros/#drm-sink","title":"DRM Sink","text":"<ul> <li>Direct Rendering Manager support \u2013 The DRM sink supports generic Linux graphics stacks via the DRM/KMS framework, making it compatible with a wide range of Linux platforms using standard graphics drivers.</li> <li>Generic Linux graphics stack \u2013 It uses GBM for efficient buffer allocation and supports both video overlay and texture rendering, choosing the best method based on hardware and system conditions.</li> <li>KMS (Kernel Mode Setting) integration \u2013 The sink manages display settings like resolution, refresh rate, and multi-monitor support through KMS. It supports both atomic and legacy APIs for broad kernel compatibility.</li> </ul>"},{"location":"entertainment/docs/components/westeros/#v4l2-sink","title":"V4L2 Sink","text":"<ul> <li>Video4Linux2 API support \u2013 The V4L2 sink offers broad compatibility using the standard Video4Linux2 API, making it ideal for systems without specialized video interfaces.</li> <li>Capture and display buffer management \u2013 It handles both capture and display buffers, supports various pixel formats and DMA buffers for zero-copy operations, and negotiates formats for optimal hardware performance.</li> <li>Cross-platform video handling \u2013 Supports hardware-accelerated decoding with graceful fallback to software, and maintains proper audio-video synchronization during playback.</li> </ul>"},{"location":"entertainment/docs/components/westeros/#protocol-extensions","title":"Protocol Extensions","text":""},{"location":"entertainment/docs/components/westeros/#xdg-shell-support","title":"XDG Shell Support","text":"<p>Westeros provides full support for XDG Shell protocol versions v4, v5, and stable, allowing applications to manage surfaces as toplevel or popup windows. It supports window states like maximized, minimized, fullscreen, and resizable, with constraint handling. Surface roles, input focus, and event routing are properly implemented. Bindings are auto-generated from XML using the Wayland scanner, ensuring compatibility with standard Wayland clients.</p>"},{"location":"entertainment/docs/components/westeros/#simple-shell","title":"Simple Shell","text":"<p>A custom Westeros extension designed for embedded systems, offering lightweight window management. It supports basic functions such as window creation, positioning, and state transitions, with reduced complexity compared to full-featured shell protocols like XDG Shell\u2014ideal for low-resource environments.</p>"},{"location":"entertainment/docs/components/westeros/#simple-buffer","title":"Simple Buffer","text":"<p>A protocol extension focused on efficient cross-process buffer sharing. It minimizes memory overhead by supporting shared memory, DMA buffers, and platform-specific formats. Reference counting and lifecycle management are included to ensure proper cleanup and resource handling\u2014critical for performance in embedded systems.</p>"},{"location":"entertainment/docs/components/westeros/#platform-support-matrix","title":"Platform Support Matrix","text":"Platform Sink Module Renderer Hardware Acceleration Key Features Generic Linux drm gl \u2713 DRM/KMS GBM, Atomic KMS, Multi-display V4L2 Devices v4l2 gl \u2713 Hardware Decode Cross-platform, Standard APIs"},{"location":"entertainment/docs/components/westeros/#key-features","title":"Key Features","text":""},{"location":"entertainment/docs/components/westeros/#compositor-types","title":"Compositor Types","text":"<p>Westeros supports three distinct compositor configurations, each designed for specific use cases and deployment scenarios.</p> <p>Normal Compositor operates as a standalone display server, directly controlling screen output and managing all client applications. This configuration is typical for embedded devices where Westeros serves as the primary display system. The normal compositor handles all aspects of display management, including resolution setting, refresh rate control, and multi-monitor support where available.</p> <p>Nested Compositor functions as a client to another Wayland compositor while simultaneously serving as a compositor for its own clients. This configuration enables complex display hierarchies and is useful for scenarios like running multiple UI environments or creating sandboxed application spaces. The nested compositor can be moved, resized, and managed like any other window while maintaining full compositor functionality for its clients.</p> <p>Embedded Compositor allows applications to integrate Wayland compositor functionality directly into their user interface. This enables seamless incorporation of external applications into a host application's UI, creating unified user experiences where third-party applications appear as native components of the host interface.</p>"},{"location":"entertainment/docs/components/westeros/#video-capabilities","title":"Video Capabilities","text":"<p>Westeros supports hardware-accelerated video decoding across all platform backends, automatically selecting the optimal decoding path based on system and hardware capabilities. It handles multiple video planes for features like picture-in-picture and multi-stream rendering, with per-stream scaling and effects.</p> <p>Aspect ratio management ensures proper display adaptation through modes like letterboxing, pillarboxing, and custom configurations. Frame stepping and seeking allow for frame-accurate navigation and variable playback rates, essential for advanced media playback.</p> <p>Audio/video synchronization is maintained through precise timing mechanisms that consider processing delays and hardware latency, ensuring smooth, accurate playback across various configurations.</p>"},{"location":"entertainment/docs/components/westeros/#advanced-features","title":"Advanced Features","text":"<p>ERM (External Resource Manager) integration enables robust resource handling across applications, with support for conflict resolution, priority-based allocation, and graceful degradation under load.</p> <p>Westeros supports seamless dynamic resolution switching without restarting apps or the compositor. It also handles multi-display setups with independent resolution, refresh, and color settings\u2014enabling mirroring and extended desktop modes.</p> <p>Comprehensive input handling includes support for multi-touch displays, external keyboards, and embedded system input devices, ensuring flexible user interaction across platforms.</p>"},{"location":"entertainment/docs/components/westeros/#usage-examples","title":"Usage Examples","text":""},{"location":"entertainment/docs/components/westeros/#basic-compositor-launch","title":"Basic Compositor Launch","text":"<p>Different launch configurations demonstrate the flexibility of the Westeros compositor across various platforms and use cases.</p> <pre><code># DRM backend with OpenGL renderer\nLD_PRELOAD=libwesteros_gl.so westeros --renderer libwesteros_render_gl.so\n\n# Embedded compositor with specific display\nwesteros --embedded --display :1 --renderer libwesteros_render_embedded.so\n\n# Nested compositor configuration\nwesteros --nested --parent-display wayland-0 --renderer libwesteros_render_gl.so\n\n# Display-specific launch with debugging\nWESTEROS_DEBUG=1 westeros_test --display westeros-2455-0\n</code></pre>"},{"location":"entertainment/docs/components/westeros/#gstreamer-pipeline-integration","title":"GStreamer Pipeline Integration","text":"<p>Westeros sink integration with GStreamer enables sophisticated media processing pipelines with hardware acceleration.</p> <pre><code># Basic video playback with hardware acceleration\ngst-launch-1.0 filesrc location=video.mp4 ! decodebin ! westerossink\n\n# Advanced pipeline with scaling and effects\ngst-launch-1.0 filesrc location=input.mp4 ! decodebin ! videoscale ! \\\n  video/x-raw,width=1920,height=1080 ! westerossink window-set=\"0,0,1920,1080\"\n\n# Multi-stream pipeline with picture-in-picture\ngst-launch-1.0 filesrc location=main.mp4 ! decodebin ! westerossink name=main \\\n  filesrc location=pip.mp4 ! decodebin ! westerossink name=pip window-set=\"1440,810,480,270\"\n</code></pre>"},{"location":"entertainment/docs/components/westeros/#dependencies","title":"Dependencies","text":""},{"location":"entertainment/docs/components/westeros/#core-dependencies","title":"Core Dependencies","text":"<p>The Westeros compositor requires several core libraries that provide essential functionality for Wayland protocol handling, input processing, and graphics rendering.</p> <p>Wayland (&gt;= 1.6.0) provides the fundamental protocol implementation and client-server communication mechanisms. The compositor uses both client and server-side Wayland libraries for different operational modes.</p> <p>libxkbcommon (&gt;= 0.8.3) and xkeyboard-config (&gt;= 2.18) handle keyboard input processing, including keymap loading, key symbol translation, and internationalization support.</p> <p>GStreamer (&gt;= 1.10.4) integration enables sophisticated media processing capabilities and provides the plugin architecture for the Westeros sink modules.</p> <p>EGL (&gt;= 1.4) and OpenGL ES (&gt;= 2.0) provide hardware-accelerated graphics rendering capabilities across different platforms.</p>"},{"location":"entertainment/docs/components/westeros/#platform-specific-dependencies","title":"Platform-Specific Dependencies","text":"<p>Each platform backend requires specific libraries and development packages for optimal functionality.</p> <p>DRM platforms need libdrm for direct rendering manager access and GBM (Generic Buffer Manager) for efficient buffer allocation and management.</p> <p>V4L2 platforms need Video4Linux2 kernel headers and may benefit from additional codec libraries for enhanced format support.</p>"},{"location":"entertainment/docs/components/westeros/#testing-and-coverage","title":"Testing and Coverage","text":""},{"location":"entertainment/docs/components/westeros/#automated-testing-framework","title":"Automated Testing Framework","text":"<p>The testing system provides comprehensive validation across multiple platforms and configurations. Located in the <code>test/</code> directory, the framework includes platform-specific test suites and code coverage analysis.</p> Test Category Coverage Platform Support Core Compositor Protocol compliance, surface management All platforms Video Rendering Hardware acceleration, format support DRM, V4L2 Input Handling Touch, keyboard, pointer devices All platforms Resource Management ERM integration, memory optimization All platforms <p>Code coverage analysis uses gcov integration to provide detailed reports on test coverage, helping identify areas that need additional testing and ensuring comprehensive validation of critical code paths.</p>"},{"location":"entertainment/docs/components/westeros/#test-execution-and-coverage-analysis","title":"Test Execution and Coverage Analysis","text":"<pre><code># Execute platform-specific test suites\n./run-tests.sh drm     # DRM platform tests\n./run-tests.sh v4l2    # V4L2 platform tests\n\n# Generate comprehensive coverage reports\n./get-coverage.sh drm     # DRM coverage analysis\n\n# Run specific test categories\nmake -f Makefile.test clean &amp;&amp; make -f Makefile.test\n</code></pre>"},{"location":"entertainment/docs/components/westeros/#release-information","title":"Release Information","text":""},{"location":"entertainment/docs/components/westeros/#current-release","title":"Current Release:","text":"<p>The latest release is <code>1.01.57</code> (November 25, 2024) and introduces several significant improvements and new features:</p> Feature Description Impact Active Format Descriptor (AFD) Video presentation metadata support Enhanced video formatting capabilities Shutdown Robustness Race condition and cleanup improvements Better system stability Timecode PTS Processing Accurate timestamp handling fixes Professional video application support ALLM Management Auto Low Latency Mode updates Improved gaming performance"},{"location":"entertainment/docs/components/westeros/#development-guidelines","title":"Development Guidelines","text":""},{"location":"entertainment/docs/components/westeros/#adding-new-platform-support","title":"Adding New Platform Support","text":"Step Task Details 1 Create Sink Module New module in <code>westeros-sink/&lt;platform&gt;/</code> 2 Implement Renderer Platform-specific video rendering and display management 3 Protocol Extensions Add specialized functionality if needed 4 Build Configuration Update autotools, add compilation flags 5 Testing Develop platform-specific test suites <p>Platform-specific rendering backends must implement the standard Westeros renderer interface while leveraging platform-specific APIs for optimal performance. This typically involves integrating with the platform's graphics drivers, video acceleration APIs, and display management systems.</p>"},{"location":"entertainment/docs/components/westeros/#protocol-extension-development","title":"Protocol Extension Development","text":"<pre><code>flowchart TD\n    A[Define XML Protocol Specs] --&gt; B[Generate Bindings]\n    B --&gt; C[Implement Client Handlers]\n    B --&gt; D[Implement Server Handlers]\n    C --&gt; E[Compositor Integration]\n    D --&gt; E\n    E --&gt; F[Testing &amp; Validation]</code></pre> <p>Creating new protocol extensions requires careful design to ensure compatibility and maintainability. Protocol binding generation uses the wayland-scanner tool to create client and server implementation code from XML specifications.</p>"},{"location":"entertainment/docs/components/westeros/#troubleshooting","title":"Troubleshooting","text":""},{"location":"entertainment/docs/components/westeros/#common-issues","title":"Common Issues","text":"Issue Type Observed Behavior Diagnostic Steps Solutions Resource Conflicts Multi-application failures Check ERM configuration Configure resource priorities Display Initialization Screen output problems Verify driver configuration Check kernel modules, permissions Video Rendering Playback issues Test hardware acceleration Verify codec support, drivers Protocol Errors Application crashes Check version compatibility Update protocol versions"},{"location":"entertainment/docs/components/westeros/#debug-options","title":"Debug Options","text":"Tool Environment Variable Purpose Usage Verbose Logging <code>WESTEROS_DEBUG=1</code> Detailed operation info Compositor debugging Protocol Debugging <code>WAYLAND_DEBUG=1</code> Message tracing Client-server communication Test Utility <code>westeros_test</code> Display verification Basic functionality testing Platform Tools Platform-specific Resource monitoring Hardware state analysis <p>Resource conflicts often arise in multi-application environments where multiple processes compete for limited hardware resources. Display initialization problems typically stem from incorrect driver configuration or hardware compatibility issues. Video rendering issues may indicate problems with hardware acceleration support or codec compatibility.</p>"},{"location":"entertainment/docs/components/rdkshell/apis/","title":"RDKShell APIs","text":""},{"location":"entertainment/docs/components/rdkshell/apis/#overview","title":"Overview","text":"<p>RDKShell provides multiple API interfaces to accommodate different integration scenarios and programming languages. The system supports JSON-RPC over both traditional socket-based IPC and modern WebSocket connections, as well as direct C++ APIs for native code integration. All APIs provide access to the same underlying functionality through the CompositorController interface.</p> JSON-RPC API WebSocket API <p>RDKShell supports WebSocket-based communication for real-time interaction. The WebSocket API uses the same method names and parameters as the JSON-RPC API but operates over WebSocket connections for lower latency and bidirectional communication.</p> <p>Connection Endpoint: <code>ws://localhost:3000</code></p> <p>Message Format: <pre><code>{\n  \"msg\": \"methodName\",\n  \"params\": {\n    \"parameter1\": \"value1\",\n    \"parameter2\": \"value2\"\n  }\n}\n</code></pre></p> C++ Native API <p>For native code integration, RDKShell provides direct C++ APIs through the CompositorController class. These APIs offer the same functionality as the JSON-RPC interfaces but with direct function calls for maximum performance.</p>"},{"location":"entertainment/docs/components/rdkshell/apis/#application-management-apis","title":"Application Management APIs","text":"createDisplay <p>Method: <code>org.rdk.RDKShell.1.createDisplay</code></p> <p>Parameters: - <code>client</code> (string, required): Unique identifier for the application - <code>displayName</code> (string, optional): Custom name for the display surface - <code>displayWidth</code> (uint32, optional): Width of the display surface - <code>displayHeight</code> (uint32, optional): Height of the display surface - <code>virtualDisplayEnabled</code> (boolean, optional): Enable virtual display mode - <code>virtualWidth</code> (uint32, optional): Virtual display width - <code>virtualHeight</code> (uint32, optional): Virtual display height - <code>topmost</code> (boolean, optional): Create display in topmost layer - <code>focus</code> (boolean, optional): Give focus to the new display - <code>autodestroy</code> (boolean, optional): Automatically destroy when client disconnects</p> <p>Response: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"3\",\n  \"result\": {\n    \"success\": true\n  }\n}\n</code></pre></p> <p>Example Request: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"3\",\n  \"method\": \"org.rdk.RDKShell.1.createDisplay\",\n  \"params\": {\n    \"client\": \"netflix\",\n    \"displayWidth\": 1920,\n    \"displayHeight\": 1080,\n    \"topmost\": true,\n    \"focus\": true\n  }\n}\n</code></pre></p> launchApplication <p>Method: <code>org.rdk.RDKShell.1.launchApplication</code></p> <p>Parameters: - <code>client</code> (string, required): Application identifier - <code>uri</code> (string, required): Application URI or path - <code>mimeType</code> (string, required): MIME type of the application - <code>topmost</code> (boolean, optional): Launch in topmost layer - <code>focus</code> (boolean, optional): Give focus to launched application</p> <p>Response: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"4\",\n  \"result\": {\n    \"success\": true\n  }\n}\n</code></pre></p> kill <p>Method: <code>org.rdk.RDKShell.1.kill</code></p> <p>Parameters: - <code>client</code> (string, required): Application identifier to terminate</p> <p>Response: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"5\",\n  \"result\": {\n    \"success\": true\n  }\n}\n</code></pre></p>"},{"location":"entertainment/docs/components/rdkshell/apis/#display-management-apis","title":"Display Management APIs","text":"getScreenResolution <p>Method: <code>org.rdk.RDKShell.1.getScreenResolution</code></p> <p>Parameters: None</p> <p>Response: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"6\",\n  \"result\": {\n    \"w\": 1920,\n    \"h\": 1080,\n    \"success\": true\n  }\n}\n</code></pre></p> setScreenResolution <p>Method: <code>org.rdk.RDKShell.1.setScreenResolution</code></p> <p>Parameters: - <code>w</code> (uint32, required): Screen width in pixels - <code>h</code> (uint32, required): Screen height in pixels</p> <p>Response: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"7\",\n  \"result\": {\n    \"success\": true\n  }\n}\n</code></pre></p> getBounds <p>Method: <code>org.rdk.RDKShell.1.getBounds</code></p> <p>Parameters: - <code>client</code> (string, required): Application identifier</p> <p>Response: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"8\",\n  \"result\": {\n    \"bounds\": {\n      \"x\": 100,\n      \"y\": 50,\n      \"w\": 800,\n      \"h\": 600\n    },\n    \"success\": true\n  }\n}\n</code></pre></p> setBounds <p>Method: <code>org.rdk.RDKShell.1.setBounds</code></p> <p>Parameters: - <code>client</code> (string, required): Application identifier - <code>x</code> (int32, required): X coordinate - <code>y</code> (int32, required): Y coordinate - <code>w</code> (uint32, required): Width in pixels - <code>h</code> (uint32, required): Height in pixels</p> <p>Response: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"9\",\n  \"result\": {\n    \"success\": true\n  }\n}\n</code></pre></p>"},{"location":"entertainment/docs/components/rdkshell/apis/#visibility-and-appearance-apis","title":"Visibility and Appearance APIs","text":"getVisibility <p>Method: <code>org.rdk.RDKShell.1.getVisibility</code></p> <p>Parameters: - <code>client</code> (string, required): Application identifier</p> <p>Response: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"10\",\n  \"result\": {\n    \"visible\": true,\n    \"success\": true\n  }\n}\n</code></pre></p> setVisibility <p>Method: <code>org.rdk.RDKShell.1.setVisibility</code></p> <p>Parameters: - <code>client</code> (string, required): Application identifier - <code>visible</code> (boolean, required): Visibility state</p> <p>Response: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"11\",\n  \"result\": {\n    \"success\": true\n  }\n}\n</code></pre></p> getOpacity <p>Method: <code>org.rdk.RDKShell.1.getOpacity</code></p> <p>Parameters: - <code>client</code> (string, required): Application identifier</p> <p>Response: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"12\",\n  \"result\": {\n    \"opacity\": 255,\n    \"success\": true\n  }\n}\n</code></pre></p> setOpacity <p>Method: <code>org.rdk.RDKShell.1.setOpacity</code></p> <p>Parameters: - <code>client</code> (string, required): Application identifier - <code>opacity</code> (uint32, required): Opacity value (0-255)</p> <p>Response: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"13\",\n  \"result\": {\n    \"success\": true\n  }\n}\n</code></pre></p>"},{"location":"entertainment/docs/components/rdkshell/apis/#z-order-management-apis","title":"Z-Order Management APIs","text":"moveToFront <p>Method: <code>org.rdk.RDKShell.1.moveToFront</code></p> <p>Parameters: - <code>client</code> (string, required): Application identifier</p> <p>Response: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"14\",\n  \"result\": {\n    \"success\": true\n  }\n}\n</code></pre></p> moveToBack <p>Method: <code>org.rdk.RDKShell.1.moveToBack</code></p> <p>Parameters: - <code>client</code> (string, required): Application identifier</p> <p>Response: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"15\",\n  \"result\": {\n    \"success\": true\n  }\n}\n</code></pre></p> moveBehind <p>Method: <code>org.rdk.RDKShell.1.moveBehind</code></p> <p>Parameters: - <code>client</code> (string, required): Application to move - <code>target</code> (string, required): Application to move behind</p> <p>Response: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"16\",\n  \"result\": {\n    \"success\": true\n  }\n}\n</code></pre></p> getZOrder <p>Method: <code>org.rdk.RDKShell.1.getZOrder</code></p> <p>Parameters: None</p> <p>Response: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"17\",\n  \"result\": {\n    \"clients\": [\"app1\", \"app2\", \"app3\"],\n    \"success\": true\n  }\n}\n</code></pre></p>"},{"location":"entertainment/docs/components/rdkshell/apis/#focus-management-apis","title":"Focus Management APIs","text":"setFocus <p>Method: <code>org.rdk.RDKShell.1.setFocus</code></p> <p>Parameters: - <code>client</code> (string, required): Application identifier</p> <p>Response: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"18\",\n  \"result\": {\n    \"success\": true\n  }\n}\n</code></pre></p> getFocused <p>Method: <code>org.rdk.RDKShell.1.getFocused</code></p> <p>Parameters: None</p> <p>Response: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"19\",\n  \"result\": {\n    \"client\": \"netflix\",\n    \"success\": true\n  }\n}\n</code></pre></p>"},{"location":"entertainment/docs/components/rdkshell/apis/#input-management-apis","title":"Input Management APIs","text":"addKeyIntercept <p>Method: <code>org.rdk.RDKShell.1.addKeyIntercept</code></p> <p>Parameters: - <code>client</code> (string, required): Application identifier - <code>keyCode</code> (uint32, required): Key code to intercept - <code>modifiers</code> (array, optional): Modifier keys (ctrl, shift, alt)</p> <p>Response: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"20\",\n  \"result\": {\n    \"success\": true\n  }\n}\n</code></pre></p> <p>Example Request: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"20\",\n  \"method\": \"org.rdk.RDKShell.1.addKeyIntercept\",\n  \"params\": {\n    \"client\": \"netflix\",\n    \"keyCode\": 48,\n    \"modifiers\": [\"ctrl\", \"shift\"]\n  }\n}\n</code></pre></p> removeKeyIntercept <p>Method: <code>org.rdk.RDKShell.1.removeKeyIntercept</code></p> <p>Parameters: - <code>client</code> (string, required): Application identifier - <code>keyCode</code> (uint32, required): Key code to remove - <code>modifiers</code> (array, optional): Modifier keys</p> <p>Response: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"21\",\n  \"result\": {\n    \"success\": true\n  }\n}\n</code></pre></p>"},{"location":"entertainment/docs/components/rdkshell/apis/#system-information-apis","title":"System Information APIs","text":"getClients <p>Method: <code>org.rdk.RDKShell.1.getClients</code></p> <p>Parameters: None</p> <p>Response: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"22\",\n  \"result\": {\n    \"clients\": [\"netflix\", \"youtube\", \"settings\"],\n    \"success\": true\n  }\n}\n</code></pre></p>"},{"location":"entertainment/docs/components/rdkshell/apis/#key-c-api-functions","title":"Key C++ API Functions","text":"<pre><code>// Application management\nbool CompositorController::createDisplay(const std::string&amp; client, const std::string&amp; displayName);\nbool CompositorController::kill(const std::string&amp; client);\nbool CompositorController::launchApplication(const std::string&amp; client, const std::string&amp; uri, const std::string&amp; mimeType);\n\n// Display management\nbool CompositorController::setBounds(const std::string&amp; client, uint32_t x, uint32_t y, uint32_t width, uint32_t height);\nbool CompositorController::getBounds(const std::string&amp; client, uint32_t &amp;x, uint32_t &amp;y, uint32_t &amp;width, uint32_t &amp;height);\nbool CompositorController::setVisibility(const std::string&amp; client, bool visible);\nbool CompositorController::getVisibility(const std::string&amp; client, bool&amp; visible);\n\n// Focus and z-order management\nbool CompositorController::setFocus(const std::string&amp; client);\nbool CompositorController::moveToFront(const std::string&amp; client);\nbool CompositorController::moveToBack(const std::string&amp; client);\nbool CompositorController::moveBehind(const std::string&amp; client, const std::string&amp; target);\n\n// Input management\nbool CompositorController::addKeyIntercept(const std::string&amp; client, uint32_t keyCode, uint32_t flags);\nbool CompositorController::removeKeyIntercept(const std::string&amp; client, uint32_t keyCode, uint32_t flags);\n</code></pre>"},{"location":"entertainment/docs/components/rdkshell/apis/#error-handling","title":"Error Handling","text":"<p>All APIs return success/failure indicators and provide detailed error information when operations fail. Common error conditions include:</p> <ul> <li>Invalid client identifier: Specified application does not exist</li> <li>Resource constraints: Insufficient memory or graphics resources</li> <li>Permission denied: Application lacks required permissions</li> <li>Invalid parameters: Malformed or out-of-range parameter values</li> <li>System state conflicts: Operation conflicts with current system state</li> </ul> <p>Error responses follow the JSON-RPC error format: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"23\",\n  \"error\": {\n    \"code\": -32602,\n    \"message\": \"Invalid params\",\n    \"data\": \"Client 'invalid_app' not found\"\n  }\n}\n</code></pre></p>"},{"location":"entertainment/docs/components/rdkshell/architecture/","title":"RDKShell Architecture","text":""},{"location":"entertainment/docs/components/rdkshell/architecture/#architectural-design","title":"Architectural Design","text":"<p>RDKShell follows a modular, event\u2011driven architecture with clear separation of concerns:</p> <pre><code>graph TB\n    A[Main Loop&lt;br/&gt;rdkshell.cpp] --&gt; B[Compositor Controller&lt;br/&gt;compositorcontroller.cpp]\n    A --&gt; C[Essos Instance&lt;br/&gt;essosinstance.cpp]\n    A --&gt; D[Input Management&lt;br/&gt;linuxinput.cpp]\n    A --&gt; E[Communication Layer]\n\n    B --&gt; F[RDK Compositor&lt;br/&gt;Surface Management]\n    B --&gt; G[Animation System&lt;br/&gt;animation.cpp]\n    B --&gt; H[Application Registry]\n\n    C --&gt; I[Wayland Integration&lt;br/&gt;Westeros]\n    C --&gt; J[OpenGL Context&lt;br/&gt;GLES2]\n\n    D --&gt; K[Linux Input Handler&lt;br/&gt;Device Management]\n    D --&gt; L[Key Mapping&lt;br/&gt;linuxkeys.cpp]\n    D --&gt; M[Event Router]\n\n    E --&gt; N[JSON-RPC Handler&lt;br/&gt;servermessagehandler.cpp]\n    E --&gt; O[WebSocket Handler&lt;br/&gt;messageHandler.cpp]\n\n    style A fill:#e1f5fe\n    style B fill:#f3e5f5\n    style C fill:#e8f5e8\n    style D fill:#fff3e0\n    style E fill:#fce4ec</code></pre> Key Architectural Principles <p>\u2022 Event\u2011Driven Design - Central main loop coordinates all subsystems through timed events and callbacks \u2022 Modular Components - Each subsystem (compositor, input, communication) operates independently with well\u2011defined interfaces \u2022 Performance\u2011Focused - 40 FPS rendering loop with frame rate limiting and efficient resource management \u2022 Cross\u2011Platform Compatibility - Abstraction layers (Essos/Westeros) enable deployment across different hardware platforms \u2022 Extensible Communication - Multiple IPC protocols (JSON\u2011RPC, WebSocket) support diverse integration scenarios  </p>"},{"location":"entertainment/docs/components/rdkshell/architecture/#core-components","title":"Core Components","text":"Main Application Loop <p>The central component of RDKShell is the main application loop implemented in <code>rdkshell.cpp</code>. This component orchestrates all system operations through a carefully timed rendering loop that maintains consistent frame rates while processing input events, updating application states, and managing system resources. The main loop operates at a configurable frame rate (default 40 FPS) and coordinates between all other subsystems.</p> <p>The main loop implements sophisticated timing logic that adapts to system load while maintaining smooth visual output. It includes frame rate limiting to prevent excessive CPU usage and provides mechanisms for other subsystems to register for periodic callbacks. The loop also handles system shutdown procedures and ensures proper cleanup of all resources when the system terminates.</p> Compositor Controller <p>The CompositorController serves as the primary interface for all application management operations. It maintains the master list of active applications, manages their z-order relationships, handles focus management, and coordinates display composition operations. This component implements the core business logic for window management including bounds calculation, visibility control, opacity management, and animation coordination.</p> <p>The CompositorController provides a unified API that abstracts the complexity of the underlying graphics and windowing systems. It handles the translation between high-level application management operations and low-level graphics operations, ensuring that applications can be managed consistently regardless of the underlying hardware capabilities.</p> Essos Instance Manager <p>The EssosInstance component provides the abstraction layer between RDKShell and the underlying windowing system. It handles the creation and management of Wayland surfaces, manages OpenGL ES contexts, and provides the rendering surface for the compositor. This component enables RDKShell to work with different windowing systems and graphics hardware through a consistent interface.</p> <p>The EssosInstance manager handles the complex initialization sequences required for graphics systems and provides fallback mechanisms when specific capabilities are not available. It manages the relationship between logical displays and physical output devices, enabling support for multiple display configurations and dynamic display management.</p> RDK Compositor System <p>The RdkCompositor hierarchy (RdkCompositor, RdkCompositorSurface, RdkCompositorNested) implements the actual display composition logic. These components handle the low-level details of surface management, texture handling, and rendering operations. They coordinate with the graphics hardware to ensure efficient composition of multiple application surfaces into the final display output.</p> <p>The compositor system includes sophisticated damage tracking to minimize unnecessary redraws and optimize performance. It supports both hardware-accelerated composition when available and software fallback modes for systems with limited graphics capabilities. The system can handle complex composition scenarios including transparency, scaling, and rotation effects.</p> Input Management System <p>The input management system consists of multiple components working together to provide comprehensive input handling. The LinuxInput component handles low-level input device management, while LinuxKeys provides key code mapping and translation. The system supports both physical input devices and virtual input generation, with sophisticated routing capabilities that allow applications to register for specific key combinations regardless of focus state.</p> <p>The input system includes support for multiple input device types and provides configurable key mapping capabilities. It handles device hotplug events and can adapt to changing input device configurations at runtime. The system also provides input event filtering and transformation capabilities to support different application requirements.</p> Communication Subsystem <p>RDKShell implements multiple communication protocols through a pluggable architecture. The ServerMessageHandler provides JSON-RPC over socket-based IPC, while the MessageHandler implements WebSocket-based communication. Both systems use the same underlying CompositorController APIs, ensuring consistent behavior across different communication methods.</p> <p>The communication subsystem is designed to be extensible, allowing for the addition of new protocols and communication methods. It includes built-in security mechanisms and access control to ensure that only authorized applications can access sensitive functionality. The system supports both synchronous and asynchronous communication patterns.</p>"},{"location":"entertainment/docs/components/rdkshell/architecture/#component-interaction-flow","title":"Component Interaction Flow","text":"<pre><code>graph TB\n    A[Main Application Loop] --&gt; B[Compositor Controller]\n    A --&gt; C[Essos Instance]\n    A --&gt; D[Input Manager]\n    A --&gt; E[Communication Handlers]\n\n    B --&gt; F[RDK Compositor]\n    B --&gt; G[Animation System]\n    B --&gt; H[Application Registry]\n\n    C --&gt; I[Wayland Surface Manager]\n    C --&gt; J[OpenGL Context]\n\n    D --&gt; K[Linux Input Handler]\n    D --&gt; L[Key Mapping System]\n    D --&gt; M[Event Router]\n\n    E --&gt; N[JSON-RPC Handler]\n    E --&gt; O[WebSocket Handler]\n    E --&gt; P[Socket Communication]\n\n    F --&gt; Q[Surface Composition]\n    F --&gt; R[Texture Management]\n\n    style A fill:#e1f5fe\n    style B fill:#f3e5f5\n    style C fill:#e8f5e8\n    style D fill:#fff3e0\n    style E fill:#fce4ec</code></pre>"},{"location":"entertainment/docs/components/rdkshell/architecture/#data-flow-architecture","title":"Data Flow Architecture","text":"Application Lifecycle Data Flow <p>When an application is launched, the request flows through the communication layer to the CompositorController, which coordinates with the EssosInstance to create the necessary Wayland surfaces. The RdkCompositor system then manages the ongoing rendering and composition of the application's visual output. State changes are propagated back through the system to update client applications and maintain consistency.</p> Input Event Processing Flow <p>Input events originate from the LinuxInput system, which captures raw input from various devices. These events are processed through the key mapping system to translate hardware-specific codes into standardized key codes. The CompositorController then applies the configured input routing rules to determine which applications should receive each event, supporting both focused application delivery and global key intercepts.</p> Rendering and Composition Flow <p>The rendering pipeline begins with the main application loop triggering a frame update. The CompositorController coordinates with all active RdkCompositor instances to update their visual state, including position, size, opacity, and any active animations. The EssosInstance provides the OpenGL context and manages the final composition to the display surface.</p>"},{"location":"entertainment/docs/components/rdkshell/architecture/#initialization-sequence","title":"Initialization Sequence","text":"<pre><code>sequenceDiagram\n    participant Main as Main Process\n    participant RDK as RdkShell Core\n    participant Essos as Essos Instance\n    participant Comp as Compositor Controller\n    participant Input as Input System\n    participant Comm as Communication\n\n    Main-&gt;&gt;RDK: initialize()\n    RDK-&gt;&gt;RDK: Load configuration\n    RDK-&gt;&gt;RDK: Setup key mappings\n    RDK-&gt;&gt;RDK: Configure memory monitoring\n    RDK-&gt;&gt;Essos: Initialize windowing system\n    Essos-&gt;&gt;Essos: Create OpenGL context\n    Essos-&gt;&gt;Essos: Setup Wayland surfaces\n    RDK-&gt;&gt;Comp: Initialize compositor\n    Comp-&gt;&gt;Comp: Setup application registry\n    RDK-&gt;&gt;Input: Initialize input handling\n    Input-&gt;&gt;Input: Configure input devices\n    Input-&gt;&gt;Input: Setup key routing\n    RDK-&gt;&gt;Comm: Start communication handlers\n    Comm-&gt;&gt;Comm: Initialize IPC channels\n    RDK-&gt;&gt;Main: Initialization complete\n    Main-&gt;&gt;RDK: run()\n    RDK-&gt;&gt;RDK: Enter main loop</code></pre>"},{"location":"entertainment/docs/components/rdkshell/architecture/#memory-and-resource-management","title":"Memory and Resource Management","text":"Memory Monitoring Architecture <p>RDKShell implements a sophisticated memory monitoring system that operates in a separate thread to avoid impacting the main rendering loop performance. The system continuously monitors system RAM, swap usage, and application-specific memory consumption. Configurable thresholds trigger notifications to applications and system components, enabling proactive resource management.</p>"},{"location":"entertainment/docs/components/rdkshell/architecture/#extension-and-plugin-architecture","title":"Extension and Plugin Architecture","text":"Westeros Plugin Integration <p>RDKShell supports Westeros plugins that can extend the core functionality with platform-specific customizations and additional functionality. The plugin system is designed with security and stability in mind, providing isolation between different extensions and the core system. Extensions can be loaded and unloaded dynamically, enabling flexible deployment scenarios and reducing memory usage when specific functionality is not required. The system includes comprehensive APIs for extensions to interact with the core functionality while maintaining appropriate access controls.</p> Built-in Extension System <p>The architecture includes built-in extensions for client control and extended input handling. These extensions demonstrate the plugin architecture and provide commonly needed functionality that can be enabled or disabled based on deployment requirements. The extension system is designed to be modular and allows for easy addition of new capabilities.</p>"},{"location":"entertainment/docs/components/rdkshell/architecture/#performance-considerations","title":"Performance Considerations","text":"Frame Rate Management <p>The architecture is designed around maintaining consistent frame rates through careful timing and resource management. The main loop includes sophisticated timing logic that adapts to system load while maintaining smooth visual output. The system can dynamically adjust frame rates based on system capabilities and current load conditions.</p> Efficient Event Processing <p>Input event processing is optimized to minimize latency while supporting complex routing scenarios. The system uses efficient data structures and algorithms to ensure that input responsiveness is maintained even with multiple applications and complex key intercept configurations.</p> Graphics Pipeline Optimization <p>The rendering pipeline is optimized for the specific requirements of set-top box and smart TV applications, with careful attention to memory bandwidth and GPU utilization patterns typical in these environments. The system includes sophisticated optimization techniques to maximize performance while maintaining visual quality.</p>"},{"location":"entertainment/docs/components/rdkshell/configuration/","title":"Configuration","text":"<p>RDKShell provides extensive configuration capabilities through environment variables, configuration files, and compile-time options. The configuration system is designed to support both development scenarios with detailed debugging capabilities and production deployments with optimized performance characteristics. The system supports hierarchical configuration sources, allowing for system-wide defaults, platform-specific overrides, and application-specific customizations.</p>"},{"location":"entertainment/docs/components/rdkshell/configuration/#environment-variables","title":"Environment Variables","text":""},{"location":"entertainment/docs/components/rdkshell/configuration/#core-system-configuration","title":"Core System Configuration","text":"Variable Type Default Description <code>RDKSHELL_LOG_LEVEL</code> string \"Information\" Sets the verbosity level for logging output. Valid values are \"Debug\", \"Information\", \"Warn\", \"Error\", and \"Fatal\". When set to \"Debug\", detailed runtime information is printed to help with development and troubleshooting. <code>RDKSHELL_FRAMERATE</code> integer 40 Controls the target frame rate for the main rendering loop. Higher values provide smoother animation but consume more CPU resources. The system will attempt to maintain this frame rate while processing input events and updating application states. <code>RDKSHELL_ENABLE_IPC</code> boolean \"0\" Enables the socket-based IPC communication system when set to \"1\". This allows external applications to communicate with RDKShell through JSON-RPC over Unix domain sockets. <code>RDKSHELL_ENABLE_WS_IPC</code> boolean \"0\" Enables the WebSocket-based IPC communication system when set to \"1\". This provides real-time bidirectional communication capabilities for web-based applications and modern client frameworks."},{"location":"entertainment/docs/components/rdkshell/configuration/#memory-management-configuration","title":"Memory Management Configuration","text":"Variable Type Default Description <code>RDKSHELL_LOW_MEMORY_THRESHOLD</code> double 200.0 Sets the threshold in megabytes for low memory notifications. When available system memory falls below this threshold, RDKShell will send low memory notifications to registered applications, allowing them to free up resources proactively. <code>RDKSHELL_CRITICALLY_LOW_MEMORY_THRESHOLD</code> double 100.0 Defines the critically low memory threshold in megabytes. When system memory falls below this level, RDKShell will send critical memory notifications and may take more aggressive resource management actions. This value must be less than or equal to the low memory threshold. <code>RDKSHELL_SWAP_MEMORY_INCREASE_THRESHOLD</code> double 50.0 Sets the threshold in megabytes for swap memory increase notifications. When swap usage increases by more than this amount, applications will be notified of potential memory pressure conditions."},{"location":"entertainment/docs/components/rdkshell/configuration/#input-system-configuration","title":"Input System Configuration","text":"Variable Type Default Description <code>RDKSHELL_KEY_INITIAL_DELAY</code> integer 500 Configures the initial delay in milliseconds before key repeat events begin. This affects how long a user must hold a key before it starts repeating, providing control over input responsiveness and preventing accidental repeated inputs. <code>RDKSHELL_KEY_REPEAT_INTERVAL</code> integer 100 Sets the interval in milliseconds between key repeat events once repeating has started. Lower values result in faster key repetition, while higher values provide more controlled input for navigation scenarios."},{"location":"entertainment/docs/components/rdkshell/configuration/#display-configuration","title":"Display Configuration","text":"Variable Type Default Description <code>RDKSHELL_SET_GRAPHICS_720</code> boolean \"0\" Forces the graphics system to initialize in 720p mode (1280x720) when set to \"1\". This is useful for devices with limited graphics capabilities or when 720p output is specifically required. The system will initialize with these dimensions regardless of the display's native resolution. <code>RDKSHELL_SHOW_SPLASH_SCREEN</code> string undefined When defined, enables the splash screen functionality. The splash screen provides visual feedback during system initialization and can be customized with specific images or animations. <code>RDKSHELL_DISABLE_SPLASH_SCREEN_FILE</code> string undefined Specifies a file path that, when present, will disable the splash screen even if <code>RDKSHELL_SHOW_SPLASH_SCREEN</code> is set. This provides a mechanism for runtime control of splash screen behavior."},{"location":"entertainment/docs/components/rdkshell/configuration/#plugin-and-extension-configuration","title":"Plugin and Extension Configuration","text":"Variable Type Default Description <code>RDKSHELL_WESTEROS_PLUGIN_DIRECTORY</code> string \"/usr/lib/plugins/westeros/\" Specifies the directory path where Westeros plugins are located. RDKShell will search this directory for compatible plugins that extend the core functionality with platform-specific features."},{"location":"entertainment/docs/components/rdkshell/configuration/#configuration-files","title":"Configuration Files","text":""},{"location":"entertainment/docs/components/rdkshell/configuration/#input-device-configuration-inputdevicesconf","title":"Input Device Configuration (<code>inputdevices.conf</code>)","text":"<pre><code>{\n    \"inputDevices\": [\n        {\n            \"vendor\": \"0x119b\",\n            \"product\": \"0x2101\", \n            \"deviceType\": \"0x00\",\n            \"deviceMode\": \"0x00\"\n        },\n        {\n            \"vendor\": \"0x119b\",\n            \"product\": \"0x212b\",\n            \"deviceType\": \"0x01\", \n            \"deviceMode\": \"0x0f\"\n        },\n        {\n            \"vendor\": \"0x06e7\",\n            \"product\": \"0x8038\",\n            \"deviceType\": \"0x02\",\n            \"deviceMode\": \"0x03\"\n        }\n    ],\n    \"irInputDeviceTypeMapping\": [\n        {\n            \"filterCode\": 19,\n            \"deviceType\": \"0xf2\"\n        },\n        {\n            \"filterCode\": 20,\n            \"deviceType\": \"0xf1\"\n        },\n        {\n            \"filterCode\": 21,\n            \"deviceType\": \"0xf3\"\n        }\n    ]\n}\n</code></pre>"},{"location":"entertainment/docs/components/rdkshell/configuration/#input-device-parameters","title":"Input Device Parameters","text":"Parameter Type Description <code>vendor</code> string USB vendor ID in hexadecimal format. This identifies the manufacturer of the input device and is used for device-specific handling and configuration. <code>product</code> string USB product ID in hexadecimal format. Combined with the vendor ID, this uniquely identifies the specific device model and determines appropriate input handling behavior. <code>deviceType</code> string Device type classification in hexadecimal format. This determines how the device's input events are processed and which input handling routines are applied. <code>deviceMode</code> string Device mode configuration in hexadecimal format. This controls specific operational characteristics of the device, such as key repeat behavior and input event filtering."},{"location":"entertainment/docs/components/rdkshell/configuration/#ir-input-device-mapping","title":"IR Input Device Mapping","text":"Parameter Type Description <code>filterCode</code> integer IR filter code that identifies specific IR signal patterns. This allows the system to distinguish between different types of IR input devices and remote controls. <code>deviceType</code> string Device type mapping for IR devices in hexadecimal format. This determines how IR input events are translated into standard input events within the system."},{"location":"entertainment/docs/components/rdkshell/configuration/#permissions-configuration-rdkshellpermissionsconf","title":"Permissions Configuration (<code>rdkshellPermissions.conf</code>)","text":"<pre><code>{\n    \"clients\": [\n        {\n            \"client\": \"trusted_application\",\n            \"extensions\": [\"libwesteros_plugin_rdkshell_client_control.so\"]\n        },\n        {\n            \"client\": \"system_service\",\n            \"extensions\": [\n                \"libwesteros_plugin_rdkshell_client_control.so\",\n                \"libwesteros_plugin_rdkshell_extended_input.so\"\n            ]\n        }\n    ],\n    \"default\": {\n        \"extensions\": []\n    }\n}\n</code></pre>"},{"location":"entertainment/docs/components/rdkshell/configuration/#permission-parameters","title":"Permission Parameters","text":"Parameter Type Description <code>client</code> string Application identifier that matches the client name used in API calls. <code>extensions</code> array List of extension library names that the client is permitted to use. <code>default.extensions</code> array Default extension permissions applied to clients not explicitly listed in the configuration."},{"location":"entertainment/docs/components/rdkshell/configuration/#compile-time-configuration-options","title":"Compile-Time Configuration Options","text":""},{"location":"entertainment/docs/components/rdkshell/configuration/#build-configuration-flags","title":"Build Configuration Flags","text":"Option Default Description <code>RDKSHELL_BUILD_APP</code> ON Controls whether the main RDKShell executable is built. <code>RDKSHELL_BUILD_WEBSOCKET_IPC</code> OFF Enables WebSocket-based IPC communication support. <code>RDKSHELL_BUILD_KEY_METADATA</code> OFF Enables extended key metadata support that provides additional information about input events. <code>RDKSHELL_BUILD_IPC</code> ON Enables traditional socket-based IPC communication. <code>RDKSHELL_BUILD_CLIENT</code> ON Controls whether the RDKShell client library is built. <code>RDKSHELL_BUILD_FORCE_1080</code> OFF Enables compile-time support for forcing 1080p resolution. <code>RDKSHELL_BUILD_ENABLE_KEYREPEATS</code> OFF Enables advanced key repeat functionality with configurable timing and behavior."},{"location":"entertainment/docs/components/rdkshell/configuration/#advanced-build-options","title":"Advanced Build Options","text":"Option Default Description <code>RDKSHELL_BUILD_HIDDEN_SUPPORT</code> OFF Enables support for hidden application states. <code>RDKSHELL_BUILD_EXTERNAL_APPLICATION_SURFACE_COMPOSITION</code> ON Enables support for compositing surfaces from external applications. <code>RDKSHELL_BUILD_KEYBUBBING_TOP_MODE</code> ON Enables key bubbling to topmost applications. <code>RDKSHELL_BUILD_KEY_METADATA_EXTENDED_SUPPORT_FOR_IR</code> OFF Enables extended IR support that provides additional metadata for infrared input devices."},{"location":"entertainment/docs/components/rdkshell/configuration/#runtime-configuration","title":"Runtime Configuration","text":""},{"location":"entertainment/docs/components/rdkshell/configuration/#memory-monitor-configuration","title":"Memory Monitor Configuration","text":"<pre><code>// Configure memory monitoring with specific parameters\nstd::map&lt;std::string, RdkShellData&gt; config;\nconfig[\"enable\"] = true;\nconfig[\"interval\"] = 2.0;  // Check every 2 seconds\nconfig[\"lowRam\"] = 150.0;  // 150MB threshold\nconfig[\"criticallyLowRam\"] = 75.0;  // 75MB critical threshold\nconfig[\"swapIncreaseLimit\"] = 25.0;  // 25MB swap increase limit\nRdkShell::setMemoryMonitor(config);\n</code></pre>"},{"location":"entertainment/docs/components/rdkshell/configuration/#dynamic-display-configuration","title":"Dynamic Display Configuration","text":"<p>Display parameters can be adjusted at runtime through the API system, allowing applications to adapt to changing display conditions or user preferences. This includes resolution changes, display mode adjustments, and multi-display configuration management.</p>"},{"location":"entertainment/docs/components/rdkshell/configuration/#input-device-runtime-configuration","title":"Input Device Runtime Configuration","text":"<p>Input device behavior can be modified at runtime through the input management APIs, enabling dynamic adaptation to different input scenarios and user preferences. This includes key mapping changes, device enable/disable operations, and input routing configuration.</p>"},{"location":"entertainment/docs/components/rdkshell/configuration/#best-practices","title":"Best Practices","text":"Development <p>Enable debug logging and extended metadata collection to facilitate troubleshooting and performance analysis.</p> <p>Use higher frame rates for smoother development experience but be aware of increased resource consumption.</p> <p>Enable additional build options that provide debugging capabilities and detailed system information.</p> Production <p>Use optimized logging levels and carefully tuned memory thresholds based on the specific hardware platform and application requirements.</p> <p>Disable unnecessary features to minimize resource usage and potential security exposure.</p> <p>Use conservative memory thresholds to ensure system stability under varying load conditions.</p> Security <p>Carefully configure the permissions system to ensure that only trusted applications have access to sensitive extensions and capabilities.</p> <p>Regularly review and update permission configurations as applications are added or removed from the system.</p> <p>Use the principle of least privilege when granting extension access to applications.</p> Performance <p>Configure frame rates and memory thresholds based on the specific hardware capabilities and performance requirements of the target deployment.</p> <p>Monitor system performance under typical usage scenarios and adjust configuration parameters to optimize for the specific use case and hardware platform.</p>"},{"location":"entertainment/docs/components/rdkshell/keymapping/","title":"RDKShell Key Mappings and Input Management","text":""},{"location":"entertainment/docs/components/rdkshell/keymapping/#overview","title":"Overview","text":"<p>RDKShell implements a comprehensive key mapping system that translates between different key code formats and provides sophisticated input event routing capabilities. The system supports both Wayland key codes for low-level input handling and RDKShell virtual key codes for application-level input processing. This dual-layer approach ensures compatibility with various input devices while providing a consistent interface for applications.</p> <p>The key mapping system is designed to handle the diverse input requirements of set-top box and smart TV environments, where applications must work with various remote controls, keyboards, and specialized input devices. The system provides flexible mapping capabilities that can be configured for different device types and user preferences.</p>"},{"location":"entertainment/docs/components/rdkshell/keymapping/#key-code-translation-system","title":"Key Code Translation System","text":"Wayland Key Codes <p>RDKShell uses Wayland key codes as the foundation for low-level input processing. These codes correspond directly to Linux input event codes and provide the interface between hardware input devices and the RDKShell input processing system. Wayland key codes are hardware-specific and may vary between different input devices and platforms.</p> RDKShell Virtual Key Codes <p>The virtual key code system provides a standardized interface for applications, abstracting away hardware-specific details and ensuring consistent behavior across different input devices and platforms. Virtual key codes are designed to be stable across different hardware configurations and provide a consistent programming interface for application developers.</p>"},{"location":"entertainment/docs/components/rdkshell/keymapping/#standard-key-mappings","title":"Standard Key Mappings","text":""},{"location":"entertainment/docs/components/rdkshell/keymapping/#alphanumeric-keys","title":"Alphanumeric Keys","text":"Key Wayland Code RDKShell Code Description 0 11 48 Number zero key 1 2 49 Number one key 2 3 50 Number two key 3 4 51 Number three key 4 5 52 Number four key 5 6 53 Number five key 6 7 54 Number six key 7 8 55 Number seven key 8 9 56 Number eight key 9 10 57 Number nine key A 30 65 Letter A key B 48 66 Letter B key C 46 67 Letter C key D 32 68 Letter D key E 18 69 Letter E key F 33 70 Letter F key G 34 71 Letter G key H 35 72 Letter H key I 23 73 Letter I key J 36 74 Letter J key K 37 75 Letter K key L 38 76 Letter L key M 50 77 Letter M key N 49 78 Letter N key O 24 79 Letter O key P 25 80 Letter P key Q 16 81 Letter Q key R 19 82 Letter R key S 31 83 Letter S key T 20 84 Letter T key U 22 85 Letter U key V 47 86 Letter V key W 17 87 Letter W key X 45 88 Letter X key Y 21 89 Letter Y key Z 44 90 Letter Z key"},{"location":"entertainment/docs/components/rdkshell/keymapping/#function-keys","title":"Function Keys","text":"Key Wayland Code RDKShell Code Description F1 59 112 Function key F1 F2 60 113 Function key F2 F3 61 114 Function key F3 F4 62 115 Function key F4 F5 63 116 Function key F5 F6 64 117 Function key F6 F7 65 118 Function key F7 F8 66 119 Function key F8 F9 67 120 Function key F9 F10 68 121 Function key F10 F11 87 122 Function key F11 F12 88 123 Function key F12 F13 183 124 Function key F13 F14 184 125 Function key F14 F15 185 126 Function key F15 F16 186 127 Function key F16 F17 187 129 Function key F17 F18 188 130 Function key F18 F19 189 131 Function key F19 F20 190 132 Function key F20 F21 191 133 Function key F21 F22 192 134 Function key F22 F23 193 135 Function key F23 F24 194 136 Function key F24"},{"location":"entertainment/docs/components/rdkshell/keymapping/#navigation-keys","title":"Navigation Keys","text":"Key Wayland Code RDKShell Code Description Up Arrow 103 38 Directional up navigation key Down Arrow 108 40 Directional down navigation key Left Arrow 105 37 Directional left navigation key Right Arrow 106 39 Directional right navigation key Home 102 36 Home navigation key End 107 35 End navigation key Page Up 104 33 Page up navigation key Page Down 109 34 Page down navigation key Insert 110 45 Insert key Delete 111 46 Delete key"},{"location":"entertainment/docs/components/rdkshell/keymapping/#control-and-modifier-keys","title":"Control and Modifier Keys","text":"Key Wayland Code RDKShell Code Flag Value Description Escape 1 27 - Escape key for canceling operations Tab 15 9 - Tab key for navigation and focus control Enter 28 13 - Enter key for confirmation and line breaks Space 57 32 - Space bar for text input and selection Backspace 14 8 - Backspace key for deleting characters Left Shift 42 16 8 Left shift modifier key Right Shift 54 16 8 Right shift modifier key Left Ctrl 29 17 16 Left control modifier key Right Ctrl 97 17 16 Right control modifier key Left Alt 56 18 32 Left alt modifier key Right Alt 100 18 32 Right alt modifier key Caps Lock 58 20 - Caps lock toggle key Num Lock 69 144 - Numeric keypad lock toggle Scroll Lock 70 145 - Scroll lock toggle key Pause 119 19 - Pause/break key"},{"location":"entertainment/docs/components/rdkshell/keymapping/#special-media-and-remote-control-keys","title":"Special Media and Remote Control Keys","text":"Key Wayland Code RDKShell Code Description Red 0x190 405 Red colored key typically found on remote controls Green 0x191 406 Green colored key typically found on remote controls Yellow 0x18e 403 Yellow colored key typically found on remote controls Blue 0x18f 404 Blue colored key typically found on remote controls Back 158 407 Back navigation key for returning to previous screens Menu 139 408 Menu key for accessing application menus Home Page 172 409 Home page key for returning to main interface Volume Up 115 175 Volume increase key Volume Down 114 174 Volume decrease key Mute 113 173 Audio mute toggle key Play/Pause 164 227 Media play/pause toggle key Play 207 226 Media play key Fast Forward 208 223 Media fast forward key Rewind 168 224 Media rewind key"},{"location":"entertainment/docs/components/rdkshell/keymapping/#numeric-keypad","title":"Numeric Keypad","text":"Key Wayland Code RDKShell Code Description Keypad 0 82 96 Numeric keypad zero Keypad 1 79 97 Numeric keypad one Keypad 2 80 98 Numeric keypad two Keypad 3 81 99 Numeric keypad three Keypad 4 75 100 Numeric keypad four Keypad 5 76 101 Numeric keypad five Keypad 6 77 102 Numeric keypad six Keypad 7 71 103 Numeric keypad seven Keypad 8 72 104 Numeric keypad eight Keypad 9 73 105 Numeric keypad nine Keypad Plus 78 107 Numeric keypad addition operator Keypad Minus 74 109 Numeric keypad subtraction operator Keypad Multiply 55 106 Numeric keypad multiplication operator Keypad Divide 98 111 Numeric keypad division operator Keypad Decimal 83 110 Numeric keypad decimal point Keypad Enter 96 13 Numeric keypad enter key"},{"location":"entertainment/docs/components/rdkshell/keymapping/#modifier-key-flags","title":"Modifier Key Flags","text":"<p>RDKShell uses flag values to represent modifier key states that can be combined with regular key codes to create complex key combinations. These flags can be combined using bitwise OR operations to represent multiple simultaneous modifier keys.</p> Modifier Flag Value Description Shift 8 Shift key modifier for uppercase letters and symbol access Control 16 Control key modifier for keyboard shortcuts and commands Alt 32 Alt key modifier for alternative character input and shortcuts Command 64 Command/Windows key modifier for system-level shortcuts"},{"location":"entertainment/docs/components/rdkshell/keymapping/#modifier-combination-examples","title":"Modifier Combination Examples","text":"<pre><code>// Ctrl+C combination\nuint32_t keyCode = 67;  // C key\nuint32_t flags = 16;    // Control modifier\n\n// Ctrl+Shift+F combination  \nuint32_t keyCode = 70;  // F key\nuint32_t flags = 24;    // Control (16) + Shift (8)\n\n// Alt+Tab combination\nuint32_t keyCode = 9;   // Tab key\nuint32_t flags = 32;    // Alt modifier\n\n// Ctrl+Alt+Delete combination\nuint32_t keyCode = 46;  // Delete key\nuint32_t flags = 48;    // Control (16) + Alt (32)\n</code></pre>"},{"location":"entertainment/docs/components/rdkshell/keymapping/#input-event-processing","title":"Input Event Processing","text":"Key Event Types <p>RDKShell processes two primary types of key events: key press events and key release events. Each event includes the key code, modifier flags, and timing metadata. The system maintains state information about which keys are currently pressed to support complex input scenarios and modifier key combinations.</p> Key Repeat Handling <p>The system supports configurable key repeat functionality with separate settings for initial delay and repeat interval. Key repeat events are marked with a special flag to distinguish them from initial key press events. The repeat behavior can be configured globally or on a per-application basis.</p> <pre><code>#define RDKSHELL_KEYDOWN_REPEAT 128\n</code></pre> <p>The key repeat system includes sophisticated logic to handle modifier keys correctly and ensure that repeat events are only generated for appropriate key types. Navigation keys and character keys typically support repeat, while modifier keys and special function keys do not.</p> Event Routing and Interception <p>Applications can register to intercept specific key combinations even when they are not in focus. This enables global hotkey functionality and allows background applications to respond to specific input events. The interception system supports complex routing scenarios where multiple applications may be interested in the same key events.</p> <p>The event routing system includes priority mechanisms to ensure that critical system functions can always access required key combinations. Applications can register for different types of key interception, including exclusive access, shared access, and monitoring-only access.</p>"},{"location":"entertainment/docs/components/rdkshell/keymapping/#mouse-and-pointer-input","title":"Mouse and Pointer Input","text":""},{"location":"entertainment/docs/components/rdkshell/keymapping/#mouse-button-mappings","title":"Mouse Button Mappings","text":"Button Flag Value Description Left Button 1 Primary mouse button for selection and activation Middle Button 2 Middle mouse button typically used for scrolling Right Button 4 Secondary mouse button for context menus"},{"location":"entertainment/docs/components/rdkshell/keymapping/#pointer-event-processing","title":"Pointer Event Processing","text":"<p>RDKShell processes pointer motion events and button press/release events, providing applications with precise cursor position information and button state changes. The system supports both absolute and relative pointer positioning and can handle multiple pointer devices simultaneously.</p> <p>The pointer event system includes support for touch interfaces and gesture recognition when available. It provides coordinate transformation capabilities to support different display resolutions and scaling factors.</p>"},{"location":"entertainment/docs/components/rdkshell/keymapping/#input-device-configuration","title":"Input Device Configuration","text":"Device Type Classifications <p>The input system supports various device type classifications that determine how input events are processed and routed through the system. Different device types may have different key mappings, repeat behaviors, and event processing characteristics.</p> Custom Input Device Support <p>RDKShell can be configured to support custom input devices through the input device configuration file, allowing for specialized remote controls and input hardware commonly used in set-top box and smart TV environments. The system includes support for device-specific key mappings and behavior customization.</p>"},{"location":"entertainment/docs/components/rdkshell/keymapping/#virtual-key-support","title":"Virtual Key Support","text":"Virtual Key Generation <p>The system supports programmatic generation of virtual key events, enabling applications to simulate user input for automation and testing scenarios. Virtual key events are processed through the same routing and interception mechanisms as physical key events.</p> Virtual Key Mapping <p>Virtual keys can be mapped to physical key codes through string-based identifiers, providing a flexible interface for dynamic key mapping scenarios. This enables applications to define custom key mappings that can be configured at runtime.</p>"},{"location":"entertainment/docs/components/rdkshell/keymapping/#best-practices","title":"Best Practices","text":"Key Intercept Registration <p>Applications should register for key intercepts only for the specific key combinations they need to handle globally. Excessive key intercept registrations can impact system performance and interfere with other applications. Applications should also properly remove their key intercept registrations when they are suspended or terminated.</p> Modifier Key Handling <p>When processing key events with modifiers, applications should check for the specific modifier combinations they support and ignore unexpected modifier states to ensure robust input handling. Applications should also be prepared to handle cases where modifier keys are pressed or released independently of other keys.</p> Input Event Cleanup <p>Applications should properly remove their key intercept registrations when they are suspended or terminated to prevent resource leaks and ensure proper input routing for other applications. The system includes automatic cleanup mechanisms, but applications should not rely solely on these mechanisms.</p> Performance Considerations <p>Input event processing should be optimized to minimize latency and ensure responsive user interaction. Applications should avoid performing heavy processing in input event handlers and should use efficient data structures for key mapping and event routing operations.</p>"},{"location":"entertainment/docs/components/rdkshell/overview/","title":"Overview","text":"<p>RDKShell is a native component that serves as the foundational application management, composition, and input handling system within the RDK (Reference Design Kit) ecosystem. It functions as a sophisticated window manager and compositor that provides comprehensive control over application lifecycle, display composition, and advanced input event processing for set-top boxes, smart TVs, and other RDK-enabled devices.</p>"},{"location":"entertainment/docs/components/rdkshell/overview/#core-functionalities","title":"Core Functionalities","text":"<p>RDKShell operates as the central orchestrator between the underlying graphics subsystem and applications running on RDK devices. It bridges the gap between low-level graphics capabilities and high-level application requirements by providing a unified interface for application management and display composition. The component integrates deeply with the Wayland display server protocol through Westeros and leverages Essos for flexible windowing system connectivity, enabling it to work seamlessly across different hardware platforms and display configurations.</p> <p>Info</p> <p>Wayland + Westeros + Essos: RDKShell uses these to ensure cross-platform compatibility and modern graphics integration.</p> <p>The module serves as the primary interface for system-level operations such as launching applications, managing their visual presentation, controlling their z-order positioning, and handling complex input event routing. This makes RDKShell essential for creating cohesive user experiences where multiple applications can coexist and interact appropriately within the same display environment.</p>"},{"location":"entertainment/docs/components/rdkshell/overview/#core-capabilities","title":"Core Capabilities","text":""},{"location":"entertainment/docs/components/rdkshell/overview/#application-lifecycle-management","title":"Application Lifecycle Management","text":"<p>RDKShell provides comprehensive application lifecycle management capabilities that extend beyond simple process control. It manages the complete lifecycle from application launch through suspension, resumption, and termination. The system maintains detailed state information for each managed application, including their display properties, input event subscriptions, and resource allocations. This enables sophisticated power management scenarios where applications can be suspended to conserve resources while maintaining their visual state for quick resumption.</p> <p>Note</p> <p>Applications can register for lifecycle events to preserve state and perform cleanup during transitions.</p> <p>The lifecycle management system supports both traditional application models where applications run continuously and modern power-efficient models where applications can be dynamically suspended and resumed based on user interaction patterns and system resource availability. Applications can register for lifecycle events to perform appropriate cleanup and state preservation operations during transitions.</p>"},{"location":"entertainment/docs/components/rdkshell/overview/#advanced-display-composition","title":"Advanced Display Composition","text":"<p>The composition engine within RDKShell handles complex multi-application display scenarios with pixel-perfect precision. It supports arbitrary positioning, scaling, rotation, and opacity control for each application window. The system can handle both traditional rectangular windows and more complex shapes through its integration with OpenGL ES 2.0 rendering pipelines. Advanced features include support for virtual displays, where applications can render to off-screen buffers for scenarios like picture-in-picture or thumbnail generation.</p> <p>Tip</p> <p>Supports both hardware-accelerated and software rendering, with fallback to software when hardware isn't available.</p> <p>The compositor supports hardware-accelerated composition when available, automatically falling back to software rendering when necessary. It includes sophisticated damage tracking to minimize unnecessary redraws and optimize performance on resource-constrained devices. The system can handle multiple display outputs simultaneously, enabling scenarios where different applications are displayed on different screens or display zones.</p>"},{"location":"entertainment/docs/components/rdkshell/overview/#sophisticated-input-event-management","title":"Sophisticated Input Event Management","text":"<p>RDKShell implements a highly configurable input event management system that goes far beyond simple key forwarding. Applications can register for specific key combinations even when they are not in focus, enabling global hotkey functionality and complex input routing scenarios. The system supports both physical key events from various input devices and virtual key generation for programmatic input simulation. Input event metadata is preserved and can be used for advanced input processing scenarios.</p> <p>Note</p> <p>Global hotkeys and key remapping are supported across devices including remote controls and touch interfaces.</p> <p>The input management system includes support for multiple input device types including traditional keyboards, remote controls, game controllers, and touch interfaces. It provides sophisticated key mapping capabilities that can translate between different input device protocols and key code formats. The system supports configurable key repeat rates, modifier key combinations, and complex input event filtering based on application requirements and system policies.</p>"},{"location":"entertainment/docs/components/rdkshell/overview/#memory-and-resource-monitoring","title":"Memory and Resource Monitoring","text":"<p>The component includes comprehensive system resource monitoring capabilities with configurable thresholds and automatic notification systems. It continuously monitors RAM usage, swap utilization, and can trigger low-memory notifications to applications and system components. This enables proactive resource management and helps prevent system instability due to resource exhaustion.</p> <p>Warning</p> <p>Applications should respond to low-memory warnings by reducing cache or suspending non-critical features.</p> <p>The monitoring system operates in a separate thread to avoid impacting the main rendering loop performance. It provides both immediate notifications for critical resource conditions and periodic reports for trend analysis. Applications can register for different types of resource notifications and adjust their behavior accordingly, such as reducing cache sizes or suspending non-essential operations during low-memory conditions.</p>"},{"location":"entertainment/docs/components/rdkshell/overview/#multi-protocol-communication","title":"Multi-Protocol Communication","text":"<p>RDKShell supports multiple communication protocols to accommodate different integration scenarios. It provides JSON-RPC APIs over both traditional socket-based IPC and modern WebSocket connections. Additionally, it offers direct C++ APIs for native code integration. This flexibility allows it to integrate with various system architectures and application frameworks commonly used in the RDK ecosystem.</p> <p>Info</p> <p>RDKShell supports both synchronous and asynchronous APIs for efficient system communication.</p> <p>The communication system is designed to be extensible, allowing for the addition of new protocols and communication methods as requirements evolve. It includes built-in security mechanisms to ensure that only authorized applications can access sensitive functionality. The system supports both synchronous and asynchronous communication patterns, enabling efficient integration with different application architectures.</p>"},{"location":"entertainment/docs/components/rdkshell/overview/#technical-components","title":"Technical Components","text":""},{"location":"entertainment/docs/components/rdkshell/overview/#graphics-and-windowing-integration","title":"Graphics and Windowing Integration","text":"<p>RDKShell builds upon industry-standard graphics technologies including OpenGL ES 2.0 for hardware-accelerated rendering and the Wayland display server protocol for modern windowing system integration. Through its use of Westeros, it can create Wayland surfaces and displays that applications can connect to, while Essos provides the flexibility to connect to either native windowing systems or existing Wayland compositors depending on the deployment scenario.</p> <p>Info</p> <p>Rendering strategies are dynamically selected based on available GPU/CPU capabilities.</p> <p>The graphics integration is designed to work efficiently across a wide range of hardware capabilities, from high-end devices with dedicated GPUs to resource-constrained embedded systems. The system automatically detects available graphics capabilities and adjusts its rendering strategies accordingly to provide optimal performance while maintaining visual quality.</p>"},{"location":"entertainment/docs/components/rdkshell/overview/#threading-and-performance-architecture","title":"Threading and Performance Architecture","text":"<p>The system is designed with performance as a primary consideration, implementing a carefully tuned main loop that maintains consistent frame rates while handling multiple concurrent operations. The default 40 FPS rendering loop can be adjusted based on system capabilities and requirements. Memory monitoring and other background operations are handled in separate threads to avoid impacting the critical rendering path.</p> <p>Tip</p> <p>Uses separate threads for background tasks to ensure smooth UI performance.</p> <p>The threading architecture is designed to minimize contention and maximize parallelism where possible. Critical operations are prioritized to ensure responsive user interaction, while background tasks are scheduled to use available system resources without interfering with real-time requirements. The system includes sophisticated timing and synchronization mechanisms to coordinate between different subsystems.</p>"},{"location":"entertainment/docs/components/rdkshell/overview/#extension-and-plugin-system","title":"Extension and Plugin System","text":"<p>RDKShell includes a sophisticated extension system that allows for platform-specific customizations and additional functionality. The system supports Westeros plugins and includes built-in extensions for client control and extended input handling. This extensibility ensures that RDKShell can be adapted to specific hardware platforms and use cases while maintaining a consistent core architecture.</p> <p>The plugin system is designed with security and stability in mind, providing isolation between different extensions and the core system. Extensions can be loaded and unloaded dynamically, enabling flexible deployment scenarios and reducing memory usage when specific functionality is not required. The system includes comprehensive APIs for extensions to interact with the core functionality while maintaining appropriate access controls.</p>"},{"location":"entertainment/docs/components/rdkshell/overview/#configuration-and-deployment-flexibility","title":"Configuration and Deployment Flexibility","text":"<p>The component supports extensive configuration through environment variables, configuration files, and runtime parameters. This includes display resolution control, memory monitoring thresholds, input device mappings, and permission systems. The configuration system is designed to support both development scenarios with extensive debugging capabilities and production deployments with optimized performance characteristics.</p> <p>Note</p> <p>Configuration changes can be applied at runtime where possible \u2014 no reboot required.</p> <p>The configuration system supports hierarchical configuration sources, allowing for system-wide defaults, platform-specific overrides, and application-specific customizations. Configuration changes can be applied at runtime where appropriate, enabling dynamic adaptation to changing system conditions and requirements without requiring system restarts.</p>"},{"location":"entertainment/docs/components/rdkshell/overview/#system-integration","title":"System Integration","text":"<p>RDKShell integrates with multiple layers of the RDK stack, from low-level graphics drivers through high-level application frameworks. It communicates with the Thunder framework for system-level coordination, integrates with various input subsystems for comprehensive input handling, and provides the foundation for application frameworks to build upon. The component's design ensures that it can adapt to different hardware capabilities while providing consistent APIs and behavior across different RDK implementations.</p> <p>Info</p> <p>Integration interfaces are consistent across platforms, even with different display/input backends.</p> <p>The integration architecture is designed to be modular and extensible, allowing for easy adaptation to new hardware platforms and software frameworks. The system provides well-defined interfaces for integration with external components while maintaining appropriate abstraction layers to ensure compatibility across different deployment scenarios.</p>"},{"location":"entertainment/docs/components/rdkshell/overview/#use-cases-and-applications","title":"Use Cases and Applications","text":"<p>RDKShell is designed to support a wide range of use cases common in modern entertainment and smart home devices. These include traditional set-top box scenarios with multiple video applications, smart TV interfaces with app stores and content discovery, and advanced scenarios like multi-room audio/video distribution and home automation integration.</p> Scenario Description Set-top boxes Multi-app video playback, z-order management Smart TVs App store navigation, content discovery, responsive UI Multi-room AV Render to off-screen buffers, distributed playback Home automation integration Input event routing, control overlay apps, support for virtual assistants and voice <p>The system's flexibility enables it to support both simple single-application scenarios and complex multi-application environments with sophisticated user interfaces. It can handle everything from basic remote control navigation to advanced touch-based interactions and voice control integration, making it suitable for a wide range of device types and user interaction models.</p>"},{"location":"entertainment/docs/components/rdkshell/overview/#architecture","title":"Architecture","text":""},{"location":"entertainment/docs/components/rdkshell/overview/#architectural-design","title":"Architectural Design","text":"<p>RDKShell follows a modular, event\u2011driven architecture with clear separation of concerns:</p> <pre><code>graph TB\n    A[Main Loop&lt;br/&gt;rdkshell.cpp] --&gt; B[Compositor Controller&lt;br/&gt;compositorcontroller.cpp]\n    A --&gt; C[Essos Instance&lt;br/&gt;essosinstance.cpp]\n    A --&gt; D[Input Management&lt;br/&gt;linuxinput.cpp]\n    A --&gt; E[Communication Layer]\n\n    B --&gt; F[RDK Compositor&lt;br/&gt;Surface Management]\n    B --&gt; G[Animation System&lt;br/&gt;animation.cpp]\n    B --&gt; H[Application Registry]\n\n    C --&gt; I[Wayland Integration&lt;br/&gt;Westeros]\n    C --&gt; J[OpenGL Context&lt;br/&gt;GLES2]\n\n    D --&gt; K[Linux Input Handler&lt;br/&gt;Device Management]\n    D --&gt; L[Key Mapping&lt;br/&gt;linuxkeys.cpp]\n    D --&gt; M[Event Router]\n\n    E --&gt; N[JSON-RPC Handler&lt;br/&gt;servermessagehandler.cpp]\n    E --&gt; O[WebSocket Handler&lt;br/&gt;messageHandler.cpp]\n\n    style A fill:#e1f5fe\n    style B fill:#f3e5f5\n    style C fill:#e8f5e8\n    style D fill:#fff3e0\n    style E fill:#fce4ec</code></pre> Key Architectural Principles <p>\u2022 Event\u2011Driven Design - Central main loop coordinates all subsystems through timed events and callbacks \u2022 Modular Components - Each subsystem (compositor, input, communication) operates independently with well\u2011defined interfaces \u2022 Performance\u2011Focused - 40 FPS rendering loop with frame rate limiting and efficient resource management \u2022 Cross\u2011Platform Compatibility - Abstraction layers (Essos/Westeros) enable deployment across different hardware platforms \u2022 Extensible Communication - Multiple IPC protocols (JSON\u2011RPC, WebSocket) support diverse integration scenarios  </p>"},{"location":"entertainment/docs/components/rdkshell/overview/#core-components","title":"Core Components","text":"Main Application Loop <p>The central component of RDKShell is the main application loop implemented in <code>rdkshell.cpp</code>. This component orchestrates all system operations through a carefully timed rendering loop that maintains consistent frame rates while processing input events, updating application states, and managing system resources. The main loop operates at a configurable frame rate (default 40 FPS) and coordinates between all other subsystems.</p> <p>The main loop implements sophisticated timing logic that adapts to system load while maintaining smooth visual output. It includes frame rate limiting to prevent excessive CPU usage and provides mechanisms for other subsystems to register for periodic callbacks. The loop also handles system shutdown procedures and ensures proper cleanup of all resources when the system terminates.</p> Compositor Controller <p>The CompositorController serves as the primary interface for all application management operations. It maintains the master list of active applications, manages their z-order relationships, handles focus management, and coordinates display composition operations. This component implements the core business logic for window management including bounds calculation, visibility control, opacity management, and animation coordination.</p> <p>The CompositorController provides a unified API that abstracts the complexity of the underlying graphics and windowing systems. It handles the translation between high-level application management operations and low-level graphics operations, ensuring that applications can be managed consistently regardless of the underlying hardware capabilities.</p> Essos Instance Manager <p>The EssosInstance component provides the abstraction layer between RDKShell and the underlying windowing system. It handles the creation and management of Wayland surfaces, manages OpenGL ES contexts, and provides the rendering surface for the compositor. This component enables RDKShell to work with different windowing systems and graphics hardware through a consistent interface.</p> <p>The EssosInstance manager handles the complex initialization sequences required for graphics systems and provides fallback mechanisms when specific capabilities are not available. It manages the relationship between logical displays and physical output devices, enabling support for multiple display configurations and dynamic display management.</p> RDK Compositor System <p>The RdkCompositor hierarchy (RdkCompositor, RdkCompositorSurface, RdkCompositorNested) implements the actual display composition logic. These components handle the low-level details of surface management, texture handling, and rendering operations. They coordinate with the graphics hardware to ensure efficient composition of multiple application surfaces into the final display output.</p> <p>The compositor system includes sophisticated damage tracking to minimize unnecessary redraws and optimize performance. It supports both hardware-accelerated composition when available and software fallback modes for systems with limited graphics capabilities. The system can handle complex composition scenarios including transparency, scaling, and rotation effects.</p> Input Management System <p>The input management system consists of multiple components working together to provide comprehensive input handling. The LinuxInput component handles low-level input device management, while LinuxKeys provides key code mapping and translation. The system supports both physical input devices and virtual input generation, with sophisticated routing capabilities that allow applications to register for specific key combinations regardless of focus state.</p> <p>The input system includes support for multiple input device types and provides configurable key mapping capabilities. It handles device hotplug events and can adapt to changing input device configurations at runtime. The system also provides input event filtering and transformation capabilities to support different application requirements.</p> Communication Subsystem <p>RDKShell implements multiple communication protocols through a pluggable architecture. The ServerMessageHandler provides JSON-RPC over socket-based IPC, while the MessageHandler implements WebSocket-based communication. Both systems use the same underlying CompositorController APIs, ensuring consistent behavior across different communication methods.</p> <p>The communication subsystem is designed to be extensible, allowing for the addition of new protocols and communication methods. It includes built-in security mechanisms and access control to ensure that only authorized applications can access sensitive functionality. The system supports both synchronous and asynchronous communication patterns.</p>"},{"location":"entertainment/docs/components/rdkshell/overview/#component-interaction-flow","title":"Component Interaction Flow","text":"<pre><code>graph TB\n    A[Main Application Loop] --&gt; B[Compositor Controller]\n    A --&gt; C[Essos Instance]\n    A --&gt; D[Input Manager]\n    A --&gt; E[Communication Handlers]\n\n    B --&gt; F[RDK Compositor]\n    B --&gt; G[Animation System]\n    B --&gt; H[Application Registry]\n\n    C --&gt; I[Wayland Surface Manager]\n    C --&gt; J[OpenGL Context]\n\n    D --&gt; K[Linux Input Handler]\n    D --&gt; L[Key Mapping System]\n    D --&gt; M[Event Router]\n\n    E --&gt; N[JSON-RPC Handler]\n    E --&gt; O[WebSocket Handler]\n    E --&gt; P[Socket Communication]\n\n    F --&gt; Q[Surface Composition]\n    F --&gt; R[Texture Management]\n\n    style A fill:#e1f5fe\n    style B fill:#f3e5f5\n    style C fill:#e8f5e8\n    style D fill:#fff3e0\n    style E fill:#fce4ec</code></pre>"},{"location":"entertainment/docs/components/rdkshell/overview/#data-flow-architecture","title":"Data Flow Architecture","text":"Application Lifecycle Data Flow <p>When an application is launched, the request flows through the communication layer to the CompositorController, which coordinates with the EssosInstance to create the necessary Wayland surfaces. The RdkCompositor system then manages the ongoing rendering and composition of the application's visual output. State changes are propagated back through the system to update client applications and maintain consistency.</p> Input Event Processing Flow <p>Input events originate from the LinuxInput system, which captures raw input from various devices. These events are processed through the key mapping system to translate hardware-specific codes into standardized key codes. The CompositorController then applies the configured input routing rules to determine which applications should receive each event, supporting both focused application delivery and global key intercepts.</p> Rendering and Composition Flow <p>The rendering pipeline begins with the main application loop triggering a frame update. The CompositorController coordinates with all active RdkCompositor instances to update their visual state, including position, size, opacity, and any active animations. The EssosInstance provides the OpenGL context and manages the final composition to the display surface.</p>"},{"location":"entertainment/docs/components/rdkshell/overview/#initialization-sequence","title":"Initialization Sequence","text":"<pre><code>sequenceDiagram\n    participant Main as Main Process\n    participant RDK as RdkShell Core\n    participant Essos as Essos Instance\n    participant Comp as Compositor Controller\n    participant Input as Input System\n    participant Comm as Communication\n\n    Main-&gt;&gt;RDK: initialize()\n    RDK-&gt;&gt;RDK: Load configuration\n    RDK-&gt;&gt;RDK: Setup key mappings\n    RDK-&gt;&gt;RDK: Configure memory monitoring\n    RDK-&gt;&gt;Essos: Initialize windowing system\n    Essos-&gt;&gt;Essos: Create OpenGL context\n    Essos-&gt;&gt;Essos: Setup Wayland surfaces\n    RDK-&gt;&gt;Comp: Initialize compositor\n    Comp-&gt;&gt;Comp: Setup application registry\n    RDK-&gt;&gt;Input: Initialize input handling\n    Input-&gt;&gt;Input: Configure input devices\n    Input-&gt;&gt;Input: Setup key routing\n    RDK-&gt;&gt;Comm: Start communication handlers\n    Comm-&gt;&gt;Comm: Initialize IPC channels\n    RDK-&gt;&gt;Main: Initialization complete\n    Main-&gt;&gt;RDK: run()\n    RDK-&gt;&gt;RDK: Enter main loop</code></pre>"},{"location":"entertainment/docs/components/rdkshell/overview/#memory-and-resource-management","title":"Memory and Resource Management","text":"Memory Monitoring Architecture <p>RDKShell implements a sophisticated memory monitoring system that operates in a separate thread to avoid impacting the main rendering loop performance. The system continuously monitors system RAM, swap usage, and application-specific memory consumption. Configurable thresholds trigger notifications to applications and system components, enabling proactive resource management.</p>"},{"location":"entertainment/docs/components/rdkshell/overview/#extension-and-plugin-architecture","title":"Extension and Plugin Architecture","text":"Westeros Plugin Integration <p>RDKShell supports Westeros plugins that can extend the core functionality with platform-specific customizations and additional functionality. The plugin system is designed with security and stability in mind, providing isolation between different extensions and the core system. Extensions can be loaded and unloaded dynamically, enabling flexible deployment scenarios and reducing memory usage when specific functionality is not required. The system includes comprehensive APIs for extensions to interact with the core functionality while maintaining appropriate access controls.</p> Built-in Extension System <p>The architecture includes built-in extensions for client control and extended input handling. These extensions demonstrate the plugin architecture and provide commonly needed functionality that can be enabled or disabled based on deployment requirements. The extension system is designed to be modular and allows for easy addition of new capabilities.</p>"},{"location":"entertainment/docs/components/rdkshell/overview/#performance-considerations","title":"Performance Considerations","text":"Frame Rate Management <p>The architecture is designed around maintaining consistent frame rates through careful timing and resource management. The main loop includes sophisticated timing logic that adapts to system load while maintaining smooth visual output. The system can dynamically adjust frame rates based on system capabilities and current load conditions.</p> Efficient Event Processing <p>Input event processing is optimized to minimize latency while supporting complex routing scenarios. The system uses efficient data structures and algorithms to ensure that input responsiveness is maintained even with multiple applications and complex key intercept configurations.</p> Graphics Pipeline Optimization <p>The rendering pipeline is optimized for the specific requirements of set-top box and smart TV applications, with careful attention to memory bandwidth and GPU utilization patterns typical in these environments. The system includes sophisticated optimization techniques to maximize performance while maintaining visual quality.</p>"},{"location":"entertainment/docs/components/rdkshell/overview/#configuration","title":"Configuration","text":"<p>RDKShell provides extensive configuration capabilities through environment variables, configuration files, and compile-time options. The configuration system is designed to support both development scenarios with detailed debugging capabilities and production deployments with optimized performance characteristics. The system supports hierarchical configuration sources, allowing for system-wide defaults, platform-specific overrides, and application-specific customizations.</p>"},{"location":"entertainment/docs/components/rdkshell/overview/#environment-variables","title":"Environment Variables","text":""},{"location":"entertainment/docs/components/rdkshell/overview/#core-system-configuration","title":"Core System Configuration","text":"Variable Type Default Description <code>RDKSHELL_LOG_LEVEL</code> string \"Information\" Sets the verbosity level for logging output. Valid values are \"Debug\", \"Information\", \"Warn\", \"Error\", and \"Fatal\". When set to \"Debug\", detailed runtime information is printed to help with development and troubleshooting. <code>RDKSHELL_FRAMERATE</code> integer 40 Controls the target frame rate for the main rendering loop. Higher values provide smoother animation but consume more CPU resources. The system will attempt to maintain this frame rate while processing input events and updating application states. <code>RDKSHELL_ENABLE_IPC</code> boolean \"0\" Enables the socket-based IPC communication system when set to \"1\". This allows external applications to communicate with RDKShell through JSON-RPC over Unix domain sockets. <code>RDKSHELL_ENABLE_WS_IPC</code> boolean \"0\" Enables the WebSocket-based IPC communication system when set to \"1\". This provides real-time bidirectional communication capabilities for web-based applications and modern client frameworks."},{"location":"entertainment/docs/components/rdkshell/overview/#memory-management-configuration","title":"Memory Management Configuration","text":"Variable Type Default Description <code>RDKSHELL_LOW_MEMORY_THRESHOLD</code> double 200.0 Sets the threshold in megabytes for low memory notifications. When available system memory falls below this threshold, RDKShell will send low memory notifications to registered applications, allowing them to free up resources proactively. <code>RDKSHELL_CRITICALLY_LOW_MEMORY_THRESHOLD</code> double 100.0 Defines the critically low memory threshold in megabytes. When system memory falls below this level, RDKShell will send critical memory notifications and may take more aggressive resource management actions. This value must be less than or equal to the low memory threshold. <code>RDKSHELL_SWAP_MEMORY_INCREASE_THRESHOLD</code> double 50.0 Sets the threshold in megabytes for swap memory increase notifications. When swap usage increases by more than this amount, applications will be notified of potential memory pressure conditions."},{"location":"entertainment/docs/components/rdkshell/overview/#input-system-configuration","title":"Input System Configuration","text":"Variable Type Default Description <code>RDKSHELL_KEY_INITIAL_DELAY</code> integer 500 Configures the initial delay in milliseconds before key repeat events begin. This affects how long a user must hold a key before it starts repeating, providing control over input responsiveness and preventing accidental repeated inputs. <code>RDKSHELL_KEY_REPEAT_INTERVAL</code> integer 100 Sets the interval in milliseconds between key repeat events once repeating has started. Lower values result in faster key repetition, while higher values provide more controlled input for navigation scenarios."},{"location":"entertainment/docs/components/rdkshell/overview/#display-configuration","title":"Display Configuration","text":"Variable Type Default Description <code>RDKSHELL_SET_GRAPHICS_720</code> boolean \"0\" Forces the graphics system to initialize in 720p mode (1280x720) when set to \"1\". This is useful for devices with limited graphics capabilities or when 720p output is specifically required. The system will initialize with these dimensions regardless of the display's native resolution. <code>RDKSHELL_SHOW_SPLASH_SCREEN</code> string undefined When defined, enables the splash screen functionality. The splash screen provides visual feedback during system initialization and can be customized with specific images or animations. <code>RDKSHELL_DISABLE_SPLASH_SCREEN_FILE</code> string undefined Specifies a file path that, when present, will disable the splash screen even if <code>RDKSHELL_SHOW_SPLASH_SCREEN</code> is set. This provides a mechanism for runtime control of splash screen behavior."},{"location":"entertainment/docs/components/rdkshell/overview/#plugin-and-extension-configuration","title":"Plugin and Extension Configuration","text":"Variable Type Default Description <code>RDKSHELL_WESTEROS_PLUGIN_DIRECTORY</code> string \"/usr/lib/plugins/westeros/\" Specifies the directory path where Westeros plugins are located. RDKShell will search this directory for compatible plugins that extend the core functionality with platform-specific features."},{"location":"entertainment/docs/components/rdkshell/overview/#configuration-files","title":"Configuration Files","text":""},{"location":"entertainment/docs/components/rdkshell/overview/#input-device-configuration-inputdevicesconf","title":"Input Device Configuration (<code>inputdevices.conf</code>)","text":"<pre><code>{\n    \"inputDevices\": [\n        {\n            \"vendor\": \"0x119b\",\n            \"product\": \"0x2101\", \n            \"deviceType\": \"0x00\",\n            \"deviceMode\": \"0x00\"\n        },\n        {\n            \"vendor\": \"0x119b\",\n            \"product\": \"0x212b\",\n            \"deviceType\": \"0x01\", \n            \"deviceMode\": \"0x0f\"\n        },\n        {\n            \"vendor\": \"0x06e7\",\n            \"product\": \"0x8038\",\n            \"deviceType\": \"0x02\",\n            \"deviceMode\": \"0x03\"\n        }\n    ],\n    \"irInputDeviceTypeMapping\": [\n        {\n            \"filterCode\": 19,\n            \"deviceType\": \"0xf2\"\n        },\n        {\n            \"filterCode\": 20,\n            \"deviceType\": \"0xf1\"\n        },\n        {\n            \"filterCode\": 21,\n            \"deviceType\": \"0xf3\"\n        }\n    ]\n}\n</code></pre>"},{"location":"entertainment/docs/components/rdkshell/overview/#input-device-parameters","title":"Input Device Parameters","text":"Parameter Type Description <code>vendor</code> string USB vendor ID in hexadecimal format. This identifies the manufacturer of the input device and is used for device-specific handling and configuration. <code>product</code> string USB product ID in hexadecimal format. Combined with the vendor ID, this uniquely identifies the specific device model and determines appropriate input handling behavior. <code>deviceType</code> string Device type classification in hexadecimal format. This determines how the device's input events are processed and which input handling routines are applied. <code>deviceMode</code> string Device mode configuration in hexadecimal format. This controls specific operational characteristics of the device, such as key repeat behavior and input event filtering."},{"location":"entertainment/docs/components/rdkshell/overview/#ir-input-device-mapping","title":"IR Input Device Mapping","text":"Parameter Type Description <code>filterCode</code> integer IR filter code that identifies specific IR signal patterns. This allows the system to distinguish between different types of IR input devices and remote controls. <code>deviceType</code> string Device type mapping for IR devices in hexadecimal format. This determines how IR input events are translated into standard input events within the system."},{"location":"entertainment/docs/components/rdkshell/overview/#permissions-configuration-rdkshellpermissionsconf","title":"Permissions Configuration (<code>rdkshellPermissions.conf</code>)","text":"<pre><code>{\n    \"clients\": [\n        {\n            \"client\": \"trusted_application\",\n            \"extensions\": [\"libwesteros_plugin_rdkshell_client_control.so\"]\n        },\n        {\n            \"client\": \"system_service\",\n            \"extensions\": [\n                \"libwesteros_plugin_rdkshell_client_control.so\",\n                \"libwesteros_plugin_rdkshell_extended_input.so\"\n            ]\n        }\n    ],\n    \"default\": {\n        \"extensions\": []\n    }\n}\n</code></pre>"},{"location":"entertainment/docs/components/rdkshell/overview/#permission-parameters","title":"Permission Parameters","text":"Parameter Type Description <code>client</code> string Application identifier that matches the client name used in API calls. <code>extensions</code> array List of extension library names that the client is permitted to use. <code>default.extensions</code> array Default extension permissions applied to clients not explicitly listed in the configuration."},{"location":"entertainment/docs/components/rdkshell/overview/#compile-time-configuration-options","title":"Compile-Time Configuration Options","text":""},{"location":"entertainment/docs/components/rdkshell/overview/#build-configuration-flags","title":"Build Configuration Flags","text":"Option Default Description <code>RDKSHELL_BUILD_APP</code> ON Controls whether the main RDKShell executable is built. <code>RDKSHELL_BUILD_WEBSOCKET_IPC</code> OFF Enables WebSocket-based IPC communication support. <code>RDKSHELL_BUILD_KEY_METADATA</code> OFF Enables extended key metadata support that provides additional information about input events. <code>RDKSHELL_BUILD_IPC</code> ON Enables traditional socket-based IPC communication. <code>RDKSHELL_BUILD_CLIENT</code> ON Controls whether the RDKShell client library is built. <code>RDKSHELL_BUILD_FORCE_1080</code> OFF Enables compile-time support for forcing 1080p resolution. <code>RDKSHELL_BUILD_ENABLE_KEYREPEATS</code> OFF Enables advanced key repeat functionality with configurable timing and behavior."},{"location":"entertainment/docs/components/rdkshell/overview/#advanced-build-options","title":"Advanced Build Options","text":"Option Default Description <code>RDKSHELL_BUILD_HIDDEN_SUPPORT</code> OFF Enables support for hidden application states. <code>RDKSHELL_BUILD_EXTERNAL_APPLICATION_SURFACE_COMPOSITION</code> ON Enables support for compositing surfaces from external applications. <code>RDKSHELL_BUILD_KEYBUBBING_TOP_MODE</code> ON Enables key bubbling to topmost applications. <code>RDKSHELL_BUILD_KEY_METADATA_EXTENDED_SUPPORT_FOR_IR</code> OFF Enables extended IR support that provides additional metadata for infrared input devices."},{"location":"entertainment/docs/components/rdkshell/overview/#runtime-configuration","title":"Runtime Configuration","text":""},{"location":"entertainment/docs/components/rdkshell/overview/#memory-monitor-configuration","title":"Memory Monitor Configuration","text":"<pre><code>// Configure memory monitoring with specific parameters\nstd::map&lt;std::string, RdkShellData&gt; config;\nconfig[\"enable\"] = true;\nconfig[\"interval\"] = 2.0;  // Check every 2 seconds\nconfig[\"lowRam\"] = 150.0;  // 150MB threshold\nconfig[\"criticallyLowRam\"] = 75.0;  // 75MB critical threshold\nconfig[\"swapIncreaseLimit\"] = 25.0;  // 25MB swap increase limit\nRdkShell::setMemoryMonitor(config);\n</code></pre>"},{"location":"entertainment/docs/components/rdkshell/overview/#dynamic-display-configuration","title":"Dynamic Display Configuration","text":"<p>Display parameters can be adjusted at runtime through the API system, allowing applications to adapt to changing display conditions or user preferences. This includes resolution changes, display mode adjustments, and multi-display configuration management.</p>"},{"location":"entertainment/docs/components/rdkshell/overview/#input-device-runtime-configuration","title":"Input Device Runtime Configuration","text":"<p>Input device behavior can be modified at runtime through the input management APIs, enabling dynamic adaptation to different input scenarios and user preferences. This includes key mapping changes, device enable/disable operations, and input routing configuration.</p>"},{"location":"entertainment/docs/components/rdkshell/overview/#best-practices","title":"Best Practices","text":"Development <p>Enable debug logging and extended metadata collection to facilitate troubleshooting and performance analysis.</p> <p>Use higher frame rates for smoother development experience but be aware of increased resource consumption.</p> <p>Enable additional build options that provide debugging capabilities and detailed system information.</p> Production <p>Use optimized logging levels and carefully tuned memory thresholds based on the specific hardware platform and application requirements.</p> <p>Disable unnecessary features to minimize resource usage and potential security exposure.</p> <p>Use conservative memory thresholds to ensure system stability under varying load conditions.</p> Security <p>Carefully configure the permissions system to ensure that only trusted applications have access to sensitive extensions and capabilities.</p> <p>Regularly review and update permission configurations as applications are added or removed from the system.</p> <p>Use the principle of least privilege when granting extension access to applications.</p> Performance <p>Configure frame rates and memory thresholds based on the specific hardware capabilities and performance requirements of the target deployment.</p> <p>Monitor system performance under typical usage scenarios and adjust configuration parameters to optimize for the specific use case and hardware platform.    </p>"},{"location":"entertainment/docs/components/rdkshell/overview/#key-mappings-and-input-management","title":"Key Mappings and Input Management","text":"<p>RDKShell implements a comprehensive key mapping system that translates between different key code formats and provides sophisticated input event routing capabilities. The system supports both Wayland key codes for low-level input handling and RDKShell virtual key codes for application-level input processing. This dual-layer approach ensures compatibility with various input devices while providing a consistent interface for applications.</p> <p>The key mapping system is designed to handle the diverse input requirements of set-top box and smart TV environments, where applications must work with various remote controls, keyboards, and specialized input devices. The system provides flexible mapping capabilities that can be configured for different device types and user preferences.</p>"},{"location":"entertainment/docs/components/rdkshell/overview/#key-code-translation-system","title":"Key Code Translation System","text":"Wayland Key Codes <p>RDKShell uses Wayland key codes as the foundation for low-level input processing. These codes correspond directly to Linux input event codes and provide the interface between hardware input devices and the RDKShell input processing system. Wayland key codes are hardware-specific and may vary between different input devices and platforms.</p> RDKShell Virtual Key Codes <p>The virtual key code system provides a standardized interface for applications, abstracting away hardware-specific details and ensuring consistent behavior across different input devices and platforms. Virtual key codes are designed to be stable across different hardware configurations and provide a consistent programming interface for application developers.</p>"},{"location":"entertainment/docs/components/rdkshell/overview/#standard-key-mappings","title":"Standard Key Mappings","text":""},{"location":"entertainment/docs/components/rdkshell/overview/#alphanumeric-keys","title":"Alphanumeric Keys","text":"Key Wayland Code RDKShell Code Description 0 11 48 Number zero key 1 2 49 Number one key 2 3 50 Number two key 3 4 51 Number three key 4 5 52 Number four key 5 6 53 Number five key 6 7 54 Number six key 7 8 55 Number seven key 8 9 56 Number eight key 9 10 57 Number nine key A 30 65 Letter A key B 48 66 Letter B key C 46 67 Letter C key D 32 68 Letter D key E 18 69 Letter E key F 33 70 Letter F key G 34 71 Letter G key H 35 72 Letter H key I 23 73 Letter I key J 36 74 Letter J key K 37 75 Letter K key L 38 76 Letter L key M 50 77 Letter M key N 49 78 Letter N key O 24 79 Letter O key P 25 80 Letter P key Q 16 81 Letter Q key R 19 82 Letter R key S 31 83 Letter S key T 20 84 Letter T key U 22 85 Letter U key V 47 86 Letter V key W 17 87 Letter W key X 45 88 Letter X key Y 21 89 Letter Y key Z 44 90 Letter Z key"},{"location":"entertainment/docs/components/rdkshell/overview/#function-keys","title":"Function Keys","text":"Key Wayland Code RDKShell Code Description F1 59 112 Function key F1 F2 60 113 Function key F2 F3 61 114 Function key F3 F4 62 115 Function key F4 F5 63 116 Function key F5 F6 64 117 Function key F6 F7 65 118 Function key F7 F8 66 119 Function key F8 F9 67 120 Function key F9 F10 68 121 Function key F10 F11 87 122 Function key F11 F12 88 123 Function key F12 F13 183 124 Function key F13 F14 184 125 Function key F14 F15 185 126 Function key F15 F16 186 127 Function key F16 F17 187 129 Function key F17 F18 188 130 Function key F18 F19 189 131 Function key F19 F20 190 132 Function key F20 F21 191 133 Function key F21 F22 192 134 Function key F22 F23 193 135 Function key F23 F24 194 136 Function key F24"},{"location":"entertainment/docs/components/rdkshell/overview/#navigation-keys","title":"Navigation Keys","text":"Key Wayland Code RDKShell Code Description Up Arrow 103 38 Directional up navigation key Down Arrow 108 40 Directional down navigation key Left Arrow 105 37 Directional left navigation key Right Arrow 106 39 Directional right navigation key Home 102 36 Home navigation key End 107 35 End navigation key Page Up 104 33 Page up navigation key Page Down 109 34 Page down navigation key Insert 110 45 Insert key Delete 111 46 Delete key"},{"location":"entertainment/docs/components/rdkshell/overview/#control-and-modifier-keys","title":"Control and Modifier Keys","text":"Key Wayland Code RDKShell Code Flag Value Description Escape 1 27 - Escape key for canceling operations Tab 15 9 - Tab key for navigation and focus control Enter 28 13 - Enter key for confirmation and line breaks Space 57 32 - Space bar for text input and selection Backspace 14 8 - Backspace key for deleting characters Left Shift 42 16 8 Left shift modifier key Right Shift 54 16 8 Right shift modifier key Left Ctrl 29 17 16 Left control modifier key Right Ctrl 97 17 16 Right control modifier key Left Alt 56 18 32 Left alt modifier key Right Alt 100 18 32 Right alt modifier key Caps Lock 58 20 - Caps lock toggle key Num Lock 69 144 - Numeric keypad lock toggle Scroll Lock 70 145 - Scroll lock toggle key Pause 119 19 - Pause/break key"},{"location":"entertainment/docs/components/rdkshell/overview/#special-media-and-remote-control-keys","title":"Special Media and Remote Control Keys","text":"Key Wayland Code RDKShell Code Description Red 0x190 405 Red colored key typically found on remote controls Green 0x191 406 Green colored key typically found on remote controls Yellow 0x18e 403 Yellow colored key typically found on remote controls Blue 0x18f 404 Blue colored key typically found on remote controls Back 158 407 Back navigation key for returning to previous screens Menu 139 408 Menu key for accessing application menus Home Page 172 409 Home page key for returning to main interface Volume Up 115 175 Volume increase key Volume Down 114 174 Volume decrease key Mute 113 173 Audio mute toggle key Play/Pause 164 227 Media play/pause toggle key Play 207 226 Media play key Fast Forward 208 223 Media fast forward key Rewind 168 224 Media rewind key"},{"location":"entertainment/docs/components/rdkshell/overview/#numeric-keypad","title":"Numeric Keypad","text":"Key Wayland Code RDKShell Code Description Keypad 0 82 96 Numeric keypad zero Keypad 1 79 97 Numeric keypad one Keypad 2 80 98 Numeric keypad two Keypad 3 81 99 Numeric keypad three Keypad 4 75 100 Numeric keypad four Keypad 5 76 101 Numeric keypad five Keypad 6 77 102 Numeric keypad six Keypad 7 71 103 Numeric keypad seven Keypad 8 72 104 Numeric keypad eight Keypad 9 73 105 Numeric keypad nine Keypad Plus 78 107 Numeric keypad addition operator Keypad Minus 74 109 Numeric keypad subtraction operator Keypad Multiply 55 106 Numeric keypad multiplication operator Keypad Divide 98 111 Numeric keypad division operator Keypad Decimal 83 110 Numeric keypad decimal point Keypad Enter 96 13 Numeric keypad enter key"},{"location":"entertainment/docs/components/rdkshell/overview/#modifier-key-flags","title":"Modifier Key Flags","text":"<p>RDKShell uses flag values to represent modifier key states that can be combined with regular key codes to create complex key combinations. These flags can be combined using bitwise OR operations to represent multiple simultaneous modifier keys.</p> Modifier Flag Value Description Shift 8 Shift key modifier for uppercase letters and symbol access Control 16 Control key modifier for keyboard shortcuts and commands Alt 32 Alt key modifier for alternative character input and shortcuts Command 64 Command/Windows key modifier for system-level shortcuts"},{"location":"entertainment/docs/components/rdkshell/overview/#modifier-combination-examples","title":"Modifier Combination Examples","text":"<pre><code>// Ctrl+C combination\nuint32_t keyCode = 67;  // C key\nuint32_t flags = 16;    // Control modifier\n\n// Ctrl+Shift+F combination  \nuint32_t keyCode = 70;  // F key\nuint32_t flags = 24;    // Control (16) + Shift (8)\n\n// Alt+Tab combination\nuint32_t keyCode = 9;   // Tab key\nuint32_t flags = 32;    // Alt modifier\n\n// Ctrl+Alt+Delete combination\nuint32_t keyCode = 46;  // Delete key\nuint32_t flags = 48;    // Control (16) + Alt (32)\n</code></pre>"},{"location":"entertainment/docs/components/rdkshell/overview/#input-event-processing","title":"Input Event Processing","text":"Key Event Types <p>RDKShell processes two primary types of key events: key press events and key release events. Each event includes the key code, modifier flags, and timing metadata. The system maintains state information about which keys are currently pressed to support complex input scenarios and modifier key combinations.</p> Key Repeat Handling <p>The system supports configurable key repeat functionality with separate settings for initial delay and repeat interval. Key repeat events are marked with a special flag to distinguish them from initial key press events. The repeat behavior can be configured globally or on a per-application basis.</p> <pre><code>#define RDKSHELL_KEYDOWN_REPEAT 128\n</code></pre> <p>The key repeat system includes sophisticated logic to handle modifier keys correctly and ensure that repeat events are only generated for appropriate key types. Navigation keys and character keys typically support repeat, while modifier keys and special function keys do not.</p> Event Routing and Interception <p>Applications can register to intercept specific key combinations even when they are not in focus. This enables global hotkey functionality and allows background applications to respond to specific input events. The interception system supports complex routing scenarios where multiple applications may be interested in the same key events.</p> <p>The event routing system includes priority mechanisms to ensure that critical system functions can always access required key combinations. Applications can register for different types of key interception, including exclusive access, shared access, and monitoring-only access.</p>"},{"location":"entertainment/docs/components/rdkshell/overview/#mouse-and-pointer-input","title":"Mouse and Pointer Input","text":""},{"location":"entertainment/docs/components/rdkshell/overview/#mouse-button-mappings","title":"Mouse Button Mappings","text":"Button Flag Value Description Left Button 1 Primary mouse button for selection and activation Middle Button 2 Middle mouse button typically used for scrolling Right Button 4 Secondary mouse button for context menus"},{"location":"entertainment/docs/components/rdkshell/overview/#pointer-event-processing","title":"Pointer Event Processing","text":"<p>RDKShell processes pointer motion events and button press/release events, providing applications with precise cursor position information and button state changes. The system supports both absolute and relative pointer positioning and can handle multiple pointer devices simultaneously.</p> <p>The pointer event system includes support for touch interfaces and gesture recognition when available. It provides coordinate transformation capabilities to support different display resolutions and scaling factors.</p>"},{"location":"entertainment/docs/components/rdkshell/overview/#input-device-configuration","title":"Input Device Configuration","text":"Device Type Classifications <p>The input system supports various device type classifications that determine how input events are processed and routed through the system. Different device types may have different key mappings, repeat behaviors, and event processing characteristics.</p> Custom Input Device Support <p>RDKShell can be configured to support custom input devices through the input device configuration file, allowing for specialized remote controls and input hardware commonly used in set-top box and smart TV environments. The system includes support for device-specific key mappings and behavior customization.</p>"},{"location":"entertainment/docs/components/rdkshell/overview/#virtual-key-support","title":"Virtual Key Support","text":"Virtual Key Generation <p>The system supports programmatic generation of virtual key events, enabling applications to simulate user input for automation and testing scenarios. Virtual key events are processed through the same routing and interception mechanisms as physical key events.</p> Virtual Key Mapping <p>Virtual keys can be mapped to physical key codes through string-based identifiers, providing a flexible interface for dynamic key mapping scenarios. This enables applications to define custom key mappings that can be configured at runtime.</p>"},{"location":"entertainment/docs/components/rdkshell/overview/#best-practices_1","title":"Best Practices","text":"Key Intercept Registration <p>Applications should register for key intercepts only for the specific key combinations they need to handle globally. Excessive key intercept registrations can impact system performance and interfere with other applications. Applications should also properly remove their key intercept registrations when they are suspended or terminated.</p> Modifier Key Handling <p>When processing key events with modifiers, applications should check for the specific modifier combinations they support and ignore unexpected modifier states to ensure robust input handling. Applications should also be prepared to handle cases where modifier keys are pressed or released independently of other keys.</p> Input Event Cleanup <p>Applications should properly remove their key intercept registrations when they are suspended or terminated to prevent resource leaks and ensure proper input routing for other applications. The system includes automatic cleanup mechanisms, but applications should not rely solely on these mechanisms.</p> Performance Considerations <p>Input event processing should be optimized to minimize latency and ensure responsive user interaction. Applications should avoid performing heavy processing in input event handlers and should use efficient data structures for key mapping and event routing operations.</p>"},{"location":"entertainment/docs/components/rdkshell/overview/#apis","title":"APIs","text":"<p>RDKShell provides multiple API interfaces to accommodate different integration scenarios and programming languages. The system supports JSON-RPC over both traditional socket-based IPC and modern WebSocket connections, as well as direct C++ APIs for native code integration. All APIs provide access to the same underlying functionality through the CompositorController interface.</p> JSON-RPC API WebSocket API <p>RDKShell supports WebSocket-based communication for real-time interaction. The WebSocket API uses the same method names and parameters as the JSON-RPC API but operates over WebSocket connections for lower latency and bidirectional communication.</p> <p>Connection Endpoint: <code>ws://localhost:3000</code></p> <p>Message Format: <pre><code>{\n  \"msg\": \"methodName\",\n  \"params\": {\n    \"parameter1\": \"value1\",\n    \"parameter2\": \"value2\"\n  }\n}\n</code></pre></p> C++ Native API <p>For native code integration, RDKShell provides direct C++ APIs through the CompositorController class. These APIs offer the same functionality as the JSON-RPC interfaces but with direct function calls for maximum performance.</p>"},{"location":"entertainment/docs/components/rdkshell/overview/#application-management-apis","title":"Application Management APIs","text":"createDisplay <p>Method: <code>org.rdk.RDKShell.1.createDisplay</code></p> <p>Parameters: - <code>client</code> (string, required): Unique identifier for the application - <code>displayName</code> (string, optional): Custom name for the display surface - <code>displayWidth</code> (uint32, optional): Width of the display surface - <code>displayHeight</code> (uint32, optional): Height of the display surface - <code>virtualDisplayEnabled</code> (boolean, optional): Enable virtual display mode - <code>virtualWidth</code> (uint32, optional): Virtual display width - <code>virtualHeight</code> (uint32, optional): Virtual display height - <code>topmost</code> (boolean, optional): Create display in topmost layer - <code>focus</code> (boolean, optional): Give focus to the new display - <code>autodestroy</code> (boolean, optional): Automatically destroy when client disconnects</p> <p>Response: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"3\",\n  \"result\": {\n    \"success\": true\n  }\n}\n</code></pre></p> <p>Example Request: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"3\",\n  \"method\": \"org.rdk.RDKShell.1.createDisplay\",\n  \"params\": {\n    \"client\": \"netflix\",\n    \"displayWidth\": 1920,\n    \"displayHeight\": 1080,\n    \"topmost\": true,\n    \"focus\": true\n  }\n}\n</code></pre></p> launchApplication <p>Method: <code>org.rdk.RDKShell.1.launchApplication</code></p> <p>Parameters: - <code>client</code> (string, required): Application identifier - <code>uri</code> (string, required): Application URI or path - <code>mimeType</code> (string, required): MIME type of the application - <code>topmost</code> (boolean, optional): Launch in topmost layer - <code>focus</code> (boolean, optional): Give focus to launched application</p> <p>Response: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"4\",\n  \"result\": {\n    \"success\": true\n  }\n}\n</code></pre></p> kill <p>Method: <code>org.rdk.RDKShell.1.kill</code></p> <p>Parameters: - <code>client</code> (string, required): Application identifier to terminate</p> <p>Response: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"5\",\n  \"result\": {\n    \"success\": true\n  }\n}\n</code></pre></p>"},{"location":"entertainment/docs/components/rdkshell/overview/#display-management-apis","title":"Display Management APIs","text":"getScreenResolution <p>Method: <code>org.rdk.RDKShell.1.getScreenResolution</code></p> <p>Parameters: None</p> <p>Response: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"6\",\n  \"result\": {\n    \"w\": 1920,\n    \"h\": 1080,\n    \"success\": true\n  }\n}\n</code></pre></p> setScreenResolution <p>Method: <code>org.rdk.RDKShell.1.setScreenResolution</code></p> <p>Parameters: - <code>w</code> (uint32, required): Screen width in pixels - <code>h</code> (uint32, required): Screen height in pixels</p> <p>Response: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"7\",\n  \"result\": {\n    \"success\": true\n  }\n}\n</code></pre></p> getBounds <p>Method: <code>org.rdk.RDKShell.1.getBounds</code></p> <p>Parameters: - <code>client</code> (string, required): Application identifier</p> <p>Response: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"8\",\n  \"result\": {\n    \"bounds\": {\n      \"x\": 100,\n      \"y\": 50,\n      \"w\": 800,\n      \"h\": 600\n    },\n    \"success\": true\n  }\n}\n</code></pre></p> setBounds <p>Method: <code>org.rdk.RDKShell.1.setBounds</code></p> <p>Parameters: - <code>client</code> (string, required): Application identifier - <code>x</code> (int32, required): X coordinate - <code>y</code> (int32, required): Y coordinate - <code>w</code> (uint32, required): Width in pixels - <code>h</code> (uint32, required): Height in pixels</p> <p>Response: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"9\",\n  \"result\": {\n    \"success\": true\n  }\n}\n</code></pre></p>"},{"location":"entertainment/docs/components/rdkshell/overview/#visibility-and-appearance-apis","title":"Visibility and Appearance APIs","text":"getVisibility <p>Method: <code>org.rdk.RDKShell.1.getVisibility</code></p> <p>Parameters: - <code>client</code> (string, required): Application identifier</p> <p>Response: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"10\",\n  \"result\": {\n    \"visible\": true,\n    \"success\": true\n  }\n}\n</code></pre></p> setVisibility <p>Method: <code>org.rdk.RDKShell.1.setVisibility</code></p> <p>Parameters: - <code>client</code> (string, required): Application identifier - <code>visible</code> (boolean, required): Visibility state</p> <p>Response: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"11\",\n  \"result\": {\n    \"success\": true\n  }\n}\n</code></pre></p> getOpacity <p>Method: <code>org.rdk.RDKShell.1.getOpacity</code></p> <p>Parameters: - <code>client</code> (string, required): Application identifier</p> <p>Response: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"12\",\n  \"result\": {\n    \"opacity\": 255,\n    \"success\": true\n  }\n}\n</code></pre></p> setOpacity <p>Method: <code>org.rdk.RDKShell.1.setOpacity</code></p> <p>Parameters: - <code>client</code> (string, required): Application identifier - <code>opacity</code> (uint32, required): Opacity value (0-255)</p> <p>Response: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"13\",\n  \"result\": {\n    \"success\": true\n  }\n}\n</code></pre></p>"},{"location":"entertainment/docs/components/rdkshell/overview/#z-order-management-apis","title":"Z-Order Management APIs","text":"moveToFront <p>Method: <code>org.rdk.RDKShell.1.moveToFront</code></p> <p>Parameters: - <code>client</code> (string, required): Application identifier</p> <p>Response: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"14\",\n  \"result\": {\n    \"success\": true\n  }\n}\n</code></pre></p> moveToBack <p>Method: <code>org.rdk.RDKShell.1.moveToBack</code></p> <p>Parameters: - <code>client</code> (string, required): Application identifier</p> <p>Response: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"15\",\n  \"result\": {\n    \"success\": true\n  }\n}\n</code></pre></p> moveBehind <p>Method: <code>org.rdk.RDKShell.1.moveBehind</code></p> <p>Parameters: - <code>client</code> (string, required): Application to move - <code>target</code> (string, required): Application to move behind</p> <p>Response: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"16\",\n  \"result\": {\n    \"success\": true\n  }\n}\n</code></pre></p> getZOrder <p>Method: <code>org.rdk.RDKShell.1.getZOrder</code></p> <p>Parameters: None</p> <p>Response: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"17\",\n  \"result\": {\n    \"clients\": [\"app1\", \"app2\", \"app3\"],\n    \"success\": true\n  }\n}\n</code></pre></p>"},{"location":"entertainment/docs/components/rdkshell/overview/#focus-management-apis","title":"Focus Management APIs","text":"setFocus <p>Method: <code>org.rdk.RDKShell.1.setFocus</code></p> <p>Parameters: - <code>client</code> (string, required): Application identifier</p> <p>Response: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"18\",\n  \"result\": {\n    \"success\": true\n  }\n}\n</code></pre></p> getFocused <p>Method: <code>org.rdk.RDKShell.1.getFocused</code></p> <p>Parameters: None</p> <p>Response: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"19\",\n  \"result\": {\n    \"client\": \"netflix\",\n    \"success\": true\n  }\n}\n</code></pre></p>"},{"location":"entertainment/docs/components/rdkshell/overview/#input-management-apis","title":"Input Management APIs","text":"addKeyIntercept <p>Method: <code>org.rdk.RDKShell.1.addKeyIntercept</code></p> <p>Parameters: - <code>client</code> (string, required): Application identifier - <code>keyCode</code> (uint32, required): Key code to intercept - <code>modifiers</code> (array, optional): Modifier keys (ctrl, shift, alt)</p> <p>Response: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"20\",\n  \"result\": {\n    \"success\": true\n  }\n}\n</code></pre></p> <p>Example Request: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"20\",\n  \"method\": \"org.rdk.RDKShell.1.addKeyIntercept\",\n  \"params\": {\n    \"client\": \"netflix\",\n    \"keyCode\": 48,\n    \"modifiers\": [\"ctrl\", \"shift\"]\n  }\n}\n</code></pre></p> removeKeyIntercept <p>Method: <code>org.rdk.RDKShell.1.removeKeyIntercept</code></p> <p>Parameters: - <code>client</code> (string, required): Application identifier - <code>keyCode</code> (uint32, required): Key code to remove - <code>modifiers</code> (array, optional): Modifier keys</p> <p>Response: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"21\",\n  \"result\": {\n    \"success\": true\n  }\n}\n</code></pre></p>"},{"location":"entertainment/docs/components/rdkshell/overview/#system-information-apis","title":"System Information APIs","text":"getClients <p>Method: <code>org.rdk.RDKShell.1.getClients</code></p> <p>Parameters: None</p> <p>Response: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"22\",\n  \"result\": {\n    \"clients\": [\"netflix\", \"youtube\", \"settings\"],\n    \"success\": true\n  }\n}\n</code></pre></p>"},{"location":"entertainment/docs/components/rdkshell/overview/#key-c-api-functions","title":"Key C++ API Functions","text":"<pre><code>// Application management\nbool CompositorController::createDisplay(const std::string&amp; client, const std::string&amp; displayName);\nbool CompositorController::kill(const std::string&amp; client);\nbool CompositorController::launchApplication(const std::string&amp; client, const std::string&amp; uri, const std::string&amp; mimeType);\n\n// Display management\nbool CompositorController::setBounds(const std::string&amp; client, uint32_t x, uint32_t y, uint32_t width, uint32_t height);\nbool CompositorController::getBounds(const std::string&amp; client, uint32_t &amp;x, uint32_t &amp;y, uint32_t &amp;width, uint32_t &amp;height);\nbool CompositorController::setVisibility(const std::string&amp; client, bool visible);\nbool CompositorController::getVisibility(const std::string&amp; client, bool&amp; visible);\n\n// Focus and z-order management\nbool CompositorController::setFocus(const std::string&amp; client);\nbool CompositorController::moveToFront(const std::string&amp; client);\nbool CompositorController::moveToBack(const std::string&amp; client);\nbool CompositorController::moveBehind(const std::string&amp; client, const std::string&amp; target);\n\n// Input management\nbool CompositorController::addKeyIntercept(const std::string&amp; client, uint32_t keyCode, uint32_t flags);\nbool CompositorController::removeKeyIntercept(const std::string&amp; client, uint32_t keyCode, uint32_t flags);\n</code></pre>"},{"location":"entertainment/docs/components/rdkshell/overview/#error-handling","title":"Error Handling","text":"<p>All APIs return success/failure indicators and provide detailed error information when operations fail. Common error conditions include:</p> <ul> <li>Invalid client identifier: Specified application does not exist</li> <li>Resource constraints: Insufficient memory or graphics resources</li> <li>Permission denied: Application lacks required permissions</li> <li>Invalid parameters: Malformed or out-of-range parameter values</li> <li>System state conflicts: Operation conflicts with current system state</li> </ul> <p>Error responses follow the JSON-RPC error format: <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"23\",\n  \"error\": {\n    \"code\": -32602,\n    \"message\": \"Invalid params\",\n    \"data\": \"Client 'invalid_app' not found\"\n  }\n}\n</code></pre></p>"},{"location":"preview-rdk/docs/getting-started/","title":"Getting Started","text":"Entertainment Connectivity <p>The user interface is the first thing consumers interact with on any video device. With RDK, you can use the built-in open-source UI built on Lightning\u2122, or develop a custom experience.</p> <p>To see RDK\u2019s built-in UI in action, watch the recording below: </p> <p>Ready to try RDK for yourself? You can get started using a Raspberry Pi, where a port of RDK is available. Follow our step-by-step guide here to bring up RDK on your device and start exploring the platform firsthand.     </p> <p>The RDK Broadband stack provides a wide range of easily configurable options to support various features. A quick look at the RDK-B user interface clearly demonstrates this</p> <p>For the first time installation &amp; configuration, RDK also offers a user friendly captive portal </p> <p>Ready to try RDK for yourself? You can get started using a Banana Pi, where a port of RDK is available. Follow our step-by-step guide here to bring up RDK on your device and start exploring the platform firsthand.     </p>"},{"location":"preview-rdk/docs/preview-rdk-broadband/","title":"Preview RDK Broadband","text":"<p>RDK</p> <p>RDK is a fully modular, portable, and customizable open source software solution that standardizes core functions used in video, broadband, and IoT devices. Deployed on over a hundred million devices around the globe, RDK enables operators to manage devices and easily customize their UIs and apps, providing analytics to improve the customer experience. RDK is platform and operator agnostic, so it can easily be ported &amp; adopted by multiple SoC/OEM/Operators, significantly reducing the time to market . With over 600 companies, RDK has an active open source community that regularly contributes cutting edge technologies to the stack.</p> <p>RDK Broadband (RDK-B) software is capable of powering next-gen gateways across DOCSIS, PON, DSL, 5G, and Ethernet, enabling OEMs to standardize elements of their modems, gateways, and converged devices. It provides common functionalities such as routing, Wi-Fi, DNS, diagnostics, remote management, and IoT interfaces, such as Bluetooth, Thread, and Zigbee.</p>"},{"location":"preview-rdk/docs/preview-rdk-broadband/#rdk-architecture","title":"RDK Architecture","text":"<p>RDK middleware is powered by generic open source software along with RDK specific open source components. The RDK Broadband middleware stack architecture is pictured below:</p> <p></p>"},{"location":"preview-rdk/docs/preview-rdk-broadband/#implementing-rdk","title":"Implementing RDK","text":"<p>Getting started with RDK is easy. A simple image depicting adoption of RDK is below:</p> <p></p>"},{"location":"preview-rdk/docs/preview-rdk-broadband/#broadband-user-interface","title":"Broadband User Interface","text":"<p>WebUI is a graphical user interface that is available on connected devices. It acts as an application running on the RDK-B stack and performs the functions of a device management interface similar to TR69 &amp; SNMP. Users can monitor and modify RDK-B feature settings/rules using WebUI. It is a client\u2013server application: the client runs in a web browser (as part of devices connected over LAN) and Lighttpd on the RDK-B stack acts as server.</p> <p>WebUi can be accessed by both the LAN clients and from the WAN Side.</p> <p>WebUI From WAN Side:</p> <p>Give 'http://&lt;WAN IP Address of RaspberryPi&gt;:8080' in browser.</p> <ul> <li>Example:\u00a0     http://192.168.1.35:8080</li> </ul> <p>If you use erouter0 IP, then it opens admin page</p> <p>Login Credentials:</p> <p>Username: admin Password: password</p> <p>Once the login is successful, the user can verify and control various aspects of the Network Connection (like the SSID of the network, password of the network etc.).</p> <p></p> <p>WebUI For LAN Clients :</p> <p>In browser on the LAN client/machine give the url http://10.0.0.1 to launch the captive portal page.</p> <p></p>"},{"location":"preview-rdk/docs/preview-rdk-video/","title":"Preview RDK","text":""},{"location":"preview-rdk/docs/preview-rdk-video/#video-user-interface-preview","title":"Video User Interface Preview","text":"<p>The front end of any video device is the user interface that consumers will see. RDK comes with an open-source UI written in Lightning\u2122 , or you can create your own. To experience the RDK UI, watch the Video:</p> <p>Try Out RDK</p> <p>If you want to play around RDK, a port of RDK is available on the popular open source platform Raspberry Pi. A guide on how to bring up RDK for Entertainment in Raspberry Pi is available here</p>"},{"location":"review/","title":"Components List","text":"Component Name Documentation Source code WAN Manager WAN Manager GitHub Cellular Manager Cellular Manager GitHub GPON Manager GPON Manager GitHub Telco Voice Manager Telco Voice Manager GitHub VLAN Manager VLAN Manager GitHub PPP Manager PPP Manager GitHub CCSP LMLite CCSP LMLITE GitHub OneWiFi One WiFi GitHub CCSP PSM CCSP PSM GitHub Utopia Utopia GitHub CCSP P&amp;M CCSP PandM GitHub CCSP LMLite CCSP LMLite GitHub"},{"location":"review/CCSPPSM/","title":"CcspPsm  Documentation","text":"<p>CcspPsm (Persistent Storage Manager) is the component in the RDK-B stack that provides centralized persistent storage services for TR-181 data model parameters and configuration data. It acts as a registry and storage manager that allows other CCSP components to store, retrieve, and manage persistent configuration parameters across device reboots. The component serves as the authoritative source for device configuration state and provides both DBus and RBus interfaces for parameter access and management.</p> <pre><code>graph TD\n    subgraph \"External Systems\"\n        TR069[TR-069 ACS]\n        WebUI[Web Management UI]\n        CLI[Command Line Interface]\n    end\n\n    subgraph \"RDK-B Middleware Components\"\n        DMCLI[dmcli]\n        TR069PA[TR-069 PA]\n        TR181PA[TR-181 PA]\n        WebPA[WebPA]\n        CcspDM[CCSP DM]\n    end\n\n    subgraph \"CcspPsm Container\"\n        PSM[CcspPsm Process]\n    end\n\n    subgraph \"Storage Layer\"\n        XMLFiles[(XML Config Files)]\n        NVRAMFiles[(NVRAM Storage)]\n        SysConfFiles[(Syscfg Storage)]\n    end\n\n    TR069 --&gt;|Management Commands| TR069PA\n    WebUI --&gt;|HTTP Requests| WebPA\n    CLI --&gt;|CLI Commands| DMCLI\n\n    TR069PA --&gt;|DBus/RBus| PSM\n    TR181PA --&gt;|DBus/RBus| PSM\n    WebPA --&gt;|DBus/RBus| PSM\n    DMCLI --&gt;|DBus/RBus| PSM\n    CcspDM --&gt;|DBus/RBus| PSM\n\n    PSM --&gt;|Read/Write Config| XMLFiles\n    PSM --&gt;|Persistent Storage| NVRAMFiles\n    PSM --&gt;|System Config| SysConfFiles\n\n    classDef external fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n    classDef component fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef psm fill:#f3e5f5,stroke:#7b1fa2,stroke-width:3px;\n    classDef storage fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n\n    class TR069,WebUI,CLI external;\n    class DMCLI,TR069PA,TR181PA,WebPA,CcspDM component;\n    class PSM psm;\n    class XMLFiles,NVRAMFiles,SysConfFiles storage;</code></pre> <p>Key Features &amp; Responsibilities: </p> <ul> <li>Persistent Parameter Storage: Provides centralized storage and retrieval of TR-181 data model parameters with persistence across device reboots</li> <li>Configuration File Management: Loads, parses, and manages XML configuration files containing default parameter values and device-specific settings</li> <li>Multi-Protocol IPC Support: Supports both DBus and RBus communication protocols for parameter access from other middleware components</li> <li>Registry Services: Maintains an in-memory registry of parameters with efficient lookup and modification capabilities</li> <li>Atomic Operations: Ensures data consistency through atomic read/write operations and proper transaction handling</li> <li>Health Monitoring: Provides component health status and diagnostic information for system monitoring</li> </ul>"},{"location":"review/CCSPPSM/#design","title":"Design","text":"<p>CcspPsm follows a modular, service-oriented architecture that separates concerns between configuration file loading, in-memory registry management, and external communication interfaces. The design emphasizes reliability through robust error handling, data validation, and atomic operations to prevent configuration corruption. Scalability is achieved through efficient data structures and optimized parameter lookup algorithms. The component maintains strong security boundaries by validating all parameter access requests and enforcing proper authentication. Maintainability is ensured through clear module separation, comprehensive logging, and well-defined interfaces between internal components.</p> <p>The design establishes clear boundaries between the File Loader module (responsible for parsing XML configurations), the System Registry module (managing in-memory parameter storage), and the SSP layer (handling external communications). Each module has distinct responsibilities: File Loader handles configuration file parsing and validation, System Registry manages parameter storage and retrieval operations, and SSP provides DBus/RBus interface implementations. This separation enables independent testing, maintenance, and evolution of each subsystem while maintaining overall system coherence.</p> <p>A container diagram of the component is given below</p> <pre><code>graph TD\n    subgraph Runtime[\"Linux Process Environment\"]\n        subgraph CcspPsmContainer[\"CcspPsm Container (C/C++)\"]\n            FileLoader[PSM File Loader Module&lt;br/&gt;XML Configuration Parser]\n            SysRegistry[PSM System Registry&lt;br/&gt;In-Memory Parameter Store]\n            SSPLayer[SSP Communication Layer&lt;br/&gt;DBus/RBus Interface]\n        end\n        subgraph Storage[\"File System Storage\"]\n            ConfigDB[(Configuration Files&lt;br/&gt;XML Format)]\n            BackupDB[(Backup Storage&lt;br/&gt;NVRAM/Flash)]\n        end\n    end\n\n    FileLoader --&gt;|Parse/Load| ConfigDB\n    FileLoader --&gt;|Initialize Parameters| SysRegistry\n    SysRegistry --&gt;|Store/Retrieve| ConfigDB\n    SysRegistry --&gt;|Backup Operations| BackupDB\n    SSPLayer --&gt;|Parameter Operations| SysRegistry\n\n    classDef loader fill:#e3f2fd,stroke:#1976d2,stroke-width:2px;\n    classDef registry fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;\n    classDef ssp fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n    classDef storage fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n\n    class FileLoader loader;\n    class SysRegistry registry;\n    class SSPLayer ssp;\n    class ConfigDB,BackupDB storage;</code></pre> <p>Request Flow Sequence</p> <p>The most critical flow is parameter retrieval/storage. When an external component requests a parameter value, the request comes through either DBus or RBus to the SSP layer, which validates the request and forwards it to the System Registry. The registry performs efficient parameter lookup using hash tables and returns the value. For parameter updates, the flow includes validation, in-memory update, and eventual persistence to storage files.</p> <pre><code>sequenceDiagram\n    participant Client as CCSP Component\n    participant SSP as SSP Layer\n    participant Registry as System Registry\n    participant Storage as File Storage\n\n    Client-&gt;&gt;SSP: GetParameterValues(names[])\n    SSP-&gt;&gt;Registry: Lookup Parameters\n    Registry-&gt;&gt;Storage: Read if not cached\n    Storage--&gt;&gt;Registry: Parameter Values\n    Registry--&gt;&gt;SSP: Return Values\n    SSP--&gt;&gt;Client: Parameter Results\n\n    Client-&gt;&gt;SSP: SetParameterValues(params[])\n    SSP-&gt;&gt;Registry: Validate &amp; Update\n    Registry-&gt;&gt;Registry: Update In-Memory\n    Registry-&gt;&gt;Storage: Schedule Persistence\n    Storage--&gt;&gt;Registry: Write Confirmation\n    Registry--&gt;&gt;SSP: Success Response\n    SSP--&gt;&gt;Client: Operation Result</code></pre> <p>Threading Model</p> <p>The CcspPsm uses a hybrid threading model with the following thread allocation:</p> <ul> <li>Main Thread: Handles DBus/RBus message processing and maintains the primary event loop for handling external requests</li> <li>On-Demand Worker Threads: Spawned as needed for file I/O operations, configuration loading, and periodic backup tasks to avoid blocking the main communication thread</li> <li>System Registry Access: Ensures thread-safe parameter access using mutex locks and atomic operations to maintain data consistency across concurrent operations</li> <li>Timer Thread: Manages periodic tasks such as configuration file synchronization and health status reporting</li> </ul>"},{"location":"review/CCSPPSM/#internal-modules","title":"Internal Modules","text":"<p>The CcspPsm component is organized into three primary modules that work together to provide persistent storage services. The File Loader module handles all configuration file operations including XML parsing, validation, and initial parameter loading. The System Registry module maintains the in-memory parameter database and provides efficient storage and retrieval operations. The SSP (System Service Provider) layer manages external communications through DBus and RBus interfaces, handling protocol-specific message formatting and authentication.</p> Module/Class Description Key Files PSM File Loader Handles XML configuration file parsing, validation, and initial parameter loading from default configuration files <code>psm_flo_base.c</code>, <code>psm_flo_parse.c</code>, <code>psm_flo_control.c</code>, <code>psm_flo_operation.c</code> PSM System Registry Manages in-memory parameter storage, provides efficient lookup/storage operations, and handles parameter persistence <code>psm_sysro_base.c</code>, <code>psm_sysro_storage.c</code>, <code>psm_sysro_operation.c</code>, <code>psm_sysro_control.c</code> SSP Communication Layer Provides DBus and RBus interface implementations for external component communication <code>ssp_main.c</code>, <code>ssp_dbus.c</code>, <code>ssp_rbus.c</code>, <code>ssp_cfmif.c</code> HAL Interface Platform-specific hardware abstraction layer for storage operations and device-specific configurations <code>psm_hal_apis.c</code> <pre><code>flowchart LR\n    subgraph CcspPsm[\"CcspPsm Component\"]\n        subgraph SSP[\"SSP Layer\"]\n            DBusIf([DBus Interface])\n            RBusIf([RBus Interface])\n            MainCtrl([Main Control])\n        end\n\n        subgraph Registry[\"System Registry\"]\n            ParamStore([Parameter Storage])\n            LookupEngine([Lookup Engine])\n            PersistMgr([Persistence Manager])\n        end\n\n        subgraph FileLoader[\"File Loader\"]\n            XMLParser([XML Parser])\n            ConfigValidator([Config Validator])\n            FileManager([File Manager])\n        end\n\n        subgraph HAL[\"HAL Interface\"]\n            StorageAPI([Storage APIs])\n            PlatformIf([Platform Interface])\n        end\n    end\n\n    DBusIf --&gt; MainCtrl\n    RBusIf --&gt; MainCtrl\n    MainCtrl --&gt; ParamStore\n    ParamStore --&gt; LookupEngine\n    LookupEngine --&gt; PersistMgr\n    PersistMgr --&gt; XMLParser\n    XMLParser --&gt; ConfigValidator\n    ConfigValidator --&gt; FileManager\n    FileManager --&gt; StorageAPI\n    StorageAPI --&gt; PlatformIf\n\n    classDef ssp fill:#e3f2fd,stroke:#1976d2,stroke-width:2px;\n    classDef registry fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;\n    classDef loader fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n    classDef hal fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n\n    class DBusIf,RBusIf,MainCtrl ssp;\n    class ParamStore,LookupEngine,PersistMgr registry;\n    class XMLParser,ConfigValidator,FileManager loader;\n    class StorageAPI,PlatformIf hal;</code></pre>"},{"location":"review/CCSPPSM/#interaction-with-other-middleware-components","title":"Interaction with Other Middleware Components","text":"<p>CcspPsm serves as the central parameter storage service for the entire RDK-B middleware stack, providing parameter storage and retrieval services to numerous components. It receives parameter get/set requests from TR-069 PA for remote management operations, TR-181 PA for data model access, WebPA for web-based configuration, and dmcli for command-line operations. The component also interacts with various functional components like WiFi manager, WAN manager, and device management modules for storing their specific configuration parameters.</p> <pre><code>flowchart LR\n    subgraph \"Management Interfaces\"\n        TR069PA[TR-069 PA]\n        WebPA[WebPA Agent]\n        DMCLI[DMCLI Tool]\n    end\n\n    subgraph \"Data Model Layer\"\n        TR181PA[TR-181 PA]\n        CcspDM[CCSP DM Bus]\n    end\n\n    subgraph \"Functional Components\"\n        WiFiMgr[WiFi Manager]\n        WANMgr[WAN Manager]\n        DevMgr[Device Manager]\n        FirewallMgr[Firewall Manager]\n    end\n\n    CcspPsm --&gt;|DBus Parameter APIs| TR069PA\n    CcspPsm --&gt;|RBus Parameter APIs| WebPA\n    CcspPsm --&gt;|DBus CLI Interface| DMCLI\n    CcspPsm --&gt;|DBus Data Model| TR181PA\n    CcspPsm --&gt;|Message Bus| CcspDM\n    CcspPsm --&gt;|DBus Config Storage| WiFiMgr\n    CcspPsm --&gt;|DBus Config Storage| WANMgr\n    CcspPsm --&gt;|DBus Config Storage| DevMgr\n    CcspPsm --&gt;|DBus Config Storage| FirewallMgr\n\n    classDef mgmt fill:#e3f2fd,stroke:#1976d2,stroke-width:2px;\n    classDef datamodel fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;\n    classDef functional fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n    classDef psm fill:#fff8e1,stroke:#f57f00,stroke-width:3px;\n\n    class TR069PA,WebPA,DMCLI mgmt;\n    class TR181PA,CcspDM datamodel;\n    class WiFiMgr,WANMgr,DevMgr,FirewallMgr functional;\n    class CcspPsm psm;</code></pre> Component Purpose of Interaction Protocols/Mechanisms TR-069 PA Remote management parameter operations for ACS communication DBus method calls, parameter get/set APIs WebPA Agent Web-based parameter management and device configuration RBus parameter APIs, notification events TR-181 PA Data model parameter access and TR-181 object management DBus parameter APIs, bulk operations DMCLI Tool Command-line parameter access for debugging and configuration DBus direct parameter APIs WiFi Manager WiFi configuration parameter storage and retrieval DBus parameter storage, configuration events WAN Manager WAN interface configuration parameter management DBus parameter storage, connection events <p>CcspPsm publishes several key events to notify other components about parameter changes and system state updates. These events enable reactive configuration management and system coordination across the middleware stack.</p> Event Purpose of Event Reason for trigger parameterValueChanged Notifies components when parameter values are modified Triggered when any TR-181 parameter is updated via set operations systemReady Indicates PSM has completed initialization and is ready for requests Fired after successful configuration loading and registry initialization configurationBackupComplete Notifies about successful configuration backup operations Triggered after periodic backup operations or manual backup requests parameterCommitReady Indicates parameters are staged and ready for commit Fired when transaction-based parameter updates are prepared for persistence"},{"location":"review/CCSPPSM/#interaction-with-other-layers","title":"Interaction with Other Layers","text":"<p>CcspPsm interacts extensively with multiple layers in the RDK-B software stack to provide comprehensive persistent storage services. At the HAL layer, it uses platform-specific storage APIs for accessing NVRAM, flash memory, and file system resources. The component interfaces with platform services like syscfg for system configuration management and integrates with Linux system services for file I/O operations and process management.</p> Layer/Service Interaction Description Mechanism HAL Storage Platform-specific storage operations for NVRAM and flash memory access Direct HAL API calls, file system operations Syscfg Service System configuration parameter management and cross-component coordination DBus syscfg APIs, shared configuration database Linux File System Configuration file I/O, backup operations, and temporary file management Standard POSIX file operations, directory monitoring Platform Services Integration with systemd, logging services, and system health monitoring System service APIs, logging frameworks Security Framework Parameter access control, authentication, and authorization Security API calls, permission validation <pre><code>graph LR\n    subgraph \"Application Layer\"\n        Apps[Management Applications]\n    end\n\n    subgraph \"Middleware Layer\"\n        CcspPsm[CcspPsm Component]\n        OtherMW[Other CCSP Components]\n    end\n\n    subgraph \"System Services Layer\"\n        Syscfg[Syscfg Service]\n        SystemD[SystemD Services]\n        Logging[Log Management]\n    end\n\n    subgraph \"HAL Layer\"\n        StorageHAL[Storage HAL]\n        PlatformHAL[Platform HAL]\n    end\n\n    subgraph \"Kernel/Hardware\"\n        FileSystem[File System]\n        NVRAM[NVRAM Storage]\n        Flash[Flash Memory]\n    end\n\n    Apps --&gt;|Management Requests| CcspPsm\n    CcspPsm --&gt;|Parameter APIs| OtherMW\n    CcspPsm --&gt;|Config Management| Syscfg\n    CcspPsm --&gt;|Service Control| SystemD\n    CcspPsm --&gt;|Diagnostic Logs| Logging\n    CcspPsm --&gt;|Storage Operations| StorageHAL\n    CcspPsm --&gt;|Platform APIs| PlatformHAL\n    StorageHAL --&gt;|File I/O| FileSystem\n    StorageHAL --&gt;|Persistent Data| NVRAM\n    StorageHAL --&gt;|Configuration| Flash\n\n    classDef app fill:#e3f2fd,stroke:#1976d2,stroke-width:2px;\n    classDef middleware fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;\n    classDef system fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n    classDef hal fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n    classDef hardware fill:#fce4ec,stroke:#c2185b,stroke-width:2px;\n\n    class Apps app;\n    class CcspPsm,OtherMW middleware;\n    class Syscfg,SystemD,Logging system;\n    class StorageHAL,PlatformHAL hal;\n    class FileSystem,NVRAM,Flash hardware;</code></pre>"},{"location":"review/CCSPPSM/#ipc-mechanism","title":"IPC Mechanism","text":"Type of IPC Message Format Mechanism DBus CCSP parameter structure with name-value pairs, XML-based method calls, structured parameter arrays DBus method invocation with CCSP base APIs, message serialization RBus RBus native data types with automatic type conversion, binary message format, event subscription model RBus direct API calls, native type marshalling, event publishing Message Queues Internal component communication using ANSC message structures, control messages, state notifications POSIX message queues, semaphore synchronization <p>CcspPsm implements a sophisticated IPC architecture supporting both legacy DBus interfaces and modern RBus communication. The DBus interface provides backward compatibility with existing CCSP components using XML-based parameter structures and method calls. The RBus interface offers improved performance with native data type support and efficient binary serialization. Internal communication between modules uses ANSC framework message structures for control operations and state management.</p> <pre><code>sequenceDiagram\n    participant Client as External Component\n    participant DBus as DBus Interface\n    participant RBus as RBus Interface  \n    participant Controller as PSM Controller\n    participant Registry as Parameter Registry\n    participant Storage as File Storage\n\n    Note over Client,Storage: DBus Parameter Get Flow\n    Client-&gt;&gt;DBus: GetParameterValues(paramNames[])\n    DBus-&gt;&gt;Controller: Process DBus Request\n    Controller-&gt;&gt;Registry: Lookup Parameters\n    Registry-&gt;&gt;Storage: Read from storage if needed\n    Storage--&gt;&gt;Registry: Parameter data\n    Registry--&gt;&gt;Controller: Parameter values\n    Controller--&gt;&gt;DBus: Format DBus Response\n    DBus--&gt;&gt;Client: Parameter results\n\n    Note over Client,Storage: RBus Parameter Set Flow\n    Client-&gt;&gt;RBus: SetParameterValues(params[])\n    RBus-&gt;&gt;Controller: Process RBus Request\n    Controller-&gt;&gt;Registry: Validate &amp; Update\n    Registry-&gt;&gt;Registry: Update in-memory store\n    Registry-&gt;&gt;Storage: Schedule persistence\n    Storage--&gt;&gt;Registry: Persistence confirmation\n    Registry--&gt;&gt;Controller: Update successful\n    Controller--&gt;&gt;RBus: Format RBus Response\n    RBus--&gt;&gt;Client: Operation result\n\n    Note over Controller,Storage: Event Publishing\n    Registry-&gt;&gt;Controller: Parameter change event\n    Controller-&gt;&gt;DBus: Publish DBus signal\n    Controller-&gt;&gt;RBus: Publish RBus event\n    DBus--&gt;&gt;Client: Parameter change notification\n    RBus--&gt;&gt;Client: Parameter change notification</code></pre>"},{"location":"review/CCSPPSM/#tr181-data-models","title":"TR\u2011181 Data Models","text":"<ul> <li>Implemented Parameters: CcspPsm implements core TR-181 Device.DeviceInfo parameters for device identification and system information, Device.ManagementServer parameters for TR-069 ACS communication settings, and Device.Time parameters for system time configuration. It also manages numerous vendor-specific and custom parameters for platform-specific device configuration.</li> <li>Parameter Registration: Parameters are registered through the System Registry module using hash-table based indexing for efficient lookup. The component supports both static parameter registration from XML configuration files and dynamic registration for runtime-created parameters. Access control is enforced through CCSP authentication mechanisms integrated with DBus and RBus interfaces.</li> <li>Custom Extensions: Platform-specific parameter extensions for advanced WiFi configuration, hardware-specific device settings, custom diagnostic parameters for system monitoring and troubleshooting, vendor-specific management parameters for proprietary features, and extended telemetry parameters for performance monitoring and analytics.</li> </ul> <p>CcspPsm manages a comprehensive set of TR-181 parameters covering device information, management server configuration, and various functional areas. The parameter implementation includes proper type validation, range checking, and access control enforcement.</p> Parameter Description Access (R/W) Default Notes <code>Device.DeviceInfo.Manufacturer</code> Device manufacturer name R \"RDK Management\" Standard TR-181 <code>Device.DeviceInfo.ModelName</code> Device model identifier R \"\" Platform-specific <code>Device.DeviceInfo.SoftwareVersion</code> Current software version R \"\" Auto-populated <code>Device.ManagementServer.URL</code> TR-069 ACS server URL R/W \"\" Management config <code>Device.ManagementServer.Username</code> ACS authentication username R/W \"\" Encrypted storage <code>Device.ManagementServer.Password</code> ACS authentication password W \"\" Write-only, encrypted <code>Device.Time.NTPServer1</code> Primary NTP server address R/W \"pool.ntp.org\" Time synchronization <code>Device.WiFi.Radio.1.Enable</code> WiFi radio 1 enable status R/W <code>true</code> Custom validation <code>Device.Custom.Namespace.DebugLevel</code> Component debug logging level R/W <code>3</code> Custom extension"},{"location":"review/CCSPPSM/#implementation-details","title":"Implementation Details","text":"<ul> <li> <p>Key Algorithms or Logic: CcspPsm employs efficient hash-table based parameter lookup algorithms in the System Registry module (<code>psm_sysro_storage.c</code>) for O(1) average-case parameter access. The File Loader module (<code>psm_flo_parse.c</code>) implements SAX-based XML parsing for memory-efficient configuration file processing. Parameter persistence uses atomic file operations with backup mechanisms to prevent configuration corruption during system failures. The component implements lazy loading for configuration parameters to optimize memory usage and startup time.</p> </li> <li> <p>Error Handling Strategy: Comprehensive error detection includes XML parsing validation, parameter type checking, storage operation verification, and IPC communication error handling. Errors are logged through the RDK logging framework with categorized severity levels (Error, Warning, Info, Debug). Critical errors trigger component restart mechanisms, while recoverable errors are handled gracefully with fallback to default values. Error propagation follows CCSP standards with appropriate error codes returned to calling components.</p> </li> <li> <p>Logging &amp; Debugging: Logging categories include CONFIG (configuration operations), STORAGE (file I/O operations), IPC (communication events), and PARAM (parameter operations). Verbosity levels range from 0 (errors only) to 4 (full debug tracing). Debug tools include parameter dump utilities, configuration validation tools, and runtime memory usage monitors. The component supports dynamic log level adjustment through TR-181 parameters for runtime debugging.</p> </li> </ul>"},{"location":"review/CCSPPSM/#key-configuration-files","title":"Key Configuration Files","text":"<p>CcspPsm relies on several critical configuration files that define default parameter values, component behavior, and platform-specific settings. These files are processed during component initialization and can be updated for customization and deployment-specific configurations.</p> Configuration File Purpose Key Parameters Default Values Override Mechanisms <code>bbhm_def_cfg_qemu.xml</code> Default parameter values and TR-181 object definitions TR-181 parameters, device-specific configs Platform defaults Environment variables, command-line args <code>debug.ini</code> Debug and logging configuration Log levels, output targets, categories Error level logging Runtime parameter updates <code>psm.cfg</code> Component-specific configuration Storage paths, backup intervals, cache sizes <code>/nvram/psm/</code> storage Configuration file overrides <code>systemd/ccsp-psm.service</code> SystemD service configuration Process startup, dependencies, restart policies Auto-restart enabled SystemD override files"},{"location":"review/CCSPPandM/","title":"CcspPandM Documentation","text":"<p>CcspPandM is the RDK-B component that implements the Protocol and Management (P&amp;M) subsystem, serving as the central TR-181 data model manager for residential gateway devices. It acts as the primary interface for device configuration, status monitoring, and protocol management across multiple network services including DHCP, DNS, firewall, routing, and device information management. The component bridges upper-layer management protocols (like TR-069/CWMP) with lower-level HAL implementations and platform services. It provides standardized TR-181 parameter access, WebConfig support for bulk configuration changes, and comprehensive device management capabilities. CcspPandM integrates with other RDK-B components through DBus messaging and serves as the authoritative source for network configuration data within the RDK-B ecosystem.</p> <pre><code>graph TD\n    subgraph \"External Management Systems\"\n        ACS[(\"ACS/TR-069 Server\")]\n        WebUI[(\"Web Management UI\")]\n        SNMP[(\"SNMP Manager\")]\n    end\n\n    subgraph \"RDK-B Gateway Device\"\n        CcspPandM[\"CcspPandM\n        TR-181 Protocol &amp; Management\"]\n\n        subgraph \"Other RDK-B Components\"\n            TR069[\"CcspTr069Pa\"]\n            WiFi[\"CcspWiFiAgent\"] \n            CM[\"CcspCMAgent\"]\n            Harvester[\"Harvester\"]\n        end\n\n        subgraph \"Platform Services\"\n            HAL[(\"HAL Layer\n            DHCP/DNS/Firewall\")]\n            Utopia[(\"Utopia\n            System Services\")]\n            Syscfg[(\"Syscfg\n            Configuration Store\")]\n        end\n    end\n\n    ACS --&gt;|\"TR-069/CWMP\"| TR069\n    WebUI --&gt;|\"HTTP/WebConfig\"| CcspPandM\n    SNMP --&gt;|\"SNMP v2c/v3\"| CcspPandM\n\n    TR069 &lt;--&gt;|\"DBus\"| CcspPandM\n    WiFi &lt;--&gt;|\"DBus\"| CcspPandM\n    CM &lt;--&gt;|\"DBus\"| CcspPandM\n    Harvester &lt;--&gt;|\"DBus\"| CcspPandM\n\n    CcspPandM --&gt;|\"HAL API Calls\"| HAL\n    CcspPandM &lt;--&gt;|\"System Calls\"| Utopia\n    CcspPandM &lt;--&gt;|\"File I/O\"| Syscfg\n\n    classDef external fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n    classDef component fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef platform fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n\n    class ACS,WebUI,SNMP external;\n    class CcspPandM,TR069,WiFi,CM,Harvester component;\n    class HAL,Utopia,Syscfg platform;</code></pre> <p>Key Features &amp; Responsibilities</p> <ul> <li>TR-181 Data Model Implementation: Provides comprehensive TR-181 parameter tree management for device configuration and status reporting including Device.IP, Device.DHCP, Device.DNS, Device.Firewall, Device.Routing, and vendor-specific extensions</li> <li>DBus Message Bus Integration: Implements CCSP DBus interface for inter-component communication, parameter get/set operations, and event notifications across the RDK-B middleware stack</li> <li>WebConfig Framework Support: Handles bulk configuration updates through WebConfig protocol for efficient mass deployment and configuration management scenarios</li> <li>Device Information Management: Manages Device.DeviceInfo parameters including hardware details, software versions, uptime statistics, and system capabilities reporting</li> <li>Network Services Configuration: Controls DHCP server/client settings, DNS configuration, firewall rules, NAT policies, routing tables, and interface management</li> <li>Authentication and User Management: Implements Device.Users and web UI authentication mechanisms with role-based access control for administrative interfaces</li> </ul>"},{"location":"review/CCSPPandM/#design","title":"Design","text":"<p>CcspPandM follows a modular, service-oriented architecture that prioritizes data model abstraction, inter-component messaging, and platform independence. The component separates TR-181 data model logic from underlying platform implementations through well-defined HAL interfaces, ensuring portability across different hardware platforms. It implements a single-threaded event-driven model with DBus integration for scalable message handling and maintains strict separation between configuration management and operational data. The design emphasizes reliability through comprehensive error handling, logging frameworks, and graceful degradation patterns. Security is embedded through parameter access control, input validation, and secure communication channels. Maintainability is achieved through clear module boundaries, standardized coding patterns, and comprehensive unit testing frameworks.</p> <p>The component enforces clear boundaries with other RDK-B components through standardized DBus interfaces and TR-181 parameter namespaces. CcspPandM is responsible for TR-181 data model integrity, configuration persistence through syscfg integration, and coordinating with platform services for network configuration changes. Other components handle protocol-specific implementations (TR-069, WiFi management) while relying on CcspPandM for centralized configuration storage and retrieval.</p> <p>A container diagram of the component is given below</p> <pre><code>graph TD\n    subgraph Runtime [\"RDK-B Runtime Environment\"]\n        subgraph CcspPandMContainer [\"CcspPandM Process Container\"]\n            SSP[\"SSP Main\n            Service Startup &amp; Management\"]\n            TR181DML[\"TR-181 DML Engine\n            Data Model Logic\"]\n            DBusInterface[\"DBus Interface\n            Message Bus Communication\"]\n            WebConfigAPI[\"WebConfig API\n            Bulk Configuration Handler\"]\n        end\n\n        subgraph ConfigStore [\"Configuration Storage\"]\n            Syscfg[(\"Syscfg Database\")]\n            PSMDb[(\"PSM Database\")]\n        end\n\n        subgraph HALLayer [\"Hardware Abstraction Layer\"]\n            NetworkHAL[(\"Network HAL\")]\n            CMHAL[(\"CM HAL\")]\n        end\n    end\n\n    SSP --&gt;|\"Initialize &amp; Control\"| TR181DML\n    TR181DML &lt;--&gt;|\"Parameter Access\"| DBusInterface\n    TR181DML --&gt;|\"Bulk Updates\"| WebConfigAPI\n    TR181DML --&gt;|\"Read/Write Config\"| Syscfg\n    TR181DML --&gt;|\"Parameter Storage\"| PSMDb\n    TR181DML --&gt;|\"HAL API Calls\"| NetworkHAL\n    TR181DML --&gt;|\"Device Info Queries\"| CMHAL\n\n    classDef process fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef storage fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;\n    classDef hal fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n\n    class SSP,TR181DML,DBusInterface,WebConfigAPI process;\n    class Syscfg,PSMDb storage;\n    class NetworkHAL,CMHAL hal;</code></pre> <p>Request Flow Sequence</p> <p>The most critical flow is TR-181 parameter access from external management systems. When a TR-069 ACS requests a parameter value, the request flows through CcspTr069Pa via DBus to CcspPandM's DBus interface, which routes to the appropriate DML handler, retrieves data from HAL or configuration stores, and returns the response through the same path.</p> <pre><code>sequenceDiagram\n    participant ACS as ACS/TR-069 Server\n    participant TR069 as CcspTr069Pa\n    participant PandM as CcspPandM\n    participant HAL as Network HAL\n    participant Syscfg as Syscfg Store\n\n    ACS-&gt;&gt;TR069: GetParameterValues(Device.IP.Interface.1.IPv4Address)\n    TR069-&gt;&gt;PandM: DBus GetParameterValues\n    PandM-&gt;&gt;HAL: GetInterfaceInfo(eth0)\n    HAL--&gt;&gt;PandM: Interface Configuration\n    PandM-&gt;&gt;Syscfg: ReadConfig(interface_params)\n    Syscfg--&gt;&gt;PandM: Stored Parameters\n    PandM--&gt;&gt;TR069: Parameter Values Response\n    TR069--&gt;&gt;ACS: GetParameterValuesResponse</code></pre> <p>Threading Model</p> <p>The CcspPandM component follows a single-threaded, event-driven architecture with the following thread allocation:</p> <ul> <li>Main Thread: Manages all DBus message processing, TR-181 parameter operations, and system interactions sequentially</li> <li>Asynchronous Messaging: Leverages the DBus event loop for handling asynchronous messages and callback execution without spawning additional threads</li> <li>HAL and Configuration Operations: All hardware abstraction layer interactions, configuration file accesses, and inter-component communications are executed synchronously within the main thread context</li> <li>Thread Synchronization: Not required due to the single-threaded design, which ensures deterministic behavior and simplifies concurrency management</li> </ul> <p>This design benefits from the DBus framework\u2019s built-in queuing and scheduling mechanisms, enabling responsive yet predictable execution without the complexity of multithreading.</p>"},{"location":"review/CCSPPandM/#internal-modules","title":"Internal Modules","text":"<p>The component is organized into distinct functional modules that handle specific aspects of TR-181 data model implementation and system integration. Each module encapsulates related functionality while maintaining clear interfaces with other modules.</p> Module/Class Description Key Files SSP (Service Startup Provider) Main process initialization, component lifecycle management, and DBus registration <code>ssp_main.c</code>, <code>ssp_action.c</code>, <code>ssp_messagebus_interface.c</code> TR-181 DML Engine Core data model logic implementation for all TR-181 objects and parameters <code>cosa_*_dml.c</code>, <code>cosa_*_internal.c</code> files Device Info Management Hardware and software information reporting, system capabilities <code>cosa_deviceinfo_dml.c</code>, <code>cosa_deviceinfo_internal.c</code> Network Configuration IP, DHCP, DNS, routing, and interface management <code>cosa_ip_dml.c</code>, <code>cosa_dhcpv4_dml.c</code>, <code>cosa_dns_dml.c</code> Security &amp; Firewall Firewall rules, NAT policies, security configuration <code>cosa_firewall_dml.c</code>, <code>cosa_nat_dml.c</code>, <code>cosa_x_cisco_com_security_dml.c</code> WebConfig Framework Bulk configuration processing and validation <code>cosa_webconfig_api.c</code>, <code>webcfgparam.c</code> Utilities &amp; Helpers Common utility functions, API abstractions, and helper modules <code>cosa_apis_util.c</code>, <code>cosa_apis_busutil.c</code>, <code>helpers.h</code> <pre><code>flowchart TD\n    subgraph CcspPandM\n        SSP([SSP Main Process])\n        DMLEngine([TR-181 DML Engine])\n        DeviceInfo([Device Info Management])\n        NetworkConfig([Network Configuration])\n        SecurityFirewall([Security &amp; Firewall])\n        WebConfig([WebConfig Framework])\n        Utilities([Utilities &amp; Helpers])\n    end\n\n    SSP --&gt; DMLEngine\n    DMLEngine --&gt; DeviceInfo\n    DMLEngine --&gt; NetworkConfig\n    DMLEngine --&gt; SecurityFirewall\n    DMLEngine --&gt; WebConfig\n    DMLEngine --&gt; Utilities\n\n    classDef core fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef functional fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;\n    classDef support fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n\n    class SSP,DMLEngine core;\n    class DeviceInfo,NetworkConfig,SecurityFirewall,WebConfig functional;\n    class Utilities support;</code></pre>"},{"location":"review/CCSPPandM/#interaction-with-other-middleware-components","title":"Interaction with Other Middleware Components","text":"<p>CcspPandM serves as the central configuration hub for the RDK-B ecosystem, providing TR-181 parameter access and coordination services to other middleware components through standardized DBus interfaces.</p> <pre><code>flowchart TD\n    CcspPandM --&gt;|\"DBus Parameter Access\"| CcspTr069Pa\n    CcspPandM &lt;--&gt;|\"DBus WiFi Config Sync\"| CcspWiFiAgent\n    CcspPandM &lt;--&gt;|\"DBus Modem Status\"| CcspCMAgent\n    CcspPandM --&gt;|\"DBus Telemetry Data\"| Harvester\n    CcspPandM --&gt;|\"DBus Event Notifications\"| CcspCommonLibrary\n    CcspPandM &lt;--&gt;|\"RBUS Parameter Updates\"| RBUSComponents</code></pre> Component Purpose of Interaction Protocols/Mechanisms CcspTr069Pa TR-069 CWMP protocol implementation for ACS communication DBus parameter get/set, event subscriptions CcspWiFiAgent WiFi configuration synchronization and status reporting DBus parameter notifications, configuration updates CcspCMAgent Cable modem status monitoring and configuration DBus status queries, event notifications Harvester Telemetry data collection and reporting DBus parameter access, periodic data requests CcspCommonLibrary Shared CCSP services and utilities DBus event publishing, component discovery RBUSComponents Next-generation message bus integration RBUS parameter subscriptions, event handling <p>CCSP P&amp;M publishes several key events that other components can subscribe to for coordination and monitoring purposes:</p> Event Purpose of Event Reason for trigger ParameterValueChange Notify subscribers of TR-181 parameter changes Configuration updates, status changes, external modifications ComponentReady Signal successful component initialization Startup completion, service availability ConfigurationApplied Confirm WebConfig bulk update completion Mass configuration deployment, validation success InterfaceStatusChange Network interface state notifications Link up/down events, IP address changes SystemRebootRequired System restart requirement notification Critical configuration changes, firmware updates"},{"location":"review/CCSPPandM/#interaction-with-other-layers","title":"Interaction with Other Layers","text":"<p>CcspPandM interacts with multiple system layers to provide comprehensive device management capabilities, abstracting platform-specific details through well-defined interfaces while maintaining direct access to configuration persistence mechanisms.</p> Layer/Service Interaction Description Mechanism Network HAL Interface configuration, DHCP operations, routing table management Direct HAL API calls, function pointers Cable Modem HAL Device information queries, hardware capabilities, diagnostic data HAL API calls, shared libraries Utopia System Services System-level network configuration, service management System calls, file operations, process control Syscfg Configuration Store Persistent parameter storage, configuration backup/restore File I/O, database transactions PSM (Persistent Storage Manager) Structured parameter persistence, atomic updates DBus interface, SQL operations Linux Kernel Network interface control, system statistics, hardware access Netlink sockets, proc/sys filesystem <pre><code>graph TD\n    subgraph \"Application Layer\"\n        WebUI[(\"Web Management Interface\")]\n        TR069[(\"TR-069 ACS Interface\")]\n    end\n\n    subgraph \"RDK-B Middleware Layer\" \n        CcspPandM[(\"CcspPandM\n        TR-181 P&amp;M\")]\n        OtherComponents[(\"Other CCSP Components\")]\n    end\n\n    subgraph \"Platform Abstraction Layer\"\n        HAL[(\"Hardware Abstraction Layer\")]\n        Utopia[(\"Utopia Services\")]\n        Syscfg[(\"Configuration Storage\")]\n    end\n\n    subgraph \"Operating System Layer\"\n        Linux[(\"Linux Kernel\")]\n        FileSystem[(\"File System\")]\n    end\n\n    WebUI --&gt;|\"HTTP/WebConfig\"| CcspPandM\n    TR069 --&gt;|\"DBus\"| CcspPandM\n    OtherComponents &lt;--&gt;|\"DBus\"| CcspPandM\n\n    CcspPandM --&gt;|\"HAL API\"| HAL\n    CcspPandM --&gt;|\"System Calls\"| Utopia\n    CcspPandM &lt;--&gt;|\"File I/O\"| Syscfg\n\n    HAL --&gt; Linux\n    Utopia --&gt; Linux\n    Syscfg --&gt; FileSystem\n    FileSystem --&gt; Linux\n\n    classDef app fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n    classDef middleware fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef platform fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;\n    classDef os fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n\n    class WebUI,TR069 app;\n    class CcspPandM,OtherComponents middleware;\n    class HAL,Utopia,Syscfg platform;\n    class Linux,FileSystem os;</code></pre>"},{"location":"review/CCSPPandM/#ipc-mechanism","title":"IPC Mechanism","text":"Type of IPC Message Format Mechanism DBus Message Bus CCSP parameter structures with JSON encoding for complex data types, binary encoding for simple types DBus method calls, signals, and property notifications with CCSP message format RBUS (Next-Gen) RBUS data structures with type-safe parameter encoding, event-driven subscriptions RBUS library calls, event subscriptions, method invocations HAL Function Calls C structure pointers with platform-specific data layouts, return codes Direct function pointer invocation, shared library loading File-based IPC INI-style configuration files, JSON WebConfig documents File system operations, atomic writes, file locking <pre><code>sequenceDiagram\n    participant Client as External Client\n    participant DBus as DBus Daemon  \n    participant PandM as CcspPandM\n    participant HAL as Network HAL\n    participant Syscfg as Syscfg Store\n\n    Client-&gt;&gt;DBus: GetParameterValues(Device.IP.Interface.1.)\n    DBus-&gt;&gt;PandM: CCSP DBus Method Call\n\n    alt Parameter requires HAL data\n        PandM-&gt;&gt;HAL: hal_GetInterfaceInfo()\n        HAL--&gt;&gt;PandM: Interface Data Structure\n    else Parameter from configuration\n        PandM-&gt;&gt;Syscfg: syscfg_get(param_name)\n        Syscfg--&gt;&gt;PandM: Configuration Value\n    end\n\n    PandM--&gt;&gt;DBus: CCSP Parameter Response\n    DBus--&gt;&gt;Client: GetParameterValuesResponse\n\n    Note over PandM: Publish parameter change event\n    PandM-&gt;&gt;DBus: ParameterValueChangeSignal\n    DBus-&gt;&gt;Client: Event Notification (if subscribed)</code></pre>"},{"location":"review/CCSPPandM/#implementation-details","title":"Implementation Details","text":"<ul> <li> <p>Key Algorithms or Logic: The component implements a hierarchical parameter tree traversal algorithm for TR-181 namespace resolution, utilizing hash maps for efficient parameter lookup and caching mechanisms for frequently accessed values. The main logic resides in <code>plugin_main.c</code> for component initialization, <code>cosa_apis_busutil.c</code> for DBus parameter routing, and individual DML files for parameter-specific handling. State machines manage configuration validation workflows and WebConfig processing pipelines.</p> </li> <li> <p>Error Handling Strategy: Comprehensive error handling includes parameter validation at input boundaries, HAL operation failure recovery, DBus communication error handling, and configuration rollback mechanisms. Errors are logged through the RDK Logger framework with categorized severity levels, and critical failures trigger component restart or system recovery procedures.</p> </li> <li> <p>Logging &amp; Debugging: The component uses RDK Logger (rdklogger) with multiple log categories including PAM (main), WIFI_AGENT, TR69AGENT, and component-specific modules. Debug levels range from FATAL/ERROR for critical issues to DEBUG/TRACE for detailed troubleshooting. Debug hooks include parameter access tracing, DBus message logging, and HAL interaction monitoring through compile-time flags.</p> </li> </ul>"},{"location":"review/CCSPPandM/#key-configuration-files","title":"Key Configuration Files","text":"Configuration File Purpose Key Parameters Default Values Override Mechanisms <code>CcspPam.cfg</code> Component registration and DBus configuration <code>ComponentId</code>, <code>DbusPath</code>, <code>DataModelXmlCfg</code> <code>com.cisco.spvtg.ccsp.pam</code>, <code>/com/cisco/spvtg/ccsp/pam</code> Environment variables, compile-time flags <code>CcspDmLib.cfg</code> Data model library configuration and TR-181 mapping <code>DataModelXml</code>, <code>LibraryPath</code>, <code>InitFunction</code> <code>TR181-USGv2.XML</code>, <code>libtr181</code> Build configuration, platform variants <code>TR181-USGv2.XML</code> Complete TR-181 data model definition and parameter mapping Object definitions, parameter types, access permissions Standard TR-181 plus vendor extensions Custom XML variants, feature flags <code>syscfg.db</code> Persistent parameter storage and configuration backup Network settings, security policies, device configuration Platform-specific defaults Factory reset, configuration restore <code>/nvram/pamssp_backtrace</code> Crash debugging and backtrace information Stack traces, error contexts, debug symbols Empty file Debug builds, crash handlers"},{"location":"review/CCSPPandM/#tr-181-data-models-supported","title":"TR-181 Data Models Supported","text":"<p>CcspPandM implements comprehensive TR-181 data model coverage for residential gateway devices:</p>"},{"location":"review/CCSPPandM/#core-device-management","title":"Core Device Management","text":"<ul> <li>Device.DeviceInfo: Hardware information, software versions, system uptime</li> <li>Device.UserInterface: Web UI configuration, language settings, access control  </li> <li>Device.Time: NTP configuration, timezone settings, system clock management</li> <li>Device.Users: User account management, authentication, role-based access</li> </ul>"},{"location":"review/CCSPPandM/#network-configuration","title":"Network Configuration","text":"<ul> <li>Device.IP: Interface configuration, IPv4/IPv6 settings, address management</li> <li>Device.DHCP: DHCP server/client configuration, lease management, reservations</li> <li>Device.DNS: DNS server settings, domain configuration, resolution policies</li> <li>Device.Routing: Static routes, dynamic routing protocols, forwarding tables</li> <li>Device.NAT: Network address translation rules, port mapping, UPnP</li> </ul>"},{"location":"review/CCSPPandM/#security-access-control","title":"Security &amp; Access Control","text":"<ul> <li>Device.Firewall: Firewall rules, security policies, intrusion detection</li> <li>Device.X_CISCO_COM_Security: Vendor-specific security enhancements</li> <li>Device.X_Comcast_COM_ParentalControl: Content filtering, access restrictions</li> </ul>"},{"location":"review/CCSPPandM/#advanced-features","title":"Advanced Features","text":"<ul> <li>Device.X_CISCO_COM_Diagnostics: Network diagnostics, connectivity testing</li> <li>Device.X_CISCO_COM_MultiLAN: Multi-LAN configuration and management  </li> <li>Device.X_RDK_Features: RDK-specific feature flags and capabilities</li> </ul> <pre><code>erDiagram\n    Device ||--o{ DeviceInfo : contains\n    Device ||--o{ IP : manages\n    Device ||--o{ DHCP : configures\n    Device ||--o{ DNS : controls\n    Device ||--o{ Firewall : secures\n    Device ||--o{ Users : authenticates\n\n    IP ||--o{ Interface : includes\n    DHCP ||--o{ Server : operates\n    DHCP ||--o{ Client : requests\n    Interface ||--o{ IPv4Address : assigns\n    Interface ||--o{ IPv6Address : assigns\n\n    DeviceInfo {\n        string Manufacturer\n        string ModelName\n        string SerialNumber\n        string SoftwareVersion\n        datetime UpTime\n    }\n\n    Interface {\n        boolean Enable\n        string Status\n        string Name\n        string Type\n        string LowerLayers\n    }</code></pre>"},{"location":"review/CellularManager/","title":"Cellular Manager Documentation","text":"<p>Cellular Manager component provides cellular/LTE modem management and connectivity services for RDK-B CPEs. It manages cellular modem lifecycle, network registration, data connectivity, and providing standardized TR-181 interfaces for cellular configuration and monitoring. The component integrates with the rest of the RDK-B ecosystem through CCSP message bus communication, HAL abstraction for hardware independence, and supports both DBus and RBus messaging protocols.</p> <pre><code>graph TD\n    subgraph ExternalSystems [\"External Systems\"]\n        Network[\" Cellular Network\"]\n        Cloud[\"Cloud Services\"]\n    end\n\n    subgraph RDKBPlatform [\"RDK-B Platform\"]\n        subgraph ApplicationLayer [\"Application Layer\"]\n            WebUI[\"WebUI\"]\n            SNMP[\"SNMP Agent\"]\n        end\n\n        subgraph MiddlewareLayer [\"Middleware Layer\"]\n            WanMgr[\"WAN Manager\"]\n            CellMgr[\"Cellular Manager\"]\n            PSM[\"PSM\"]\n        end\n\n        subgraph HALLayer [\"HAL Layer\"]\n            CellHAL[\"Cellular HAL\"]\n        end\n\n        subgraph HardwareLayer [\"Hardware Layer\"]\n            Modem[\"Cellular Modem\"]\n        end\n    end\n\n    WebUI --&gt;|TR-181| CellMgr\n    SNMP --&gt;|SNMP MIB| CellMgr\n    WanMgr &lt;--&gt;|DBus/RBus| CellMgr\n    CellMgr &lt;--&gt;|HAL APIs| CellHAL\n    CellHAL --&gt;|QMI/AT Commands| Modem\n    CellMgr &lt;--&gt;|Parameter Storage| PSM\n    Modem &lt;--&gt;|Radio| Network\n    Network &lt;--&gt;|Internet| Cloud\n\n    classDef external fill:#ffeb3b,stroke:#f57f17,stroke-width:2px\n    classDef app fill:#e3f2fd,stroke:#1976d2,stroke-width:2px\n    classDef middleware fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px\n    classDef hal fill:#e8f5e8,stroke:#388e3c,stroke-width:2px\n    classDef hardware fill:#fce4ec,stroke:#c2185b,stroke-width:2px\n\n    class Network,Cloud external\n    class WebUI,SNMP app\n    class WanMgr,CellMgr,PSM middleware\n    class CellHAL hal\n    class Modem hardware</code></pre> <p>Key Features &amp; Responsibilities</p> <ul> <li>Cellular Modem Management: Handles cellular modem initialization, configuration, and lifecycle management including device detection, slot selection, and power management</li> <li>Network Registration &amp; Connectivity: Manages network attachment, profile selection, PDN context establishment, and maintains IPv4/IPv6 connectivity status</li> <li>State Machine Control: Implements a comprehensive state machine that transitions through DOWN, DEACTIVATED, DEREGISTERED, REGISTERED, and CONNECTED states</li> <li>TR-181 Data Model Implementation: Exposes standardized TR-181 Cellular parameters for device management, status monitoring, and configuration through both CCSP and RBus interfaces</li> <li>HAL Abstraction Layer: Provides hardware abstraction through cellular HAL APIs, supporting various cellular modems with QMI-based communication</li> <li>Event Broadcasting: Publishes cellular status changes, registration events, and connectivity state transitions to other RDK-B components</li> </ul>"},{"location":"review/CellularManager/#design","title":"Design","text":"<p>The Cellular Manager follows a layered architecture approach with clear separation of concerns between hardware abstraction, business logic, and data model layers. The design emphasizes modularity through well-defined interfaces between the HAL layer, state machine controller, and TR-181 implementation. Reliability is achieved through robust error handling, retry mechanisms, and comprehensive logging throughout the cellular connection lifecycle. The component maintains scalability by supporting multiple cellular profiles, different modem types through HAL abstraction, and extensible configuration mechanisms. Security is implemented through controlled access to cellular parameters, secure credential management for network profiles, and proper validation of configuration changes. Maintainability is ensured through modular code organization, comprehensive unit test coverage, and clear documentation of APIs and state transitions.</p> <p>The design supports both traditional CCSP DBus messaging and modern RBus communication protocols, allowing for flexible deployment scenarios. Clear boundaries are established between the cellular manager core logic and external dependencies like HAL implementations, ensuring portability across different hardware platforms.</p> <p>Component responsibilities are clearly defined: the cellular manager handles high-level policy decisions and state management, the HAL layer provides hardware-specific implementations, and the TR-181 layer exposes standardized interfaces for external consumption.</p> <p>A container diagram of the component is given below</p> <pre><code>graph TD\n    subgraph Runtime [\"Linux RDK-B Runtime\"]\n        subgraph CellularContainer [\"Cellular Manager Container (C/C++)\"]\n            CellularMain[Main Process&lt;br/&gt;cellularmgr_main.c]\n            StateMachine[State Machine&lt;br/&gt;cellularmgr_sm.c]\n            HALInterface[HAL Interface&lt;br/&gt;cellular_hal.c]\n            TR181Layer[TR-181 DML&lt;br/&gt;cellularmgr_cellular_dml.c]\n            RBusLayer[RBus Interface&lt;br/&gt;cellularmgr_rbus_dml.c]\n        end\n        subgraph MessageBus [\"CCSP Message Bus\"]\n            DBusBroker[(DBus Broker)]\n        end\n        subgraph RBusBroker [\"RBus Broker\"]\n            RBus[(RBus)]\n        end\n    end\n\n    CellularMain --&gt;|Initialize| StateMachine\n    StateMachine --&gt;|HAL Calls| HALInterface\n    TR181Layer --&gt;|DBus| DBusBroker\n    RBusLayer --&gt;|RBus| RBus\n    CellularMain --&gt;|Register Components| DBusBroker\n\n    classDef container fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef messagebus fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n    class CellularMain,StateMachine,HALInterface,TR181Layer,RBusLayer container;\n    class DBusBroker,RBus messagebus;</code></pre> <p>Request Flow Sequence</p> <p>The most critical flow is cellular network connection establishment, starting from cellular enable request through network attachment to active data connectivity.</p> <pre><code>sequenceDiagram\n    participant Client as External Client\n    participant TR181 as TR-181 Interface\n    participant SM as State Machine\n    participant HAL as Cellular HAL\n    participant Modem as Cellular Modem\n\n    Client-&gt;&gt;TR181: Set X_RDK_Enable=true\n    TR181-&gt;&gt;SM: Start State Machine\n    SM-&gt;&gt;HAL: cellular_hal_open_device()\n    HAL-&gt;&gt;Modem: Initialize modem communication\n    Modem--&gt;&gt;HAL: Device ready\n    HAL--&gt;&gt;SM: DEVICE_OPEN_STATUS_UP\n    SM-&gt;&gt;HAL: cellular_hal_monitor_device_status()\n    HAL-&gt;&gt;Modem: Query registration status\n    Modem--&gt;&gt;HAL: Registration complete\n    HAL--&gt;&gt;SM: NAS_REGISTERED\n    SM-&gt;&gt;HAL: cellular_hal_start_network()\n    HAL-&gt;&gt;Modem: Establish PDN context\n    Modem--&gt;&gt;HAL: IP address assigned\n    HAL--&gt;&gt;SM: NETWORK_PACKET_SERVICE_ATTACHED\n    SM--&gt;&gt;TR181: Update X_RDK_Status=CONNECTED\n    TR181--&gt;&gt;Client: Status update complete</code></pre> <p>Threading Model</p> <p>The Cellular Manager uses a single-threaded, event-driven model with the following thread responsibilities:</p> <ul> <li>Main Thread: Handles CCSP message bus events, TR-181 parameter requests, and state machine transitions</li> <li>Timer-Based Polling: Implements background monitoring via periodic polling to query cellular modem status and update internal state</li> <li>HAL-Managed Worker Threads: HAL layer may internally spawn worker threads for QMI communication and modem interaction, managed transparently from the application layer</li> <li>Callback Mechanism: Uses asynchronous callbacks from the HAL to receive notifications without blocking main thread operations during network and modem interactions</li> </ul>"},{"location":"review/CellularManager/#internal-modules","title":"Internal Modules","text":"<p>The Cellular Manager is organized into several key modules that handle different aspects of cellular management functionality. The core modules work together to provide comprehensive cellular connectivity services while maintaining clear separation of concerns.</p> Module/Class Description Key Files Main Process Entry point and initialization, handles CCSP component registration and message bus setup <code>cellularmgr_main.c</code>, <code>cellularmgr_global.h</code> State Machine Core cellular connection state management, transitions between DOWN/DEACTIVATED/REGISTERED/CONNECTED states <code>cellularmgr_sm.c</code>, <code>cellularmgr_sm.h</code> Cellular APIs High-level cellular management APIs, profile management, and network control functions <code>cellularmgr_cellular_apis.c</code>, <code>cellularmgr_cellular_apis.h</code> HAL Interface Hardware abstraction layer interface for modem communication and QMI protocol handling <code>cellular_hal.c</code>, <code>cellular_hal.h</code>, <code>cellular_hal_qmi_apis.c</code> TR-181 DML TR-181 data model implementation for parameter get/set operations and validation <code>cellularmgr_cellular_dml.c</code>, <code>cellularmgr_cellular_dml.h</code> RBus Interface RBus protocol implementation for modern message bus communication <code>cellularmgr_rbus_dml.c</code>, <code>cellularmgr_rbus_events.c</code> Message Bus CCSP message bus interface for component communication and event handling <code>cellularmgr_messagebus_interface.c</code>, <code>cellularmgr_bus_utils.c</code> <pre><code>flowchart TD\n    subgraph CellularManager [\"Cellular Manager\"]\n        MainProcess([Main Process])\n        StateMachine([State Machine])\n        CellularAPIs([Cellular APIs])\n        HALInterface([HAL Interface])\n        TR181DML([TR-181 DML])\n        RBusInterface([RBus Interface])\n        MessageBus([Message Bus])\n        WebConfig([WebConfig])\n    end\n\n    MainProcess --&gt; StateMachine\n    MainProcess --&gt; MessageBus\n    StateMachine --&gt; CellularAPIs\n    CellularAPIs --&gt; HALInterface\n    TR181DML --&gt; CellularAPIs\n    RBusInterface --&gt; CellularAPIs\n    MessageBus --&gt; TR181DML\n\n    classDef core fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef interface fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;\n    class MainProcess,StateMachine,CellularAPIs,HALInterface core;\n    class TR181DML,RBusInterface,MessageBus,WebConfig interface;</code></pre>"},{"location":"review/CellularManager/#interaction-with-other-middleware-components","title":"Interaction with Other Middleware Components","text":"<p>The Cellular Manager integrates with multiple RDK-B components to provide comprehensive cellular connectivity and management services. It communicates with WAN Manager for network interface coordination, PSM for persistent configuration storage, and CcspCr for component registration and discovery.</p> <pre><code>flowchart LR\n    CellularManager --&gt;|DBus Messages| WANManager\n    CellularManager --&gt;|DBus Messages| PSM\n    CellularManager --&gt;|DBus Registration| CcspCr\n    CellularManager --&gt;|DBus Events| CcspPandM\n    CellularManager --&gt;|RBus Events| RBusComponents[RBus Components]\n\n    classDef cellular fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef external fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n    class CellularManager cellular;\n    class WANManager,PSM,CcspCr,CcspPandM,RBusComponents external;</code></pre> Component Purpose of Interaction Protocols/Mechanisms WAN Manager Coordinate cellular WAN interface status, notify of connectivity changes, and manage failover scenarios DBus messages, Event notifications PSM (Persistent Storage Manager) Store and retrieve cellular configuration parameters, profile settings, and persistent state information DBus parameter get/set operations CcspCr (Component Registrar) Register cellular manager component, discover other components, and maintain component health status DBus component registration and health check CcspPandM (Provisioning and Management) Report cellular device status, provide telemetry data, and handle factory reset scenarios DBus events and status reporting RBus Components Modern RBus-based components for cellular status monitoring and configuration management RBus publish/subscribe events <p>The Cellular Manager publishes several key events that other components can subscribe to for coordination and monitoring purposes:</p> Event Purpose of Event Reason for trigger CellularStatusChange Notify of cellular connection status transitions Triggered when state machine transitions between DOWN/DEACTIVATED/REGISTERED/CONNECTED states CellularProfileChange Notify of cellular profile configuration changes Triggered when cellular profile is modified through WebConfig or TR-181 parameter updates CellularDeviceDetected Notify of cellular modem hardware detection Triggered during component initialization when cellular modem is successfully detected and opened CellularNetworkRegistration Notify of cellular network registration status Triggered when modem completes network registration or loses network connectivity CellularDataConnectivity Notify of data connection establishment or failure Triggered when PDN context is established or fails, indicating data connectivity status"},{"location":"review/CellularManager/#interaction-with-other-layers","title":"Interaction with Other Layers","text":"<p>The Cellular Manager operates within a layered architecture, interfacing with the Hardware Abstraction Layer (HAL) for cellular modem control, platform-specific services for system integration, and external network services for cellular connectivity.</p> Layer/Service Interaction Description Mechanism Cellular HAL Hardware abstraction for cellular modem operations including device control, QMI communication, and status monitoring Direct API calls to cellular_hal_* functions Platform Services System-level services for network interface management, routing, and platform-specific cellular configurations System calls, configuration file updates External Cellular Network Communication with cellular towers and network infrastructure for registration, authentication, and data services Cellular modem communication via HAL Linux Network Stack Integration with Linux networking for interface configuration, IP address assignment, and routing table updates Network interface APIs, system configuration <pre><code>graph TD\n    subgraph ApplicationLayer [\"Application Layer\"]\n        WebUI[Web UI]\n        CLI[CLI Tools]\n    end\n\n    subgraph MiddlewareLayer [\"RDK-B Middleware Layer\"]\n        CellularManager[Cellular Manager]\n        WANManager[WAN Manager]\n        PSM[PSM]\n    end\n\n    subgraph HALLayer [\"Hardware Abstraction Layer\"]\n        CellularHAL[Cellular HAL]\n        QMILibrary[QMI Library]\n    end\n\n    subgraph PlatformLayer [\"Platform Layer\"]\n        LinuxKernel[Linux Kernel]\n        NetworkStack[Network Stack]\n        ModemDriver[Modem Driver]\n    end\n\n    subgraph HardwareLayer [\"Hardware Layer\"]\n        CellularModem[Cellular Modem]\n    end\n\n    ApplicationLayer --&gt;|TR-181 Parameters| MiddlewareLayer\n    CellularManager --&gt;|HAL APIs| CellularHAL\n    CellularHAL --&gt;|QMI Protocol| QMILibrary\n    QMILibrary --&gt;|System Calls| PlatformLayer\n    ModemDriver --&gt;|Hardware Control| CellularModem\n\n    classDef middleware fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef hal fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n    classDef platform fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n    class CellularManager,WANManager,PSM middleware;\n    class CellularHAL,QMILibrary hal;\n    class LinuxKernel,NetworkStack,ModemDriver platform;</code></pre>"},{"location":"review/CellularManager/#ipc-mechanism","title":"IPC Mechanism","text":"Type of IPC Message Format Mechanism DBus (CCSP) XML-structured messages with CCSP-specific headers, parameter names in TR-181 format, and typed value encoding DBus method calls for parameter get/set, signal emissions for events RBus JSON-formatted messages with hierarchical parameter paths, typed value encoding, and event subscription capabilities RBus publish/subscribe for events, method calls for parameter operations HAL Interface Direct C function calls with structured data types, return codes, and callback mechanisms Synchronous API calls with callback registration for asynchronous events <pre><code>sequenceDiagram\n    participant Client as Client Application\n    participant DBus as DBus Broker\n    participant CellularMgr as Cellular Manager\n    participant HAL as Cellular HAL\n    participant Modem as Cellular Modem\n\n    Client-&gt;&gt;DBus: DBus Method Call&lt;br/&gt;GetParameterValues(Device.Cellular.X_RDK_Status)\n    DBus-&gt;&gt;CellularMgr: CCSP Message&lt;br/&gt;Parameter Request\n    CellularMgr-&gt;&gt;HAL: cellular_hal_get_device_status()\n    HAL-&gt;&gt;Modem: QMI Status Query\n    Modem--&gt;&gt;HAL: QMI Response\n    HAL--&gt;&gt;CellularMgr: Status Structure\n    CellularMgr--&gt;&gt;DBus: CCSP Response&lt;br/&gt;Parameter Value\n    DBus--&gt;&gt;Client: DBus Method Response\n\n    Note over CellularMgr,HAL: Asynchronous Event Flow\n    Modem-&gt;&gt;HAL: Status Change Notification\n    HAL-&gt;&gt;CellularMgr: Callback Function\n    CellularMgr-&gt;&gt;DBus: DBus Signal&lt;br/&gt;Parameter Value Changed\n    DBus-&gt;&gt;Client: Event Notification</code></pre>"},{"location":"review/CellularManager/#tr181-data-models","title":"TR\u2011181 Data Models","text":"<ul> <li>Implemented Parameters: The Cellular Manager implements the Device.Cellular TR-181 object with RDK-specific extensions (X_RDK_*) for enhanced cellular management and monitoring capabilities.</li> <li>Parameter Registration: Parameters are registered through CCSP component registration using the RdkCellularManager.xml data model definition file, with support for both DBus and RBus access methods.</li> <li>Custom Extensions: <ul> <li>X_RDK_Enable: Custom boolean parameter for enabling/disabling cellular functionality with persistent storage support</li> <li>X_RDK_Status: Custom enumerated status parameter providing detailed cellular connection state information beyond standard TR-181</li> <li>X_RDK_Model/Vendor/HardwareRevision: Custom device identification parameters for cellular modem hardware information</li> <li>X_RDK_ControlInterface/DataInterface: Custom interface identification parameters for managing cellular control and data interfaces</li> <li>X_RDK_ProfileTable: Custom cellular profile management for multiple APN configurations and network preferences</li> </ul> </li> </ul> Parameter Description Access (R/W) Default Notes <code>Device.Cellular.Enable</code> Enable/disable cellular functionality R/W <code>false</code> Standard TR-181 <code>Device.Cellular.Status</code> Cellular connection status R <code>Down</code> Standard TR-181 <code>Device.Cellular.X_RDK_Enable</code> RDK-specific cellular enable control R/W <code>false</code> Custom extension <code>Device.Cellular.X_RDK_Status</code> Detailed cellular status enumeration R <code>DOWN</code> Custom extension <code>Device.Cellular.X_RDK_Model</code> Cellular modem model information R <code>\"\"</code> Custom extension <code>Device.Cellular.X_RDK_Vendor</code> Cellular modem vendor information R <code>\"\"</code> Custom extension <code>Device.Cellular.X_RDK_HardwareRevision</code> Cellular modem hardware revision R <code>\"\"</code> Custom extension <code>Device.Cellular.X_RDK_ControlInterface</code> Cellular control interface name R <code>\"\"</code> Custom extension <code>Device.Cellular.X_RDK_DataInterface</code> Cellular data interface name R <code>\"\"</code> Custom extension <code>Device.Cellular.X_RDK_DataInterfaceLink</code> Link status of data interface R <code>Down</code> Custom extension"},{"location":"review/CellularManager/#implementation-details","title":"Implementation Details","text":"<ul> <li> <p>Key Algorithms or Logic: The core algorithm is the cellular state machine (<code>cellularmgr_sm.c</code>) that manages transitions between DOWN, DEACTIVATED, DEREGISTERED, REGISTERED, and CONNECTED states based on modem status, network registration, and data connectivity. The QMI communication logic in <code>cellular_hal_qmi_apis.c</code> handles Qualcomm Modem Interface protocol for modem control and status monitoring. Profile selection algorithm evaluates available cellular profiles based on network conditions and user preferences.</p> </li> <li> <p>Error Handling Strategy: Errors are categorized into recoverable and non-recoverable types. Recoverable errors (network timeouts, temporary registration failures) trigger retry mechanisms with exponential backoff. Non-recoverable errors (hardware failures, invalid configurations) transition the state machine to error states and generate appropriate log messages. All error conditions are logged with appropriate severity levels and forwarded to telemetry systems for monitoring.</p> </li> <li> <p>Logging &amp; Debugging: The component uses RDK Logger (RDK_LOG) with multiple log levels (FATAL, ERROR, WARN, NOTICE, INFO, DEBUG). Logging categories include cellular state transitions, HAL operations, parameter changes, and network events. Debug hooks are available through cellular HAL test APIs and state machine debug interfaces for troubleshooting connectivity issues.</p> </li> </ul>"},{"location":"review/CellularManager/#key-configuration-files","title":"Key Configuration Files","text":"Configuration File Purpose Key Parameters Default Values Override Mechanisms <code>RdkCellularManager.xml</code> TR-181 data model definition Parameter definitions, access rights, data types N/A Component compilation <code>RdkCellularManager.service</code> SystemD service configuration Service dependencies, execution parameters Standard service settings SystemD override files <code>/etc/device.properties</code> Device-specific configuration LOG4C_RCPATH, device capabilities Device-dependent Environment variables <code>/usr/rdk/cellularmanager/</code> Runtime configuration directory Profile definitions, runtime state Empty directory WebConfig updates <code>/tmp/cellularmanager_initialized_bootup</code> Initialization marker file Component initialization status Not present Runtime creation"},{"location":"review/GPONManager/","title":"GPON Manager Documentation","text":"<p>GPON Manager is one of the WAN Management components in the RDK-B stack, responsible for managing GPON interfaces and their associated physical media. It serves as the primary abstraction layer between the rest of the RDK-B ecosystem and the underlying GPON hardware abstraction layer (HAL), providing centralized management of GPON physical interfaces, optical transceivers, and associated network parameters. The component implements TR-181 data models for GPON-specific parameters and maintains real-time monitoring of optical network conditions including power levels, alarms, and link states. It integrates seamlessly with the broader RDK-B platform by exposing standardized DBus interfaces for configuration management and event notifications. The GPON Manager plays a vital role in fiber-optic broadband deployments by ensuring reliable optical network connectivity and providing comprehensive diagnostic capabilities for service providers.</p> <p><pre><code>graph TD\n    subgraph External [\"External Systems\"]\n        OLT[OLT - Optical Line Terminal&lt;br/&gt;Service Provider Network]\n        Management[Network Management System&lt;br/&gt;Service Provider Operations]\n    end\n\n    subgraph RDKBPlatform [\"RDK-B Platform\"]\n        User1[WAN Manager&lt;br/&gt;WAN Interface Management] \n        User2[Telemetry Agent&lt;br/&gt;Performance Monitoring]\n        User3[Device Management&lt;br/&gt;TR-069/USP Agent]\n        GponMgr[\ud83d\udd0c GPON Manager&lt;br/&gt;Optical Network Management]\n    end\n\n    subgraph Hardware [\"Hardware Layer\"]\n        OpticalHW[Optical Transceiver Hardware&lt;br/&gt;SFP/BoB Modules]\n        GponInterface[GPON Network Interface&lt;br/&gt;Physical Layer]\n    end\n\n    OLT -.-&gt;|Optical Fiber| GponInterface\n    Management --&gt;|SNMP/TR-069| User3\n    User1 &lt;--&gt;|DBus Events| GponMgr\n    User2 &lt;--&gt;|Telemetry Data| GponMgr\n    User3 &lt;--&gt;|TR-181 Parameters| GponMgr\n    GponMgr &lt;--&gt;|JSON/HAL| OpticalHW\n    GponMgr &lt;--&gt;|JSON/HAL| GponInterface\n\n    classDef user fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n    classDef component fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef external fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n    classDef hardware fill:#ffebee,stroke:#c62828,stroke-width:2px;\n\n    class User1,User2,User3 user;\n    class GponMgr component;\n    class OLT,Management external;\n    class OpticalHW,GponInterface hardware;</code></pre> Key Features &amp; Responsibilities:</p> <ul> <li>Physical Media Management: Monitors and manages GPON optical transceivers including SFP modules, power levels, temperature sensors, and optical signal quality metrics</li> <li>Link State Machine: Implements sophisticated state machine logic to handle GPON link establishment, maintenance, and failure recovery scenarios</li> <li>Alarm Monitoring: Provides comprehensive alarm detection and reporting for Loss of Signal (LOS), Loss of Frame (LOF), and other critical optical network conditions</li> <li>TR-181 Data Model Implementation: Exposes standardized GPON parameters through TR-181 interfaces for configuration management and status reporting</li> <li>HAL Integration: Communicates with vendor-specific GPON HAL implementations through JSON-based messaging protocols</li> <li>Event Subscription: Supports real-time event notifications for GPON state changes, alarms, and operational status updates</li> </ul>"},{"location":"review/GPONManager/#design","title":"Design","text":"<p>The GPON Manager is architected around modular design principles that separate concerns between GPON hardware abstraction, TR-181 data model implementation, and link state management. The component emphasizes reliability through comprehensive error handling, robust state machine logic, and graceful failure recovery mechanisms. Scalability is achieved through dynamic table management for multiple GPON interfaces and support for various optical transceiver types including SFP and BoB modules. Security is ensured through controlled access to GPON parameters via DBus interfaces and validation of all configuration changes. The design maintains clear boundaries between the TR-181 middle layer, the core GPON management logic, and the HAL interface layer. Data persistence responsibilities are handled through the TR-181 parameter storage mechanisms, while real-time event management is delegated to the HAL interface layer. The component's interface management focuses on providing standardized GPON parameter access while abstracting vendor-specific HAL implementations.</p> <p>A container diagram of the component is given below</p> <pre><code>graph TD\n    subgraph Runtime [\"RDK-B Linux Runtime\"]\n        subgraph GponManagerContainer [\"GPON Manager Container\"]\n            GponController[GPON Controller&lt;br/&gt;Link State Management]\n            TR181Layer[TR-181 Middle Layer&lt;br/&gt;Data Model Implementation]\n            HALInterface[HAL Interface&lt;br/&gt;JSON Communication]\n        end\n        subgraph Database [\"Syscfg Database\"]\n            ConfigDB[(Configuration Storage)]\n        end\n        subgraph HALLayer [\"GPON HAL Layer\"]\n            VendorHAL[Vendor GPON HAL&lt;br/&gt;Hardware Abstraction]\n        end\n    end\n    GponController --&gt;|State Events| TR181Layer\n    TR181Layer --&gt;|Parameter Access| ConfigDB\n    HALInterface --&gt;|JSON Messages| VendorHAL\n    GponController --&gt;|HAL Commands| HALInterface\n\n    classDef component fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef database fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n    classDef external fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n\n    class GponController,TR181Layer,HALInterface component;\n    class ConfigDB database;\n    class VendorHAL external;</code></pre> <p>Request Flow Sequence</p> <p>The most critical flow involves GPON physical media status monitoring and link state management. When the GPON Manager receives HAL events indicating changes in optical signal conditions, the component processes these through its link state machine, updates TR-181 parameters, and notifies other RDK-B components of state changes.</p> <pre><code>sequenceDiagram\n    participant HAL as GPON HAL\n    participant GponMgr as GPON Manager\n    participant TR181 as TR-181 Layer\n    participant DBus as DBus Interface\n    participant Client as RDK-B Client\n\n    HAL-&gt;&gt;GponMgr: Physical Media Status Event\n    GponMgr-&gt;&gt;GponMgr: Process Link State Machine\n    GponMgr-&gt;&gt;TR181: Update Parameter Values\n    TR181-&gt;&gt;DBus: Publish Parameter Change\n    DBus-&gt;&gt;Client: Parameter Change Notification\n    Client-&gt;&gt;DBus: Get GPON Status Request\n    DBus-&gt;&gt;TR181: Parameter Access\n    TR181-&gt;&gt;GponMgr: Retrieve Current State\n    GponMgr-&gt;&gt;HAL: Query HAL Parameters\n    HAL--&gt;&gt;GponMgr: HAL Response\n    GponMgr--&gt;&gt;TR181: Current Values\n    TR181--&gt;&gt;DBus: Parameter Response\n    DBus--&gt;&gt;Client: GPON Status Response</code></pre> <p>Threading Model</p> <p>The GPON Manager uses a single-threaded, event-driven model with the following thread responsibilities:</p> <ul> <li>Main Thread: Handles TR-181 parameter requests, HAL event processing, and execution of the link state machine</li> <li>On-Demand Worker Threads: Spawned for HAL JSON message processing and handling timeout-related tasks</li> <li>Link State Machine: Operates with a configurable timeout interval (default 500ms) to ensure timely responses to optical network conditions while maintaining overall system responsiveness</li> </ul>"},{"location":"review/GPONManager/#internal-modules","title":"Internal Modules","text":"<p>The GPON Manager consists of several specialized modules that handle different aspects of GPON network management. The GPON Controller module serves as the central orchestrator, managing the overall component lifecycle and coordinating between other modules. The Link State Machine module implements the core logic for GPON link establishment and maintenance, processing optical signal conditions and managing state transitions. The TR-181 Middle Layer provides the standardized data model interface, exposing GPON parameters to other RDK-B components through DBus. The HAL Interface module handles communication with vendor-specific GPON HAL implementations using JSON-based messaging protocols.</p> Module/Class Description Key Files GPON Controller Central management and event coordination for GPON interfaces <code>gponmgr_controller.c</code>, <code>gponmgr_controller.h</code> Link State Machine GPON link state management and optical signal monitoring <code>gponmgr_link_state_machine.c</code>, <code>gponmgr_link_state_machine.h</code> TR-181 Middle Layer Data model implementation and parameter management <code>gponmgr_dml_*.c</code>, <code>gpon_apis.h</code> HAL Interface JSON-based communication with GPON HAL <code>gponmgr_dml_hal.c</code>, <code>gponmgr_dml_hal.h</code> SSP Framework Service Specific Platform framework integration <code>ssp_main.c</code>, <code>ssp_messagebus_interface.c</code> <pre><code>flowchart TD\n    subgraph GponManager [\"GPON Manager\"]\n        Controller([GPON Controller&lt;br/&gt;Event Coordination])\n        StateMachine([Link State Machine&lt;br/&gt;Optical Link Management])\n        TR181([TR-181 Middle Layer&lt;br/&gt;Data Model Interface])\n        HALInterface([HAL Interface&lt;br/&gt;JSON Communication])\n        SSP([SSP Framework&lt;br/&gt;Platform Integration])\n    end\n\n    Controller --&gt; StateMachine\n    StateMachine --&gt; TR181\n    Controller --&gt; HALInterface\n    HALInterface --&gt; TR181\n    SSP --&gt; Controller\n    TR181 --&gt; SSP\n\n    classDef module fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;\n    class Controller,StateMachine,TR181,HALInterface,SSP module;</code></pre>"},{"location":"review/GPONManager/#interaction-with-other-middleware-components","title":"Interaction with Other Middleware Components","text":"<p>The GPON Manager interacts with several key RDK-B middleware components to provide comprehensive GPON network management. It communicates with the WAN Manager component through TR-181 parameter notifications to coordinate WAN interface status and configuration changes. The component publishes telemetry events to the Telemetry component for optical network performance monitoring and diagnostic data collection. Integration with the PSM (Persistent Storage Manager) ensures GPON configuration parameters are properly stored and restored across system reboots.</p> <pre><code>flowchart TD\n    GponManager[GPON Manager] --&gt;|DBus Parameter Events| WANManager[WAN Manager]\n    GponManager --&gt;|Telemetry Events| TelemetryComponent[Telemetry Component]\n    GponManager --&gt;|Configuration Storage| PSM[Persistent Storage Manager]\n    GponManager --&gt;|System Events| SystemdNotify[Systemd Notify]</code></pre> Component Purpose of Interaction Protocols/Mechanisms WAN Manager GPON interface status and configuration coordination DBus parameter notifications Telemetry Component Optical network performance data and diagnostics Event publishing PSM Configuration parameter persistence and restoration DBus parameter storage System Manager Service lifecycle and health monitoring Systemd notifications <p>The GPON Manager publishes various events to notify other components of significant GPON network state changes and operational conditions.</p> Event Purpose of Event Reason for trigger Physical Media Status Notifies of optical transceiver status changes Physical media link up/down, module insertion/removal GPON Alarm Events Reports critical optical network alarms Loss of Signal, Loss of Frame, temperature thresholds VEIP State Changes Virtual Ethernet Interface Point status updates Administrative state changes, operational status transitions PLOAM Registration GPON registration state notifications ONT registration with OLT, authentication status"},{"location":"review/GPONManager/#interaction-with-other-layers","title":"Interaction with Other Layers","text":"<p>The GPON Manager serves as a crucial intermediary between the RDK-B middleware layer and the underlying hardware abstraction and platform services. It maintains clear abstraction boundaries while enabling comprehensive GPON network management capabilities.</p> Layer/Service Interaction Description Mechanism GPON HAL Hardware abstraction for optical transceivers and GPON interfaces JSON-based messaging over TCP/IP Linux Platform System configuration and network interface management Syscfg API, system calls Hardware Layer Direct optical transceiver monitoring and control HAL abstraction RDK-B Middleware Parameter management and event notifications DBus interfaces <pre><code>graph TD\n    subgraph MiddlewareLayer [\"RDK-B Middleware Layer\"]\n        GponManager[GPON Manager]\n        WANManager[WAN Manager]\n        PSM[PSM]\n    end\n\n    subgraph PlatformLayer [\"Linux Platform Layer\"]\n        Syscfg[Syscfg Database]\n        NetworkStack[Network Stack]\n    end\n\n    subgraph HALLayer [\"Hardware Abstraction Layer\"]\n        GponHAL[GPON HAL]\n    end\n\n    subgraph HardwareLayer [\"Hardware Layer\"]\n        OpticalTransceiver[Optical Transceiver]\n        GponInterface[GPON Interface]\n    end\n\n    GponManager --&gt;|DBus| WANManager\n    GponManager --&gt;|DBus| PSM\n    GponManager --&gt;|Syscfg API| Syscfg\n    GponManager --&gt;|JSON/TCP| GponHAL\n    GponHAL --&gt;|HAL API| OpticalTransceiver\n    GponHAL --&gt;|HAL API| GponInterface\n\n    classDef middleware fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef platform fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n    classDef hal fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n    classDef hardware fill:#ffebee,stroke:#c62828,stroke-width:2px;\n\n    class GponManager,WANManager,PSM middleware;\n    class Syscfg,NetworkStack platform;\n    class GponHAL hal;\n    class OpticalTransceiver,GponInterface hardware;</code></pre>"},{"location":"review/GPONManager/#ipc-mechanism","title":"IPC Mechanism","text":"Type of IPC Message Format Mechanism DBus Standard DBus message format with TR-181 parameter structures DBus method calls and signals for parameter access JSON over TCP JSON-structured messages conforming to GPON HAL schema TCP socket communication on port 40100 Syscfg API Key-value pairs for configuration storage Direct API calls to syscfg library <pre><code>sequenceDiagram\n    participant Client as RDK-B Client\n    participant GponMgr as GPON Manager\n    participant HAL as GPON HAL\n    participant Syscfg as Syscfg Database\n\n    Client-&gt;&gt;GponMgr: DBus Method Call (Get Parameter)\n    GponMgr-&gt;&gt;HAL: JSON Request (getParameters)\n    HAL--&gt;&gt;GponMgr: JSON Response (getParametersResponse)\n    GponMgr-&gt;&gt;Syscfg: syscfg_get (parameter)\n    Syscfg--&gt;&gt;GponMgr: Configuration Value\n    GponMgr--&gt;&gt;Client: DBus Response (Parameter Value)\n\n    Note over HAL,GponMgr: Event Subscription Flow\n    HAL-&gt;&gt;GponMgr: JSON Event (publishEvent)\n    GponMgr-&gt;&gt;GponMgr: Process State Machine\n    GponMgr-&gt;&gt;Client: DBus Signal (Parameter Change)</code></pre>"},{"location":"review/GPONManager/#tr181-data-models","title":"TR\u2011181 Data Models","text":"<ul> <li>Implemented Parameters: The GPON Manager implements comprehensive TR-181 parameters under the <code>Device.X_RDK_ONT</code> namespace, covering physical media properties, VEIP (Virtual Ethernet Interface Point) configuration, and PLOAM (Physical Layer Operations Administration and Maintenance) parameters. Default values are typically hardware-dependent and retrieved from the GPON HAL.</li> <li>Parameter Registration: Parameters are registered through the RDK-B TR-181 framework using DBus interfaces, with automatic parameter change notifications and validation mechanisms.</li> <li>Custom Extensions: The component implements RDK-specific extensions for GPON management including redundancy state control, enhanced alarm monitoring, and optical power management beyond standard TR-181 specifications.</li> </ul> Parameter Description Access (R/W) Default Notes <code>Device.X_RDK_ONT.PhysicalMedia.{i}.Cage</code> Optical transceiver cage type (BoB/SFP) R \"SFP\" Hardware dependent <code>Device.X_RDK_ONT.PhysicalMedia.{i}.ModuleVendor</code> Optical module vendor name R \"\" Retrieved from HAL <code>Device.X_RDK_ONT.PhysicalMedia.{i}.ModuleName</code> Optical module model name R \"\" Retrieved from HAL <code>Device.X_RDK_ONT.PhysicalMedia.{i}.PonMode</code> PON technology mode (GPON/XG-PON/NG-PON2/XGS-PON2) R \"GPON\" Hardware dependent <code>Device.X_RDK_ONT.PhysicalMedia.{i}.Status</code> Physical media operational status R \"Down\" Standard TR-181 <code>Device.X_RDK_ONT.PhysicalMedia.{i}.Enable</code> Administrative enable state R/W <code>false</code> WAN unification <code>Device.X_RDK_ONT.PhysicalMedia.{i}.RedundancyState</code> Redundancy state (Active/Standby) R \"Active\" Custom extension <code>Device.X_RDK_ONT.PhysicalMedia.{i}.RxPower.SignalLevel</code> Received optical power level in dBm R <code>0</code> Real-time from HAL <code>Device.X_RDK_ONT.PhysicalMedia.{i}.TxPower.SignalLevel</code> Transmitted optical power level in dBm R <code>0</code> Real-time from HAL <code>Device.X_RDK_ONT.PhysicalMedia.{i}.Temperature.CurrentTemp</code> Optical transceiver temperature in Celsius R <code>0</code> Real-time from HAL <code>Device.X_RDK_ONT.PhysicalMedia.{i}.Alarm.LOS</code> Loss of Signal alarm status R \"Inactive\" Critical alarm <code>Device.X_RDK_ONT.PhysicalMedia.{i}.Alarm.LOF</code> Loss of Frame alarm status R \"Inactive\" Critical alarm <code>Device.X_RDK_ONT.Gtc.CorrectedFecBytes</code> FEC corrected bytes count R <code>0</code> Performance metric <code>Device.X_RDK_ONT.Gtc.HecErrorCount</code> Header Error Check error count R <code>0</code> Performance metric <code>Device.X_RDK_ONT.Veip.{i}.AdministrativeState</code> VEIP administrative state R/W \"Unlock\" GPON specific <code>Device.X_RDK_ONT.Veip.{i}.OperationalState</code> VEIP operational state R \"Disabled\" GPON specific <code>Device.X_RDK_ONT.Ploam.OnuId</code> ONT identifier assigned by OLT R <code>0</code> GPON registration <code>Device.X_RDK_ONT.Ploam.RegistrationState</code> ONT registration state with OLT R \"O1\" GPON specific <code>Device.X_RDK_ONT.Ploam.VendorId</code> ONT vendor identifier R \"\" GPON registration <code>Device.X_RDK_ONT.Ploam.SerialNumber</code> ONT serial number R \"\" GPON registration"},{"location":"review/GPONManager/#implementation-details","title":"Implementation Details","text":"<ul> <li>Key Algorithms or Logic: The core algorithm implements a finite state machine for GPON link management located in <code>gponmgr_link_state_machine.c</code>. The state machine handles transitions between link states based on optical signal conditions, VEIP interface status, and PLOAM registration state. The JSON message parsing and HAL communication logic resides in <code>gponmgr_dml_hal.c</code> with comprehensive error handling for HAL connectivity issues.</li> <li>Error Handling Strategy: Errors are detected through return code validation, JSON schema compliance checking, and HAL response timeouts. All errors are logged using CcspTrace macros with appropriate severity levels. Critical errors trigger component restart through the SSP framework, while transient errors are handled through retry mechanisms with exponential backoff.</li> <li>Logging &amp; Debugging: The component uses RDK-B standard logging categories including CcspTraceInfo, CcspTraceWarning, and CcspTraceError. Debug hooks are available through the DBus interface for runtime diagnostics. HAL communication can be debugged through JSON message logging when enabled.</li> </ul>"},{"location":"review/GPONManager/#key-configuration-files","title":"Key Configuration Files","text":"Configuration File Purpose Key Parameters Default Values Override Mechanisms <code>gpon_manager_conf.json</code> Main GPON Manager configuration <code>hal_schema_path</code>, <code>server_port</code> <code>/etc/rdk/schemas/gpon_hal_schema.json</code>, <code>40100</code> Environment variables <code>gpon_manager_wan_unify_conf.json</code> WAN unification specific settings WAN Manager integration parameters Varies by deployment Build-time configuration <code>RdkGponManager.xml</code> TR-181 data model definitions Parameter mappings, function bindings N/A Compile-time only <code>gpon_hal_schema.json</code> HAL interface schema definition JSON message validation rules Schema version 0.0.1 HAL vendor updates"},{"location":"review/LMLite/","title":"CcspLMLite Documentation","text":"<p>CcspLMLite (LAN Management Lite) is the RDK-B component responsible for managing connected devices, host discovery, presence detection, and network traffic monitoring within the local area network. It serves as the central hub for tracking network device information, providing TR-181 data model implementation for device management, and facilitating telemetry data collection. The component bridges low-level network discovery mechanisms with high-level management services, integrating with CCSP framework, WebPA for cloud communication, and RBus for inter-component messaging.</p> <pre><code>graph TD\n    subgraph \"External Systems\"\n        Cloud[Cloud Management]\n        TR069[TR-069 ACS]\n    end\n\n    subgraph \"RDK-B Gateway\"\n        subgraph \"Management Layer\"\n            WebPA[WebPA Agent]\n            TR069Agent[TR-069 Agent]\n            CcspCR[CCSP Component Registry]\n        end\n\n        subgraph \"Middleware Layer\"\n            CcspLMLite[CcspLMLite]\n            WiFiAgent[WiFi Agent]\n            CcspPSM[PSM]\n            CcspTr069Pa[TR-069 PA]\n        end\n\n        subgraph \"HAL Layer\"\n            WiFiHAL[WiFi HAL]\n            EthHAL[Ethernet HAL]\n            MoCAHAL[MoCA HAL]\n        end\n\n        subgraph \"Platform Layer\"\n            NetworkStack[Linux Network Stack]\n            DeviceDrivers[Device Drivers]\n        end\n    end\n\n    Cloud --&gt;|HTTPS/WebPA| WebPA\n    TR069 --&gt;|HTTPS/CWMP| TR069Agent\n\n    WebPA --&gt;|DBus| CcspLMLite\n    TR069Agent --&gt;|DBus| CcspTr069Pa\n    CcspTr069Pa --&gt;|DBus| CcspLMLite\n    CcspCR --&gt;|DBus| CcspLMLite\n\n    CcspLMLite --&gt;|DBus| WiFiAgent\n    CcspLMLite --&gt;|DBus| CcspPSM\n    CcspLMLite --&gt;|RBus| WiFiAgent\n\n    WiFiAgent --&gt;|API| WiFiHAL\n    CcspLMLite --&gt;|Netlink/Proc| NetworkStack\n    NetworkStack --&gt; DeviceDrivers\n\n    classDef external fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n    classDef management fill:#e3f2fd,stroke:#1976d2,stroke-width:2px;\n    classDef middleware fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n    classDef hal fill:#fce4ec,stroke:#c2185b,stroke-width:2px;\n    classDef platform fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;\n\n    class Cloud,TR069 external;\n    class WebPA,TR069Agent,CcspCR management;\n    class CcspLMLite,WiFiAgent,CcspPSM,CcspTr069Pa middleware;\n    class WiFiHAL,EthHAL,MoCAHAL hal;\n    class NetworkStack,DeviceDrivers platform;</code></pre> <p>Key Features &amp; Responsibilities</p> <ul> <li>Host Discovery &amp; Management: Discovers, tracks, and manages connected devices across WiFi, Ethernet, and MoCA interfaces, maintaining comprehensive device information including MAC addresses, IP assignments, device types, and connection status</li> <li>Presence Detection: Implements advanced presence detection algorithms using IPv4/IPv6 pings and network activity monitoring to determine device active/inactive states with configurable polling intervals and retry mechanisms</li> <li>TR-181 Data Model Implementation: Provides complete TR-181 Hosts data model implementation with read/write parameter support, device enumeration, and vendor-specific extensions for RDK-specific functionality</li> <li>Network Traffic Monitoring: Collects and reports WAN traffic statistics, device-specific traffic patterns, and network utilization metrics for bandwidth management and analytics</li> <li>Telemetry Data Collection: Generates network device status reports, traffic statistics, and presence notifications in Avro format for upstream cloud analytics and monitoring systems</li> <li>Cross-Interface Integration: Coordinates with multiple network interfaces (WiFi, Ethernet, MoCA) to provide unified device visibility and consistent device identification across different connection types</li> </ul>"},{"location":"review/LMLite/#design","title":"Design","text":"<p>CcspLMLite follows a modular, event-driven architecture that emphasizes separation of concerns and loose coupling between functional components. The design prioritizes real-time responsiveness for presence detection while maintaining data consistency across multiple network interfaces. Scalability is achieved through efficient data structures and periodic harvesting mechanisms that can handle up to 256 concurrent devices. Reliability is ensured through robust error handling, graceful degradation during interface failures, and persistent state management via PSM integration. Security considerations include MAC address validation, IP address verification, and controlled access to sensitive network information through TR-181 parameter permissions.</p> <p>The component implements clear boundaries between data collection (host discovery), data processing (presence detection algorithms), data storage (device state management), and data presentation (TR-181 interface). Interface management responsibilities are distributed across specialized modules: network interface abstraction handles multi-interface coordination, DML modules manage TR-181 parameter operations, and telemetry modules handle data serialization and reporting. The design supports both polling-based and event-driven data collection modes to optimize performance based on network conditions and device requirements.</p> <p>A container diagram of the component is given below</p> <pre><code>graph TD\n    subgraph \"Linux Runtime Environment\"\n        subgraph \"CcspLMLite Container\"\n            subgraph \"Core Engine\"\n                LMCore[LM Core Engine&lt;br/&gt;Device Discovery &amp; Management]\n                PDCore[Presence Detection Engine&lt;br/&gt;Active/Inactive State Management]\n            end\n\n            subgraph \"Data Layer\"\n                DeviceDB[(Device Database&lt;br/&gt;In-Memory Host Information)]\n                ConfigDB[(Configuration Store&lt;br/&gt;PSM Integration)]\n            end\n\n            subgraph \"Interface Layer\"\n                TR181DML[TR-181 DML Interface&lt;br/&gt;Parameter Management]\n                WebPAIntf[WebPA Interface&lt;br/&gt;Cloud Communication]\n                RBusIntf[RBus Interface&lt;br/&gt;Event Publishing]\n            end\n\n            subgraph \"Network Modules\"\n                NetIntf[Network Interface Handler&lt;br/&gt;Multi-Interface Coordination]\n                TrafficMon[Traffic Monitor&lt;br/&gt;Bandwidth &amp; Usage Tracking]\n            end\n        end\n\n        subgraph \"External Dependencies\"\n            MessageBus[CCSP Message Bus&lt;br/&gt;DBus Communication]\n            LinuxNet[Linux Network Stack&lt;br/&gt;Netlink/Proc Interfaces]\n        end\n    end\n\n    LMCore --&gt; DeviceDB\n    PDCore --&gt; DeviceDB\n    LMCore --&gt; NetIntf\n    PDCore --&gt; NetIntf\n\n    TR181DML --&gt; DeviceDB\n    WebPAIntf --&gt; DeviceDB\n    RBusIntf --&gt; DeviceDB\n\n    NetIntf --&gt; LinuxNet\n    TrafficMon --&gt; LinuxNet\n\n    TR181DML --&gt; MessageBus\n    WebPAIntf --&gt; MessageBus\n\n    ConfigDB --&gt; MessageBus\n\n    classDef core fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef data fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n    classDef interface fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n    classDef network fill:#fce4ec,stroke:#c2185b,stroke-width:2px;\n    classDef external fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;\n\n    class LMCore,PDCore core;\n    class DeviceDB,ConfigDB data;\n    class TR181DML,WebPAIntf,RBusIntf interface;\n    class NetIntf,TrafficMon network;\n    class MessageBus,LinuxNet external;</code></pre> <p>Request Flow Sequence</p> <p>The most critical flow is the device discovery and presence detection sequence, which involves continuous monitoring of network interfaces, device state updates, and TR-181 parameter synchronization.</p> <pre><code>sequenceDiagram\n    participant Client as TR-181 Client\n    participant DML as TR-181 DML Handler\n    participant LMCore as LM Core Engine\n    participant NetIntf as Network Interface\n    participant DeviceDB as Device Database\n    participant PDEngine as Presence Detection\n\n    Client-&gt;&gt;DML: GET Device.Hosts.Host.{i}\n    DML-&gt;&gt;DeviceDB: Query Device Information\n    DeviceDB--&gt;&gt;DML: Device Data\n    DML--&gt;&gt;Client: TR-181 Response\n\n    Note over NetIntf: Periodic Network Scan\n    NetIntf-&gt;&gt;LMCore: New Device Detected\n    LMCore-&gt;&gt;DeviceDB: Update Device Entry\n    LMCore-&gt;&gt;PDEngine: Start Presence Monitoring\n\n    loop Presence Detection Cycle\n        PDEngine-&gt;&gt;NetIntf: Ping Device\n        NetIntf--&gt;&gt;PDEngine: Response/Timeout\n        PDEngine-&gt;&gt;DeviceDB: Update Active Status\n        PDEngine-&gt;&gt;DML: Trigger Parameter Update\n    end\n\n    DML-&gt;&gt;Client: Parameter Change Notification</code></pre> <p>Threading Model</p> <p>The CcspLMLite uses a multi-threaded architecture with the following thread allocation:</p> <ul> <li>Main Thread: Handles initialization, CCSP message bus communication, and TR-181 parameter requests</li> <li>Device Discovery Thread: Continuously monitors network interfaces and processes newly connected devices</li> <li>Presence Detection Thread: Runs with a configurable polling interval (default 10 seconds) to determine device active/inactive states</li> <li>Traffic Monitoring Thread: Operates in the background to collect bandwidth usage statistics without impacting real-time operations</li> <li>Event Processing Threads: Handle WebPA message publishing and RBus event notifications</li> <li>Thread Synchronization: Ensures data consistency across concurrent operations using mutex locks and condition variables, while supporting responsive user interface interactions</li> </ul>"},{"location":"review/LMLite/#internal-modules","title":"Internal Modules","text":"<p>The CcspLMLite component consists of several specialized modules that work together to provide comprehensive network device management functionality. The core LM (LAN Management) module orchestrates device discovery and maintains the central device database. DML modules provide TR-181 parameter interface implementations for different functional areas. Network interface handlers abstract platform-specific networking operations, while telemetry modules handle data serialization and cloud communication.</p> Module/Class Description Key Files LM Core Engine Central device discovery and management engine that coordinates host tracking, device enumeration, and state synchronization <code>lm_main.c</code>, <code>lm_main.h</code>, <code>lm_api.c</code>, <code>lm_api.h</code> TR-181 Hosts DML Implements Device.Hosts.Host.{i} TR-181 data model with parameter get/set operations and device table management <code>cosa_hosts_dml.c</code>, <code>cosa_hosts_dml.h</code> Presence Detection Advanced device presence detection using ping mechanisms, activity monitoring, and configurable timeout/retry logic <code>device_presence_detection.c</code>, <code>device_presence_detection.h</code> Network Device Status Harvests and reports network device status information with Avro serialization for telemetry data collection <code>network_devices_status.c</code>, <code>network_devices_status.h</code>, <code>network_devices_status_avropack.c</code> Traffic Monitoring WAN traffic counting and bandwidth monitoring with per-device statistics and RBus API integration <code>cosa_wantraffic_api.c</code>, <code>cosa_wantraffic_utils.c</code>, <code>wtc_rbus_apis.c</code> WebPA Interface Cloud communication interface for device management commands, notifications, and telemetry data upstream delivery <code>webpa_interface.c</code>, <code>webpa_interface.h</code>, <code>webpa_pd_with_seshat.c</code> Network Interface Handler Multi-interface coordination for WiFi, Ethernet, and MoCA connections with unified device identification <code>network_devices_interface.c</code>, <code>network_devices_interface.h</code> SSP Framework System Service Provider framework integration with CCSP message bus, component registration, and lifecycle management <code>ssp_main.c</code>, <code>ssp_messagebus_interface.c</code>, <code>ssp_action.c</code> <pre><code>flowchart TD\n    subgraph CcspLMLite\n        subgraph \"Core Layer\"\n            LMCore[LM Core Engine&lt;br/&gt;Device Management]\n            PDEngine[Presence Detection&lt;br/&gt;Activity Monitoring] \n        end\n\n        subgraph \"Interface Layer\"\n            HostsDML[Hosts DML&lt;br/&gt;TR-181 Implementation]\n            XHostsDML[XHosts DML&lt;br/&gt;Extended Parameters]\n            NDStatusDML[ND Status DML&lt;br/&gt;Status Reporting]\n            NDTrafficDML[ND Traffic DML&lt;br/&gt;Traffic Statistics]\n        end\n\n        subgraph \"Communication Layer\"\n            WebPAIntf[WebPA Interface&lt;br/&gt;Cloud Communication]\n            RBusAPI[RBus APIs&lt;br/&gt;Event Publishing]\n            NetIntf[Network Interface&lt;br/&gt;Multi-Interface Handler]\n        end\n\n        subgraph \"Data Processing\"\n            AvroStatus[Avro Status Packer&lt;br/&gt;Status Serialization]\n            AvroTraffic[Avro Traffic Packer&lt;br/&gt;Traffic Serialization]\n            TrafficUtils[Traffic Utils&lt;br/&gt;WAN Monitoring]\n        end\n\n        subgraph \"Framework\"\n            SSP[SSP Framework&lt;br/&gt;CCSP Integration]\n            MsgBus[Message Bus Interface&lt;br/&gt;DBus Communication]\n        end\n    end\n\n    LMCore --&gt; HostsDML\n    LMCore --&gt; XHostsDML\n    PDEngine --&gt; HostsDML\n\n    LMCore --&gt; NetIntf\n    PDEngine --&gt; NetIntf\n\n    HostsDML --&gt; WebPAIntf\n    NDStatusDML --&gt; AvroStatus\n    NDTrafficDML --&gt; AvroTraffic\n\n    TrafficUtils --&gt; RBusAPI\n    AvroStatus --&gt; WebPAIntf\n    AvroTraffic --&gt; WebPAIntf\n\n    SSP --&gt; MsgBus\n    HostsDML --&gt; MsgBus\n    XHostsDML --&gt; MsgBus\n    NDStatusDML --&gt; MsgBus\n    NDTrafficDML --&gt; MsgBus\n\n    classDef core fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef interface fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n    classDef comm fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n    classDef data fill:#fce4ec,stroke:#c2185b,stroke-width:2px;\n    classDef framework fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;\n\n    class LMCore,PDEngine core;\n    class HostsDML,XHostsDML,NDStatusDML,NDTrafficDML interface;\n    class WebPAIntf,RBusAPI,NetIntf comm;\n    class AvroStatus,AvroTraffic,TrafficUtils data;\n    class SSP,MsgBus framework;</code></pre>"},{"location":"review/LMLite/#interaction-with-other-middleware-components","title":"Interaction with Other Middleware Components","text":"<p>CcspLMLite integrates extensively with other RDK-B middleware components to provide comprehensive network management functionality. It communicates with WiFi Agent to retrieve wireless device information and association status, coordinating device discovery across multiple interfaces. The component interfaces with PSM (Persistent Storage Manager) for configuration parameter persistence and system state management. Integration with TR-069 PA enables remote management capabilities through TR-181 parameter exposure. WebPA Agent coordination facilitates cloud-based device management and telemetry data delivery for analytics platforms.</p> <pre><code>flowchart LR\n    CcspLMLite --&gt;|DBus GetParameterValues&lt;br/&gt;Device Association Info| WiFiAgent[WiFi Agent]\n    CcspLMLite --&gt;|DBus SetParameterValues&lt;br/&gt;Configuration Persistence| PSM[PSM]\n    CcspLMLite --&gt;|DBus RegisterNamespace&lt;br/&gt;TR-181 Parameter Exposure| TR069PA[TR-069 PA]\n    CcspLMLite --&gt;|HTTP POST /api/v1/device&lt;br/&gt;Telemetry Data Upload| WebPAAgent[WebPA Agent]\n    CcspLMLite --&gt;|RBus Publish&lt;br/&gt;Device Status Events| EventBus[RBus Event System]\n    CcspLMLite --&gt;|DBus ComponentCheck&lt;br/&gt;Health Monitoring| CcspCR[CCSP Component Registry]\n    CcspLMLite --&gt;|Netlink Sockets&lt;br/&gt;Network Interface Monitoring| NetworkStack[Linux Network Stack]\n\n    classDef middleware fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef external fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n    classDef system fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n\n    class CcspLMLite middleware;\n    class WiFiAgent,PSM,TR069PA,WebPAAgent,CcspCR middleware;\n    class EventBus external;\n    class NetworkStack system;</code></pre> Component Purpose of Interaction Protocols/Mechanisms WiFi Agent Retrieve wireless device association status, RSSI values, and interface-specific device information for unified device tracking DBus GetParameterValues, Event Notifications PSM Persist configuration parameters like polling intervals, presence detection settings, and harvesting configurations across system reboots DBus SetParameterValues, GetParameterValues TR-069 PA Expose TR-181 Device.Hosts.Host.{i} parameters for remote management and configuration through TR-069 protocol DBus RegisterNamespace, Parameter Notifications WebPA Agent Upload telemetry data including device status reports, traffic statistics, and presence notifications to cloud analytics platforms HTTP POST JSON/Avro, Message Queue CCSP Component Registry Register component capabilities, health status reporting, and inter-component discovery for system orchestration DBus ComponentRegistration, Health Checks RBus Event System Publish device presence events, traffic threshold notifications, and real-time device status changes for system-wide notifications RBus Event Publishing, Subscriptions <p>The component publishes several events to notify other system components about network device state changes and significant events that may require system-wide coordination or external reporting.</p> Event Purpose of Event Reason for trigger Device.Hosts.Host.{i}.Active Device presence state change notification indicating when devices join or leave the network Triggered when presence detection algorithms determine device active/inactive state changes based on ping responses and network activity Device.X_RDK_NetworkDeviceStatus Comprehensive device status report containing device counts, interface statistics, and connection details Triggered periodically based on harvesting schedule or on-demand when significant network topology changes are detected Device.X_RDK_NetworkTrafficCount WAN traffic statistics and per-device bandwidth utilization reports for network monitoring and analytics Triggered at configured reporting intervals or when traffic thresholds are exceeded for bandwidth management Device.Hosts.PresenceNotification Real-time presence notifications for specific monitored devices with configurable MAC address filtering Triggered immediately when monitored devices (configured via presence notification list) change presence status"},{"location":"review/LMLite/#interaction-with-other-layers","title":"Interaction with Other Layers","text":"<p>CcspLMLite interacts with multiple layers of the RDK-B software stack to provide comprehensive network device management. At the HAL layer, it interfaces with WiFi HAL for wireless device information and MoCA HAL for coax network devices. Platform-specific interactions include direct Linux network stack integration through netlink sockets and proc filesystem monitoring. External service integration encompasses cloud analytics platforms through WebPA and TR-069 ACS communication for remote management capabilities.</p> Layer/Service Interaction Description Mechanism WiFi HAL Retrieves wireless client association information, RSSI measurements, and interface status for WiFi-connected devices HAL API calls, callback registrations MoCA HAL Obtains MoCA network topology, device association status, and coax interface statistics for unified device visibility HAL API calls, status polling Linux Network Stack Monitors network interface changes, ARP table updates, and routing information for device discovery and IP tracking Netlink sockets, /proc filesystem WebPA Cloud Service Uploads telemetry data, receives device management commands, and provides cloud-based analytics integration HTTPS REST API, JSON/Avro payload TR-069 ACS Exposes device management parameters for remote configuration and monitoring through standardized TR-181 data model CWMP protocol, XML-RPC System Logging Records component events, error conditions, and debug information for system monitoring and troubleshooting Syslog, structured logging <pre><code>graph TD\n    %% Cloud Services\n    subgraph Cloud[\"Cloud Services Layer\"]\n        CloudAnalytics[\"Cloud Analytics Platform\"]\n        TR069ACS[\"TR-069 ACS\"]\n    end\n\n    %% Applications\n    subgraph Apps[\"Application Layer\"]\n        WebUI[\"Web Management Interface\"]\n        MobileApp[\"Mobile Applications\"]\n    end\n\n    %% Middleware\n    subgraph Middleware[\"RDK-B Middleware Layer\"]\n        CcspLMLite[\"CcspLMLite Component\"]\n        WiFiAgent[\"WiFi Agent\"]\n        PSM[\"PSM\"]\n        WebPAAgent[\"WebPA Agent\"]\n    end\n\n    %% HAL\n    subgraph HAL[\"HAL Layer\"]\n        WiFiHAL[\"WiFi HAL\"]\n        EthHAL[\"Ethernet HAL\"]\n        MoCAHAL[\"MoCA HAL\"]\n    end\n\n    %% Platform\n    subgraph Platform[\"Platform Layer\"]\n        LinuxKernel[\"Linux Kernel\"]\n        NetlinkSockets[\"Netlink Sockets\"]\n        ProcFS[\"/proc filesystem\"]\n        DeviceDrivers[\"Network Device Drivers\"]\n    end\n\n    %% Hardware\n    subgraph HW[\"Hardware Layer\"]\n        WiFiChipset[\"WiFi Chipset\"]\n        EthController[\"Ethernet Controller\"]\n        MoCAController[\"MoCA Controller\"]\n    end\n\n    %% Edges\n    CloudAnalytics &lt;--&gt;|\"HTTPS / JSON\"| WebPAAgent\n    TR069ACS &lt;--&gt;|\"CWMP / XML-RPC\"| CcspLMLite\n\n    WebUI &lt;--&gt;|\"HTTP / TR-181\"| CcspLMLite\n    MobileApp &lt;--&gt;|\"REST API\"| WebPAAgent\n\n    CcspLMLite &lt;--&gt;|\"DBus\"| WiFiAgent\n    CcspLMLite &lt;--&gt;|\"DBus\"| PSM\n    CcspLMLite &lt;--&gt;|\"DBus\"| WebPAAgent\n\n    WiFiAgent &lt;--&gt;|\"HAL API\"| WiFiHAL\n    CcspLMLite &lt;--&gt;|\"HAL API\"| EthHAL\n    CcspLMLite &lt;--&gt;|\"HAL API\"| MoCAHAL\n\n    CcspLMLite &lt;--&gt;|\"Netlink\"| NetlinkSockets\n    CcspLMLite &lt;--&gt;|\"File I/O\"| ProcFS\n    NetlinkSockets --&gt; LinuxKernel\n    ProcFS --&gt; LinuxKernel\n    LinuxKernel --&gt; DeviceDrivers\n\n    WiFiHAL --&gt; DeviceDrivers\n    EthHAL --&gt; DeviceDrivers  \n    MoCAHAL --&gt; DeviceDrivers\n\n    DeviceDrivers --&gt; WiFiChipset\n    DeviceDrivers --&gt; EthController\n    DeviceDrivers --&gt; MoCAController\n\n    %% Styling\n    classDef cloud fill:#e3f2fd,stroke:#1976d2,stroke-width:2px;\n    classDef app fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n    classDef middleware fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n    classDef hal fill:#fce4ec,stroke:#c2185b,stroke-width:2px;\n    classDef platform fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;\n    classDef hardware fill:#f1f8e9,stroke:#689f38,stroke-width:2px;\n\n    class CloudAnalytics,TR069ACS cloud;\n    class WebUI,MobileApp app;\n    class CcspLMLite,WiFiAgent,PSM,WebPAAgent middleware;\n    class WiFiHAL,EthHAL,MoCAHAL hal;\n    class LinuxKernel,NetlinkSockets,ProcFS,DeviceDrivers platform;\n    class WiFiChipset,EthController,MoCAController hardware;</code></pre>"},{"location":"review/LMLite/#ipc-mechanism","title":"IPC Mechanism","text":"Type of IPC Message Format Mechanism DBus Inter-Component Communication XML-based parameter structure with CCSP-specific headers including component name, method calls, and parameter arrays DBus method calls with CCSP message bus integration for TR-181 parameter operations RBus Event Publishing Binary serialized event data with topic-based routing containing device status, traffic statistics, and presence notifications RBus publish/subscribe pattern with structured data types and filtering WebPA Message Queue JSON and Avro binary formats for telemetry data including device status reports, traffic counters, and network topology information HTTP POST to WebPA agent with message queuing for reliable cloud delivery Unix Domain Sockets Custom binary protocol for local LM API communication including device queries, configuration updates, and status requests Unix socket server (/tmp/lm.sock) with request/response pattern <pre><code>sequenceDiagram\n    participant Client as External Client\n    participant DBus as DBus Message Bus\n    participant LMLite as CcspLMLite\n    participant RBus as RBus Event System\n    participant WebPA as WebPA Agent\n    participant Cloud as Cloud Analytics\n\n    Note over Client, Cloud: TR-181 Parameter Request Flow\n    Client-&gt;&gt;DBus: GetParameterValues(Device.Hosts.Host.1.Active)\n    DBus-&gt;&gt;LMLite: CCSP_MESSAGE_BUS_GET\n    LMLite-&gt;&gt;DBus: Parameter Value Response\n    DBus--&gt;&gt;Client: TR-181 Response\n\n    Note over LMLite, Cloud: Device Status Event Flow\n    LMLite-&gt;&gt;RBus: rbusEvent_Publish(DeviceStatusEvent)\n    RBus-&gt;&gt;WebPA: Event Subscription Delivery\n\n    Note over LMLite, Cloud: Telemetry Data Flow  \n    LMLite-&gt;&gt;WebPA: HTTP POST /api/v1/device (Avro payload)\n    WebPA-&gt;&gt;Cloud: HTTPS Upload (Compressed data)\n    Cloud--&gt;&gt;WebPA: ACK Response\n    WebPA--&gt;&gt;LMLite: Upload Status\n\n    Note over LMLite, LMLite: Internal API Communication\n    LMLite-&gt;&gt;LMLite: Unix Socket /tmp/lm.sock\n    Note right of LMLite: Local API for device queries&lt;br/&gt;and configuration updates</code></pre>"},{"location":"review/LMLite/#tr181-data-models","title":"TR\u2011181 Data Models","text":"<ul> <li>Implemented Parameters: CcspLMLite implements the Device.Hosts object hierarchy including Host table entries, device enumeration parameters, presence detection controls, and RDK-specific extensions for enhanced network management functionality. Parameters include device identification, network interface associations, traffic statistics, and vendor-specific device classification.</li> <li>Parameter Registration: Parameters are registered through CCSP message bus integration using XML-based data model definitions from LMLite.XML configuration file. Access control is managed through TR-181 parameter permissions with read-only and read-write designations based on security requirements.</li> <li>Custom Extensions: X_CISCO_COM device type classification for enhanced device identification, X_RDKCENTRAL-COM presence detection controls for configurable monitoring, X_RDK presence notification system for real-time alerts, and traffic counting extensions for bandwidth management and analytics.</li> </ul> Parameter Description Access (R/W) Default Notes <code>Device.Hosts.HostNumberOfEntries</code> Total number of discovered devices R <code>0</code> Dynamic count <code>Device.Hosts.Host.{i}.PhysAddress</code> Device MAC address R <code>\"\"</code> Unique identifier <code>Device.Hosts.Host.{i}.IPAddress</code> Current IP address assignment R <code>\"\"</code> DHCP or static <code>Device.Hosts.Host.{i}.Active</code> Device presence status R <code>false</code> Presence detection <code>Device.Hosts.Host.{i}.DHCPClient</code> DHCP client identifier R <code>\"\"</code> DHCP integration <code>Device.Hosts.Host.{i}.AssociatedDevice</code> Associated interface reference R <code>\"\"</code> Interface mapping <code>Device.Hosts.Host.{i}.Layer1Interface</code> Physical interface reference R <code>\"\"</code> Layer 1 association <code>Device.Hosts.Host.{i}.Layer3Interface</code> Network interface reference R <code>\"\"</code> Layer 3 association <code>Device.Hosts.Host.{i}.HostName</code> Device hostname R <code>\"\"</code> DNS/DHCP name <code>Device.Hosts.Host.{i}.X_CISCO_COM_DeviceType</code> Device classification R <code>1</code> Custom device type <code>Device.Hosts.Host.{i}.X_CISCO_COM_NetworkInterface</code> Network interface type R <code>\"\"</code> WiFi/Ethernet/MoCA <code>Device.Hosts.Host.{i}.X_CISCO_COM_ConnectionStatus</code> Connection status details R <code>\"\"</code> Extended status <code>Device.Hosts.Host.{i}.X_CISCO_COM_ActiveTime</code> Active connection duration R <code>0</code> Time tracking <code>Device.Hosts.Host.{i}.X_CISCO_COM_InactiveTime</code> Inactive duration R <code>0</code> Presence monitoring <code>Device.Hosts.Host.{i}.X_CISCO_COM_RSSI</code> WiFi signal strength R <code>0</code> WiFi devices only <code>Device.Hosts.X_CISCO_COM_ConnectedDeviceNumber</code> Total connected devices R <code>0</code> Device count <code>Device.Hosts.X_CISCO_COM_ConnectedWiFiNumber</code> WiFi device count R <code>0</code> WiFi-specific count <code>Device.Hosts.X_RDKCENTRAL-COM_HostVersionId</code> Host table version R <code>0</code> Change tracking <code>Device.Hosts.X_RDKCENTRAL-COM_HostCountPeriod</code> Polling interval R/W <code>10</code> Seconds <code>Device.Hosts.X_RDK_PresenceDetectEnable</code> Presence detection enable R/W <code>true</code> Feature control <code>Device.Hosts.X_RDKCENTRAL-COM_WebPA_PresenceNotificationEnable</code> WebPA notifications R/W <code>false</code> Cloud notifications <code>Device.Hosts.X_RDKCENTRAL-COM_AddPresenceNotificationMac</code> Add MAC to monitoring W <code>\"\"</code> Notification list <code>Device.Hosts.X_RDKCENTRAL-COM_DeletePresenceNotificationMac</code> Remove MAC from monitoring W <code>\"\"</code> Notification list <code>Device.X_RDK_NetworkDevicesStatus.ReportingPeriod</code> Status reporting interval R/W <code>900</code> Telemetry timing <code>Device.X_RDK_NetworkDevicesStatus.Enabled</code> Status harvesting enable R/W <code>false</code> Feature control <code>Device.X_RDK_NetworkDevicesTraffic.ReportingPeriod</code> Traffic reporting interval R/W <code>900</code> Telemetry timing <code>Device.X_RDK_NetworkDevicesTraffic.Enabled</code> Traffic harvesting enable R/W <code>false</code> Feature control"},{"location":"review/LMLite/#implementation-details","title":"Implementation Details","text":"<ul> <li> <p>Key Algorithms or Logic: Device discovery uses ARP table monitoring combined with network interface scanning to detect new device connections (<code>lm_wrapper.c</code>, <code>network_devices_interface.c</code>). Presence detection implements a dual-mode algorithm using IPv4/IPv6 ping with configurable retry counts and timeout intervals (<code>device_presence_detection.c</code>). Traffic monitoring utilizes netlink socket integration to capture per-device bandwidth statistics with aggregation logic for WAN interface monitoring (<code>cosa_wantraffic_utils.c</code>). State machine management for device lifecycle transitions between connected/disconnected/active/inactive states with hysteresis to prevent flapping (<code>lm_main.c</code>).</p> </li> <li> <p>Error Handling Strategy: Comprehensive error detection includes network interface failure recovery, CCSP message bus reconnection logic, and graceful degradation when HAL components are unavailable. Errors are categorized by severity with different response strategies: critical errors trigger component restart, warning conditions enable fallback modes, and informational errors continue with limited functionality. All error conditions are logged with structured information including error codes, component context, and recovery actions taken.</p> </li> <li> <p>Logging &amp; Debugging: Multi-level logging system with categories for device discovery (LM), presence detection (PD), traffic monitoring (TM), and telemetry (TEL). Verbosity levels include ERROR, WARN, INFO, and DEBUG with runtime configuration through TR-181 parameters. Debug tools include device table dumps, presence detection state visualization, traffic statistics reporting, and message bus transaction logging. Performance metrics tracking for polling intervals, response times, and memory utilization with configurable thresholds for system monitoring.</p> </li> </ul>"},{"location":"review/LMLite/#key-configuration-files","title":"Key Configuration Files","text":"<p>CcspLMLite relies on several configuration files to define its behavior, TR-181 parameter structure, and telemetry data schemas. These configuration files control everything from data model definitions to serialization formats for cloud analytics.</p> Configuration File Purpose Key Parameters Default Values Override Mechanisms <code>config/LMLite.XML</code> TR-181 data model definition Object hierarchy, parameter types, access permissions, DML function mappings Device.Hosts.* parameters, read/write permissions Environment variables, build-time configuration <code>config/NetworkDevicesStatus.avsc</code> Avro schema for device status telemetry Device status fields, data types, serialization structure Device count, interface statistics, presence data Schema versioning, runtime validation <code>config/NetworkDevicesTraffic.avsc</code> Avro schema for traffic telemetry Traffic counters, bandwidth metrics, per-device statistics TX/RX bytes, packet counts, interface mapping Schema versioning, cloud compatibility <code>/etc/ccsp/lm.cfg</code> Runtime configuration parameters Polling intervals, presence detection timeouts, device limits 10s polling, 3 retries, 256 max devices TR-181 parameter override, CLI configuration <code>/tmp/lm.sock</code> Unix domain socket configuration Socket permissions, buffer sizes, connection limits 755 permissions, 4KB buffer, unlimited connections System configuration, security policies"},{"location":"review/OneWifi/","title":"OneWifi Documentation","text":"<p>OneWifi is a unified component for managing Wi-Fi parameters, statistics, telemetry, steering and optimization in the RDK-B ecosystem. It provides a comprehensive solution capable of running on both Gateways and Extenders, centralizing Wi-Fi management across diverse hardware platforms. The component serves as the primary interface between the RDK-B middleware stack and the underlying Wi-Fi Hardware Abstraction Layer (HAL), implementing TR-181 data models for standardized device management. OneWifi integrates with other RDK-B components through DBus and RBus communication mechanisms, providing configuration management, telemetry collection, and real-time optimization services. It supports advanced Wi-Fi features including EasyMesh, band steering, client management, and security protocols while maintaining backward compatibility with existing RDK-B deployments.</p> <pre><code>graph TD\n    subgraph \"RDK-B Ecosystem\"\n        User[Network Administrator/CPE Management]\n        WebPA[WebPA/TR-069 ACS]\n        TelemetryAgent[Telemetry Agent]\n        CcspPAM[CCSP PAM]\n    end\n\n    subgraph \"OneWifi System Context\"\n        OneWifi[ OneWifi Manager]\n    end\n\n    subgraph \"Platform Layer\"\n        WiFiHAL[ WiFi HAL]\n        OVSDB[( OVSDB)]\n        PSM[( PSM Database)]\n    end\n\n    subgraph \"External Systems\"\n        Cloud[ Cloud Analytics]\n        EasyMesh[ EasyMesh Controller]\n    end\n\n    User --&gt;|TR-181 Commands| WebPA\n    WebPA --&gt;|DBus/RBus| OneWifi\n    TelemetryAgent --&gt;|Statistics Request| OneWifi\n    CcspPAM --&gt;|Configuration| OneWifi\n\n    OneWifi --&gt;|HAL API Calls| WiFiHAL\n    OneWifi --&gt;|Config Storage| OVSDB\n    OneWifi --&gt;|Parameter Storage| PSM\n    OneWifi --&gt;|Telemetry Data| Cloud\n    OneWifi --&gt;|Mesh Commands| EasyMesh\n\n    classDef user fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n    classDef component fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef external fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n\n    class User,WebPA,TelemetryAgent,CcspPAM user;\n    class OneWifi component;\n    class Cloud,EasyMesh,WiFiHAL,OVSDB,PSM external;</code></pre> <p>Key Features &amp; Responsibilities</p> <ul> <li>Unified Wi-Fi Configuration Management: Centralizes all Wi-Fi parameter configuration including radio settings, SSID management, security protocols, and access point configurations across multiple interfaces and bands</li> <li>Real-time Telemetry and Statistics Collection: Aggregates comprehensive Wi-Fi statistics including client connection data, radio performance metrics, traffic analysis, and network health indicators for cloud analytics and local monitoring</li> <li>EasyMesh Support and Mesh Management: Implements IEEE 1905.1 EasyMesh standard for seamless mesh network deployment, including controller and agent functionality for multi-AP coordination</li> <li>Advanced Security and Client Management: Provides comprehensive security features including WPA3, 802.1X authentication, client steering, band steering, and access control list management </li> <li>Multi-platform Hardware Abstraction: Abstracts underlying Wi-Fi hardware differences through standardized HAL interface, supporting various chipset vendors and platform configurations </li> <li>TR-181 Data Model Implementation: Complete implementation of TR-181 WiFi data model with custom RDK extensions for standardized device management and remote configuration </li> </ul>"},{"location":"review/OneWifi/#design","title":"Design","text":"<p>OneWifi follows a layered, modular architecture that separates concerns between configuration management, data processing, and hardware abstraction. The design emphasizes scalability through service-oriented architecture where different Wi-Fi services (private, public, mesh, managed) can be dynamically loaded and configured based on deployment requirements. Reliability is ensured through robust error handling, state machine implementations, and comprehensive logging across all modules. Security is built-in at every layer with encrypted communication channels, secure credential storage, and comprehensive access control mechanisms. The component maintains clear boundaries with other RDK-B middleware through well-defined IPC interfaces, primarily using DBus and RBus for inter-component communication. Maintainability is achieved through consistent coding standards, comprehensive documentation, and modular design that allows independent updates of individual services without affecting the entire system.</p> <p>A container diagram of the component is given below</p> <pre><code>graph TD\n    subgraph Runtime [\"Linux Runtime\"]\n        subgraph OneWifiContainer [\"OneWifi Container Process\"]\n            WifiMgr[ WiFi Manager&lt;br/&gt;Core orchestration and state management]\n            WifiCtrl[ WiFi Controller&lt;br/&gt;Configuration and policy enforcement]\n            WifiDML[ Data Model Layer&lt;br/&gt;TR-181 parameter handling]\n            ServicesMgr[ Services Manager&lt;br/&gt;Dynamic service lifecycle management]\n            StatsMgr[ Statistics Manager&lt;br/&gt;Telemetry collection and processing]\n            WebConfigMgr[ WebConfig Manager&lt;br/&gt;Cloud configuration synchronization]\n        end\n        subgraph DatabaseLayer [\"Storage Layer\"]\n            OVSDB[( OVSDB&lt;br/&gt;Runtime configuration)]\n            PSM[( PSM DB&lt;br/&gt;Persistent parameters)]\n        end\n        subgraph HALLayer [\"Hardware Abstraction\"]\n            WiFiHAL[ WiFi HAL&lt;br/&gt;Hardware interface]\n        end\n    end\n\n    WifiMgr --&gt;|Control Commands| WifiCtrl\n    WifiMgr --&gt;|Parameter Access| WifiDML\n    WifiMgr --&gt;|Service Lifecycle| ServicesMgr\n    WifiMgr --&gt;|Statistics Request| StatsMgr\n    WifiMgr --&gt;|Config Sync| WebConfigMgr\n\n    WifiCtrl --&gt;|HAL API Calls| WiFiHAL\n    WifiDML --&gt;|Parameter Storage| PSM\n    ServicesMgr --&gt;|Runtime Config| OVSDB\n    StatsMgr --&gt;|Hardware Stats| WiFiHAL\n    WebConfigMgr --&gt;|Config Persistence| OVSDB\n\n    classDef manager fill:#e3f2fd,stroke:#1976d2,stroke-width:2px;\n    classDef storage fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;\n    classDef hal fill:#e8f5e8,stroke:#388e3c,stroke-width:2px;\n\n    class WifiMgr,WifiCtrl,WifiDML,ServicesMgr,StatsMgr,WebConfigMgr manager;\n    class OVSDB,PSM storage;\n    class WiFiHAL hal;</code></pre> <p>Request Flow Sequence</p> <p>The most critical flow in OneWifi is the TR-181 parameter configuration request from external management systems. When a configuration change arrives via WebPA or TR-069, it follows a structured validation and application process through multiple layers.</p> <pre><code>sequenceDiagram\n    participant ACS as TR-069 ACS/WebPA\n    participant Bus as DBus/RBus\n    participant WifiMgr as WiFi Manager\n    participant WifiDML as Data Model Layer\n    participant WifiCtrl as WiFi Controller\n    participant PSM as PSM Database\n    participant HAL as WiFi HAL\n    participant Hardware as WiFi Hardware\n\n    ACS-&gt;&gt;Bus: SetParameterValue(Device.WiFi.Radio.1.Channel, \"6\")\n    Bus-&gt;&gt;WifiMgr: Parameter Set Request\n    WifiMgr-&gt;&gt;WifiDML: Validate Parameter\n    WifiDML-&gt;&gt;WifiDML: Schema Validation\n    WifiDML-&gt;&gt;PSM: Store Parameter\n    PSM--&gt;&gt;WifiDML: Store Confirmation\n    WifiDML-&gt;&gt;WifiCtrl: Apply Configuration\n    WifiCtrl-&gt;&gt;WifiCtrl: Policy Validation\n    WifiCtrl-&gt;&gt;HAL: wifi_setRadioChannel(1, 6)\n    HAL-&gt;&gt;Hardware: Hardware Configuration\n    Hardware--&gt;&gt;HAL: Success/Failure\n    HAL--&gt;&gt;WifiCtrl: Result\n    WifiCtrl--&gt;&gt;WifiDML: Apply Result\n    WifiDML--&gt;&gt;WifiMgr: Configuration Status\n    WifiMgr--&gt;&gt;Bus: Response\n    Bus--&gt;&gt;ACS: SetParameterResponse</code></pre> <p>Threading Model</p> <p>The OneWifi component uses a hybrid threading model with the following thread responsibilities:</p> <ul> <li>Main Thread: Runs an event loop to process messages from DBus/RBus interfaces and internal component communications</li> <li>Dedicated Worker Threads: Spawned for CPU-intensive tasks such as statistics collection, telemetry processing, and hardware polling</li> <li>Statistics Manager Threads: Periodically collect data from the WiFi HAL and process it for telemetry reporting</li> <li>WebConfig Synchronization Thread: Handles cloud communication and configuration sync without blocking the main control flow</li> <li>Thread Synchronization: Managed using pthread mutexes and condition variables; <code>data_cache_lock</code> protects shared configuration data, while individual module locks prevent race conditions during concurrent operations</li> </ul>"},{"location":"review/OneWifi/#internal-modules","title":"Internal Modules","text":"<p>OneWifi is organized into several key modules that handle different aspects of Wi-Fi management. The WiFi Manager serves as the central orchestrator, coordinating between all other modules and maintaining overall system state. The Data Model Layer (DML) handles TR-181 parameter processing and validation, receiving configuration requests from external systems. The WiFi Controller manages policy enforcement and hardware configuration, translating high-level configuration into hardware-specific commands. The Services Manager provides dynamic loading and management of different Wi-Fi service types including private networks, public hotspots, and mesh services. The Statistics Manager collects and processes telemetry data from hardware and other modules for reporting to cloud analytics platforms.</p> Module/Class Description Key Files WiFi Manager Central orchestration engine managing overall system state and inter-module coordination <code>wifi_mgr.c</code>, <code>wifi_mgr.h</code> WiFi Controller Policy enforcement and hardware configuration management with queue-based message processing <code>wifi_ctrl.c</code>, <code>wifi_ctrl.h</code>, <code>wifi_ctrl_queue_handlers.c</code> Data Model Layer TR-181 parameter handling, validation, and persistence management <code>dml/tr_181/</code>, <code>wifi_dml.h</code> Services Manager Dynamic Wi-Fi service lifecycle management for private, public, mesh, and managed services <code>services/wifi_services_mgr.c</code>, <code>services/wifi_services_mgr.h</code> Statistics Manager Telemetry collection, processing, and reporting for cloud analytics <code>stats/wifi_monitor.c</code>, <code>stats/</code> WebConfig Manager Cloud configuration synchronization and multi-document WebConfig support <code>webconfig/</code>, <code>wifi_multidoc_webconfig.c</code> Database Layer Configuration and runtime data persistence through OVSDB and PSM interfaces <code>db/wifi_db_apis.c</code>, <code>db/</code> Platform Abstraction Hardware and platform-specific adaptations for different RDK-B deployments <code>platform/</code>, <code>stubs/</code> <pre><code>flowchart TD\n    subgraph OneWifi [\"OneWifi Architecture\"]\n        subgraph Core [\"Core Layer\"]\n            WifiMgr([WiFi Manager&lt;br/&gt;Central Orchestration])\n            WifiCtrl([WiFi Controller&lt;br/&gt;Policy &amp; Hardware Config])\n            WifiDML([Data Model Layer&lt;br/&gt;TR-181 Processing])\n        end\n\n        subgraph Services [\"Services Layer\"]\n            ServicesMgr([Services Manager&lt;br/&gt;Service Lifecycle])\n            PrivateService([Private Network Service])\n            PublicService([Public Hotspot Service])\n            MeshService([EasyMesh Service])\n        end\n\n        subgraph Data [\"Data &amp; Analytics Layer\"]\n            StatsMgr([Statistics Manager&lt;br/&gt;Telemetry Collection])\n            WebConfigMgr([WebConfig Manager&lt;br/&gt;Cloud Sync])\n            DBLayer([Database Layer&lt;br/&gt;Persistence])\n        end\n\n        subgraph Platform [\"Platform Layer\"]\n            PlatformAbs([Platform Abstraction])\n            HALInterface([HAL Interface])\n        end\n    end\n\n    WifiMgr --&gt; WifiCtrl\n    WifiMgr --&gt; WifiDML\n    WifiMgr --&gt; ServicesMgr\n    WifiMgr --&gt; StatsMgr\n    WifiMgr --&gt; WebConfigMgr\n\n    ServicesMgr --&gt; PrivateService\n    ServicesMgr --&gt; PublicService\n    ServicesMgr --&gt; MeshService\n\n    WifiCtrl --&gt; HALInterface\n    WifiDML --&gt; DBLayer\n    StatsMgr --&gt; HALInterface\n    WebConfigMgr --&gt; DBLayer\n\n    HALInterface --&gt; PlatformAbs\n\n    classDef core fill:#e3f2fd,stroke:#1976d2,stroke-width:2px;\n    classDef services fill:#fff3e0,stroke:#f57c00,stroke-width:2px;\n    classDef data fill:#e8f5e8,stroke:#388e3c,stroke-width:2px;\n    classDef platform fill:#fce4ec,stroke:#c2185b,stroke-width:2px;\n\n    class WifiMgr,WifiCtrl,WifiDML core;\n    class ServicesMgr,PrivateService,PublicService,MeshService services;\n    class StatsMgr,WebConfigMgr,DBLayer data;\n    class PlatformAbs,HALInterface platform;</code></pre>"},{"location":"review/OneWifi/#interaction-with-other-middleware-components","title":"Interaction with Other Middleware Components","text":"<p>OneWifi integrates extensively with the RDK-B middleware ecosystem through well-defined interfaces and communication protocols. It receives configuration commands from CCSP PAM (Platform and Application Manager) via DBus, processes TR-181 parameter requests from WebPA for remote device management, and provides telemetry data to the Telemetry Agent for cloud analytics. The component also interacts with PSM (Persistent Storage Manager) for parameter persistence and OVSDB for runtime configuration storage.</p> <pre><code>flowchart LR\n    OneWifi[OneWifi Manager] \n\n    OneWifi --&gt;|DBus TR-181 Parameters| CcspPAM[CCSP PAM]\n    OneWifi --&gt;|RBus Events &amp; Statistics| TelemetryAgent[Telemetry Agent]\n    OneWifi --&gt;|DBus Configuration| WebPA[WebPA]\n    OneWifi --&gt;|Parameter Storage| PSM[PSM]\n    OneWifi --&gt;|Runtime Config| OVSDB[(OVSDB)]\n    OneWifi --&gt;|Mesh Coordination| CcspMesh[CCSP Mesh Agent]\n    OneWifi --&gt;|System Events| SystemD[SystemD]\n    OneWifi --&gt;|Log Management| RdkLogger[RDK Logger]\n\n    classDef onewifi fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef rdkb fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n    classDef storage fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;\n    classDef system fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n\n    class OneWifi onewifi;\n    class CcspPAM,TelemetryAgent,WebPA,CcspMesh rdkb;\n    class PSM,OVSDB storage;\n    class SystemD,RdkLogger system;</code></pre> Component Purpose of Interaction Protocols/Mechanisms CCSP PAM Device configuration management and TR-181 parameter coordination DBus method calls and property access Telemetry Agent WiFi statistics and performance metrics reporting for cloud analytics RBus events and data publishing WebPA Remote device management and cloud-based configuration updates DBus parameter get/set operations PSM (Persistent Storage Manager) Long-term storage of WiFi configuration parameters and device settings Direct API calls for parameter persistence OVSDB Runtime configuration database for OpenFlow and networking state management OVSDB client API and JSON-RPC protocol CCSP Mesh Agent EasyMesh coordination and multi-AP network management DBus messaging for mesh topology updates SystemD Service lifecycle management and system integration SystemD service notifications and dependencies RDK Logger Centralized logging and debug information management Logging API calls with categorized log levels <p>OneWifi publishes several key events to notify other components of important state changes and operational events. These events support the broader RDK-B ecosystem's need for real-time awareness of WiFi network status and performance.</p> Event Purpose of Event Reason for trigger WiFi.Radio.StatusChange Notify radio state transitions (up/down/scanning) Radio enable/disable, channel changes, or hardware failures WiFi.AccessPoint.ClientConnect Signal new client associations to access points Client device successfully authenticates and associates WiFi.AccessPoint.ClientDisconnect Signal client disconnections from access points Client device disconnects, timeout, or security violation WiFi.Statistics.Update Periodic statistics data for telemetry collection Scheduled telemetry intervals or significant metric changes WiFi.Configuration.Applied Confirm successful configuration changes TR-181 parameter updates successfully applied to hardware WiFi.EasyMesh.TopologyChange Mesh network topology updates New mesh nodes join/leave or link quality changes WiFi.Security.Violation Security-related events and policy violations Authentication failures, intrusion attempts, or policy breaches"},{"location":"review/OneWifi/#interaction-with-other-layers","title":"Interaction with Other Layers","text":"<p>OneWifi interacts with multiple layers in the RDK-B software stack, providing abstraction between high-level management interfaces and low-level hardware control. At the HAL layer, it communicates with the WiFi Hardware Abstraction Layer to control radio parameters, manage client connections, and retrieve hardware statistics. Platform-specific interactions include integration with OpenWrt build systems, systemd service management, and platform-specific configuration files. External service interactions encompass cloud analytics platforms for telemetry reporting, EasyMesh controllers for multi-AP coordination, and remote management systems through TR-069/WebPA protocols.</p> Layer/Service Interaction Description Mechanism WiFi HAL Hardware control for radio configuration, client management, and statistics collection Direct C API function calls (wifi_setRadioChannel, wifi_getStats, etc.) Platform Services Integration with systemd, OpenWrt build system, and platform-specific configurations SystemD service files, platform-specific makefiles, and configuration scripts OVSDB Platform OpenFlow database integration for software-defined networking features OVSDB client library with JSON-RPC protocol over Unix sockets Cloud Analytics Telemetry data upload and cloud-based WiFi optimization recommendations HTTPS POST requests with JSON payloads to cloud endpoints EasyMesh External Controllers Multi-AP coordination with external mesh controllers IEEE 1905.1 protocol over Ethernet with TLV message format TR-069/WebPA ACS Remote device management and configuration from service provider systems SOAP/HTTP for TR-069, HTTP/JSON for WebPA with TLS encryption <pre><code>graph TD\n    subgraph \"Application Layer\"\n        WebUI[Web Management UI]\n        MobileApp[Mobile Apps]\n        CloudPortal[Service Provider Portal]\n    end\n\n    subgraph \"Management Layer\"\n        TR069[TR-069 ACS]\n        WebPA[WebPA]\n        CcspPAM[CCSP PAM]\n    end\n\n    subgraph \"OneWifi Component Layer\"\n        OneWifi[OneWifi Manager]\n    end\n\n    subgraph \"Platform Layer\"\n        OVSDB[(OVSDB)]\n        PSM[(PSM)]\n        SystemD[SystemD]\n        RdkLogger[RDK Logger]\n    end\n\n    subgraph \"HAL Layer\"\n        WiFiHAL[WiFi HAL]\n        NetworkHAL[Network HAL]\n    end\n\n    subgraph \"Hardware Layer\"\n        WiFiChipset[WiFi Chipset]\n        NetworkHW[Network Hardware]\n    end\n\n    WebUI --&gt; TR069\n    MobileApp --&gt; WebPA\n    CloudPortal --&gt; TR069\n\n    TR069 --&gt; CcspPAM\n    WebPA --&gt; CcspPAM\n    CcspPAM --&gt; OneWifi\n\n    OneWifi --&gt; PSM\n    OneWifi --&gt; OVSDB\n    OneWifi --&gt; SystemD\n    OneWifi --&gt; RdkLogger\n\n    OneWifi --&gt; WiFiHAL\n    OneWifi --&gt; NetworkHAL\n\n    WiFiHAL --&gt; WiFiChipset\n    NetworkHAL --&gt; NetworkHW\n\n    classDef app fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n    classDef mgmt fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n    classDef component fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef platform fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;\n    classDef hal fill:#fce4ec,stroke:#c2185b,stroke-width:2px;\n    classDef hw fill:#f1f8e9,stroke:#689f38,stroke-width:2px;\n\n    class WebUI,MobileApp,CloudPortal app;\n    class TR069,WebPA,CcspPAM mgmt;\n    class OneWifi component;\n    class OVSDB,PSM,SystemD,RdkLogger platform;\n    class WiFiHAL,NetworkHAL hal;\n    class WiFiChipset,NetworkHW hw;</code></pre>"},{"location":"review/OneWifi/#ipc-mechanism","title":"IPC Mechanism","text":"<p>OneWifi utilizes multiple IPC mechanisms to communicate with different components in the RDK-B ecosystem, with the choice of mechanism optimized for each specific interaction pattern and performance requirement.</p> Type of IPC Message Format Mechanism DBus XML-based message format with method calls, signals, and properties following DBus specification Used for TR-181 parameter access, CCSP component integration, and legacy RDK-B middleware communication RBus JSON-based lightweight messaging with event subscription and property notification Modern RDK-B communication for telemetry events, statistics publishing, and real-time notifications Unix Domain Sockets Binary protocol with custom message headers containing type, length, and payload data High-performance communication with OVSDB and direct HAL interactions requiring low latency Shared Memory Structured data formats with semaphore-based synchronization for concurrent access Large data transfers like statistics buffers and configuration caches between processes Message Queues Priority-based message queuing with typed messages for asynchronous processing Internal component communication for configuration requests and event processing <pre><code>sequenceDiagram\n    participant WebPA as WebPA Client\n    participant DBus as DBus Daemon  \n    participant OneWifi as OneWifi Manager\n    participant RBus as RBus Broker\n    participant TelemetryAgent as Telemetry Agent\n    participant OVSDB as OVSDB Server\n    participant HAL as WiFi HAL\n\n    Note over WebPA,HAL: Configuration Request Flow\n    WebPA-&gt;&gt;DBus: SetParameterValue(Device.WiFi.Radio.1.Enable, true)\n    DBus-&gt;&gt;OneWifi: Method Call with XML payload\n    OneWifi-&gt;&gt;OneWifi: Process &amp; Validate Configuration\n    OneWifi-&gt;&gt;HAL: wifi_setRadioEnable(1, true) via direct API\n    HAL--&gt;&gt;OneWifi: Success/Error Response\n    OneWifi-&gt;&gt;DBus: Method Response (XML)\n    DBus--&gt;&gt;WebPA: SetParameterResponse\n\n    Note over OneWifi,TelemetryAgent: Event Publishing Flow  \n    OneWifi-&gt;&gt;RBus: PublishEvent(\"WiFi.Radio.StatusChange\") with JSON data\n    RBus-&gt;&gt;TelemetryAgent: Event Notification (JSON)\n\n    Note over OneWifi,OVSDB: Configuration Storage Flow\n    OneWifi-&gt;&gt;OVSDB: JSON-RPC Insert/Update via Unix Socket\n    OVSDB--&gt;&gt;OneWifi: Transaction Result (JSON-RPC)</code></pre>"},{"location":"review/OneWifi/#tr181-data-models","title":"TR\u2011181 Data Models","text":"<p>OneWifi implements comprehensive TR-181 WiFi data model support with both standard parameters and RDK-specific extensions. Parameters are registered through the CCSP framework using DBus interfaces, with runtime parameter access handled through the Data Model Layer (DML). The component supports both read-only status parameters and read-write configuration parameters, with automatic validation and persistence through PSM. Custom extensions provide additional functionality specific to RDK-B deployments including advanced statistics, mesh management, and cloud integration features.</p> Parameter Description Access (R/W) Default Notes <code>Device.WiFi.RadioNumberOfEntries</code> Number of WiFi radio interfaces R Detected from HAL Standard TR-181 <code>Device.WiFi.Radio.{i}.Enable</code> Enable/disable radio interface R/W <code>true</code> Standard TR-181 <code>Device.WiFi.Radio.{i}.Channel</code> Operating channel number R/W <code>Auto</code> Standard TR-181 <code>Device.WiFi.Radio.{i}.TransmitPower</code> Transmission power percentage R/W <code>100</code> Standard TR-181 <code>Device.WiFi.SSID.{i}.SSID</code> Service Set Identifier name R/W <code>RDK-WiFi</code> Standard TR-181 <code>Device.WiFi.AccessPoint.{i}.Enable</code> Enable/disable access point R/W <code>false</code> Standard TR-181 <code>Device.WiFi.AccessPoint.{i}.Security.ModeEnabled</code> Security mode (None/WEP/WPA/WPA2/WPA3) R/W <code>WPA2-Personal</code> Standard TR-181 <code>Device.WiFi.X_RDKCENTRAL-COM_vAPStatsEnable</code> Enable per-vAP statistics collection R/W <code>false</code> RDK Extension <code>Device.WiFi.X_COMCAST-COM_MacFilter</code> MAC address filtering configuration R/W <code>Disabled</code> Custom Extension <code>Device.WiFi.X_RDKCENTRAL-COM_BandSteering.Enable</code> Enable band steering functionality R/W <code>false</code> RDK Extension <code>Device.WiFi.X_RDKCENTRAL-COM_PreferPrivate</code> Prefer private over public networks R/W <code>true</code> RDK Extension <code>Device.WiFi.Radio.{i}.Stats.BytesSent</code> Total bytes transmitted R <code>0</code> Standard TR-181 <code>Device.WiFi.Radio.{i}.X_COMCAST-COM_RadioStatisticsMeasuringRate</code> Statistics collection interval R/W <code>15</code> Custom Extension <p>Parameter Registration: Parameters are registered during OneWifi initialization through the CCSP Data Model Library (CcspDmLib). The registration process uses XML configuration files (<code>TR181-WiFi-USGv2.XML</code>) to define parameter schemas, access permissions, and callback functions. Runtime parameter access is handled through DBus method calls that route to specific getter/setter functions in the DML layer.</p> <p>Custom Extensions: OneWifi implements several custom TR-181 parameter namespaces to support RDK-specific functionality. The <code>X_RDKCENTRAL-COM</code> namespace provides advanced telemetry controls, mesh management parameters, and cloud integration settings. The <code>X_COMCAST-COM</code> namespace includes service provider-specific features like advanced statistics collection rates and custom security policies. These extensions maintain backward compatibility while enabling advanced deployment scenarios.</p>"},{"location":"review/OneWifi/#implementation-details","title":"Implementation Details","text":"<ul> <li> <p>Key Algorithms or Logic: OneWifi implements several critical algorithms for WiFi optimization and management. The band steering algorithm in <code>wifi_ctrl.c</code> uses RSSI thresholds and client capability detection to intelligently move dual-band clients to optimal frequency bands, reducing congestion on 2.4GHz while maximizing 5GHz utilization. The channel selection algorithm analyzes interference patterns, DFS requirements, and regulatory constraints to automatically select optimal channels during startup and dynamic optimization events. Client load balancing logic distributes new client associations across multiple access points in mesh deployments, considering factors like signal strength, current load, and backhaul capacity. The statistics aggregation engine in <code>wifi_monitor.c</code> implements time-series data collection with configurable sampling rates and intelligent data compression to minimize storage and transmission overhead.</p> </li> <li> <p>Error Handling Strategy: OneWifi employs a multi-layered error handling approach with graceful degradation capabilities. Hardware errors from the WiFi HAL are logged with detailed context and trigger automatic recovery procedures including radio resets and configuration reapplication. Configuration validation occurs at multiple levels - schema validation in the DML layer, policy validation in the controller, and hardware capability validation before HAL calls. IPC communication failures implement retry mechanisms with exponential backoff and alternative communication paths where available. Resource exhaustion is handled through memory monitoring, connection limits, and emergency cleanup procedures that maintain core functionality even under stress conditions.</p> </li> <li> <p>Logging &amp; Debugging: OneWifi integrates with the RDK Logger framework providing categorized logging across multiple verbosity levels. DEBUG level captures detailed parameter validation, state transitions, and inter-module communications for development troubleshooting. INFO level logs configuration changes, client connection events, and operational status updates for normal monitoring. ERROR level records failures, security violations, and critical system events requiring immediate attention. TRACE level provides detailed function entry/exit information and variable dumps for deep debugging scenarios. Debug tools include runtime log level adjustment via TR-181 parameters, memory usage monitoring, and performance profiling hooks integrated with standard Linux debugging tools.</p> </li> </ul>"},{"location":"review/OneWifi/#key-configuration-files","title":"Key Configuration Files","text":"<p>OneWifi relies on several configuration files that define its behavior, parameter schemas, and operational characteristics across different deployment scenarios.</p> Configuration File Purpose Key Parameters Default Values Override Mechanisms <code>CcspWifi.cfg</code> CCSP component registration and DBus configuration <code>Component.ID</code>, <code>Component.DbusPath</code>, <code>DataModelXmlCfg</code> <code>com.cisco.spvtg.ccsp.wifi</code>, <code>/com/cisco/spvtg/ccsp/wifi</code> Environment variables, command line parameters <code>TR181-WiFi-USGv2.XML</code> TR-181 parameter schema definitions and callback mappings Parameter definitions, access permissions, validation rules Defined per parameter in XML schema Custom XML overlays, vendor-specific extensions <code>bus_dml_config.json</code> DBus and RBus interface mappings for data model access Bus interface names, method signatures, event subscriptions Standard RDK-B bus configuration JSON configuration overlays <code>rdkb-wifi.ovsschema</code> OVSDB schema for WiFi configuration and state management Table definitions, column types, constraint rules OVSDB standard schema with WiFi extensions Schema version upgrades, custom table additions <code>home.schema</code> and <code>private.schema</code> WiFi service configuration schemas for different network types Service type definitions, security policies, client limits Service-specific defaults WebConfig document updates <code>WifiSingleClient.avsc</code> Avro schema for single client telemetry data serialization Client metric definitions, data types, required fields Telemetry framework standards Schema evolution, version compatibility <code>EasymeshCfg.json</code> EasyMesh configuration including controller and agent settings Mesh roles, topology preferences, coordination protocols IEEE 1905.1 standard defaults Runtime mesh configuration updates"},{"location":"review/PPPManager/","title":"PPP Manager Documentation","text":"<p>PPP Manager is the middleware component in the RDK-B stack responsible for managing Point-to-Point Protocol (PPP) connections, including PPPoE (PPP over Ethernet) and PPPoA (PPP over ATM) interfaces. It handles PPP session establishment, authentication, network configuration, and connection monitoring for broadband WAN connections. The component provides a TR-181 compliant interface for configuration and monitoring while integrating with the CCSP framework for inter-component communication. It manages PPP daemon processes, processes connection events through IPC mechanisms, and maintains interface statistics and state information.</p> <pre><code>graph TD\n    subgraph \"External Systems\"\n        ISP[Internet Service Provider&lt;br/&gt;PPP Authentication &amp; Connectivity]\n        Management[Network Administrators&lt;br/&gt;Configuration &amp; Monitoring]\n        WebUI[Web Management Interface&lt;br/&gt;Device Configuration]\n    end\n\n    subgraph \"RDK-B Platform\"\n        PPPManager[PPP Manager&lt;br/&gt;PPP Interface Management&lt;br/&gt;&amp; TR-181 Implementation]\n    end\n\n    subgraph \"RDK-B Components\"\n        WANManager[WAN Manager&lt;br/&gt;WAN Policy &amp; Coordination]\n        PSM[PSM&lt;br/&gt;Persistent Storage Manager]\n        PAM[P&amp;M&lt;br/&gt;Platform &amp; Access Manager]\n        SNMP[SNMP Agent&lt;br/&gt;Network Management]\n        EventHandler[System Event Handler&lt;br/&gt;Event Broadcasting]\n    end\n\n    subgraph \"Platform Layer\"\n        CCSP[CCSP Framework&lt;br/&gt;Component Infrastructure]\n        HAL[Platform HAL&lt;br/&gt;Hardware Abstraction]\n        PPPDaemon[PPP Daemon&lt;br/&gt;Protocol Implementation]\n    end\n\n    subgraph \"Physical Layer\"\n        DSLModem[DSL/Cable Modem&lt;br/&gt;Physical Connection]\n        NetworkHW[Network Hardware&lt;br/&gt;Ethernet/ATM Interfaces]\n    end\n\n    %% External interactions\n    Management --&gt;|TR-181 Parameters| PPPManager\n    WebUI --&gt;|Configuration Requests| PPPManager\n    PPPManager --&gt;|PPP Authentication| ISP\n\n    %% RDK-B component interactions\n    PPPManager &lt;--&gt;|Interface Coordination| WANManager\n    PPPManager &lt;--&gt;|Configuration Storage| PSM\n    PPPManager &lt;--&gt;|Device Parameters| PAM\n    PPPManager --&gt;|Status Updates| SNMP\n    PPPManager --&gt;|Event Notifications| EventHandler\n\n    %% Platform interactions\n    PPPManager --&gt;|Component Communication| CCSP\n    PPPManager --&gt;|Hardware Control| HAL\n    PPPManager &lt;--&gt;|Protocol Control| PPPDaemon\n\n    %% Hardware interactions\n    PPPDaemon --&gt;|Physical Connection| DSLModem\n    HAL --&gt;|Interface Control| NetworkHW\n    DSLModem &lt;--&gt;|PPP Connection| ISP\n\n    classDef external fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n    classDef component fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef rdkb fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;\n    classDef platform fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n    classDef hardware fill:#fce4ec,stroke:#c2185b,stroke-width:2px;\n\n    class ISP,Management,WebUI external;\n    class PPPManager component;\n    class WANManager,PSM,PAM,SNMP,EventHandler rdkb;\n    class CCSP,HAL,PPPDaemon platform;\n    class DSLModem,NetworkHW hardware;</code></pre> <p>Key Features &amp; Responsibilities</p> <ul> <li>PPP Session Management: Handles establishment, maintenance, and teardown of PPP connections including PPPoE and PPPoA link types</li> <li>Authentication Protocol Support: Implements PAP, CHAP, MS-CHAP, and AUTO authentication mechanisms for secure connection establishment</li> <li>Network Configuration Protocol (NCP) Support: Manages IPCP for IPv4 and IPv6CP for IPv6 address configuration and DNS server assignment</li> <li>Connection State Monitoring: Tracks connection status, handles state transitions, and provides real-time connection health monitoring</li> <li>TR-181 Data Model Implementation: Exposes standardized TR-181 parameters for Device.PPP hierarchy with custom RDK extensions</li> <li>IPC Event Processing: Receives and processes PPP daemon events through Unix domain sockets for real-time status updates</li> <li>Statistics Collection: Gathers interface statistics including bytes/packets sent/received and error counters from kernel interfaces</li> <li>Integration with WAN Manager: Coordinates with WAN Manager component for WAN interface management and configuration</li> </ul>"},{"location":"review/PPPManager/#design","title":"Design","text":"<p>The PPP Manager follows a modular, event-driven architecture that separates TR-181 data model management from core PPP functionality. The design emphasizes reliability through robust error handling, state management, and graceful degradation during connection failures. It maintains scalability by supporting multiple PPP interfaces simultaneously while ensuring thread-safe operations. Security is implemented through encrypted authentication protocols and secure credential storage via PSM (Persistent Storage Manager). The component follows RDK-B architectural patterns with clear separation between data model layer, business logic, and platform abstraction layers.</p> <p>The design supports maintainability through clear module boundaries where TR-181 middle layer handles parameter management, core PPP manager handles connection logic, and IPC layer manages event communication. Connection state is maintained consistently across all modules with proper synchronization mechanisms. The component is designed for extensibility to support additional authentication methods and connection types as needed.</p> <p>A container diagram of the component is given below</p> <pre><code>graph TD\n    subgraph Runtime [\"RDK-B Middleware Runtime (Linux)\"]\n        subgraph PppManagerContainer [\"PPP Manager Container\"]\n            SSPMain[SSP Main Process&lt;br/&gt;Business Logic]\n            TR181Layer[TR-181 Middle Layer&lt;br/&gt;Data Model Management]\n            IPCHandler[IPC Handler&lt;br/&gt;Event Processing]\n        end\n        subgraph PSMContainer [\"PSM Container\"]\n            PSM[(Persistent Storage Manager&lt;br/&gt;Configuration Storage)]\n        end\n        subgraph PPPDContainer [\"PPPD Container\"]\n            PPPD[PPP Daemon Process&lt;br/&gt;Protocol Implementation]\n        end\n    end\n\n    SSPMain --&gt;|DBus| TR181Layer\n    TR181Layer --&gt;|PSM API| PSM\n    IPCHandler --&gt;|Unix Socket| PPPD\n    SSPMain --&gt;|IPC Events| IPCHandler\n\n    classDef component fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef storage fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;\n    classDef daemon fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n\n    class SSPMain,TR181Layer,IPCHandler component;\n    class PSM storage;\n    class PPPD daemon;</code></pre> <p>Request Flow Sequence</p> <p>The most critical flow is PPP connection establishment. When a connection request is initiated through TR-181 parameters, the request flows from the data model layer to the SSP main process, which configures and starts the PPP daemon. The daemon establishes the PPP connection and sends status updates via IPC, which are processed by the IPC handler and propagated back to update the data model state.</p> <pre><code>sequenceDiagram\n    participant Client as Management Client\n    participant TR181 as TR-181 Layer  \n    participant SSP as SSP Main Process\n    participant IPC as IPC Handler\n    participant PPPD as PPP Daemon\n    participant PSM as PSM Storage\n\n    Client-&gt;&gt;TR181: Set Interface.Enable=true\n    TR181-&gt;&gt;PSM: Store configuration\n    TR181-&gt;&gt;SSP: Trigger connection\n    SSP-&gt;&gt;PPPD: Start PPP process with config\n    PPPD--&gt;&gt;IPC: Connection state events\n    IPC-&gt;&gt;SSP: Process state change\n    SSP-&gt;&gt;TR181: Update ConnectionStatus\n    TR181--&gt;&gt;Client: Status notification</code></pre> <p>Threading Model</p> <p>The PPP Manager uses a multi-threaded model with the following thread allocation:</p> <ul> <li>Main Thread: Handles DBus communication and TR-181 parameter management</li> <li>Event Handler Thread: Processes IPC messages from PPP daemon processes to ensure non-blocking event handling</li> <li>On-Demand Worker Threads: Created for connection establishment and teardown operations to avoid blocking the main control loop</li> <li>Thread Synchronization: Managed using mutex locks and condition variables to ensure data consistency during concurrent operations</li> </ul>"},{"location":"review/PPPManager/#internal-modules","title":"Internal Modules","text":"<p>The PPP Manager consists of several key modules that work together to provide comprehensive PPP connection management. The TR-181 middle layer receives configuration requests from external clients and manages the standardized data model. The core SSP module handles business logic including connection state management and integration with other RDK-B components. The IPC module provides real-time communication with PPP daemon processes for status monitoring and event handling.</p> Module/Class Description Key Files SSP Main Process Core service startup, initialization, and main control loop <code>pppmgr_ssp_main.c</code>, <code>pppmgr_global.h</code> TR-181 Middle Layer Data model implementation, parameter validation, and PSM integration <code>pppmgr_dml.c</code>, <code>pppmgr_dml_ppp_apis.c</code>, <code>pppmgr_data.c</code> IPC Handler Event processing, daemon communication, and state synchronization <code>pppmgr_ipc.c</code> Message Bus Interface DBus communication and CCSP framework integration <code>pppmgr_ssp_messagebus_interface.c</code> SSP Action Handler Connection management, daemon control, and error handling <code>pppmgr_ssp_action.c</code> <pre><code>flowchart TD\n    subgraph PPPManager [\"PPP Manager Component\"]\n        SSPMain([SSP Main Process&lt;br/&gt;Initialization &amp; Control])\n        TR181([TR-181 Middle Layer&lt;br/&gt;Data Model &amp; API])\n        IPCHandler([IPC Handler&lt;br/&gt;Event Processing])\n        MsgBus([Message Bus Interface&lt;br/&gt;DBus Communication])\n        ActionHandler([SSP Action Handler&lt;br/&gt;Connection Management])\n    end\n\n    SSPMain --&gt; TR181\n    SSPMain --&gt; IPCHandler\n    SSPMain --&gt; MsgBus\n    TR181 --&gt; ActionHandler\n    IPCHandler --&gt; ActionHandler\n\n    classDef module fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    class SSPMain,TR181,IPCHandler,MsgBus,ActionHandler module;</code></pre>"},{"location":"review/PPPManager/#interaction-with-other-middleware-components","title":"Interaction with Other Middleware Components","text":"<p>The PPP Manager integrates closely with several RDK-B middleware components to provide comprehensive WAN connectivity management. It communicates with the WAN Manager for coordinated WAN interface management and receives configuration updates through standardized DBus interfaces. The component interacts with PSM for persistent configuration storage and retrieval, ensuring settings survive system reboots.</p> <pre><code>flowchart LR\n    PPPManager --&gt;|DBus API| WANManager[WAN Manager&lt;br/&gt;WAN Interface Coordination]\n    PPPManager --&gt;|PSM API| PSM[Persistent Storage Manager&lt;br/&gt;Configuration Storage]\n    PPPManager --&gt;|DBus Events| CcspCR[CCSP Component Registry&lt;br/&gt;Component Registration]\n    PPPManager --&gt;|Syslog| LogManager[System Logging&lt;br/&gt;Event Logging]</code></pre> Component Purpose of Interaction Protocols/Mechanisms WAN Manager Coordinate WAN interface management and share connection status DBus API calls, Event notifications PSM (Persistent Storage Manager) Store and retrieve PPP configuration parameters and credentials PSM API calls over DBus CCSP Component Registry Register component capabilities and subscribe to system events DBus registration and event subscription System Logging Log connection events, errors, and diagnostic information Syslog protocol, Local logging <p>The PPP Manager publishes several key events that other components can subscribe to for coordination and monitoring purposes:</p> Event Purpose of Event Reason for trigger PPP_INTERFACE_UP Notify successful PPP connection establishment PPP daemon reports successful link negotiation and IP configuration PPP_INTERFACE_DOWN Notify PPP connection termination Connection loss, authentication failure, or manual disconnection PPP_IPCP_COMPLETED Notify successful IPv4 configuration IPCP negotiation completed with IP address assignment PPP_IPv6CP_COMPLETED Notify successful IPv6 configuration IPv6CP negotiation completed with interface identifier assignment PPP_AUTH_FAILED Notify authentication failure Invalid credentials or authentication protocol mismatch"},{"location":"review/PPPManager/#interaction-with-other-layers","title":"Interaction with Other Layers","text":"<p>The PPP Manager operates at the middleware layer and interacts with both lower-level platform services and higher-level management interfaces. It abstracts PPP daemon management from upper layers while providing standardized TR-181 interfaces for configuration and monitoring.</p> Layer/Service Interaction Description Mechanism Platform HAL System network interface management and statistics retrieval HAL API calls for interface operations Linux Kernel Network interface statistics and routing table management Proc filesystem reads (/proc/net/dev) PPP Daemon (pppd) PPP protocol implementation and connection establishment Unix domain sockets, Process control System Services Process management, logging, and system event handling System calls, Syslog <pre><code>graph TD\n    subgraph Applications [\"Application Layer\"]\n        WebUI[Web UI&lt;br/&gt;Management Interface]\n        SNMP[SNMP Agent&lt;br/&gt;Network Management]\n    end\n\n    subgraph Middleware [\"Middleware Layer\"]\n        PPPManager[PPP Manager&lt;br/&gt;Connection Management]\n        WANManager[WAN Manager&lt;br/&gt;Interface Coordination]\n    end\n\n    subgraph Platform [\"Platform Layer\"]\n        HAL[Platform HAL&lt;br/&gt;Hardware Abstraction]\n        SystemServices[System Services&lt;br/&gt;Process &amp; Logging]\n    end\n\n    subgraph Kernel [\"Linux Kernel\"]\n        NetworkStack[Network Stack&lt;br/&gt;Protocol Implementation]\n        ProcFS[Proc Filesystem&lt;br/&gt;Statistics Interface]\n    end\n\n    Applications --&gt;|TR-181 DBus| PPPManager\n    PPPManager --&gt;|HAL API| HAL\n    PPPManager --&gt;|System Calls| SystemServices\n    PPPManager --&gt;|Proc FS Read| ProcFS\n    PPPManager --&gt;|Unix Socket| NetworkStack\n\n    classDef app fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n    classDef middleware fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef platform fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n    classDef kernel fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;\n\n    class WebUI,SNMP app;\n    class PPPManager,WANManager middleware;\n    class HAL,SystemServices platform;\n    class NetworkStack,ProcFS kernel;</code></pre>"},{"location":"review/PPPManager/#ipc-mechanism","title":"IPC Mechanism","text":"<p>The PPP Manager uses multiple IPC mechanisms for different types of communication, with Unix domain sockets being the primary mechanism for real-time PPP daemon communication.</p> Type of IPC Message Format Mechanism Unix Domain Sockets Binary structured messages with event type, instance number, and connection parameters in C struct format Unix socket server listening on <code>/tmp/pppmgr_socket</code> for PPP daemon events DBus XML-encoded method calls and signals following CCSP message bus protocol DBus system bus for TR-181 parameter access and component communication PSM API Key-value pairs with parameter names and values encoded as strings DBus-based PSM interface for persistent configuration storage <pre><code>sequenceDiagram\n    participant PPPD as PPP Daemon\n    participant IPC as IPC Handler\n    participant SSP as SSP Main\n    participant TR181 as TR-181 Layer\n    participant Client as Management Client\n\n    PPPD-&gt;&gt;IPC: Unix Socket Event (PPP_INTERFACE_UP)\n    IPC-&gt;&gt;SSP: Process state change message\n    SSP-&gt;&gt;TR181: Update ConnectionStatus parameter\n    TR181-&gt;&gt;Client: DBus signal notification\n\n    Client-&gt;&gt;TR181: DBus Get/Set parameter request\n    TR181-&gt;&gt;SSP: Parameter change notification\n    SSP-&gt;&gt;PPPD: Configure connection (if needed)</code></pre>"},{"location":"review/PPPManager/#tr181-data-models","title":"TR\u2011181 Data Models","text":"<p>The PPP Manager implements comprehensive TR-181 Device.PPP data model hierarchy with both standard parameters and custom RDK extensions for enhanced functionality.</p> <ul> <li>Implemented Parameters: The component implements the complete Device.PPP object hierarchy including supported NCPs, interface management, authentication, and statistics collection. Parameters support both IPv4 (IPCP) and IPv6 (IPv6CP) network configuration protocols.</li> <li>Parameter Registration: Parameters are registered through the CCSP message bus framework with automatic discovery and validation. The component uses PSM for persistent storage of configuration parameters.</li> <li>Custom Extensions: Several custom parameters are implemented including X_RDK_LinkType for PPPoA/PPPoE distinction, X_T_ONLINE_DE_SRU/SRD for carrier-specific extensions, and enhanced error reporting capabilities.</li> </ul>"},{"location":"review/PPPManager/#core-ppp-parameters","title":"Core PPP Parameters","text":"Parameter Description Access (R/W) Default Notes <code>Device.PPP.SupportedNCPs</code> Supported Network Control Protocols R \"IPCP,IPv6CP\" Standard <code>Device.PPP.InterfaceNumberOfEntries</code> Number of PPP interface instances R <code>0</code> Standard"},{"location":"review/PPPManager/#ppp-interface-parameters","title":"PPP Interface Parameters","text":"Parameter Description Access (R/W) Default Notes <code>Device.PPP.Interface.{i}.Enable</code> Enable/disable PPP interface R/W <code>false</code> Standard <code>Device.PPP.Interface.{i}.Status</code> Interface operational status R \"Down\" Standard <code>Device.PPP.Interface.{i}.Name</code> Interface name (e.g., ppp0) R \"\" Standard <code>Device.PPP.Interface.{i}.ConnectionStatus</code> PPP connection state R \"Disconnected\" Standard <code>Device.PPP.Interface.{i}.LastConnectionError</code> Last connection error code R \"ERROR_NONE\" Standard <code>Device.PPP.Interface.{i}.Username</code> Authentication username R/W \"\" Standard <code>Device.PPP.Interface.{i}.Password</code> Authentication password R/W \"\" Standard <code>Device.PPP.Interface.{i}.AuthenticationProtocol</code> Auth protocol (PAP/CHAP/MS-CHAP/AUTO) R/W \"AUTO\" Standard <code>Device.PPP.Interface.{i}.MaxMRUSize</code> Maximum Receive Unit size R/W <code>1500</code> Standard <code>Device.PPP.Interface.{i}.X_RDK_LinkType</code> Link type specification R/W \"PPPoE\" Custom"},{"location":"review/PPPManager/#pppoe-specific-parameters","title":"PPPoE Specific Parameters","text":"Parameter Description Access (R/W) Default Notes <code>Device.PPP.Interface.{i}.PPPoE.SessionID</code> PPPoE session identifier R <code>0</code> Standard <code>Device.PPP.Interface.{i}.PPPoE.ACName</code> Access Concentrator name R/W \"\" Standard <code>Device.PPP.Interface.{i}.PPPoE.ServiceName</code> PPPoE service name R/W \"\" Standard"},{"location":"review/PPPManager/#ipcp-parameters","title":"IPCP Parameters","text":"Parameter Description Access (R/W) Default Notes <code>Device.PPP.Interface.{i}.IPCP.LocalIPAddress</code> Local IP address assigned R \"0.0.0.0\" Standard <code>Device.PPP.Interface.{i}.IPCP.RemoteIPAddress</code> Remote peer IP address R \"0.0.0.0\" Standard <code>Device.PPP.Interface.{i}.IPCP.DNSServers</code> DNS server addresses R \"\" Standard <code>Device.PPP.Interface.{i}.IPCP.PassthroughEnable</code> Enable IP passthrough R/W <code>false</code> Standard"},{"location":"review/PPPManager/#statistics-parameters","title":"Statistics Parameters","text":"Parameter Description Access (R/W) Default Notes <code>Device.PPP.Interface.{i}.Stats.BytesSent</code> Total bytes transmitted R <code>0</code> Standard <code>Device.PPP.Interface.{i}.Stats.BytesReceived</code> Total bytes received R <code>0</code> Standard <code>Device.PPP.Interface.{i}.Stats.PacketsSent</code> Total packets transmitted R <code>0</code> Standard <code>Device.PPP.Interface.{i}.Stats.PacketsReceived</code> Total packets received R <code>0</code> Standard <code>Device.PPP.Interface.{i}.Stats.ErrorsSent</code> Transmission errors R <code>0</code> Standard <code>Device.PPP.Interface.{i}.Stats.ErrorsReceived</code> Reception errors R <code>0</code> Standard"},{"location":"review/PPPManager/#implementation-details","title":"Implementation Details","text":"<ul> <li> <p>Key Algorithms or Logic: The core connection state machine manages PPP interface lifecycle through defined states (Unconfigured, Connecting, Authenticating, Connected, Disconnected). Authentication logic supports multiple protocols with automatic fallback mechanisms. The main implementation resides in <code>pppmgr_ipc.c</code> for event processing and <code>pppmgr_dml_ppp_apis.c</code> for TR-181 parameter management. Statistics collection uses periodic polling of <code>/proc/net/dev</code> and <code>/proc/net/dev_extstats</code> for comprehensive interface metrics.</p> </li> <li> <p>Error Handling Strategy: Errors are categorized into connection errors, authentication failures, and system errors with specific error codes mapped to TR-181 standard values. All errors are logged through the CCSP trace system with appropriate severity levels. Connection failures trigger automatic retry mechanisms with exponential backoff. Critical errors result in component restart through systemd integration.</p> </li> <li> <p>Logging &amp; Debugging: The component uses CCSP trace macros with configurable verbosity levels (ERROR, WARNING, INFO, DEBUG). Debug logging can be enabled through <code>/etc/debug.ini</code> configuration. Key connection events, state transitions, and error conditions are logged with contextual information including interface names, error codes, and timestamps.</p> </li> </ul>"},{"location":"review/PPPManager/#key-configuration-files","title":"Key Configuration Files","text":"<p>The PPP Manager relies on several configuration files for proper operation and parameter management.</p> Configuration File Purpose Key Parameters Default Values Override Mechanisms <code>RdkPppManager.xml</code> TR-181 data model definition Object hierarchy, parameter types, function mappings N/A Compile-time only <code>/etc/debug.ini</code> Debug logging configuration <code>LOG_LEVEL</code>, <code>TRACE_ENABLE</code> <code>INFO</code>, <code>false</code> Runtime modification <code>PSM Database</code> Persistent parameter storage Interface configs, credentials, connection settings Component defaults TR-181 parameter sets <code>/tmp/pppmgr_socket</code> IPC socket endpoint Socket permissions, buffer sizes System defaults Environment variables <code>pppd configuration</code> PPP daemon settings Plugin paths, authentication options <code>/usr/lib/pppd/2.4.9/</code> Runtime parameters"},{"location":"review/RBus/","title":"RBus Documentation","text":"<p>RBus (RDK Bus) is a lightweight, fast and efficient bus messaging system that enables IPC and RPC between multiple processes running on RDK-B devices. It provides a hierarchical data model framework with named objects containing properties, events, and methods, serving as the primary IPC backbone for RDK-B middleware components. RBus abstracts complex IPC mechanisms and provides a unified interface for component communication, data model management, and event distribution. It supports both synchronous and asynchronous communication patterns with built-in discovery, routing, and session management capabilities. The framework is designed for high-performance, low-latency communication in embedded device environments.</p> <pre><code>graph TD\n    subgraph External [\"External Systems &amp; Users\"]\n        WebAdmin[Web Administrator]\n        MobileApp[Mobile App]\n        CloudMgmt[Cloud Management]\n        TR069[TR-069 ACS]\n        SNMPMgr[SNMP Manager]\n    end\n\n    subgraph RDKBDevice [\"RDK-B IPC\"]\n        RBus[RBus Framework&lt;br/&gt;IPC &amp; Data Model Bus]\n    end\n\n    subgraph RDKBComponents [\"Other RDK-B System Components\"]\n        WiFiMgr[WiFi Manager]\n        WANMgr[WAN Manager]\n        DeviceMgr[Device Manager]\n        PSM[Persistent Storage Manager]\n        Telemetry[Telemetry Agent]\n        WebUI[Web UI Backend]\n        TR069Agent[TR-069 Agent]\n        SNMPAgent[SNMP Agent]\n    end\n\n    subgraph Hardware [\"Hardware Layer\"]\n        NetworkHW[Network Hardware]\n        SystemHW[System Hardware]\n    end\n\n    %% External interactions\n    WebAdmin --&gt;|HTTP/HTTPS| WebUI\n    MobileApp --&gt;|REST API| WebUI\n    CloudMgmt --&gt;|HTTPS/WSS| Telemetry\n    TR069 --&gt;|CWMP/HTTP| TR069Agent\n    SNMPMgr --&gt;|SNMP v2c/v3| SNMPAgent\n\n    %% RBus as central hub\n    WebUI --&gt;|Data Model API| RBus\n    TR069Agent --&gt;|Parameter Access| RBus\n    SNMPAgent --&gt;|MIB Data Queries| RBus\n    Telemetry --&gt;|Event Collection| RBus\n\n    RBus --&gt;|IPC Messages| WiFiMgr\n    RBus --&gt;|Property Access| WANMgr\n    RBus --&gt;|Configuration API| DeviceMgr\n    RBus --&gt;|Data Persistence| PSM\n\n    %% Hardware interactions\n    WiFiMgr --&gt;|HAL Calls| NetworkHW\n    WANMgr --&gt;|HAL Calls| NetworkHW\n    DeviceMgr --&gt;|HAL Calls| SystemHW\n\n    classDef external fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n    classDef rbus fill:#e1f5fe,stroke:#0277bd,stroke-width:3px;\n    classDef component fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n    classDef hardware fill:#fce4ec,stroke:#c2185b,stroke-width:2px;\n\n    class WebAdmin,MobileApp,CloudMgmt,TR069,SNMPMgr external;\n    class RBus rbus;\n    class WiFiMgr,WANMgr,DeviceMgr,PSM,Telemetry,WebUI,TR069Agent,SNMPAgent component;\n    class NetworkHW,SystemHW hardware;</code></pre> <p>Key Features &amp; Responsibilities</p> <ul> <li>Interprocess Communication Framework: Provides lightweight IPC and RPC mechanisms for process communication across the RDK-B stack with support for both local and remote procedure calls.</li> <li>Hierarchical Data Model Management: Implements a tree-structured data model with named objects, properties, events, and methods that can be dynamically registered and discovered by other components.</li> <li>Event-Driven Architecture: Supports publish-subscribe event model with filtering capabilities, enabling real-time notifications and data change propagation across components.</li> <li>Session Management: Provides connection lifecycle management, client registration, heartbeat monitoring, and automatic cleanup of disconnected clients.</li> <li>Message Routing &amp; Discovery: Includes rtrouted daemon for intelligent message routing, service discovery, and load balancing across distributed processes.</li> <li>Asynchronous Operations: Supports non-blocking operations with callback mechanisms for improved performance and responsiveness in embedded environments.</li> </ul>"},{"location":"review/RBus/#design","title":"Design","text":"<p>RBus follows a modular, event-driven architecture designed for embedded systems with strict performance and memory constraints. The design emphasizes separation of concerns through distinct layers: core messaging (rtmessage), high-level API (rbus), and routing infrastructure (rtrouted). Modularity is achieved through well-defined interfaces between components, allowing independent development and testing of messaging, data model, and routing subsystems. Scalability is ensured through efficient message routing algorithms and connection pooling that can handle hundreds of concurrent clients. Reliability is built-in through automatic reconnection, heartbeat monitoring, session recovery, and graceful degradation when components become unavailable. Security is implemented through configurable access controls, message encryption capabilities, and process isolation. Maintainability is supported through comprehensive logging, debugging hooks, and clean separation between platform-specific and generic code.</p> <p>The design supports loose coupling between components through the data model abstraction, where producers and consumers interact via named objects rather than direct references. Clear boundaries exist between the core messaging layer (handles transport), the RBus API layer (manages data model), and application components (implement business logic). The rtrouted daemon serves as the central message broker, handling routing decisions and connection management independently of client applications.</p> <p>A container diagram of the component is given below</p> <pre><code>graph TD\n    subgraph \"RDK-B Runtime Environment\"\n        subgraph RBusContainer [\"RBus Container\"]\n            subgraph CoreLayer [\"Core Messaging Layer\"]\n                RTMessage[rtmessage]\n                RTRouted[rtrouted daemon]\n            end\n            subgraph APILayer [\"RBus API Layer\"]\n                RBusAPI[rbus library]\n                DataModel[Data Model Manager]\n            end\n            subgraph SessionLayer [\"Session Management\"]\n                SessionMgr[Session Manager]\n                HeartBeat[Heartbeat Monitor]\n            end\n        end\n\n        subgraph ClientApps [\"Other RDK-B Components\"]\n            Provider1[WiFi Manager]\n            Provider2[Device Manager]\n            Consumer1[Web UI]\n            Consumer2[TR-069 Agent]\n        end\n\n        subgraph HALLayer [\"HAL Layer\"]\n            HAL[(Hardware Abstraction)]\n        end\n    end\n\n    RTRouted --&gt;|Message Routing| RBusAPI\n    RBusAPI --&gt;|Data Model API| DataModel\n    SessionMgr --&gt;|Connection Mgmt| RTMessage\n    HeartBeat --&gt;|Health Check| SessionMgr\n\n    Provider1 --&gt;|Publish Data| RBusAPI\n    Provider2 --&gt;|Register Objects| RBusAPI\n    RBusAPI --&gt;|IPC Messages| Consumer1\n    RBusAPI --&gt;|Event Notifications| Consumer2\n\n    DataModel --&gt;|HAL Calls| HAL\n\n    classDef core fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef api fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;\n    classDef client fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n    classDef hal fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n\n    class RTMessage,RTRouted core;\n    class RBusAPI,DataModel,SessionMgr,HeartBeat api;\n    class Provider1,Provider2,Consumer1,Consumer2 client;\n    class HAL hal;</code></pre> <p>Request Flow Sequence</p> <p>The most critical flow is the data model operation where a client requests data from a provider. The sequence starts with client discovery of available objects, followed by connection establishment, request routing through rtrouted, provider processing, and response delivery with optional event subscriptions.</p> <pre><code>sequenceDiagram\n    participant Client as RDK-B Client\n    participant RBusLib as RBus Library\n    participant RTRouted as rtrouted daemon\n    participant Provider as Data Provider\n    participant DataModel as Data Model\n\n    Client-&gt;&gt;RBusLib: rbus_open(\"client_name\")\n    RBusLib-&gt;&gt;RTRouted: Connect &amp; Register\n    RTRouted--&gt;&gt;RBusLib: Connection Established\n\n    Client-&gt;&gt;RBusLib: rbus_get(\"Device.WiFi.Status\")\n    RBusLib-&gt;&gt;RTRouted: Route Request Message\n    RTRouted-&gt;&gt;Provider: Forward Get Request\n    Provider-&gt;&gt;DataModel: Query Object Property\n    DataModel--&gt;&gt;Provider: Property Value\n    Provider--&gt;&gt;RTRouted: Response Message\n    RTRouted--&gt;&gt;RBusLib: Forward Response\n    RBusLib--&gt;&gt;Client: Return Value\n\n    Client-&gt;&gt;RBusLib: rbus_subscribe(\"Device.WiFi.Status\")\n    RBusLib-&gt;&gt;RTRouted: Subscribe Request\n    RTRouted-&gt;&gt;Provider: Register Subscription\n    Provider--&gt;&gt;RTRouted: Subscription Confirmed\n\n    Note over Provider: WiFi Status Changes\n    Provider-&gt;&gt;RTRouted: Publish Event\n    RTRouted-&gt;&gt;RBusLib: Event Notification\n    RBusLib-&gt;&gt;Client: Event Callback</code></pre> <p>Threading Model</p> <p>The RBus system employs a hybrid threading model tailored for embedded environments, with the following thread allocation:</p> <ul> <li>Core Daemon (<code>rtrouted</code>): Operates as a single-threaded event loop using <code>select()</code> for I/O multiplexing, ensuring low resource usage and predictable performance</li> <li> <p>Client Libraries: Support both single-threaded and multi-threaded modes:</p> </li> <li> <p>Single-Threaded Mode: All RBus operations execute synchronously on the calling thread</p> </li> <li>Multi-Threaded Mode: A dedicated worker thread processes incoming messages and event callbacks, allowing the main thread to focus on application logic</li> <li>Thread Pools: Spawned on demand to manage concurrent subscriptions; configurable based on available system resources</li> <li>Session Manager: Runs in a separate thread to independently monitor connection health, decoupled from core message processing</li> </ul>"},{"location":"review/RBus/#internal-modules","title":"Internal Modules","text":"<p>RBus is organized into several key modules that handle different aspects of the messaging framework. The core rtmessage module provides low-level transport and serialization. The high-level rbus module implements the data model API and manages object registration. The rtrouted daemon handles message routing and service discovery across the system.</p> Module/Class Description Key Files rtmessage Core messaging transport layer providing socket communication, message serialization, and connection management <code>rtMessage.c</code>, <code>rtConnection.c</code>, <code>rtMessageHeader.c</code> rbus High-level API layer implementing data model objects, properties, events, and method invocation <code>rbus.c</code>, <code>rbus_object.c</code>, <code>rbus_property.c</code>, <code>rbus_value.c</code> rbuscore Core RBus functionality including handle management, callback routing, and message processing <code>rbuscore.c</code>, <code>rbuscore_message.c</code> rtrouted Message routing daemon providing service discovery, connection brokering, and message forwarding <code>rtrouted.c</code>, <code>rtRoutingTree.c</code> session_manager Connection lifecycle management including client registration, heartbeat monitoring, and cleanup Session manager source files Subscriptions Event subscription management with filtering, interval-based updates, and asynchronous notifications <code>rbus_subscriptions.c</code>, <code>rbus_asyncsubscribe.c</code>, <code>rbus_intervalsubscription.c</code> Data Serialization Message encoding/decoding, buffer management, and data type conversion <code>rbus_buffer.c</code>, <code>rbus_message.c</code>, <code>rtEncoder.c</code> <pre><code>flowchart TD\n    subgraph RBus\n        subgraph HighLevel [\"High-Level API\"]\n            RBusAPI([rbus])\n            Objects([rbus_object])\n            Properties([rbus_property])\n            Values([rbus_value])\n        end\n\n        subgraph CoreLayer [\"Core Layer\"]\n            RBusCore([rbuscore])\n            Messages([rbuscore_message])\n            Handles([rbus_handle])\n        end\n\n        subgraph Transport [\"Transport Layer\"]\n            RTMessage([rtmessage])\n            Connection([rtConnection])\n            Routing([rtRoutingTree])\n        end\n\n        subgraph Services [\"Services\"]\n            RTRouted([rtrouted])\n            SessionMgr([session_manager])\n            Subscriptions([rbus_subscriptions])\n        end\n    end\n\n    RBusAPI --&gt; Objects\n    RBusAPI --&gt; Properties\n    Objects --&gt; Values\n    RBusAPI --&gt; RBusCore\n    RBusCore --&gt; Messages\n    RBusCore --&gt; Handles\n    Messages --&gt; RTMessage\n    Handles --&gt; Connection\n    RTMessage --&gt; Connection\n    Connection --&gt; Routing\n    RTRouted --&gt; Routing\n    RTRouted --&gt; SessionMgr\n    RBusCore --&gt; Subscriptions\n\n    classDef highlevel fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef core fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;\n    classDef transport fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n    classDef service fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n\n    class RBusAPI,Objects,Properties,Values highlevel;\n    class RBusCore,Messages,Handles core;\n    class RTMessage,Connection,Routing transport;\n    class RTRouted,SessionMgr,Subscriptions service;</code></pre>"},{"location":"review/RBus/#interaction-with-other-middleware-components","title":"Interaction with Other Middleware Components","text":"<p>RBus serves as the central IPC backbone for RDK-B middleware, enabling communication between various components through standardized data model interfaces. Components register their data objects with RBus and can be discovered and accessed by other components through hierarchical naming conventions.</p> <pre><code>flowchart LR\n    RBus --&gt;|Data Model API| WiFiManager[WiFi Manager]\n    RBus --&gt;|Event Notifications| WANManager[WAN Manager]\n    RBus --&gt;|Property Access| DeviceManager[Device Manager]\n    RBus --&gt;|Method Calls| TR069Agent[TR-069 Agent]\n    RBus --&gt;|Telemetry Events| TelemetryAgent[Telemetry Agent]\n    RBus --&gt;|Configuration Updates| WebUI[Web UI]\n    RBus --&gt;|Status Queries| SNMP[SNMP Agent]\n    RBus --&gt;|Parameter Access| PSM[Persistent Storage Manager]\n\n    classDef rbus fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef component fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n\n    class RBus rbus;\n    class WiFiManager,WANManager,DeviceManager,TR069Agent,TelemetryAgent,WebUI,SNMP,PSM component;</code></pre> Component Purpose of Interaction Protocols/Mechanisms WiFi Manager WiFi configuration management, status reporting, and client connection events RBus Data Model API, Event Subscriptions WAN Manager WAN interface status, IP configuration, and connectivity state management RBus Property Access, Method Invocation Device Manager Device information, system status, and hardware configuration management RBus Object Registration, Property Publishing TR-069 Agent Remote management parameter access and configuration synchronization RBus Get/Set Operations, Bulk Data Transfer Telemetry Agent System metrics collection and telemetry data aggregation RBus Event Publishing, Periodic Data Collection Web UI User interface data binding and real-time status updates RBus Subscriptions, Asynchronous Notifications SNMP Agent SNMP MIB data access and trap generation RBus Query Interface, Event-to-Trap Mapping PSM Configuration persistence and parameter storage RBus Configuration API, Data Validation <p>RBus publishes various system-wide events that enable reactive programming and real-time updates across components:</p> Event Purpose of Event Reason for trigger Component.Ready Indicates component initialization completion Published when component successfully registers all data objects and is ready to serve requests ValueChange Property value modification notification Triggered when any registered property value changes, enabling real-time UI updates and dependent component reactions Connection.Lost Client disconnection notification Published when rtrouted detects client connection failure, enabling cleanup and failover procedures Discovery.NewComponent New component registration Triggered when a new component registers with RBus, enabling dynamic service discovery SystemInfo.Update System status change notification Published on significant system state changes like interface up/down, memory pressure, or configuration updates"},{"location":"review/RBus/#interaction-with-other-layers","title":"Interaction with Other Layers","text":"<p>RBus operates primarily in the middleware layer but interacts with both lower HAL layers and upper application layers through well-defined interfaces. It abstracts the complexity of inter-component communication while providing efficient access to hardware resources.</p> Layer/Service Interaction Description Mechanism HAL Layer Hardware abstraction for device-specific operations and status reporting Direct function calls, shared libraries Linux Kernel System services including networking, process management, and IPC primitives System calls, netlink sockets, signal handling Configuration Management Persistent storage and configuration file management File I/O, configuration parsing, validation callbacks Logging Framework System-wide logging and debugging support RDK Logger integration, syslog interface Security Framework Authentication, authorization, and secure communication Access control lists, certificate validation External Management TR-069, SNMP, and other external management protocols Protocol adaptation layers, data transformation <pre><code>graph TD\n    subgraph \"Application Layer\"\n        Apps[RDK-B Applications]\n        WebUI[Web Interface]\n        Management[TR-069/SNMP]\n    end\n\n    subgraph \"Middleware Layer\"\n        RBus[RBus Framework]\n        Components[RDK-B Components]\n    end\n\n    subgraph \"Platform Layer\"\n        HAL[Hardware Abstraction Layer]\n        Linux[Linux Kernel Services]\n        Security[Security Framework]\n    end\n\n    subgraph \"Hardware Layer\"\n        Hardware[Device Hardware]\n    end\n\n    Apps --&gt;|RBus API| RBus\n    WebUI --&gt;|Data Binding| RBus\n    Management --&gt;|Parameter Access| RBus\n    RBus --&gt;|Component IPC| Components\n    Components --&gt;|HAL Calls| HAL\n    RBus --&gt;|System Services| Linux\n    RBus --&gt;|Security Services| Security\n    HAL --&gt;|Device Control| Hardware\n\n    classDef app fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef middleware fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;\n    classDef platform fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n    classDef hardware fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n\n    class Apps,WebUI,Management app;\n    class RBus,Components middleware;\n    class HAL,Linux,Security platform;\n    class Hardware hardware;</code></pre>"},{"location":"review/RBus/#ipc-mechanism","title":"IPC Mechanism","text":"<p>RBus implements a sophisticated IPC framework that supports multiple communication patterns and message formats optimized for embedded systems.</p> Type of IPC Message Format Mechanism Request-Response Binary encoded messages with msgpack serialization containing method name, parameters, and request ID Unix domain sockets with rtrouted message routing Publish-Subscribe Event messages with topic hierarchies, filter expressions, and typed payloads Broadcast distribution through rtrouted with subscriber filtering Asynchronous Callbacks Callback registration messages with function pointers and user data contexts Thread-safe callback queues with event loop integration Bulk Data Transfer Chunked message protocol for large data transfers with flow control Streaming message protocol with acknowledgment and retry logic <pre><code>sequenceDiagram\n    participant ClientApp as Client Application\n    participant RBusLib as RBus Library\n    participant RTRouted as rtrouted daemon\n    participant Provider as Service Provider\n    participant SessionMgr as Session Manager\n\n    Note over ClientApp,SessionMgr: Initial Connection Setup\n    ClientApp-&gt;&gt;RBusLib: rbus_open(\"MyClient\")\n    RBusLib-&gt;&gt;RTRouted: CONNECT_MSG {client_name, pid}\n    RTRouted-&gt;&gt;SessionMgr: Register Client Session\n    SessionMgr--&gt;&gt;RTRouted: Session Created\n    RTRouted--&gt;&gt;RBusLib: CONNECTION_ACK {session_id}\n    RBusLib--&gt;&gt;ClientApp: RBUS_ERROR_SUCCESS\n\n    Note over ClientApp,SessionMgr: Synchronous Request-Response\n    ClientApp-&gt;&gt;RBusLib: rbus_get(\"Device.WiFi.SSID\")\n    RBusLib-&gt;&gt;RTRouted: GET_REQUEST_MSG {object_name, request_id}\n    RTRouted-&gt;&gt;Provider: Forward GET_REQUEST\n    Provider-&gt;&gt;Provider: Process Request\n    Provider--&gt;&gt;RTRouted: GET_RESPONSE_MSG {value, status}\n    RTRouted--&gt;&gt;RBusLib: Forward Response\n    RBusLib--&gt;&gt;ClientApp: Return Value\n\n    Note over ClientApp,SessionMgr: Event Subscription\n    ClientApp-&gt;&gt;RBusLib: rbus_subscribe(\"Device.Network.*\", callback)\n    RBusLib-&gt;&gt;RTRouted: SUBSCRIBE_MSG {filter, callback_id}\n    RTRouted-&gt;&gt;Provider: Register Subscription\n    Provider--&gt;&gt;RTRouted: SUBSCRIBE_ACK\n    RTRouted--&gt;&gt;RBusLib: Subscription Confirmed\n\n    Note over ClientApp,SessionMgr: Asynchronous Event Delivery\n    Provider-&gt;&gt;RTRouted: PUBLISH_EVENT_MSG {topic, data}\n    RTRouted-&gt;&gt;RTRouted: Apply Filters\n    RTRouted-&gt;&gt;RBusLib: EVENT_MSG {topic, data, subscription_id}\n    RBusLib-&gt;&gt;ClientApp: Invoke Event Callback</code></pre>"},{"location":"review/RBus/#implementation-details","title":"Implementation Details","text":"<ul> <li> <p>Key Algorithms or Logic: RBus implements several critical algorithms including hierarchical object lookup using Patricia trees for O(log n) performance, event filtering with compiled filter expressions, and adaptive message routing with load balancing. The main routing logic resides in <code>rtrouted.c</code> and <code>rtRoutingTree.c</code>. Message serialization uses msgpack for efficient binary encoding implemented in <code>rtEncoder.c</code>. Connection management uses epoll-based event loops for scalable I/O handling in <code>rtConnection.c</code>.</p> </li> <li> <p>Error Handling Strategy: Errors are detected at multiple layers with standardized error codes defined in <code>rbuscore_types.h</code>. Critical errors trigger automatic reconnection attempts with exponential backoff. Component failures are isolated through process boundaries and graceful degradation. All errors are logged with contextual information including component name, operation type, and stack traces where applicable.</p> </li> <li> <p>Logging &amp; Debugging: RBus integrates with RDK Logger providing configurable log levels (FATAL, ERROR, WARN, INFO, DEBUG). Debug categories include RBUS_CORE, RBUS_MESSAGE, RBUS_ROUTING for granular control. Memory leak detection and performance profiling hooks are available in debug builds. The framework provides runtime diagnostic tools including connection status, message statistics, and object registry inspection.</p> </li> </ul>"},{"location":"review/RBus/#key-configuration-files","title":"Key Configuration Files","text":"<p>RBus configuration is managed through multiple files that control daemon behavior, client settings, and system integration.</p> Configuration File Purpose Key Parameters Default Values Override Mechanisms <code>rbus_rdkv.conf</code> RDK-V platform configuration <code>RTROUTER_OPTIONAL_ARGS</code>, <code>RBUS_ROOT</code> <code>-f -l DEBUG</code>, <code>/tmp</code> Environment variables <code>rbus_client_rdkc.conf</code> RDK-C client configuration <code>CLIENT_TIMEOUT</code>, <code>MAX_CONNECTIONS</code> <code>30000ms</code>, <code>256</code> Command line arguments <code>rbus.service</code> SystemD service definition <code>ExecStart</code>, <code>Restart</code>, <code>TimeoutSec</code> <code>rtrouted</code>, <code>no</code>, <code>300</code> SystemD overrides <code>rbus_heartbeat.service</code> Heartbeat monitoring service <code>HEARTBEAT_INTERVAL</code>, <code>DEAD_CLIENT_TIMEOUT</code> <code>5s</code>, <code>30s</code> Service configuration <code>rbus_session_mgr.service</code> Session management service <code>SESSION_CLEANUP_INTERVAL</code> <code>60s</code> Runtime parameters"},{"location":"review/TelcoVoiceManager/","title":"Telco Voice Manager Documentation","text":"<p>RDK Telco Voice Manager is the middleware component designed to manage vendor voice stacks through TR-104 configuration and provides a standardized interface for voice services in RDK-B platforms. It acts as a bridge between the RDK-B framework and vendor-specific voice implementations, enabling voice service management, configuration, and monitoring capabilities. The component supports both TR-104 v1 and v2 data models and integrates with HAL layers to abstract vendor-specific voice stack implementations. It manages voice profiles, lines, physical interfaces, and provides telemetry reporting capabilities while maintaining compatibility with CCSP (Common Component Software Platform) architecture.</p> <pre><code>graph TD\n    subgraph Users [\" Users\"]\n\n        ServiceProvider[ Service Provider&lt;br/&gt;SIP Infrastructure]\n        Administrator[ Network Administrator&lt;br/&gt;Configuration Management]\n        EndUser[ End User&lt;br/&gt;Voice Calls]\n    end\n\n\n    subgraph RDKBDevice [\" RDK-B Device\"]\n        TelcoVoiceManager[ Telco Voice Manager&lt;br/&gt;Voice Service Management]\n\n    end\n\n    subgraph ExternalSystems [\" External Systems\"]\n\n        WebConfigServer[ WebConfig Server&lt;br/&gt;Remote Configuration]\n        TelemetryServer[Telemetry Server&lt;br/&gt;Monitoring &amp; Analytics]\n        SIPRegistrar[ SIP Registrar&lt;br/&gt;Authentication &amp; Registration]\n    end\n\n\n    subgraph RDKBComponents [\" RDK-B Components\"]\n        CCSpFramework[ CCSP Framework&lt;br/&gt;Parameter Management]\n\n        NetworkManager[Network Manager&lt;br/&gt;Interface Monitoring]\n        VoiceHAL[Voice HAL&lt;br/&gt;Hardware Abstraction]\n    end\n\n\n    ServiceProvider &lt;--&gt;|SIP/RTP| TelcoVoiceManager\n    Administrator --&gt;|TR-181 Config| TelcoVoiceManager\n    EndUser --&gt;|Voice Services| TelcoVoiceManager\n\n\n    TelcoVoiceManager &lt;--&gt;|HTTPS/JSON| WebConfigServer\n    TelcoVoiceManager --&gt;|Statistics| TelemetryServer\n\n    TelcoVoiceManager &lt;--&gt;|SIP Registration| SIPRegistrar\n\n    TelcoVoiceManager &lt;--&gt;|DBus/TR-181| CCSpFramework\n    TelcoVoiceManager &lt;--&gt;|Status Events| NetworkManager\n\n    TelcoVoiceManager &lt;--&gt;|JSON HAL| VoiceHAL\n\n    classDef user fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n\n    classDef component fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef external fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n    classDef rdkb fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;\n\n\n    class ServiceProvider,Administrator,EndUser user;\n    class TelcoVoiceManager component;\n    class WebConfigServer,TelemetryServer,SIPRegistrar external;\n\n    class CCSpFramework,NetworkManager,VoiceHAL rdkb;</code></pre> <p>Key Features &amp; Responsibilities: </p> <ul> <li>Voice Service Management: Manages voice services including SIP configuration, voice profiles, and line management with support for multiple voice service instances</li> <li>TR-104 Data Model Implementation: Implements TR-104 v1 and v2 specifications for voice service parameters with comprehensive parameter validation and persistence</li> <li>HAL Abstraction Layer: Provides JSON-based HAL interface to abstract vendor voice stack implementations and enable cross-platform compatibility</li> <li>Network Monitoring: Monitors network interface changes and firewall rule configurations to ensure voice service connectivity and security</li> <li>Telemetry &amp; Reporting: Collects and reports voice service statistics, call logs, and diagnostic information through RDK telemetry framework</li> <li>WebConfig Integration: Supports remote configuration management through WebConfig protocol for dynamic voice service provisioning</li> </ul>"},{"location":"review/TelcoVoiceManager/#design","title":"Design","text":"<p>The Telco Voice Manager follows a layered architecture approach that separates concerns between TR-181 data model management, business logic, and hardware abstraction. The design emphasizes modularity through clear separation of TR-104 v1/v2 implementations, ensuring backward compatibility while supporting newer specifications. The component maintains reliability through comprehensive error handling, parameter validation, and graceful degradation when voice services are unavailable. Security is implemented through proper access controls, encrypted credential storage, and secure communication channels with vendor voice stacks. The architecture supports scalability by allowing multiple voice service instances and dynamic configuration changes without service interruption.</p> <p>The design establishes clear boundaries between the TR-181 data model layer (responsible for CCSP integration), the middle layer (handling business logic and data transformation), and the HAL layer (abstracting vendor implementations). Data persistence responsibilities are handled through CCSP's PSM (Parameter Storage Management) system, while interface management is centralized in the controller module for consistent event handling and service coordination.</p> <p>A container diagram of the component is given below</p> <pre><code>graph TD\n    subgraph Runtime [\"RDK-B Linux Runtime\"]\n        subgraph TelcoVoiceContainer [\"Telco Voice Manager Container\"]\n            Controller[Controller Module&lt;br/&gt;Event handling &amp; service coordination]\n            TR181Layer[TR-181 Layer&lt;br/&gt;CCSP Data Model Integration]\n            MiddleLayer[Middle Layer&lt;br/&gt;Business Logic &amp; Validation]\n            HALInterface[HAL Interface&lt;br/&gt;JSON-based vendor abstraction]\n            NetworkMonitor[Network Monitor&lt;br/&gt;Interface &amp; firewall monitoring]\n            WebConfigModule[WebConfig Module&lt;br/&gt;Remote configuration support]\n        end\n        subgraph VendorVoice [\"Vendor Voice Stack\"]\n            VoiceHAL[(Voice HAL Server)]\n        end\n        subgraph CCSPFramework [\"CCSP Framework\"]\n            MessageBus[(CCSP Message Bus)]\n            PSM[(Parameter Storage)]\n        end\n    end\n\n    Controller --&gt;|Event Subscribe/Publish| MessageBus\n    TR181Layer --&gt;|DBus| MessageBus\n    MiddleLayer --&gt;|Parameter Get/Set| PSM\n    HALInterface --&gt;|JSON/TCP| VoiceHAL\n    NetworkMonitor --&gt;|Sysevent| MessageBus\n    WebConfigModule --&gt;|HTTP/WebPA| MessageBus\n\n    classDef component fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef external fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n    classDef storage fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n\n    class Controller,TR181Layer,MiddleLayer,HALInterface,NetworkMonitor,WebConfigModule component;\n    class VoiceHAL external;\n    class MessageBus,PSM storage;</code></pre> <p>Request Flow Sequence</p> <p>The most critical flow is TR-181 parameter configuration which starts from CCSP clients, flows through the TR-181 layer for validation, gets processed by the middle layer for business logic, and finally reaches the vendor voice stack through the HAL interface.</p> <pre><code>sequenceDiagram\n    participant Client as CCSP Client\n    participant TR181 as TR-181 Layer\n    participant Middle as Middle Layer\n    participant HAL as HAL Interface\n    participant Vendor as Vendor Voice Stack\n\n    Client-&gt;&gt;TR181: SetParameterValues (Voice.Line.Enable)\n    TR181-&gt;&gt;TR181: Validate Parameter\n    TR181-&gt;&gt;Middle: Process Configuration\n    Middle-&gt;&gt;Middle: Apply Business Logic\n    Middle-&gt;&gt;HAL: JSON Request (setParameters)\n    HAL-&gt;&gt;Vendor: Forward to Voice HAL\n    Vendor--&gt;&gt;HAL: JSON Response\n    HAL--&gt;&gt;Middle: Status/Result\n    Middle--&gt;&gt;TR181: Commit/Rollback\n    TR181--&gt;&gt;Client: SetParameterValuesResponse</code></pre> <p>Threading Model</p> <p>The Telco Voice Manager uses a multi-threaded model with the following thread allocation:</p> <ul> <li>Main Thread: Handles CCSP message bus operations, TR-181 parameter processing, and component lifecycle management</li> <li>Network Monitor Thread: Dedicated thread for monitoring network interface changes and sysevent notifications</li> <li>HAL Communication Thread: Manages asynchronous communication with vendor voice stack through JSON HAL client</li> <li>Event Handler Thread: Processes voice service events and publishes telemetry data to the RDK telemetry framework</li> <li>WebConfig Thread: Handles remote configuration updates and applies them to the voice service configuration</li> </ul>"},{"location":"review/TelcoVoiceManager/#internal-modules","title":"Internal Modules","text":"<p>The component is organized into distinct modules that handle specific aspects of voice service management. The Controller module receives external events and coordinates responses across other modules. The TR-181 layer modules handle CCSP integration and data model compliance. The Middle layer contains the core business logic and parameter validation. The HAL interface module abstracts vendor-specific implementations.</p> Module/Class Description Key Files Controller Main service controller handling initialization, event subscription, and coordination <code>telcovoicemgr_controller.c</code>, <code>telcovoicemgr_controller.h</code> SSP Main CCSP Service Support Point main entry and lifecycle management <code>telcovoicemgr_ssp_main.c</code>, <code>telcovoicemgr_ssp_global.h</code> Network Monitor Network interface and firewall rule monitoring for voice connectivity <code>telcovoicemgr_nw_monitor.c</code>, <code>telcovoicemgr_nw_monitor.h</code> TR-181 APIs CCSP TR-181 data model implementation and parameter handlers <code>telcovoicemgr_dml_apis.c</code>, <code>telcovoicemgr_dml_apis.h</code> Middle Layer Business logic, parameter validation, and data transformation <code>telcovoicemgr_dml_data.c</code>, <code>telcovoicemgr_dml_backendmgr.c</code> HAL Interface JSON-based communication with vendor voice stack <code>telcovoicemgr_dml_hal.c</code>, <code>telcovoicemgr_dml_hal.h</code> WebConfig Module Remote configuration management and WebPA integration <code>telcovoicemgr_webconfig.c</code>, <code>telcovoicemgr_webconfig.h</code> Voice Reporting Telemetry data collection and reporting functionality <code>voice_report.c</code>, <code>voice_report.h</code> <pre><code>flowchart TD\n    subgraph TelcoVoiceManager\n        Controller([Controller&lt;br/&gt;Service coordination])\n        SSPMain([SSP Main&lt;br/&gt;CCSP lifecycle])\n        NetworkMonitor([Network Monitor&lt;br/&gt;Interface monitoring])\n        TR181APIs([TR-181 APIs&lt;br/&gt;Data model handlers])\n        MiddleLayer([Middle Layer&lt;br/&gt;Business logic])\n        HALInterface([HAL Interface&lt;br/&gt;Vendor abstraction])\n        WebConfig([WebConfig&lt;br/&gt;Remote config])\n        VoiceReporting([Voice Reporting&lt;br/&gt;Telemetry collection])\n    end\n\n    Controller --&gt; SSPMain\n    Controller --&gt; NetworkMonitor\n    Controller --&gt; TR181APIs\n    TR181APIs --&gt; MiddleLayer\n    MiddleLayer --&gt; HALInterface\n    MiddleLayer --&gt; WebConfig\n    MiddleLayer --&gt; VoiceReporting\n    NetworkMonitor --&gt; Controller</code></pre>"},{"location":"review/TelcoVoiceManager/#interaction-with-other-middleware-components","title":"Interaction with Other Middleware Components","text":"<p>The component integrates with various RDK-B middleware components to provide comprehensive voice service functionality. It communicates with the CCSP framework for parameter management and with telemetry services for reporting. Network-related interactions include coordination with WAN Manager for interface status and with firewall services for security rule management.</p> <pre><code>flowchart LR\n    TelcoVoiceManager --&gt;|DBus/CCSP| CCSPMessageBus[CCSP Message Bus]\n    TelcoVoiceManager --&gt;|HTTP POST /upload| TelemetryAgent[Telemetry Agent]\n    TelcoVoiceManager --&gt;|DBus| PSM[Parameter Storage Manager]\n    TelcoVoiceManager --&gt;|Sysevent| NetworkManager[Network Manager]\n    TelcoVoiceManager --&gt;|WebPA/HTTP| WebConfigAgent[WebConfig Agent]\n    TelcoVoiceManager --&gt;|JSON/TCP| VendorVoiceStack[Vendor Voice Stack]</code></pre> Component Purpose of Interaction Protocols/Mechanisms CCSP Message Bus TR-181 parameter operations, component registration, and inter-component communication DBus Parameter Storage Manager Persistent storage of voice configuration parameters and settings DBus Telemetry Agent Voice service statistics and diagnostic data reporting HTTP POST Network Manager Network interface status monitoring and connectivity events Sysevent WebConfig Agent Remote configuration management and bulk parameter updates WebPA/HTTP Vendor Voice Stack Voice service control, configuration, and status monitoring JSON over TCP <p>Telco Voice Manager publishes several key events that other components can subscribe to for coordination and monitoring purposes</p> Event Purpose of Event Reason for trigger VoiceServiceStatusChange Voice service operational status update Service initialization complete, service failure detected LineRegistrationStatus Voice line registration state change SIP registration success/failure, network connectivity change CallLogUpdate New call record available Call completed, call statistics updated FirewallRuleChange Voice service firewall rule modification Network interface change, security policy update ConfigurationChange Voice configuration parameter update WebConfig update received, parameter modified via TR-181"},{"location":"review/TelcoVoiceManager/#interaction-with-other-layers","title":"Interaction with Other Layers","text":"<p>The component interacts with multiple layers in the RDK-B software stack, from HAL abstraction to platform services and external systems. The HAL layer interaction enables vendor-agnostic voice stack management, while platform layer integration provides system-level services like network monitoring and storage.</p> Layer/Service Interaction Description Mechanism Voice HAL Voice service control, parameter configuration, and status monitoring JSON over TCP Platform Services System event monitoring, network interface management, file system access Sysevent, syscfg CCSP Framework Component registration, parameter management, message bus communication DBus Telemetry Service Voice statistics reporting, diagnostic data collection HTTP POST WebConfig Service Remote configuration updates, bulk parameter provisioning WebPA/HTTP <pre><code>graph LR\n    subgraph ApplicationLayer [\"Application Layer\"]\n        TelcoVoiceManager[Telco Voice Manager]\n    end\n\n    subgraph MiddlewareLayer [\"Middleware Layer\"]\n        CCSPFramework[CCSP Framework]\n        TelemetryService[Telemetry Service]\n        WebConfigService[WebConfig Service]\n    end\n\n    subgraph PlatformLayer [\"Platform Layer\"]\n        NetworkServices[Network Services]\n        StorageServices[Storage Services]\n        SystemServices[System Services]\n    end\n\n    subgraph HALLayer [\"HAL Layer\"]\n        VoiceHAL[Voice HAL]\n    end\n\n    TelcoVoiceManager --&gt;|DBus| CCSPFramework\n    TelcoVoiceManager --&gt;|HTTP| TelemetryService\n    TelcoVoiceManager --&gt;|WebPA| WebConfigService\n    TelcoVoiceManager --&gt;|Sysevent| NetworkServices\n    TelcoVoiceManager --&gt;|File I/O| StorageServices\n    TelcoVoiceManager --&gt;|System calls| SystemServices\n    TelcoVoiceManager --&gt;|JSON/TCP| VoiceHAL</code></pre>"},{"location":"review/TelcoVoiceManager/#ipc-mechanism","title":"IPC Mechanism","text":"Type of IPC Message Format Mechanism DBus CCSP standard message format with parameter names, values, and types encoded as DBus variants CCSP Message Bus for TR-181 parameter operations and component communication JSON over TCP JSON-RPC style messages with action, parameters, and response fields defined by HAL schema Voice HAL interface for vendor voice stack communication HTTP POST JSON payload with telemetry data, timestamps, and metadata following RDK telemetry schema Telemetry reporting to collection services Sysevent Key-value pairs for network events with interface names and status information Network interface and firewall rule monitoring <pre><code>sequenceDiagram\n    participant CCMClient as CCSP Client\n    participant TelcoVoiceMgr as Telco Voice Manager  \n    participant VoiceHAL as Voice HAL Server\n    participant TelemetryAgent as Telemetry Agent\n\n    CCMClient-&gt;&gt;TelcoVoiceMgr: DBus SetParameterValues\n    Note over CCMClient,TelcoVoiceMgr: CCSP standard parameter format\n\n    TelcoVoiceMgr-&gt;&gt;VoiceHAL: JSON setParameters request\n    Note over TelcoVoiceMgr,VoiceHAL: {\"action\":\"setParameters\",\"parameters\":[...]}\n\n    VoiceHAL--&gt;&gt;TelcoVoiceMgr: JSON response\n    Note over VoiceHAL,TelcoVoiceMgr: {\"result\":\"success\",\"status\":0}\n\n    TelcoVoiceMgr--&gt;&gt;CCMClient: DBus response\n\n    TelcoVoiceMgr-&gt;&gt;TelemetryAgent: HTTP POST telemetry\n    Note over TelcoVoiceMgr,TelemetryAgent: Voice statistics JSON payload</code></pre>"},{"location":"review/TelcoVoiceManager/#tr181-data-models","title":"TR\u2011181 Data Models","text":"<ul> <li> <p>Implemented Parameters: The component implements TR-104 voice service parameters under the Services.VoiceService hierarchy, including voice profiles, lines, physical interfaces, and capabilities. It also provides custom RDK extensions for enhanced voice management and reporting.</p> </li> <li> <p>Parameter Registration: Parameters are registered through CCSP's component registration mechanism using XML data model definitions. Access is provided via DBus interface with proper validation and access control.</p> </li> <li> <p>Custom Extensions: X_RDK_TelcoVoice namespace for vendor-agnostic configuration, X_RDK_Report.Voice for telemetry reporting, X_RDK_Debug for diagnostic controls, and X_RDK_BoundIfName for interface binding specifications.</p> </li> </ul> Parameter Description Access (R/W) Default Notes <code>Services.VoiceService.{i}.Enable</code> Enable/disable voice service instance R/W <code>false</code> TR-104 standard <code>Services.VoiceService.{i}.VoiceProfile.{i}.Line.{i}.Enable</code> Enable/disable voice line R/W <code>Disabled</code> TR-104 standard <code>Services.VoiceService.{i}.VoiceProfile.{i}.Line.{i}.DirectoryNumber</code> Phone number assignment R/W <code>\"\"</code> TR-104 standard <code>Services.VoiceService.{i}.VoiceProfile.{i}.Line.{i}.SIP.AuthUserName</code> SIP authentication username R/W <code>\"\"</code> TR-104 standard <code>Services.VoiceService.{i}.PhyInterface.{i}.Description</code> Physical interface description R Platform-specific TR-104 standard <code>Services.VoiceService.{i}.Capabilities.MaxLineCount</code> Maximum supported lines R Platform-specific TR-104 standard <code>X_RDK_TelcoVoice.Data</code> Bulk configuration data in JSON format R/W <code>\"\"</code> RDK custom <code>X_RDK_TelcoVoice.DatamodelVersion</code> Supported TR-104 version R <code>\"1.0\"</code> or <code>\"2.0\"</code> RDK custom <code>Services.X_RDK_Report.Voice.Enabled</code> Enable voice telemetry reporting R/W <code>false</code> RDK custom <code>Services.X_RDK_Report.Voice.ReportingPeriod</code> Telemetry reporting interval in seconds R/W <code>300</code> RDK custom"},{"location":"review/TelcoVoiceManager/#implementation-details","title":"Implementation Details","text":"<ul> <li> <p>Key Algorithms or Logic: The component implements a state machine for voice service lifecycle management, with states including Uninitialized, Initializing, Enabled, and Disabled. Configuration validation algorithms ensure TR-104 compliance and parameter consistency. The HAL communication layer uses JSON-RPC style messaging with retry logic and timeout handling. Main implementation resides in <code>telcovoicemgr_controller.c</code>, <code>telcovoicemgr_dml_hal.c</code>, and version-specific files under middle_layer_src.</p> </li> <li> <p>Error Handling Strategy: Errors are detected through parameter validation, HAL communication timeouts, and service health monitoring. All errors are logged using CCSP tracing with appropriate severity levels. Critical errors trigger service restart through CCSP's watchdog mechanism, while recoverable errors are handled through retry logic and graceful degradation.</p> </li> <li> <p>Logging &amp; Debugging: Logging uses CCSP trace categories including CCSP_TRACE_LEVEL_INFO, CCSP_TRACE_LEVEL_WARNING, and CCSP_TRACE_LEVEL_ERROR. Debug controls are available through X_RDK_Debug parameters for module-specific log levels. Voice call debugging is supported through CCTKTraceGroup and CCTKTraceLevel parameters.</p> </li> </ul>"},{"location":"review/TelcoVoiceManager/#key-configuration-files","title":"Key Configuration Files","text":"Configuration File Purpose Key Parameters Default Values Override Mechanisms <code>telcovoice_config_default.json</code> Default voice service configuration <code>VoiceServiceIndex</code>, <code>VoiceProfile</code>, <code>Line</code> settings Service disabled, no lines configured WebConfig, TR-181 parameters <code>telcovoice_config_default_v2.json</code> TR-104 v2 default configuration Enhanced VoIP profiles, codec settings Advanced codec support enabled WebConfig, TR-181 parameters <code>telcovoice_manager_conf.json</code> HAL client configuration HAL server endpoint, timeout values localhost:8080, 30s timeout Environment variables, build flags <code>RdkTelcoVoiceManager_v1.xml</code> TR-181 data model definition for v1 Parameter definitions, access controls Standard TR-104 v1 parameters Build-time configuration <code>RdkTelcoVoiceManager_v2.xml</code> TR-181 data model definition for v2 Enhanced parameter set, new objects Standard TR-104 v2 parameters Build-time configuration <code>telcovoice_hal_schema_v1.json</code> HAL interface schema validation JSON message format, parameter types Schema version 0.0.1 HAL server implementation"},{"location":"review/Utopia/","title":"Utopia Documentation","text":"<p>Utopia is a foundational middleware component in the RDK-B stack that provides essential network services and configuration management for broadband gateway devices. It serves as the core infrastructure layer that manages network services, firewall operations, system events, and device configuration through a unified framework. Utopia acts as the bridge between higher-level CCSP components and the underlying Linux system, providing standardized APIs and event-driven service management. The component integrates tightly with the RDK-B ecosystem by offering system configuration storage (syscfg), inter-process communication via system events (sysevent), and orchestrating various network services like DHCP, firewall, routing, and multi-network management.</p> <p>Key Features &amp; Responsibilities</p> <ul> <li>System Configuration Management: Provides persistent configuration storage and retrieval through the syscfg subsystem with key-value pair storage and transaction support</li> <li>Event-Driven Service Orchestration: Manages inter-process communication and service coordination through the sysevent messaging system with publish-subscribe patterns</li> <li>Network Service Management: Orchestrates core networking services including DHCP server/client, IPv4/IPv6 configuration, and multi-network interface management</li> <li>Firewall and Security Services: Implements comprehensive iptables-based firewall management with rule generation, port forwarding, and security policy enforcement</li> <li>Service Lifecycle Management: Provides unified service management with start/stop/restart capabilities, dependency tracking, and health monitoring</li> <li>Platform Abstraction Layer: Offers hardware abstraction through PAL (Platform Abstraction Layer) for device-specific implementations</li> </ul>"},{"location":"review/Utopia/#design","title":"Design","text":"<p>Utopia follows a modular, event-driven architecture that emphasizes separation of concerns and service autonomy. The design is built around three core principles: configuration management through syscfg for persistent storage, event coordination through sysevent for inter-process communication, and service management for orchestrating network operations. The architecture promotes loose coupling between services through well-defined APIs and message passing, enabling independent service lifecycle management and fault isolation. Modularity is achieved through separate service executables that can be started, stopped, and restarted independently without affecting the entire system. Reliability is ensured through persistent configuration storage, service health monitoring, and automatic service recovery mechanisms. The design emphasizes maintainability through clear service boundaries, standardized configuration interfaces, and comprehensive logging throughout all subsystems.</p> <p>Each service in utopia operates as an independent process that communicates through the sysevent bus, allowing for horizontal scaling and fault tolerance. Configuration data is centralized in syscfg but accessed through well-defined APIs that abstract storage implementation details. Security is integrated at multiple layers including firewall rule management, access control through service boundaries, and secure configuration handling.</p> <p>A container diagram of the component is given below</p> <pre><code>graph TD\n    subgraph Runtime [\"Linux Runtime Environment\"]\n        subgraph UtopiaContainer [\"Utopia Container\"]\n            Syseventd[Sysevent Daemon&lt;br/&gt;IPC Message Bus]\n            SyscfgLib[Syscfg Library&lt;br/&gt;Configuration Storage]\n            ServiceDHCP[Service DHCP&lt;br/&gt;DHCP Server Management]\n            ServiceFirewall[Service Firewall&lt;br/&gt;iptables Management]\n            ServiceMultinet[Service Multinet&lt;br/&gt;Multi-network Support]\n            ServiceWAN[Service WAN&lt;br/&gt;WAN Configuration]\n            ServiceRouted[Service Routed&lt;br/&gt;Routing Management]\n            UtilLib[Utility Libraries&lt;br/&gt;Common Functions]\n        end\n        subgraph LinuxKernel [\"Linux Kernel\"]\n            Netfilter[(Netfilter/iptables)]\n            NetworkStack[(Network Stack)]\n            FileSystem[(File System)]\n        end\n    end\n\n    Syseventd --&gt;|TCP/UDS| ServiceDHCP\n    Syseventd --&gt;|TCP/UDS| ServiceFirewall\n    Syseventd --&gt;|TCP/UDS| ServiceMultinet\n    ServiceFirewall --&gt;|System Calls| Netfilter\n    ServiceDHCP --&gt;|Socket API| NetworkStack\n    SyscfgLib --&gt;|File I/O| FileSystem\n    ServiceDHCP --&gt;|Library Calls| SyscfgLib\n    ServiceFirewall --&gt;|Library Calls| SyscfgLib\n\n    classDef service fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef library fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n    classDef kernel fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n\n    class Syseventd,ServiceDHCP,ServiceFirewall,ServiceMultinet,ServiceWAN,ServiceRouted service;\n    class SyscfgLib,UtilLib library;\n    class Netfilter,NetworkStack,FileSystem kernel;</code></pre> <p>Request Flow Sequence</p> <p>When a service needs to be started, the request flows through sysevent messaging where the service manager receives the start event, validates dependencies through syscfg configuration, initializes the target service process, and updates service status through sysevent notifications.</p> <pre><code>sequenceDiagram\n    participant Client as Client Process\n    participant Sysevent as Sysevent Daemon\n    participant SvcMgr as Service Manager\n    participant Service as Target Service\n    participant Syscfg as Syscfg Library\n\n    Client-&gt;&gt;Sysevent: sysevent_set(\"service_start\", \"dhcp\")\n    Sysevent-&gt;&gt;SvcMgr: Event Notification\n    SvcMgr-&gt;&gt;Syscfg: Read service configuration\n    Syscfg--&gt;&gt;SvcMgr: Configuration data\n    SvcMgr-&gt;&gt;Service: Start service process\n    Service-&gt;&gt;Syscfg: Initialize from config\n    Service-&gt;&gt;Sysevent: Register event handlers\n    Service--&gt;&gt;SvcMgr: Startup confirmation\n    SvcMgr-&gt;&gt;Sysevent: sysevent_set(\"service_status\", \"started\")\n    Sysevent--&gt;&gt;Client: Event completion</code></pre> <p>Threading Model</p> <p>The Utopia framework utilizes a multi-process architecture, with the following threading and concurrency model:</p> <ul> <li>Independent Services: Each service runs as a separate single-threaded process, enabling process isolation and fault containment</li> <li>Sysevent Daemon: Operates as an event-driven loop using <code>select()</code> or <code>poll()</code> to handle multiple client connections concurrently</li> <li>Service Processes: Typically single-threaded and event-driven, responding to <code>sysevent</code> notifications and dynamic configuration changes</li> <li>On-Demand Worker Threads: Spawned for specific tasks such as file I/O in <code>syscfg</code> or network operations within services; these threads are short-lived and used sparingly</li> <li>Firewall Service: May fork temporary worker processes to handle complex iptables rule generation for improved parallelism and reliability</li> </ul> <p>Thread Synchronization: Generally unnecessary due to the isolated, single-threaded design of most processes. Concurrency is managed at the process level, ensuring robustness and responsiveness without shared-state complexity.</p>"},{"location":"review/Utopia/#internal-modules","title":"Internal Modules","text":"<p>Utopia is organized into several key subsystems that provide different aspects of system and network management functionality. The sysevent subsystem handles all inter-process communication and event coordination. The syscfg subsystem manages persistent configuration storage and retrieval. Network services handle protocol-specific operations like DHCP, routing, and firewall management.</p> Module/Class Description Key Files Sysevent Inter-process communication bus for event messaging and service coordination <code>source/sysevent/lib/libsysevent.c</code>, <code>source/sysevent/server/syseventd.c</code> Syscfg Persistent configuration management with key-value storage and transaction support <code>source/syscfg/lib/syscfg.c</code>, <code>source/syscfg/cmd/syscfg_cmd.c</code> Service DHCP DHCP server and client management with lease tracking and configuration <code>source/service_dhcp/service_dhcp.c</code>, <code>source/service_dhcp/dhcp_server_functions.c</code> Service Firewall iptables-based firewall management with rule generation and policy enforcement <code>source/firewall/firewall.c</code>, <code>source/firewall/firewall_ext.c</code> Service Multinet Multi-network interface management for complex network topologies <code>source/service_multinet/service_multinet_lib.c</code>, <code>source/service_multinet/service_multinet_handler.c</code> Service Manager Central service lifecycle management and dependency coordination <code>source/services/lib/srvmgr.c</code> Utility Libraries Common functions for logging, RPC, and system utilities <code>source/util/utils/util.c</code>, <code>source/ulog/ulog.c</code> <pre><code>flowchart TD\n    subgraph Utopia\n        Sysevent([Sysevent IPC Bus])\n        Syscfg([Syscfg Storage])\n        SvcMgr([Service Manager])\n\n        subgraph NetworkServices\n            DHCP([DHCP Service])\n            Firewall([Firewall Service])\n            Multinet([Multinet Service])\n            WAN([WAN Service])\n            Routed([Routed Service])\n        end\n\n        subgraph Utilities\n            ULog([Logging])\n            RPC([RPC Framework])\n            Utils([Utility Functions])\n        end\n    end\n\n    SvcMgr --&gt; Sysevent\n    NetworkServices --&gt; Sysevent\n    NetworkServices --&gt; Syscfg\n    Utilities --&gt; Sysevent\n    Utilities --&gt; Syscfg\n\n    classDef core fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef network fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;\n    classDef utility fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n\n    class Sysevent,Syscfg,SvcMgr core;\n    class DHCP,Firewall,Multinet,WAN,Routed network;\n    class ULog,RPC,Utils utility;</code></pre>"},{"location":"review/Utopia/#interaction-with-other-middleware-components","title":"Interaction with Other Middleware Components","text":"<p>Utopia integrates extensively with other RDK-B components through well-defined interfaces and protocols. It provides foundational services that higher-level components depend on for network configuration and system event handling.</p> <pre><code>flowchart TD\n    Utopia --&gt;|DBus Messages| CcspPaM[CCSP P&amp;M]\n    Utopia --&gt;|DBus Messages| CcspTr069[CCSP TR-069]\n    Utopia --&gt;|Configuration Events| WebPA[WebPA Agent]\n    Utopia --&gt;|Network Status| WifiAgent[WiFi Agent]\n    Utopia --&gt;|Service Events| HAL[Hardware Abstraction Layer]\n    Utopia --&gt;|System Events| Telemetry[RDK Telemetry]\n\n    classDef utopia fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef rdkb fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;\n\n    class Utopia utopia;\n    class CcspPaM,CcspTr069,WebPA,WifiAgent,HAL,Telemetry rdkb;</code></pre> Component Purpose of Interaction Protocols/Mechanisms CCSP P&amp;M Device configuration management and TR-181 parameter access DBus method calls, sysevent notifications CCSP TR-069 Remote management and configuration synchronization DBus messages, syscfg parameter updates WebPA Agent Real-time configuration updates and device management HTTP notifications, sysevent triggers WiFi Agent Network interface coordination and wireless configuration Sysevent messages, shared configuration Hardware Abstraction Layer Platform-specific network and system operations Function calls, configuration files RDK Telemetry System health monitoring and performance metrics Event notifications, log messages <p>Utopia publishes several key events that other components can subscribe to for coordination and monitoring purposes:</p> Event Purpose of Event Reason for trigger <code>service_start</code> Service lifecycle management Request to start a specific system service <code>service_stop</code> Service lifecycle management Request to stop a running system service <code>firewall-restart</code> Firewall rule updates Configuration changes requiring rule regeneration <code>dhcp_client_restart</code> DHCP client renewal WAN configuration changes or lease expiration <code>lan_status_change</code> Network interface updates LAN interface up/down state changes <code>wan_status_change</code> WAN connectivity updates Internet connection status changes <code>syscfg_commit</code> Configuration persistence Commit pending configuration changes to storage"},{"location":"review/Utopia/#interaction-with-other-layers","title":"Interaction with Other Layers","text":"<p>Utopia interfaces with multiple system layers to provide comprehensive network and system management functionality. It abstracts hardware-specific operations through the PAL layer while interfacing directly with Linux kernel services.</p> Layer/Service Interaction Description Mechanism PAL (Platform Abstraction Layer) Hardware-specific network and system operations Function calls, shared libraries Linux Kernel Network stack operations, netfilter rules, file system access System calls, proc/sys filesystem DBus System Inter-component communication with CCSP stack DBus method calls, signal broadcasts External Services Integration with upstream providers and cloud services HTTP/HTTPS, TCP/UDP sockets <pre><code>graph TD\n    subgraph \"Application Layer\"\n        CCSP[CCSP Components]\n        WebPA[WebPA Agent]\n        Management[Management Apps]\n    end\n\n    subgraph \"Middleware Layer\"\n        Utopia[Utopia Services]\n        DBusLayer[DBus System Bus]\n    end\n\n    subgraph \"Platform Layer\"\n        PAL[Platform Abstraction Layer]\n        HAL[Hardware Abstraction Layer]\n    end\n\n    subgraph \"Kernel Layer\"\n        LinuxKernel[Linux Kernel]\n        Netfilter[Netfilter/iptables]\n        NetworkStack[Network Stack]\n    end\n\n    CCSP &lt;--&gt;|DBus Messages| DBusLayer\n    WebPA &lt;--&gt;|HTTP/Events| Utopia\n    Management &lt;--&gt;|Configuration| Utopia\n\n    Utopia &lt;--&gt;|Service Calls| PAL\n    Utopia &lt;--&gt;|System Calls| LinuxKernel\n    Utopia &lt;--&gt;|iptables Rules| Netfilter\n    Utopia &lt;--&gt;|Socket API| NetworkStack\n\n    PAL --&gt; HAL\n    HAL --&gt; LinuxKernel\n\n    classDef app fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n    classDef middleware fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef platform fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;\n    classDef kernel fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n\n    class CCSP,WebPA,Management app;\n    class Utopia,DBusLayer middleware;\n    class PAL,HAL platform;\n    class LinuxKernel,Netfilter,NetworkStack kernel;</code></pre>"},{"location":"review/Utopia/#ipc-mechanism","title":"IPC Mechanism","text":"Type of IPC Message Format Mechanism Sysevent Messaging Text-based key-value pairs with event names and data payloads. Format: \"event_name key=value key2=value2\" TCP sockets on localhost:18667 or Unix domain sockets for local communication DBus Integration DBus XML introspection format with method calls, properties, and signals for CCSP integration Standard DBus system bus with registered service names and object paths Syscfg Storage Key-value pairs stored in binary format with transaction logs and atomic updates Direct file I/O with locking mechanisms and backup/recovery support <pre><code>sequenceDiagram\n    participant Client as Client Process\n    participant Syseventd as Sysevent Daemon\n    participant ServiceA as Service A\n    participant ServiceB as Service B\n    participant Syscfg as Syscfg Storage\n\n    Client-&gt;&gt;Syseventd: sysevent_set(\"lan_status\", \"up\")\n    Syseventd-&gt;&gt;ServiceA: Event notification (lan_status=up)\n    Syseventd-&gt;&gt;ServiceB: Event notification (lan_status=up)\n\n    ServiceA-&gt;&gt;Syscfg: syscfg_get(\"dhcp_enabled\")\n    Syscfg--&gt;&gt;ServiceA: Configuration value\n\n    ServiceA-&gt;&gt;Syseventd: sysevent_set(\"dhcp_restart\", \"1\")\n    Syseventd-&gt;&gt;ServiceB: Event notification (dhcp_restart=1)\n\n    ServiceB--&gt;&gt;Syseventd: Service action completed\n    ServiceB-&gt;&gt;Syscfg: syscfg_set(\"service_status\", \"running\")</code></pre>"},{"location":"review/Utopia/#implementation-details","title":"Implementation Details","text":"<ul> <li>Key Algorithms or Logic: The sysevent system uses a publish-subscribe pattern with event registration and notification queues implemented in <code>source/sysevent/lib/libsysevent.c</code>. The firewall service employs rule generation algorithms that parse configuration data and generate iptables commands in <code>source/firewall/firewall.c</code>. Service dependency management uses a state machine approach in <code>source/services/lib/srvmgr.c</code> for orchestrating service startup sequences.</li> <li>Error Handling Strategy: Errors are detected through return code checking, logged via the ulog subsystem, and propagated through sysevent error notifications. Critical errors trigger service restart mechanisms while configuration errors are logged and reported to management interfaces.</li> <li>Logging &amp; Debugging: The ulog subsystem provides categorized logging with levels (ERROR, WARN, INFO, DEBUG) and module-specific tags. Debug information is available through runtime flags and can be enabled per service or globally through syscfg configuration.</li> </ul>"},{"location":"review/Utopia/#key-configuration-files","title":"Key Configuration Files","text":"Configuration File Purpose Key Parameters Default Values Override Mechanisms <code>/etc/utopia/system_defaults</code> System default configuration parameters <code>device_mode</code>, <code>lan_ifname</code>, <code>wan_proto</code> <code>router</code>, <code>brlan0</code>, <code>dhcp</code> Environment variables, command line <code>/etc/syscfg.db</code> Persistent configuration storage <code>dhcp_start</code>, <code>dhcp_num</code>, <code>firewall_enabled</code> <code>100</code>, <code>50</code>, <code>1</code> Syscfg API, web interface <code>/var/lib/utopia/service.conf</code> Service configuration and state Service definitions, dependencies, startup order Service-specific Sysevent messages <code>/etc/utopia/registration.d/</code> Service registration scripts Service handlers, event mappings Per-service scripts Manual script updates"},{"location":"review/VLANManager/","title":"VLAN Manager Documentation","text":"<p>The VLAN Manager is the RDK-B component responsible for managing VLAN termination and Ethernet link configuration. It provides comprehensive VLAN bridging capabilities, enabling network segmentation and traffic isolation through IEEE 802.1Q VLAN tagging. The component serves as the central management point for all VLAN-related operations, including VLAN interface creation, configuration, and monitoring. It integrates seamlessly with the RDK-B TR-181 data model to expose VLAN parameters for external management and configuration. The VLAN Manager abstracts underlying hardware-specific VLAN implementations through a standardized HAL interface, ensuring portability across different hardware platforms.</p> <pre><code>graph TD\n    subgraph External [\"External Systems &amp; Users\"]\n        TR069[TR-069 ACS&lt;br/&gt;Auto Configuration Server]\n        WebUI[Web Management UI&lt;br/&gt;Device Configuration]\n        CLI[Command Line Interface&lt;br/&gt;Local Management]\n        SNMP[SNMP Manager&lt;br/&gt;Network Monitoring]\n    end\n\n    subgraph RDKBSystem [\"RDK-B Gateway System\"]\n        VLANManager[VLAN Manager&lt;br/&gt;IEEE 802.1Q VLAN Management]\n\n        subgraph MiddlewareComponents [\"RDK-B Middleware\"]\n            NetworkMgr[Network Manager&lt;br/&gt;Interface Coordination]\n            PSM[Platform Storage Manager&lt;br/&gt;Configuration Persistence]\n            TelemetryAgent[Telemetry Agent&lt;br/&gt;Metrics Collection]\n            CCSP[CCSP Framework&lt;br/&gt;Message Bus &amp; Lifecycle]\n        end\n\n        subgraph HardwareLayer [\"Hardware &amp; Platform\"]\n            EthernetHAL[Ethernet/VLAN HAL&lt;br/&gt;Hardware Abstraction]\n            LinuxKernel[Linux Network Stack&lt;br/&gt;VLAN Devices &amp; Bridges]\n            EthernetHW[Ethernet Hardware&lt;br/&gt;Switch/NIC Ports]\n        end\n    end\n\n    TR069 --&gt;|TR-181 Parameters&lt;br/&gt;CWMP Protocol| VLANManager\n    WebUI --&gt;|HTTP/HTTPS Requests&lt;br/&gt;TR-181 Parameters| VLANManager\n    CLI --&gt;|Local Commands&lt;br/&gt;Direct Parameter Access| VLANManager\n    SNMP --&gt;|SNMP Queries&lt;br/&gt;Status Monitoring| VLANManager\n\n    VLANManager &lt;--&gt;|Configuration Events&lt;br/&gt;DBus Messages| NetworkMgr\n    VLANManager &lt;--&gt;|Persistent Storage&lt;br/&gt;DBus API| PSM\n    VLANManager --&gt;|Performance Metrics&lt;br/&gt;Telemetry Events| TelemetryAgent\n    VLANManager &lt;--&gt;|Component Lifecycle&lt;br/&gt;DBus/CCSP| CCSP\n\n    VLANManager --&gt;|JSON HAL Protocol&lt;br/&gt;VLAN Operations| EthernetHAL\n    EthernetHAL --&gt;|System Calls&lt;br/&gt;Netlink Messages| LinuxKernel\n    LinuxKernel --&gt;|Device Drivers&lt;br/&gt;Hardware Control| EthernetHW\n\n    classDef external fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;\n    classDef vlanmgr fill:#e1f5fe,stroke:#0277bd,stroke-width:3px;\n    classDef middleware fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n    classDef hardware fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n\n    class TR069,WebUI,CLI,SNMP external;\n    class VLANManager vlanmgr;\n    class NetworkMgr,PSM,TelemetryAgent,CCSP middleware;\n    class EthernetHAL,LinuxKernel,EthernetHW hardware;</code></pre> <p>Key Features &amp; Responsibilities</p> <ul> <li>VLAN Termination Management: Creates, configures, and manages VLAN interfaces with IEEE 802.1Q tagging support, including VLAN ID assignment and TPID configuration</li> <li>Ethernet Link Configuration: Manages Ethernet link properties including enable/disable states, MAC address configuration, priority tagging, and lower layer associations</li> <li>TR-181 Data Model Integration: Implements X_RDK_Ethernet.Link and X_RDK_Ethernet.VLANTermination objects providing standardized parameter access for external management systems</li> <li>HAL Abstraction: Provides hardware-independent VLAN operations through JSON-based HAL communication protocol with vendor-specific implementations</li> <li>PSM Database Integration: Maintains persistent storage of VLAN configurations using Platform Storage Manager (PSM) for configuration persistence across reboots</li> <li>Telemetry and Monitoring: Generates telemetry events for VLAN interface lifecycle operations and provides real-time status monitoring capabilities</li> </ul>"},{"location":"review/VLANManager/#design","title":"Design","text":"<p>The VLAN Manager follows a layered architecture approach with clear separation between the TR-181 data model interface, business logic, and hardware abstraction layers. The design emphasizes modularity by separating Ethernet link management from VLAN termination logic, allowing independent operation and configuration of each component. Scalability is achieved through dynamic table management supporting up to 128 VLAN interfaces and Ethernet links per the TR-181 specification. The component ensures reliability through atomic parameter operations following TR-69 specifications, where all parameter changes are validated before commitment. Security is maintained through controlled access to VLAN operations via the CCSP message bus, ensuring only authorized components can modify network configurations. Maintainability is supported through clear API boundaries, comprehensive logging, and standardized HAL interfaces that facilitate hardware vendor integration.</p> <p>The design establishes clear boundaries between the VLAN Manager and other RDK-B components through well-defined interfaces. The TR-181 interface boundary handles all external parameter access and management operations. The HAL boundary provides hardware abstraction for VLAN and Ethernet operations. The PSM boundary manages persistent configuration storage and retrieval. Each boundary has specific responsibilities: the TR-181 boundary validates parameters and maintains data model consistency, the HAL boundary translates generic operations to hardware-specific commands, and the PSM boundary ensures configuration persistence and backup/restore capabilities.</p> <p>A container diagram of the component is given below</p> <pre><code>graph TD\n    subgraph Runtime [\"RDK-B Middleware Runtime (Linux)\"]\n        subgraph VlanManagerContainer [\"VLAN Manager Container\"]\n            SSPMain[SSP Main Process&lt;br/&gt;ssp_main.c]\n            TR181Layer[TR-181 Data Model Layer&lt;br/&gt;vlan_dml.c, ethernet_dml.c]\n            VlanAPIs[VLAN Management APIs&lt;br/&gt;vlan_apis.c]\n            EthAPIs[Ethernet Link APIs&lt;br/&gt;ethernet_apis.c]\n            HALInterface[HAL Interface Layer&lt;br/&gt;vlan_eth_hal.c]\n        end\n        subgraph PSM [\"PSM Database (syscfg)\"]\n            ConfigDB[(Configuration Storage)]\n        end\n        subgraph HALVendor [\"Vendor HAL Implementation\"]\n            VendorHAL[Ethernet/VLAN HAL&lt;br/&gt;JSON Protocol]\n        end\n    end\n\n    SSPMain --&gt;|Initialize| TR181Layer\n    TR181Layer --&gt;|API Calls| VlanAPIs\n    TR181Layer --&gt;|API Calls| EthAPIs\n    VlanAPIs --&gt;|HAL Calls| HALInterface\n    EthAPIs --&gt;|HAL Calls| HALInterface\n    HALInterface --&gt;|JSON Messages| VendorHAL\n    VlanAPIs --&gt;|Read/Write Config| ConfigDB\n    EthAPIs --&gt;|Read/Write Config| ConfigDB\n\n    classDef component fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef database fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n    classDef external fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n\n    class SSPMain,TR181Layer,VlanAPIs,EthAPIs,HALInterface component;\n    class ConfigDB database;\n    class VendorHAL external;</code></pre> <p>Request Flow Sequence</p> <p>The most critical flow involves VLAN interface creation and configuration. External management systems send TR-181 parameter set requests through the CCSP message bus to the VLAN Manager. The TR-181 layer validates parameters and calls the appropriate VLAN APIs. The VLAN APIs interact with the HAL interface to configure hardware-specific VLAN settings. Configuration changes are persisted to PSM database. Status updates and telemetry events are generated to inform other components of the changes.</p> <pre><code>sequenceDiagram\n    participant Mgmt as Management System\n    participant CCSP as CCSP Message Bus\n    participant TR181 as TR-181 Layer\n    participant VlanAPI as VLAN APIs\n    participant HAL as HAL Interface\n    participant PSM as PSM Database\n    participant Vendor as Vendor HAL\n\n    Mgmt-&gt;&gt;CCSP: SetParameterValues (VLAN Config)\n    CCSP-&gt;&gt;TR181: Set VLAN Parameters\n    TR181-&gt;&gt;TR181: Validate Parameters\n    TR181-&gt;&gt;VlanAPI: Configure VLAN Interface\n    VlanAPI-&gt;&gt;HAL: JSON HAL Request\n    HAL-&gt;&gt;Vendor: Hardware VLAN Config\n    Vendor--&gt;&gt;HAL: Configuration Response\n    HAL--&gt;&gt;VlanAPI: HAL Response\n    VlanAPI-&gt;&gt;PSM: Persist Configuration\n    PSM--&gt;&gt;VlanAPI: Storage Confirmation\n    VlanAPI--&gt;&gt;TR181: Operation Result\n    TR181-&gt;&gt;TR181: Commit Changes\n    TR181--&gt;&gt;CCSP: Parameter Set Response\n    CCSP--&gt;&gt;Mgmt: Success Response</code></pre> <p>Threading Model</p> <p>The VLAN Manager uses a single-threaded model with the following thread allocation:</p> <ul> <li>Main Thread: Handles all TR-181 parameter operations, HAL communications, and PSM database interactions sequentially</li> <li>Inter-Component Communication: Utilizes the CCSP message bus for asynchronous messaging with other RDK-B components, while maintaining all internal processing within the main thread</li> <li>Thread Synchronization: Not required due to the single-threaded design, which ensures atomicity and consistency during VLAN configuration changes</li> </ul>"},{"location":"review/VLANManager/#internal-modules","title":"Internal Modules","text":"<p>The VLAN Manager is organized into distinct modules, each handling specific aspects of VLAN and Ethernet management. The SSP (Service Support Platform) module manages component lifecycle and message bus integration. The TR-181 modules implement the standardized data model interfaces for external access. The API modules contain the core business logic for VLAN and Ethernet operations. The HAL interface module provides hardware abstraction capabilities.</p> Module/Class Description Key Files SSP Main Component initialization, message bus integration, and lifecycle management <code>ssp_main.c</code>, <code>ssp_global.h</code>, <code>ssp_messagebus_interface.c</code> VLAN Data Model TR-181 VLANTermination object implementation with parameter validation and commit/rollback <code>vlan_dml.c</code>, <code>vlan_dml.h</code> Ethernet Data Model TR-181 Ethernet Link object implementation with link management and marking support <code>ethernet_dml.c</code>, <code>ethernet_dml.h</code> VLAN APIs Core VLAN management logic, interface creation/deletion, and configuration persistence <code>vlan_apis.c</code>, <code>vlan_apis.h</code>, <code>vlan_internal.c</code> Ethernet APIs Ethernet link management, MAC address handling, and priority tagging operations <code>ethernet_apis.c</code>, <code>ethernet_apis.h</code>, <code>ethernet_internal.c</code> HAL Interface Hardware abstraction layer for VLAN and Ethernet operations using JSON protocol <code>vlan_eth_hal.c</code>, <code>vlan_eth_hal.h</code> Plugin Main Component registration and plugin initialization for TR-181 integration <code>plugin_main.c</code>, <code>plugin_main_apis.c</code> <pre><code>flowchart TD\n    subgraph VLANManager[\"VLAN Manager Component\"]\n        SSP([SSP Main&lt;br/&gt;Lifecycle &amp; Message Bus])\n        TR181_VLAN([VLAN Data Model&lt;br/&gt;TR-181 Interface])\n        TR181_ETH([Ethernet Data Model&lt;br/&gt;TR-181 Interface])\n        VLAN_API([VLAN APIs&lt;br/&gt;Business Logic])\n        ETH_API([Ethernet APIs&lt;br/&gt;Business Logic])\n        HAL([HAL Interface&lt;br/&gt;Hardware Abstraction])\n        Plugin([Plugin Main&lt;br/&gt;Component Registration])\n    end\n\n    SSP --&gt; TR181_VLAN\n    SSP --&gt; TR181_ETH\n    SSP --&gt; Plugin\n    TR181_VLAN --&gt; VLAN_API\n    TR181_ETH --&gt; ETH_API\n    VLAN_API --&gt; HAL\n    ETH_API --&gt; HAL\n    Plugin --&gt; TR181_VLAN\n    Plugin --&gt; TR181_ETH\n\n    classDef module fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    class SSP,TR181_VLAN,TR181_ETH,VLAN_API,ETH_API,HAL,Plugin module;</code></pre>"},{"location":"review/VLANManager/#interaction-with-other-middleware-components","title":"Interaction with Other Middleware Components","text":"<p>The VLAN Manager interacts with several RDK-B middleware components to provide comprehensive VLAN management capabilities. It communicates with the Platform Storage Manager (PSM) for configuration persistence, the CCSP Common Resource Locator (CRL) for component discovery, and various network management components for coordinated network operations.</p> <pre><code>flowchart LR\n    VLANManager --&gt;|DBus/CCSP| PSM[Platform Storage Manager]\n    VLANManager --&gt;|DBus/CCSP| CRL[CCSP Common Resource Locator]\n    VLANManager --&gt;|DBus Events| NetworkManager[Network Manager]\n    VLANManager --&gt;|Telemetry Events| TelemetryAgent[Telemetry Agent]\n    VLANManager --&gt;|JSON HAL| VendorHAL[Vendor HAL Implementation]\n\n    classDef vlanmgr fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef rdkb fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n    classDef external fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n\n    class VLANManager vlanmgr;\n    class PSM,CRL,NetworkManager,TelemetryAgent rdkb;\n    class VendorHAL external;</code></pre> Component Purpose of Interaction Protocols/Mechanisms Platform Storage Manager (PSM) Persistent storage of VLAN configurations, backup and restore operations DBus/CCSP message bus CCSP Common Resource Locator (CRL) Component discovery and registration within the CCSP framework DBus/CCSP message bus Network Manager Coordination of network interface operations and status updates DBus events and notifications Telemetry Agent Collection of VLAN operation metrics and performance data Telemetry event publishing Vendor HAL Implementation Hardware-specific VLAN and Ethernet operations JSON-based HAL protocol <p>The VLAN Manager publishes several events to notify other components of significant VLAN operations and state changes. These events enable coordinated network management and monitoring across the RDK-B stack.</p> Event Purpose of Event Reason for trigger RDKB_VLAN_CREATE VLAN interface creation notification Triggered when a new VLAN interface is successfully created and configured RDKB_VLAN_DELETE VLAN interface deletion notification Triggered when a VLAN interface is removed from the system VLAN_STATUS_CHANGE VLAN interface status update Triggered when VLAN interface status changes (Up/Down/Error states) ETHERNET_LINK_STATE Ethernet link state change notification Triggered when underlying Ethernet link status changes affecting VLAN operations"},{"location":"review/VLANManager/#interaction-with-other-layers","title":"Interaction with Other Layers","text":"<p>The VLAN Manager operates within a layered architecture, interacting with multiple system layers to provide comprehensive VLAN management capabilities. It abstracts hardware-specific operations through the HAL layer while integrating with platform services for persistence and system-level operations.</p> Layer/Service Interaction Description Mechanism HAL (Hardware Abstraction Layer) Hardware-specific VLAN and Ethernet operations including interface creation, VLAN tagging, and status monitoring JSON-based message protocol over sockets Platform Layer (Linux Kernel) Network interface management, VLAN device creation, and system-level network operations System calls and netlink sockets via HAL Storage Layer (PSM/syscfg) Persistent configuration storage, backup/restore operations, and default value management DBus API calls to PSM daemon CCSP Framework Component lifecycle management, message bus communication, and inter-component coordination DBus/CCSP message bus protocol <pre><code>graph TD\n    subgraph ApplicationLayer [\"Application Layer\"]\n        ManagementApps[Management Applications&lt;br/&gt;TR-069, WebUI, CLI]\n    end\n\n    subgraph MiddlewareLayer [\"RDK-B Middleware Layer\"]\n        VLANManager[VLAN Manager&lt;br/&gt;TR-181 Data Model]\n        OtherComponents[Other RDK-B Components&lt;br/&gt;Network Manager, etc.]\n        CCSP[CCSP Framework&lt;br/&gt;Message Bus]\n    end\n\n    subgraph HALLayer [\"Hardware Abstraction Layer\"]\n        EthVLANHAL[Ethernet/VLAN HAL&lt;br/&gt;JSON Protocol]\n    end\n\n    subgraph PlatformLayer [\"Platform Layer\"]\n        LinuxKernel[Linux Kernel&lt;br/&gt;Network Stack, VLAN Devices]\n        PSM[Platform Storage Manager&lt;br/&gt;Configuration Database]\n    end\n\n    subgraph HardwareLayer [\"Hardware Layer\"]\n        EthernetHW[Ethernet Hardware&lt;br/&gt;Switch/NIC]\n    end\n\n    ManagementApps --&gt;|TR-181 Parameters| VLANManager\n    VLANManager &lt;--&gt;|DBus/CCSP| CCSP\n    VLANManager &lt;--&gt;|DBus| PSM\n    VLANManager &lt;--&gt;|Events/Notifications| OtherComponents\n    VLANManager --&gt;|JSON HAL Messages| EthVLANHAL\n    EthVLANHAL --&gt;|System Calls/Netlink| LinuxKernel\n    LinuxKernel --&gt;|Device Drivers| EthernetHW\n\n    classDef application fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;\n    classDef middleware fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef hal fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n    classDef platform fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n    classDef hardware fill:#fce4ec,stroke:#c2185b,stroke-width:2px;\n\n    class ManagementApps application;\n    class VLANManager,OtherComponents,CCSP middleware;\n    class EthVLANHAL hal;\n    class LinuxKernel,PSM platform;\n    class EthernetHW hardware;</code></pre>"},{"location":"review/VLANManager/#ipc-mechanism","title":"IPC Mechanism","text":"Type of IPC Message Format Mechanism DBus/CCSP Message Bus XML-encoded messages with parameter names, values, and types following CCSP protocol specification DBus API calls for inter-component communication within RDK-B middleware JSON HAL Protocol JSON-formatted messages containing action types, parameters, and responses defined by HAL schema TCP sockets or Unix domain sockets for HAL communication with vendor implementations PSM Database Access Key-value pairs with hierarchical naming convention (dmsb.vlanmanager.*) for configuration parameters DBus API calls to PSM daemon for persistent storage operations <pre><code>sequenceDiagram\n    participant Client as Management Client\n    participant CCSP as CCSP Message Bus\n    participant VLANMgr as VLAN Manager\n    participant PSM as PSM Database\n    participant HAL as Vendor HAL\n\n    Client-&gt;&gt;CCSP: SetParameterValues Request&lt;br/&gt;(XML/CCSP Format)\n    CCSP-&gt;&gt;VLANMgr: Parameter Set Message&lt;br/&gt;(DBus Protocol)\n    VLANMgr-&gt;&gt;VLANMgr: Validate Parameters\n    VLANMgr-&gt;&gt;PSM: Store Configuration&lt;br/&gt;(DBus Key-Value)\n    PSM--&gt;&gt;VLANMgr: Storage Confirmation\n    VLANMgr-&gt;&gt;HAL: Configure Hardware&lt;br/&gt;(JSON HAL Message)\n    HAL--&gt;&gt;VLANMgr: Operation Response&lt;br/&gt;(JSON Format)\n    VLANMgr--&gt;&gt;CCSP: Parameter Set Response&lt;br/&gt;(DBus Protocol)\n    CCSP--&gt;&gt;Client: SetParameterValues Response&lt;br/&gt;(XML/CCSP Format)</code></pre>"},{"location":"review/VLANManager/#tr181-data-models","title":"TR\u2011181 Data Models","text":"<ul> <li> <p>Implemented Parameters: The VLAN Manager implements the X_RDK_Ethernet object tree including Link and VLANTermination sub-objects. The Link object manages Ethernet interface properties while VLANTermination handles VLAN-specific configurations. Parameters include interface enable/disable states, VLAN ID assignment, TPID configuration, MAC address settings, and priority tagging options.</p> </li> <li> <p>Parameter Registration: Parameters are registered through the CCSP framework using TR-181 XML definitions. The component registers with the CCSP Common Resource Locator (CRL) and exposes parameters via DBus interface. Parameter access is controlled through the CCSP message bus with appropriate access permissions.</p> </li> <li> <p>Custom Extensions: X_RDK_BaseInterface parameter provides hardware-specific interface mapping for vendor implementations. X_RDK_Marking object enables traffic marking and quality of service configurations. X_RDK_Refresh parameter triggers interface state synchronization with underlying hardware.</p> </li> </ul> Parameter Description Access (R/W) Default Notes <code>Device.X_RDK_Ethernet.Link.{i}.Enable</code> Enable/disable Ethernet link interface R/W <code>false</code> Controls interface operational state <code>Device.X_RDK_Ethernet.Link.{i}.Status</code> Current operational status of the link R <code>Down</code> Up/Down/Unknown/Dormant/NotPresent/LowerLayerDown/Error <code>Device.X_RDK_Ethernet.Link.{i}.Alias</code> User-friendly name for the interface R/W <code>\"\"</code> Maximum 64 characters <code>Device.X_RDK_Ethernet.Link.{i}.Name</code> System name of the interface R/W <code>\"\"</code> Maximum 64 characters <code>Device.X_RDK_Ethernet.Link.{i}.LowerLayers</code> Lower layer interface references R/W <code>\"\"</code> Comma-separated list of interface paths <code>Device.X_RDK_Ethernet.Link.{i}.MACAddress</code> MAC address of the interface R <code>\"\"</code> Read-only hardware address <code>Device.X_RDK_Ethernet.Link.{i}.MACAddrOffSet</code> MAC address offset for multi-instance R <code>0</code> Offset value for MAC address calculation <code>Device.X_RDK_Ethernet.Link.{i}.PriorityTagging</code> Enable IEEE 802.1p priority tagging R/W <code>false</code> VLAN priority tagging support <code>Device.X_RDK_Ethernet.Link.{i}.X_RDK_BaseInterface</code> Hardware base interface name R/W <code>\"\"</code> Vendor-specific interface mapping <code>Device.X_RDK_Ethernet.Link.{i}.X_RDK_Refresh</code> Trigger interface state refresh R/W <code>false</code> Write <code>true</code> to refresh interface state <code>Device.X_RDK_Ethernet.VLANTermination.{i}.Enable</code> Enable/disable VLAN termination R/W <code>false</code> Controls VLAN interface operational state <code>Device.X_RDK_Ethernet.VLANTermination.{i}.Status</code> Current VLAN interface status R <code>Down</code> Up/Down/Unknown/Dormant/NotPresent/LowerLayerDown/Error <code>Device.X_RDK_Ethernet.VLANTermination.{i}.Alias</code> User-friendly name for VLAN interface R/W <code>\"\"</code> Maximum 64 characters <code>Device.X_RDK_Ethernet.VLANTermination.{i}.Name</code> System name of VLAN interface R/W <code>\"\"</code> Maximum 64 characters <code>Device.X_RDK_Ethernet.VLANTermination.{i}.LastChange</code> Time of last status change R <code>0</code> Seconds since last change <code>Device.X_RDK_Ethernet.VLANTermination.{i}.LowerLayers</code> Lower layer interface references R/W <code>\"\"</code> Parent interface for VLAN termination <code>Device.X_RDK_Ethernet.VLANTermination.{i}.VLANID</code> IEEE 802.1Q VLAN identifier R/W <code>0</code> VLAN ID (1-4094) <code>Device.X_RDK_Ethernet.VLANTermination.{i}.TPID</code> Tag Protocol Identifier R/W <code>0x8100</code> Ethernet type for VLAN tagging <code>Device.X_RDK_Ethernet.VLANTermination.{i}.X_RDK_BaseInterface</code> Hardware base interface for VLAN R/W <code>\"\"</code> Vendor-specific base interface <code>Device.X_RDK_Ethernet.Link.{i}.X_RDK_Marking.{j}.SKBPort</code> Socket buffer port identifier R <code>0</code> Network stack port mapping <code>Device.X_RDK_Ethernet.Link.{i}.X_RDK_Marking.{j}.EthernetPriorityMark</code> IEEE 802.1p priority value R/W <code>0</code> Priority marking (0-7) Parameter Description Access Default Notes <code>Device.X_RDK_Ethernet.Link.{i}.Enable</code> Enable/disable Ethernet link interface R/W <code>false</code> Controls interface operational state <code>Device.X_RDK_Ethernet.Link.{i}.Status</code> Current operational status of the link R <code>Down</code> Up/Down/Unknown/Dormant/NotPresent/LowerLayerDown/Error <code>Device.X_RDK_Ethernet.Link.{i}.Alias</code> User-friendly name for the interface R/W <code>\"\"</code> Max 64 chars <code>Device.X_RDK_Ethernet.Link.{i}.Name</code> System name of the interface R/W <code>\"\"</code> Max 64 chars <code>Device.X_RDK_Ethernet.Link.{i}.LowerLayers</code> Lower layer interface references R/W <code>\"\"</code> Comma-separated list <code>Device.X_RDK_Ethernet.Link.{i}.MACAddress</code> MAC address of the interface R <code>\"\"</code> Read-only <code>Device.X_RDK_Ethernet.Link.{i}.MACAddrOffSet</code> MAC address offset for multi-instance R <code>0</code> Offset for MAC calc <code>Device.X_RDK_Ethernet.Link.{i}.PriorityTagging</code> Enable IEEE 802.1p priority tagging R/W <code>false</code> VLAN priority tagging <code>Device.X_RDK_Ethernet.Link.{i}.X_RDK_BaseInterface</code> Hardware base interface name R/W <code>\"\"</code> Vendor-specific <code>Device.X_RDK_Ethernet.Link.{i}.X_RDK_Refresh</code> Trigger interface state refresh R/W <code>false</code> Write <code>true</code> to refresh <code>Device.X_RDK_Ethernet.VLANTermination.{i}.Enable</code> Enable/disable VLAN termination R/W <code>false</code> Controls VLAN state <code>Device.X_RDK_Ethernet.VLANTermination.{i}.Status</code> Current VLAN interface status R <code>Down</code> Up/Down/Unknown/... <code>Device.X_RDK_Ethernet.VLANTermination.{i}.Alias</code> User-friendly VLAN name R/W <code>\"\"</code> Max 64 chars <code>Device.X_RDK_Ethernet.VLANTermination.{i}.Name</code> System VLAN name R/W <code>\"\"</code> Max 64 chars <code>Device.X_RDK_Ethernet.VLANTermination.{i}.LastChange</code> Time of last status change R <code>0</code> Seconds since change <code>Device.X_RDK_Ethernet.VLANTermination.{i}.LowerLayers</code> Parent interface reference R/W <code>\"\"</code> Interface for VLAN termination <code>Device.X_RDK_Ethernet.VLANTermination.{i}.VLANID</code> VLAN identifier R/W <code>0</code> Range: 1\u20134094 <code>Device.X_RDK_Ethernet.VLANTermination.{i}.TPID</code> Tag Protocol Identifier R/W <code>0x8100</code> VLAN tagging type <code>Device.X_RDK_Ethernet.VLANTermination.{i}.X_RDK_BaseInterface</code> VLAN base interface R/W <code>\"\"</code> Vendor-specific <code>Device.X_RDK_Ethernet.Link.{i}.X_RDK_Marking.{j}.SKBPort</code> Socket buffer port identifier R <code>0</code> Stack port mapping <code>Device.X_RDK_Ethernet.Link.{i}.X_RDK_Marking.{j}.EthernetPriorityMark</code> IEEE 802.1p priority value R/W <code>0</code> Range: 0\u20137"},{"location":"review/VLANManager/#implementation-details","title":"Implementation Details","text":"<ul> <li> <p>Key Algorithms or Logic: The core VLAN management logic implements IEEE 802.1Q VLAN tagging with support for configurable TPID values and VLAN ID ranges (1-4094). The component uses atomic parameter operations following TR-69 specifications with validate-commit-rollback patterns implemented in <code>vlan_dml.c</code> and <code>ethernet_dml.c</code>. State machine logic manages interface lifecycle transitions between Up/Down/Error states with proper dependency handling for lower layer interfaces. The HAL communication protocol implements JSON-based message exchange with retry mechanisms and error handling located in <code>vlan_eth_hal.c</code>.</p> </li> <li> <p>Error Handling Strategy: Errors are categorized into validation errors (parameter range/format issues), HAL operation errors (hardware communication failures), and system errors (resource allocation failures). All errors are logged with appropriate severity levels using CcspTraceError/CcspTraceWarning macros. Parameter validation errors return CCSP fault codes to management clients. HAL errors trigger retry mechanisms with exponential backoff. Critical errors are reported through telemetry events for monitoring and diagnostics.</p> </li> <li> <p>Logging &amp; Debugging: The component uses CCSP logging framework with configurable verbosity levels controlled via <code>/etc/debug.ini</code>. Log categories include VLAN operations (VLAN_CREATE/DELETE), parameter operations (PARAM_SET/GET), HAL communication (HAL_REQUEST/RESPONSE), and error conditions (ERROR/WARNING). Debug mode enables detailed parameter validation traces and HAL message logging. Telemetry markers provide operational metrics for VLAN interface lifecycle events.</p> </li> </ul>"},{"location":"review/VLANManager/#key-configuration-files","title":"Key Configuration Files","text":"<p>The VLAN Manager uses several configuration files to control its operation and define system-specific parameters. These files provide default values, HAL schema definitions, and runtime configuration options.</p> Configuration File Purpose Key Parameters Default Values Override Mechanisms <code>vlan_manager_conf.json</code> Main runtime configuration <code>hal_schema_path</code>, <code>server_port</code> <code>/etc/rdk/schemas/ethlinkvlanterm_hal_schema.json</code>, <code>4096</code> Environment variables, command line arguments <code>RdkVlanManager.xml</code> TR-181 data model definitions Object definitions, parameter types, function mappings N/A Not user-configurable, defines data model structure <code>ethlinkvlanterm_hal_schema.json</code> HAL protocol schema definitions JSON message formats, parameter validation rules Schema version <code>0.0.1</code> HAL vendor implementations must comply with schema <code>/etc/debug.ini</code> Debug and logging configuration Log levels, trace categories Standard CCSP logging defaults Runtime modification supported PSM Database Keys Persistent parameter storage <code>dmsb.vlanmanager.*</code> hierarchy Component-specific defaults TR-181 parameter operations, factory reset"},{"location":"review/WANManager/","title":"WAN Manager Documentation","text":"<p>WAN Manager is the centralized orchestrator for WAN interface selection, configuration, and failover management within the RDK-B stack. It abstracts multiple physical WAN interfaces (Ethernet, DSL, DOCSIS, Cellular, GPON) into a unified policy-driven framework while handling link-layer and IP-layer configuration through integration with other RDK components. The component implements intelligent failover policies, manages DHCP/PPP sessions, exposes TR-181 data models, and provides runtime configuration via RBUS. WAN Manager sits between Interface Managers (which handle physical layer) and system services, coordinating interface selection based on availability, priority, and connectivity validation. It ensures seamless Internet connectivity by automatically switching between available WAN interfaces according to configured policies and monitoring interface health.</p> <pre><code>graph TD\n    subgraph External [\"External Systems\"]\n        Cloud[Cloud Management]\n        ISP[Internet Service Provider]\n        WebUI[Web Management UI]\n    end\n\n    subgraph RDKBStack [\"RDK-B Platform\"]\n        WANMgr[WAN Manager]\n        InterfaceMgrs[Interface Managers\\nXDSL, Ethernet, DOCSIS, Cellular]\n        VLANMgr[VLAN Manager]\n        DHCPMgr[DHCP Manager] \n        HAL[Hardware Abstraction Layer]\n        SysEvents[System Events]\n        WebConfig[WebConfig Framework]\n    end\n\n    subgraph Hardware [\"Physical Layer\"]\n        EthPort[Ethernet Port]\n        DSLModem[DSL Modem]\n        CableModem[Cable Modem]\n        CellularModem[Cellular Modem]\n    end\n\n    Cloud --&gt;|WebConfig Blob| WebConfig\n    WebUI --&gt;|TR-181 Commands| WANMgr\n    WebConfig --&gt;|Configuration| WANMgr\n    WANMgr &lt;--&gt;|Status/Config| InterfaceMgrs\n    WANMgr &lt;--&gt;|VLAN Config| VLANMgr\n    WANMgr &lt;--&gt;|DHCP Control| DHCPMgr\n    WANMgr &lt;--&gt;|System Events| SysEvents\n    InterfaceMgrs &lt;--&gt;|HAL APIs| HAL\n    HAL &lt;--&gt;|Physical Control| EthPort\n    HAL &lt;--&gt;|Physical Control| DSLModem\n    HAL &lt;--&gt;|Physical Control| CableModem\n    HAL &lt;--&gt;|Physical Control| CellularModem\n    WANMgr --&gt;|Internet Traffic| ISP\n\n    classDef external fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n    classDef core fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef platform fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;\n    classDef hardware fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n\n    class Cloud,ISP,WebUI external;\n    class WANMgr core;\n    class InterfaceMgrs,VLANMgr,DHCPMgr,HAL,SysEvents,WebConfig platform;\n    class EthPort,DSLModem,CableModem,CellularModem hardware;</code></pre> <p>Key Features &amp; Responsibilities</p> <ul> <li>Centralized WAN Orchestration: Manages multiple physical WAN interfaces through a unified policy engine that handles interface selection, failover, and configuration coordination with other RDK-B components.</li> <li>Policy-Driven Interface Selection: Implements multiple selection policies (AutoWAN, Parallel Scan, Fixed Mode, Primary Priority) with configurable failover logic and group-based interface management.</li> <li>Multi-Interface Failover Management: Provides automatic failover between interface groups with configurable restoration delays, health monitoring, and seamless connectivity transitions.</li> <li>TR-181 Data Model Implementation: Exposes comprehensive WAN configuration and status through X_RDK_WanManager TR-181 objects including interface tables, PHY status, IP configuration, and PPP parameters.</li> <li>DHCP/PPP Lifecycle Management: Coordinates DHCPv4/v6 client operations, PPP session management, and IP address assignment while updating system events and TR-181 status parameters.</li> <li>System Integration &amp; Event Management: Publishes system events for WAN status, coordinates with firewall/routing services, manages LED indicators, and integrates with telemetry systems.</li> <li>Virtual Interface Management: Supports complex interface stacks with VLAN tagging, marking tables for QoS, and virtual interface state machines for proper bring-up sequencing.</li> </ul>"},{"location":"review/WANManager/#design","title":"Design","text":"<p>WAN Manager follows a modular architecture with clear separation between policy logic, interface state management, data modeling, and system integration. The design emphasizes configurability through multiple selection policies that can be applied to interface groups, enabling flexible deployment scenarios from simple failover to complex multi-WAN configurations. Modularity is achieved through distinct controllers for failover policy, selection policies per group, and interface state machines per virtual interface, allowing independent scaling and customization. Scalability is supported through dynamic interface tables, group-based policy management, and support for up to 32 WAN interfaces with unlimited virtual interfaces per base interface. Reliability is ensured through proper initialization sequencing, rollback mechanisms for configuration changes, health monitoring with DNS connectivity checks, and graceful error handling with comprehensive logging. Security is maintained through capability dropping after initialization, input validation for all TR-181 parameters, and secure IPC mechanisms. Maintainability is achieved through consistent APIs, comprehensive debugging support, and clear module boundaries with well-defined interfaces.</p> <p>The design supports multiple concurrent policies operating on different interface groups, enabling scenarios like AutoWAN selection between primary interfaces (DOCSIS/Ethernet) while maintaining cellular backup in a separate group. Each interface group can have its own selection policy, timeout configuration, and priority settings, providing maximum flexibility for diverse deployment requirements.</p> <p>Clear boundaries exist between the core policy engine (handles high-level decisions), interface state machines (manage individual interface lifecycle), data layer (maintains configuration and runtime state), and integration layer (handles external communications with other RDK components and system services).</p> <p>Responsibilities are distributed with the data layer handling persistent storage and TR-181 mapping, policy controllers managing interface selection and failover decisions, state machines coordinating interface bring-up/tear-down sequences, and integration modules providing system event publishing and external component communication.</p> <p>A container diagram of the component is given below</p> <pre><code>graph TD\n    subgraph Runtime [\"Linux Userspace Process (C/C++)\"]\n        subgraph WANManagerContainer [\"wanmanager Process\"]\n            Core[Core Engine\\nwanmgr_core.c\\nwanmgr_main.c]\n            PolicyController[Policy Controller\\nwanmgr_controller.c]\n            Policies[Policy Implementations\\nwanmgr_policy_*.c]\n            DataLayer[Data Management\\nwanmgr_data.c\\nwanmgr_dml_*.c]\n            StateMachines[Interface State Machines\\nwanmgr_interface_sm.c]\n            DHCPv4Handler[DHCPv4 Handler\\nwanmgr_dhcpv4_*.c]\n            DHCPv6Handler[DHCPv6 Handler\\nwanmgr_dhcpv6_*.c]\n            WebConfigProcessor[WebConfig Processor\\nwanmgr_webconfig_*.c]\n            IPCServer[IPC Server\\nwanmgr_ipc.c]\n            SysEventManager[System Events\\nwanmgr_sysevents.c]\n            TelemetryAgent[Telemetry Agent\\nwanmgr_telemetry.c\\nwanmgr_t2_telemetry.c]\n            NetworkUtils[Network Utilities\\nwanmgr_net_utils.c]\n        end\n        subgraph MessageBus [\"CCSP/RBUS Message Bus\"]\n            TR181API[TR-181 API Interface]\n            EventBus[Event Publication Bus]\n        end\n        subgraph SystemServices [\"System Services\"]\n            SysEventD[(syseventd)]\n            DHCPClients[(DHCP Clients)]\n            NetworkStack[(Linux Network Stack)]\n        end\n    end\n\n    Core --&gt; PolicyController\n    PolicyController --&gt; Policies\n    PolicyController --&gt; StateMachines\n    StateMachines --&gt; DHCPv4Handler\n    StateMachines --&gt; DHCPv6Handler\n    DataLayer --&gt; TR181API\n    WebConfigProcessor --&gt; DataLayer\n    PolicyController --&gt; DataLayer\n    DHCPv4Handler --&gt; SysEventManager\n    DHCPv6Handler --&gt; SysEventManager\n    SysEventManager --&gt; SysEventD\n    StateMachines --&gt; NetworkUtils\n    NetworkUtils --&gt; NetworkStack\n    TelemetryAgent --&gt; EventBus\n    Core --&gt; IPCServer\n\n    classDef core fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef policy fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px; \n    classDef integration fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n    classDef external fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n\n    class Core,DataLayer core;\n    class PolicyController,Policies,StateMachines policy;\n    class DHCPv4Handler,DHCPv6Handler,WebConfigProcessor,IPCServer,SysEventManager,TelemetryAgent,NetworkUtils integration;\n    class TR181API,EventBus,SysEventD,DHCPClients,NetworkStack external;</code></pre> <p>Request Flow Sequence</p> <p>The most critical flow is interface failover triggered by connectivity loss, involving policy re-evaluation, state machine transitions, and system reconfiguration. This sequence demonstrates the coordination between policy engine, state machines, and system integration components.</p> <pre><code>sequenceDiagram\n    participant Monitor as Connectivity Monitor\n    participant Policy as Policy Controller\n    participant SM as Interface State Machine\n    participant DHCP as DHCP Handler\n    participant SysEv as System Events\n    participant Net as Network Utils\n    participant FW as Firewall Service\n\n    Monitor-&gt;&gt;Policy: Interface Down Event\n    Policy-&gt;&gt;Policy: Evaluate Failover Policy\n    Policy-&gt;&gt;SM: Deactivate Current Interface\n    SM-&gt;&gt;DHCP: Release DHCP Lease\n    SM-&gt;&gt;Net: Remove Routes/Addresses\n    SM-&gt;&gt;SysEv: Publish wan-status=down\n    Policy-&gt;&gt;Policy: Select Next Interface\n    Policy-&gt;&gt;SM: Activate Backup Interface\n    SM-&gt;&gt;Net: Configure Interface Stack\n    SM-&gt;&gt;DHCP: Request New Lease\n    DHCP--&gt;&gt;SM: Lease Acquired\n    SM-&gt;&gt;Net: Configure Routes\n    SM-&gt;&gt;SysEv: Publish wan-status=up\n    SysEv--&gt;&gt;FW: Trigger firewall-restart\n    Policy-&gt;&gt;Monitor: Interface Active</code></pre> <p>Threading Model</p> <p>WAN Manager operates primarily as a single-threaded daemon with event-driven architecture. The main thread runs the core policy loop via <code>WanMgr_Core_Start()</code> which continuously evaluates interface states and policy decisions. Additional concurrency comes from:</p> <ul> <li>Asynchronous Event Handlers: CCSP/RBUS message bus callbacks execute in separate contexts for TR-181 parameter operations and event subscriptions</li> <li>System Event Callbacks: syseventd notifications arrive asynchronously for interface state changes, DHCP events, and system status updates  </li> <li>Signal Handlers: Registered for graceful shutdown (SIGTERM, SIGINT) and diagnostic functions (SIGUSR1/2) that execute in signal context</li> <li>DHCP Client Integration: External DHCP client processes communicate via system events and file-based IPC, handled asynchronously</li> <li>Capability Management: Early initialization includes capability dropping and privilege reduction before entering the main event loop</li> </ul> <p>The threading model avoids explicit thread pools, instead relying on the message bus framework and system event infrastructure to provide necessary concurrency for handling multiple interface operations and external communications simultaneously.</p>"},{"location":"review/WANManager/#internal-modules","title":"Internal Modules","text":"<p>The WAN Manager comprises several specialized modules that work together to provide comprehensive WAN interface management. The Core Engine initializes the system and runs the main control loop, while Policy Controllers implement different selection strategies. Interface State Machines handle the lifecycle of individual interfaces, and various handlers manage DHCP, system integration, and external communications.</p> Module/Class Description Key Files Core Engine Main initialization, control loop, and module coordination <code>wanmgr_main.c</code>, <code>wanmgr_core.c</code> Policy Controller Manages interface selection policies and failover decisions <code>wanmgr_controller.c</code>, <code>wanmgr_controller.h</code> AutoWAN Policy Implements sequential interface testing with connectivity validation <code>wanmgr_policy_autowan_impl.c</code>, <code>wanmgr_policy_auto_impl.c</code> Parallel Scan Policy Attempts multiple interfaces simultaneously for fastest connection <code>wanmgr_policy_parallel_scan_impl.c</code> Fixed Mode Policies Provides static interface selection with optional failover <code>wanmgr_policy_fm_impl.c</code>, <code>wanmgr_policy_fmob_impl.c</code> Primary Priority Policies Priority-based selection with primary/secondary hierarchy <code>wanmgr_policy_pp_impl.c</code>, <code>wanmgr_policy_ppob_impl.c</code> Data Management Layer Handles interface data structures, locking, and persistence <code>wanmgr_data.c</code>, <code>wanmgr_data.h</code> Interface State Machine Manages interface lifecycle, link state, and protocol stack <code>wanmgr_interface_sm.c</code>, <code>wanmgr_interface_sm.h</code> DHCPv4 Management Handles DHCPv4 client operations, lease management, and events <code>wanmgr_dhcpv4_apis.c</code>, <code>wanmgr_dhcpv4_internal.c</code> DHCPv6 Management Manages DHCPv6 client operations, prefix delegation, and IPv6 setup <code>wanmgr_dhcpv6_apis.c</code>, <code>wanmgr_dhcpv6_internal.c</code> WebConfig Integration Processes configuration blobs and manages runtime updates <code>wanmgr_webconfig_apis.c</code>, <code>wanmgr_webconfig.c</code> System Events Manager Publishes and subscribes to system-wide event notifications <code>wanmgr_sysevents.c</code>, <code>wanmgr_sysevents.h</code> IPC Server Handles inter-process communication for management commands <code>wanmgr_ipc.c</code>, <code>wanmgr_ipc.h</code> TR-181 DML Layer Implements TR-181 data model APIs and parameter validation <code>TR-181/middle_layer_src/wanmgr_dml_*.c</code> Network Utilities Provides network configuration helpers and system integration <code>wanmgr_net_utils.c</code>, <code>wanmgr_utils.c</code> Telemetry Integration Manages telemetry data collection and reporting <code>wanmgr_telemetry.c</code>, <code>wanmgr_t2_telemetry.c</code> Failover Orchestration Coordinates complex failover scenarios and restoration logic <code>wanmgr_wan_failover.c</code>, <code>wanmgr_wan_failover.h</code> <pre><code>flowchart TD\n    subgraph WANManager [\"WAN Manager Process\"]\n        Core[Core Engine]\n        PolicyCtrl[Policy Controller]\n        AutoWAN[AutoWAN Policy]\n        ParallelScan[Parallel Scan Policy] \n        FixedMode[Fixed Mode Policy]\n        PrimaryPriority[Primary Priority Policy]\n        DataLayer[Data Management]\n        StateMachine[Interface State Machine]\n        DHCPv4[DHCPv4 Handler]\n        DHCPv6[DHCPv6 Handler]\n        WebConfig[WebConfig Processor]\n        SysEvents[System Events]\n        IPC[IPC Server]\n        TR181[TR-181 DML]\n        NetUtils[Network Utils]\n        Telemetry[Telemetry Agent]\n        Failover[Failover Logic]\n    end\n\n    Core --&gt; PolicyCtrl\n    PolicyCtrl --&gt; AutoWAN\n    PolicyCtrl --&gt; ParallelScan\n    PolicyCtrl --&gt; FixedMode\n    PolicyCtrl --&gt; PrimaryPriority\n    PolicyCtrl --&gt; Failover\n    PolicyCtrl --&gt; StateMachine\n    StateMachine --&gt; DHCPv4\n    StateMachine --&gt; DHCPv6\n    StateMachine --&gt; NetUtils\n    DataLayer --&gt; TR181\n    WebConfig --&gt; DataLayer\n    DHCPv4 --&gt; SysEvents\n    DHCPv6 --&gt; SysEvents\n    SysEvents --&gt; PolicyCtrl\n    Core --&gt; IPC\n    Core --&gt; Telemetry\n\n    classDef core fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef policy fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;\n    classDef handler fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n    classDef integration fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n\n    class Core,DataLayer core;\n    class PolicyCtrl,AutoWAN,ParallelScan,FixedMode,PrimaryPriority,Failover policy;\n    class StateMachine,DHCPv4,DHCPv6,NetUtils handler;\n    class WebConfig,SysEvents,IPC,TR181,Telemetry integration;</code></pre>"},{"location":"review/WANManager/#interaction-with-other-middleware-components","title":"Interaction with Other Middleware Components","text":"<p>WAN Manager integrates extensively with the RDK-B middleware ecosystem through various protocols and mechanisms. It coordinates with Interface Managers for physical layer status, communicates with VLAN and DHCP managers for network stack configuration, and integrates with system services for event publication and telemetry reporting.</p> <pre><code>flowchart LR\n    WANManager --&gt;|RBUS/CCSP Param Ops| CCSPComponents[(CCSP Components)]\n    WANManager --&gt;|Interface Status/Config| InterfaceManagers[(Interface Managers)]\n    WANManager --&gt;|VLAN Configuration| VLANManager[(VLAN Manager)]\n    WANManager --&gt;|DHCP Control Commands| DHCPManager[(DHCP Manager)]\n    WANManager --&gt;|System Event Pub/Sub| SystemEventD[(syseventd)]\n    WANManager --&gt;|Configuration Blob Processing| WebConfigFW[(WebConfig Framework)]\n    WebConfigFW --&gt;|JSON Configuration| WANManager\n    WANManager --&gt;|Telemetry Events| TelemetryService[(Telemetry Service)]\n    WANManager --&gt;|Firewall Restart Triggers| FirewallServices[(Firewall Services)]\n    WANManager --&gt;|LED Status Updates| LEDManager[(LED Manager)]\n    WANManager --&gt;|Network Stack Operations| LinuxNetworking[(Linux Network Stack)]\n\n    classDef wanmgr fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef middleware fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;\n    classDef system fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n\n    class WANManager wanmgr;\n    class CCSPComponents,InterfaceManagers,VLANManager,DHCPManager,WebConfigFW middleware;\n    class SystemEventD,TelemetryService,FirewallServices,LEDManager,LinuxNetworking system;</code></pre> Component Purpose of Interaction Protocols/Mechanisms Interface Managers (XDSL, Ethernet, DOCSIS, Cellular) Physical layer status reporting and configuration RBUS events and parameter operations CCSP/TR-181 Framework Data model parameter get/set operations and validation CCSP Message Bus with DML APIs VLAN Manager VLAN interface creation and configuration for tagged traffic System calls and configuration APIs DHCP Manager DHCP server configuration and lease management coordination System events and configuration files WebConfig Framework Dynamic configuration updates via cloud management JSON blob processing with callback APIs syseventd System-wide event publication and subscription sysevent API with key-value notifications Telemetry Service Operational metrics and performance data reporting Telemetry 2.0 bus with structured events Firewall Services Network security rule updates on interface changes System event triggers for service restart LED Manager Hardware status indication for user feedback System events for LED state control Linux Network Stack Direct network interface and routing configuration Netlink sockets and system utilities <p>The WAN Manager publishes several key events that other components can subscribe to for coordination and monitoring purposes:</p> Event Purpose of Event Reason for trigger <code>wan-status</code> Overall WAN connectivity state notification Interface up/down transitions, policy changes <code>ipv4-up</code> / <code>ipv6-up</code> IP stack availability notification DHCP lease acquisition, static IP configuration <code>wan-restart</code> WAN subsystem restart notification Configuration changes requiring full restart <code>firewall-restart</code> Security rule update notification Interface IP address changes, routing updates <code>routed-status</code> Routing table status notification Default route changes, multi-homing updates <code>rdkb_wan_status</code> LED status update for hardware indication Link state changes, connectivity validation <code>dhcp_server-restart</code> DHCP server reconfiguration notification WAN IP changes affecting LAN DHCP pool <code>lan-prefix_set</code> / <code>lan-prefix_clear</code> IPv6 prefix delegation events DHCPv6 prefix acquisition/loss <code>radvd_restart</code> Router advertisement daemon restart IPv6 prefix or configuration changes"},{"location":"review/WANManager/#interaction-with-other-layers","title":"Interaction with Other Layers","text":"<p>WAN Manager operates primarily at the middleware layer but interfaces with both lower hardware abstraction layers and higher-level system services. The abstraction boundaries are well-defined to maintain modularity and enable platform portability across different RDK-B deployments.</p> Layer/Service Interaction Description Mechanism HAL (Hardware Abstraction Layer) Indirect access to hardware interface status and capabilities TR-181 middle layer APIs and CCSP message bus Platform Services (System Scripts, Init System) System service coordination, startup sequencing, and event propagation System events, service dependencies, capability management External Services (Cloud Management, Monitoring) Configuration distribution, status reporting, and remote management WebConfig framework, telemetry APIs, TR-181 remote access Linux Kernel (Network Stack) Direct network interface configuration and routing management Netlink sockets, ioctl calls, sysfs interfaces RDK-B Middleware (CCSP Framework) Component communication, data model exposure, and event distribution CCSP message bus, RBUS, shared libraries <pre><code>graph TD\n    subgraph CloudLayer [\"Cloud Management Layer\"]\n        CloudMgmt[(Cloud Management Platform)]\n        RemoteMonitoring[(Remote Monitoring)]\n    end\n\n    subgraph ApplicationLayer [\"Application Layer\"]\n        WebUI[(Web Management UI)]\n        CLITools[(CLI Management Tools)]\n    end\n\n    subgraph MiddlewareLayer [\"RDK-B Middleware Layer\"]\n        WANManager[WAN Manager]\n        CCSPFramework[(CCSP Framework)]\n        OtherComponents[(Other RDK Components)]\n    end\n\n    subgraph PlatformLayer [\"Platform Services Layer\"]\n        SystemServices[(System Services)]\n        InitSystem[(Init System)]\n        SecurityServices[(Security Services)]\n    end\n\n    subgraph HALLayer [\"Hardware Abstraction Layer\"]\n        NetworkHAL[(Network HAL)]\n        PlatformHAL[(Platform HAL)]\n    end\n\n    subgraph KernelLayer [\"Linux Kernel Layer\"]\n        NetworkStack[(Network Stack)]\n        DeviceDrivers[(Device Drivers)]\n    end\n\n    subgraph HardwareLayer [\"Hardware Layer\"]\n        EthernetPorts[(Ethernet Ports)]\n        WirelessModems[(Wireless Modems)]\n        DSLModems[(DSL Modems)]\n    end\n\n    CloudMgmt --&gt;|WebConfig| WANManager\n    RemoteMonitoring --&gt;|Telemetry| WANManager\n    WebUI --&gt;|TR-181| WANManager\n    CLITools --&gt;|TR-181| WANManager\n    WANManager &lt;--&gt;|Message Bus| CCSPFramework\n    WANManager &lt;--&gt;|Events/IPC| OtherComponents\n    WANManager &lt;--&gt;|System Events| SystemServices\n    WANManager &lt;--&gt;|Service Control| InitSystem\n    WANManager &lt;--&gt;|Capabilities| SecurityServices\n    SystemServices &lt;--&gt;|HAL APIs| NetworkHAL\n    SystemServices &lt;--&gt;|HAL APIs| PlatformHAL\n    NetworkHAL &lt;--&gt;|System Calls| NetworkStack\n    PlatformHAL &lt;--&gt;|Driver APIs| DeviceDrivers\n    NetworkStack &lt;--&gt;|Hardware Control| EthernetPorts\n    DeviceDrivers &lt;--&gt;|Hardware Control| WirelessModems\n    DeviceDrivers &lt;--&gt;|Hardware Control| DSLModems\n\n    classDef cloud fill:#fff3e0,stroke:#ef6c00,stroke-width:2px;\n    classDef app fill:#f8bbd9,stroke:#c2185b,stroke-width:2px;\n    classDef middleware fill:#e1f5fe,stroke:#0277bd,stroke-width:2px;\n    classDef platform fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px;\n    classDef hal fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px;\n    classDef kernel fill:#fce4ec,stroke:#8bc34a,stroke-width:2px;\n    classDef hardware fill:#f1f8e9,stroke:#689f38,stroke-width:2px;\n\n    class CloudMgmt,RemoteMonitoring cloud;\n    class WebUI,CLITools app;\n    class WANManager,CCSPFramework,OtherComponents middleware;\n    class SystemServices,InitSystem,SecurityServices platform;\n    class NetworkHAL,PlatformHAL hal;\n    class NetworkStack,DeviceDrivers kernel;\n    class EthernetPorts,WirelessModems,DSLModems hardware;</code></pre>"},{"location":"review/WANManager/#ipc-mechanism","title":"IPC Mechanism","text":"<p>WAN Manager employs multiple IPC mechanisms to communicate with different components in the system. Each mechanism is optimized for its specific use case, from high-performance local communication to standardized middleware integration.</p> Type of IPC Message Format Mechanism Internal Management IPC Structured command messages with interface identifiers and operation parameters Custom IPC server (<code>wanmgr_ipc.c</code>) using Unix domain sockets System Event Communication Key-value pairs with event names and string/numeric values syseventd API with publish/subscribe pattern TR-181 Parameter Operations CCSP message format with parameter paths, values, and transaction IDs CCSP Message Bus / RBUS with standardized RPC calls WebConfig Blob Processing JSON-formatted configuration data with structured object hierarchy WebConfig framework callbacks with parsed data structures Telemetry Data Reporting Key-value telemetry events with timestamps and metadata Telemetry 2.0 bus with structured event publishing DHCP Client Integration File-based state sharing and process signals Filesystem monitoring and signal-based notifications <pre><code>sequenceDiagram\n    participant Mgmt as Management Client\n    participant IPC as WAN Manager IPC Server\n    participant Policy as Policy Controller\n    participant SM as State Machine  \n    participant SysEv as System Events\n    participant CCSP as CCSP Bus\n\n    Mgmt-&gt;&gt;IPC: SetInterfaceStatus(eth0, UP)\n    IPC-&gt;&gt;Policy: Process Interface Command\n    Policy-&gt;&gt;SM: Update Interface State\n    SM-&gt;&gt;SysEv: Publish wan_interface_status=up\n    Policy-&gt;&gt;Policy: Re-evaluate Selection Policy  \n    Policy-&gt;&gt;CCSP: Update TR-181 Parameters\n    CCSP--&gt;&gt;Policy: Parameter Update Confirmation\n    SysEv--&gt;&gt;SM: System Event Callback\n    SM--&gt;&gt;Policy: State Change Notification\n    Policy--&gt;&gt;IPC: Command Processing Complete\n    IPC--&gt;&gt;Mgmt: Status Response (SUCCESS)</code></pre>"},{"location":"review/WANManager/#tr181-data-models","title":"TR\u2011181 Data Models","text":"<p>WAN Manager implements a comprehensive TR-181 data model under the <code>X_RDK_WanManager</code> object hierarchy, providing standardized access to WAN configuration and status information. The implementation supports dynamic table operations, parameter validation, and atomic commit/rollback semantics for configuration changes.</p> <ul> <li>Implemented Parameters: The WAN Manager exposes over 50 TR-181 parameters covering global WAN settings, per-interface configuration, PHY status, IP configuration, PPP settings, and QoS marking tables. All parameters support proper validation, range checking, and dependency enforcement.</li> <li>Parameter Registration: Parameters are registered through the CCSP framework using function handlers defined in <code>RdkWanManager.xml</code>. Each parameter type (string, boolean, integer) has dedicated getter/setter functions with validation and commit handlers for transactional updates.</li> <li>Custom Extensions: WAN Manager extends standard TR-181 with RDK-specific objects for advanced multi-WAN scenarios, interface grouping, policy configuration, and vendor-specific interface types not covered in standard specifications.</li> </ul> Parameter Description Access (R/W) Default Notes <code>X_RDK_WanManager.Enable</code> Global WAN Manager enable flag R/W <code>true</code> Master control for WAN operations <code>X_RDK_WanManager.Policy</code> Active interface selection policy R/W <code>AUTOWAN_MODE</code> Enum: FIXED_MODE, PRIMARY_PRIORITY, AUTOWAN_MODE, etc. <code>X_RDK_WanManager.AllowRemoteInterfaces</code> Enable remote CPE interface support R/W <code>false</code> For distributed WAN configurations <code>X_RDK_WanManager.ResetActiveInterface</code> Trigger active interface reset R/W <code>false</code> Write-only trigger parameter <code>X_RDK_WanManager.RestorationDelay</code> Failover restoration delay in seconds R/W <code>30</code> Range: 0-3600 seconds <code>X_RDK_WanManager.WanFailoverData</code> Failover configuration data R/W <code>\"\"</code> JSON-formatted configuration <code>X_RDK_WanManager.DnsConnectivityCheck.Enable</code> DNS connectivity validation enable R/W <code>true</code> Health monitoring feature <code>X_RDK_WanManager.CPEInterface.{i}.Name</code> Interface name identifier R/W <code>\"\"</code> Physical interface name (e.g., eth0) <code>X_RDK_WanManager.CPEInterface.{i}.DisplayName</code> Human-readable interface name R/W <code>\"\"</code> UI display name <code>X_RDK_WanManager.CPEInterface.{i}.Wan.Enable</code> Interface enable flag R/W <code>false</code> Per-interface enable control <code>X_RDK_WanManager.CPEInterface.{i}.Wan.SelectionTimeout</code> Interface selection timeout R/W <code>120</code> Range: 20-65535 seconds <code>X_RDK_WanManager.CPEInterface.{i}.Wan.Type</code> Interface type classification R/W <code>Unconfigured</code> Enum: Primary, Secondary, Unconfigured <code>X_RDK_WanManager.CPEInterface.{i}.Wan.Priority</code> Interface selection priority R/W <code>1</code> Lower values = higher priority <code>X_RDK_WanManager.CPEInterface.{i}.Wan.Group</code> Interface group assignment R/W <code>1</code> Group ID for policy application <code>X_RDK_WanManager.CPEInterface.{i}.Wan.Status</code> Current interface status R <code>Disabled</code> Enum: Disabled, Up, Down, etc. <code>X_RDK_WanManager.CPEInterface.{i}.Wan.ActiveLink</code> Active link indicator R <code>false</code> True if currently active <code>X_RDK_WanManager.CPEInterface.{i}.IP.IPv4Status</code> IPv4 connectivity status R/W <code>Down</code> Current IPv4 state <code>X_RDK_WanManager.CPEInterface.{i}.IP.IPv6Status</code> IPv6 connectivity status R/W <code>Down</code> Current IPv6 state <code>X_RDK_WanManager.CPEInterface.{i}.PPP.Enable</code> PPP session enable R/W <code>false</code> For PPPoE/PPPoA interfaces <code>X_RDK_WanManager.CPEInterface.{i}.PPP.IPCPEnable</code> IPCP negotiation enable R/W <code>true</code> IPv4 over PPP control <code>X_RDK_WanManager.CPEInterface.{i}.PPP.IPv6CPEnable</code> IPv6CP negotiation enable R/W <code>false</code> IPv6 over PPP control"},{"location":"review/WANManager/#implementation-details","title":"Implementation Details","text":"<ul> <li> <p>Key Algorithms or Logic: </p> <ul> <li>Policy Selection Algorithm: The AutoWAN policy (<code>wanmgr_policy_autowan_impl.c</code>) implements a sequential interface testing algorithm that validates connectivity using DNS queries, ping tests, and HTTP connectivity checks before selecting an interface as active. The algorithm maintains state machines for each interface group and implements timeout-based selection with configurable validation criteria.</li> <li>Interface State Machine: Located in <code>wanmgr_interface_sm.c</code>, this implements a comprehensive state machine handling interface lifecycle from physical detection through IP configuration. States include STANDBY, INITIALIZING, VALIDATING, UP, and DOWN with proper transition handling and rollback capabilities.</li> <li>Failover Decision Engine: The failover logic in <code>wanmgr_wan_failover.c</code> and <code>wanmgr_controller.c</code> monitors interface health, implements restoration timers, and coordinates seamless failover between interface groups. It considers interface priority, group membership, connectivity validation results, and configured policies.</li> <li>WebConfig Processing: The blob processing logic in <code>wanmgr_webconfig_apis.c</code> implements atomic configuration updates with validation, rollback capabilities, and dependency checking for interface marking, QoS configuration, and failover parameters.</li> </ul> </li> <li> <p>Error Handling Strategy: WAN Manager implements comprehensive error handling with multiple layers of validation and recovery. Function return codes use <code>ANSC_STATUS</code> enumeration for consistent error reporting. Critical errors trigger automatic rollback of configuration changes, while transient errors are handled with retry mechanisms and exponential backoff. All errors are logged through the CCSP trace system with appropriate severity levels, and telemetry events are generated for monitoring systems.</p> </li> <li> <p>Logging &amp; Debugging: The component uses CCSP trace macros (<code>CcspTraceError</code>, <code>CcspTraceWarning</code>, <code>CcspTraceInfo</code>, <code>CcspTraceDebug</code>) with configurable log levels controlled via <code>/etc/debug.ini</code>. Debug output includes interface state transitions, policy decisions, DHCP events, and system integration points. Runtime debugging is supported through signal handlers (SIGUSR1/2) that dump internal state, and the process maintains a PID file at <code>/var/tmp/wanmanager.pid</code> for external monitoring.</p> </li> </ul>"},{"location":"review/WANManager/#key-configuration-files","title":"Key Configuration Files","text":"<p>WAN Manager uses multiple configuration sources ranging from compile-time XML definitions to runtime configuration blobs and system event state storage. The configuration system supports atomic updates, validation, and rollback capabilities for operational reliability.</p> Configuration File Purpose Key Parameters Default Values Override Mechanisms <code>config/RdkWanManager.xml</code> TR-181 data model definition and function mapping Object hierarchy, parameter types, access permissions, validation rules Schema-defined defaults Build-time compilation, runtime TR-181 sets <code>config/RdkWanManager_v2.xml</code> Enhanced data model with additional features Extended interface types, advanced policies, enhanced monitoring Version 2 defaults Conditional compilation flags WebConfig WAN Blob Runtime interface and QoS configuration Interface markings, priority settings, failover configuration, group assignments Cloud-managed defaults WebConfig framework distribution <code>/etc/debug.ini</code> Logging and debug configuration Trace levels, component logging, debug flags Platform-specific defaults Direct file editing, service restart System Events Dynamic runtime state storage Interface status, IP configuration, connectivity state, system flags Runtime-determined WAN Manager and system service updates <code>/tmp/wanmanager_initialized</code> Service initialization marker Crash detection, restart behavior N/A (presence-based) Service lifecycle management Linux Capabilities Security and privilege configuration Network administration, system control, file access Minimal required set Build configuration, runtime dropping"},{"location":"sitemap/","title":"Index","text":"Sitemap <p>Home</p>"},{"location":"source/docs/build-system/","title":"Build System","text":""},{"location":"source/docs/build-system/#yocto-build-system-overview","title":"Yocto Build System Overview","text":"<p>The Yocto Project is an open source collaboration project that provides templates, tools and methods to help create custom Linux-based systems for embedded products. It is an open source project initiated by the Linux Foundation in 2010. The Yocto Project uses the OpenEmbedded build system to construct complete Linux images.</p> <p>The core components of the Yocto Project are:</p> <ul> <li>BitBake     , the build engine is a task scheduler, like make. It interprets configuration files and recipes (also called metadata) to perform a set of tasks, to download, configure and build specified packages and filesystem images.</li> <li>OpenEmbedded-Core     , a set of base layers. It is a set of recipes, layers and classes which are shared between all OpenEmbedded based systems. Recipes have a specific syntax and describe how to fetch, configure, compile and package applications and images. Layers are sets of recipes, matching a common purpose. Multiple layers are used within a same distribution, depending on the requirements.</li> </ul>"},{"location":"source/docs/build-system/#yocto-architecture","title":"Yocto Architecture","text":""},{"location":"source/docs/build-system/#bitbake","title":"BitBake","text":"<p>BitBake is the task executor and scheduler used by the OpenEmbedded build system to build images. BitBake is a generic task execution engine that allows shell and Python tasks to be run efficiently and in parallel while working within complex inter-task dependency constraints. BitBake stores the output of each task in a directory, the shared state cache. Its location is controlled by the SSTATE_DIR variable. This cache is use to speed up compilation.</p> <p>Usage: <pre><code>bitbake [options] [recipename/target ...]\u00a0\n</code></pre> Bitbake executes all the layers starting with a prefix \u2018meta\u2019.</p> <p>The build/ directory</p> <ul> <li>conf/     \u00a0: Configuration files - image specific and layer configuration.</li> <li>downloads/     \u00a0: This folder stores the downloaded upstream tarballs of the packages used in the builds, facilitating fast rebuilds. If the content of this folder is deleted, the builds will go and refetch the source tars again.</li> <li>sstate-cache/     \u00a0: Shared state cache, it is the local prebuilt store used by all builds. It will be populated when you do the builds. It is important to keep this directory safe for sstate reuse.</li> <li>tmp/     \u00a0: Holds all the build.</li> <li>tmp/buildstats/     \u00a0: Build statistics for all packages built (CPU usage, elapsed time, host, timestamps).</li> <li>tmp/deploy/     \u00a0: Final output of the build.</li> <li>tmp/deploy/images/     \u00a0: Contains the complete images built by the OpenEmbedded build system. These images are used to flash the target.</li> <li>tmp/work/     \u00a0: Set of specific work directories, split by architecture. They are used to unpack, configure and build the packages. Contains the patched sources, generated objects and logs.</li> <li>tmp/sysroots/     \u00a0: Shared libraries and headers used to compile packages for the target but also for the host.</li> </ul> <p>Note: \u00a0build-(e.g. build-oem-platform) - This is the object/build directory, all objects and intermediate files for all components are stored in this folder. if you want to do a clean build you can delete this folder, then run ./meta-cmf/setup-environment and rebuild. The build will be very fast since it will reuse the sstate (prebuilts) during this build, assuming the sstate-cache directory was populated with previous builds already."},{"location":"source/docs/build-system/#meta-layers","title":"Meta-layers","text":"<p>Meta-layer contains configuration, recipes, classes, patches.</p> <ul> <li>Configuration (*.conf) files: global definition of variables</li> <li>Classes (*.bbclass): encapsulation and inheritance of build logic, packaging etc.</li> <li>Recipes (*.bb, *.bbappend): logical units of software/Images to build\u00a0</li> </ul> <p>Bitbake parses the build classes, config files, and recipes. For every task, a shell script on-the-fly is created and executed.</p>"},{"location":"source/docs/build-system/#recipe","title":"Recipe","text":"<p>Recipes are essentially a set of instructions for building packages. A recipe describes where you get source code and which patches to apply. Recipes describe dependencies for libraries or for other recipes, and they also contain configuration and compilation options. Recipes contain the logical unit of execution, the software to build, the images to build, and use the .bb file extension.</p> <p>The recipes are parsed by the BitBake build engine. The format of a recipe file name is  _.bb <p>A recipe contains configuration variables: name, license, dependencies, path to retrieve the source code etc. It also contains functions that can be run (fetch, configure, compile. . .), called tasks.</p> <p>Recipe provides:</p> <ul> <li>Descriptive information about the package.</li> <li>Existing dependencies (both build and runtime dependencies)</li> <li>DEPENDS &amp; RDEPENDS variables holds the build &amp; runtime dependencies e.g.</li> <li>Where the source code resides and how to fetch it: SRC_URI variable holds the URL path to fetch</li> <li>The version of the recipe</li> <li>Whether the source code requires any patches, where to find them, and how to apply them</li> <li>How to configure and compile the source code</li> <li>Where on the target machine to install the package or packages created</li> </ul>"},{"location":"source/docs/build-system/#append-files","title":"Append Files","text":"<p>Files that append build information to a recipe file. Append files are known as BitBake append files and .bbappend files. The OpenEmbedded build system expects every append file to have a corresponding recipe (.bb) file. Furthermore, the append file and corresponding recipe file must use the same root filename. The filenames can differ only in the file type suffix used (e.g. formfactor_0.0.bb and formfactor_0.0.bbappend).</p> <p>Information in append files overrides the information in the similarly-named recipe file.</p>"},{"location":"source/docs/build-system/#patches","title":"Patches","text":"<p>Patches can be applied to recipe files. Patch files should be having extension *.patch. Place the patch file in subdirectory of recipe named (component) folder.\u00a0 The subdirectory should be preferably named as that of component or as \u2018files\u2019. Add the below line to the recipe file</p> <p>SRC_URI += file://filename.patch/ \u00a0</p>"},{"location":"source/docs/build-system/#external-src","title":"External SRC","text":"<p>By default, the OpenEmbedded build system uses the Build Directory when building source code. The build process involves fetching the source files, unpacking them, and then patching them if necessary before the build takes place.\u00a0</p> <p>Yocto place individual components at discrete locations for the build purpose. For example; consider emulator build</p> <p>../../&lt; Project Folder &gt;/build-qemux86mc/tmp/work/i586-rdk-linux/iarmbus</p> <p>../../&lt; Project Folder &gt;/build-qemux86mc/tmp/work/qemux86mc-rdk-linux/devicesettings</p> <p>It will be difficult for a developer to do a code walk through since the entire source code is spread across multiple directories. You might want to\u00a0build software from source files that are external to and thus outside of the OpenEmbedded build system.For example</p> <p>../../&lt; Project Folder&gt;/generic</p> <p>You want the recipe's SRC_URI variable to point to the external directory and use it as is, not copy it.\u00a0Yocto provides a solution to this by its external SRC support. By this all the components will be pulled to a single place.\u00a0Say, you are component owner and only focused to modify source code of that component and build it alone.\u00a0Modify the files under\u00a0../../&lt; Project Folder &gt;/generic/iarmbus\u00a0(as an example; you can modify any component like this)</p> <p>bitbake iarmbus (as an example; you can build any component like this)</p> <p>To build from software that comes from an external source, all you need to do is inherit the externalsrc class and then set the EXTERNALSRC variable to point to your external source code.</p> <p>The statements to put in your local.conf file are illustrated below:</p> <pre><code>INHERIT += \"externalsrc\"\nEXTERNALSRC_pn-myrecipe = \"path-to-your-source-tree\"\n</code></pre> <p>By default, externalsrc.bbclass builds the source code in a directory separate from the external source directory as specified by EXTERNALSRC. If you need to have the source built in the same directory in which it resides, or some other nominated directory, you can set EXTERNALSRC_BUILD to point to that directory: <pre><code>EXTERNALSRC_BUILD_pn-myrecipe = \"path-to-your-source-tree\"\n</code></pre> To know the components building from external SRC, see the content of the file\u00a0../../&lt;  Project Folder &gt;/build-qemux86mc/conf/auto.conf (In case of emulator)</p>"},{"location":"source/docs/build-system/#yocto-build-types","title":"Yocto Build Types","text":""},{"location":"source/docs/build-system/#references","title":"References","text":"<ul> <li>The Yocto Project</li> <li>Yocto Developer Manual</li> <li>SystemD</li> </ul>"},{"location":"source/docs/creating-yocto-sdk/","title":"Creating Yocto SDK","text":""},{"location":"source/docs/creating-yocto-sdk/#introduction","title":"Introduction","text":"<p>Welcome to the Yocto Software Development Kit (SDK) Guide. SDK allows developers in quick development and testing during development stage. It eliminates the need of downloading &amp; setting-up of full repository environments.</p> <p>Setting a full RDK stack is also quite time consuming and requires a high end machine having good disk space and CPU power for the build process. In the other hand SDK supports following features to overcome above challenges.</p> <ul> <li>A minimal collection of tool chain, development binaries, supporting headers &amp; libraries are shipped in the form of a self extracting script.</li> <li>Allows to build any component using generic auto tool or similar build approach.</li> <li>Supports packaging so as to install the modified software in target in a easy manner while taking care of the dependencies.</li> </ul> <p>This page provides information that explains how to use both the Yocto SDK to develop images and components using the Yocto Project.\u00a0A SDK consists of the following:</p> <ul> <li>Cross-Development Toolchain     : This toolchain contains a compiler, debugger, and various miscellaneous tools.</li> <li>Libraries, Headers, and Symbols     : The libraries, headers, and symbols are specific to the image (i.e. they match the image).</li> <li>Environment Setup Script     : This *.sh file, once run, sets up the cross-development environment by defining variables and preparing for SDK use.</li> </ul> <p>We can use the standard SDK to independently develop and test code that is destined to run on some target machine.</p> <p>SDKs are completely self-contained. The binaries are linked against their own copy of libc, which results in no dependencies on the target system. To achieve this, the pointer to the dynamic loader is configured at install time since that path cannot be dynamically altered. This is the reason for a wrapper around the populate_sdk and populate_sdk_ext archives.</p> <p>Another feature for the SDKs is that only one set of cross-compiler toolchain binaries are produced per architecture. This feature takes advantage of the fact that the target hardware can be passed to gcc as a set of compiler options. Those options are set up by the environment script and contained in variables such as CC and LD. This reduces the space needed for the tools. Understand, however, that a sysroot is still needed for every target since those binaries are target-specific.</p> <p>The SDK development environment consists of the following:</p> <ul> <li> <p>The self-contained SDK, which is an architecture-specific cross-toolchain and matching sysroots (target and native) all built by the OpenEmbedded build system (e.g. the SDK). The toolchain and sysroots are based on a Metadata configuration and extensions, which allows you to cross-develop on the host machine for the target hardware. </p> </li> <li> <p>Various user-space tools that greatly enhance your application development experience. These tools are also separate from the actual SDK but can be independently obtained and used in the development process.</p> </li> </ul>"},{"location":"source/docs/creating-yocto-sdk/#the-cross-development-toolchain","title":"The Cross-Development Toolchain","text":"<p>The\u00a0Cross-Development Toolchain\u00a0consists of a cross-compiler, cross-linker, and cross-debugger that are used to develop user-space applications for targeted hardware. This toolchain is created by running a toolchain installer script or through a\u00a0Build Directory\u00a0that is based on your Metadata configuration or extension for your targeted device. The cross-toolchain works with a matching target sysroot.</p>"},{"location":"source/docs/creating-yocto-sdk/#sysroots","title":"Sysroots","text":"<p>The native and target sysroots contain needed headers and libraries for generating binaries that run on the target architecture. The target sysroot is based on the target root filesystem image that is built by the OpenEmbedded build system and uses the same Metadata configuration used to build the cross-toolchain.</p>"},{"location":"source/docs/creating-yocto-sdk/#user-space-tools","title":"User-Space Tools","text":"<p>User-space tools, which are available as part of the SDK development environment, can be helpful. The tools include LatencyTOP, PowerTOP, Perf, SystemTap, and Lttng-ust. These tools are common development tools for the Linux platform.</p> <ul> <li> <p>LatencyTOP:     \u00a0LatencyTOP focuses on latency that causes skips in audio, stutters in your desktop experience, or situations that overload your server even when you have plenty of CPU power left.</p> </li> <li> <p>PowerTOP:     \u00a0Helps you determine what software is using the most power.\u00a0</p> </li> <li> <p>Perf:     \u00a0Performance counters for Linux used to keep track of certain types of hardware and software events.\u00a0</p> </li> <li> <p>SystemTap:     \u00a0A free software infrastructure that simplifies information gathering about a running Linux system. This information helps you diagnose performance or functional problems. l.</p> </li> <li> <p>Lttng-ust:     \u00a0A User-space Tracer designed to provide detailed information on user-space activity.\u00a0</p> </li> </ul>"},{"location":"source/docs/creating-yocto-sdk/#sdk-development-model","title":"SDK Development Model","text":"<p>Fundamentally, the SDK fits into the development process as follows:</p> <p></p> <p>The SDK is installed on any machine and can be used to develop applications, images, and kernels. An SDK can even be used by a QA Engineer or Release Engineer. The fundamental concept is that the machine that has the SDK installed does not have to be associated with the machine that has the Yocto Project installed. A developer can independently compile and test an object on their machine and then, when the object is ready for integration into an image, they can simply make it available to the machine that has the Yocto Project. Once the object is available, the image can be rebuilt using the Yocto Project to produce the modified image.</p> <p>You just need to follow these general steps:</p> <ol> <li> <p>Install the SDK for your target hardware: For information on how to install the SDK, see the \"Installing the SDK\" section.</p> </li> <li> <p>Download the Target Image: The Yocto Project supports several target architectures and has many pre-built kernel images and root filesystem images. If you are going to develop your application on hardware, go to the machines\u00a0download area and choose a target machine area from which to download the kernel image and root filesystem. This download area could have several files in it that support development using actual hardware. For example, the area might contain <code>.hddimg</code> files that combine the kernel image with the filesystem, boot loaders, and so forth. Be sure to get the files you need for your particular development process.</p> </li> <li> <p>Develop and Test your Application: At this point, you have the tools to develop your application. If you need to separately install and use the emulator, you can go to Emulator to download and learn about the emulator.\u00a0</p> </li> </ol>"},{"location":"source/docs/creating-yocto-sdk/#using-the-sdk","title":"Using the SDK","text":""},{"location":"source/docs/creating-yocto-sdk/#generating-sdk","title":"Generating SDK","text":"<p>To generate SDK use the following command: <pre><code>$ bitbake  &lt;image&gt;  -c populate_sdk\n#e.g: $ bitbake\u00a0rdk-generic-broadband-image -c populate_sdk\n</code></pre> The command results in a toolchain installer that contains the sysroot that matches your target root filesystem. Another powerful feature is that the toolchain is completely self-contained. The binaries are linked against their own copy of libc, which results in no dependencies on the target system. To achieve this, the pointer to the dynamic loader is configured at install time since that path cannot be dynamically altered. This is the reason for a wrapper around the populate_sdk archive.</p> <p>Remember, before using BitBake command, you must source the build environment setup script and you must make sure yourconf/local.conf variables are correct. In particular, you need to be sure the MACHINE variable matches the architecture for which you are building and that the SDKMACHINE variable is correctly set if you are building a toolchain designed to run on an architecture that differs from your current development host machine (i.e. the build machine).</p> <p>When the bitbake command completes, the SDK will be populated in tmp/deploy/sdk location.</p>"},{"location":"source/docs/creating-yocto-sdk/#installing-sdk","title":"Installing SDK","text":"<p>The first thing you need to do is install the SDK on your host development machine by running the\u00a0 <code>*.sh</code> \u00a0installation script.</p> <p>The toolchains the Yocto Project provides are based off the\u00a0 <code>core-image-sato</code> \u00a0image and contain libraries appropriate for developing against that image. Each type of development system supports five or more target architectures.</p> <p>The names of the tarball installer scripts are such that a string representing the host system appears first in the filename and then is immediately followed by a string representing the target architecture.</p> <p><pre><code>rdk-glibc-host_system-image_type-arch-toolchain-release_version.sh\n</code></pre> Where:  - <code>host_system</code> is a string representing your development system: For e.g. <code>i686</code> or <code>x86_64</code>  - <code>image_type</code> is the image for which the SDK was built.  - <code>arch</code> is a string representing the tuned target architecture: For e.g., <code>i586</code>, <code>x86_64</code>, <code>powerpc</code>, <code>mips</code>, <code>armv7a</code> or <code>armv5te</code>  - <code>release_version</code>  is a string representing the release number of the Yocto Project: For e.g., <code>2.0</code> </p> <p>For example, the following toolchain installer is for a 64-bit development host system and a i586-tuned target architecture based off the SDK for <code>core-image-sato</code> and using the  2.1 snapshot: <pre><code>rdk-glibc-x86_64-arm-toolchain-2.0.sh\n</code></pre></p> <p>The SDK and toolchains are self-contained and by default are installed into <code>/opt/poky</code> . . However, when you run the SDK installer, you can choose an installation directory.</p> <p>Note</p> <p>You must change the permissions on the toolchain installer script so that it is executable: <pre><code>$ chmod +x rdk-glibc-x86_64-arm-toolchain-2.0.sh\n</code></pre> The following command shows how to run the installer given a toolchain tarball for a 64-bit x86 development host system and a 32-bit x86 target architecture. The example assumes the toolchain installer is located in <code>~/Downloads/</code></p> <p>RW Permissions</p> <p>If you do not have write permissions for the directory into which you are installing the SDK, the installer notifies you and exits. Be sure you have write permissions in the directory and run the installer again.</p> <pre><code>$ ./rdk-glibc-x86_64-arm-toolchain-2.0.sh \n\nRDK (A Yocto Project based Distro) SDK installer version 2.0 \n============================================================  \nEnter target directory for SDK (default: /opt/rdk/2.0): \nYou are about to install the SDK to \"/opt/rdk/2.0\". Proceed[Y/n]? Y \nExtracting SDK............................................................................done \nSetting it up...done \nSDK has been successfully set up and is ready to be used\nEach time you wish to use the SDK in a new shell session, you need to source the environment setup script e.g. \n$ . /opt/rdk/2.0/environment-setup-cortexa7t2hf-neon-vfpv4-rdk-linux-gnueabi\n</code></pre>"},{"location":"source/docs/creating-yocto-sdk/#running-the-sdk-environment-setup-script","title":"Running the SDK Environment Setup Script","text":"<p>Once you have the SDK installed, you must run the SDK environment setup script before you can actually use it. This setup script resides in the directory you chose when you installed the SDK.\u00a0</p> <p>Before running the script, be sure it is the one that matches the architecture for which you are developing. Environment setup scripts begin with the string \" <code>environment-setup</code> \" and include as part of their name the tuned target architecture. For example, the command to source a setup script for an IA-based target machine using i586 tuning and located in the default SDK installation directory is as follows:</p> <pre><code>$ source /mnt/sdk/environment-setup-cortexa7hf-neon-vfpv4-rdk-linux-gnueabi\n</code></pre> <p>When you run the setup script, many environment variables are defined:</p> <pre><code>SDKTARGETSYSROOT - The path to the sysroot used for cross-compilation\nPKG_CONFIG_PATH - The path to the target pkg-config files\nCONFIG_SITE - A GNU autoconf site file preconfigured for the target\nCC - The minimal command and arguments to run the C compiler \nCXX - The minimal command and arguments to run the C++ compiler\nCPP - The minimal command and arguments to run the C preprocessor\nAS - The minimal command and arguments to run the assembler\nLD - The minimal command and arguments to run the linker\nGDB - The minimal command and arguments to run the GNU Debugger\nSTRIP - The minimal command and arguments to run 'strip', which strips symbols \nRANLIB - The minimal command and arguments to run 'ranlib'\nOBJCOPY - The minimal command and arguments to run 'objcopy' \nOBJDUMP - The minimal command and arguments to run 'objdump'\nAR - The minimal command and arguments to run 'ar' \nNM - The minimal command and arguments to run 'nm' \nTARGET_PREFIX - The toolchain binary prefix for the target tools \nCROSS_COMPILE - The toolchain binary prefix for the target tools\nCONFIGURE_FLAGS - The minimal arguments for GNU configure\nCFLAGS - Suggested C flags\nCXXFLAGS - Suggested C++ flags\nLDFLAGS - Suggested linker flags when you use CC to link \nCPPFLAGS - Suggested preprocessor flags\n</code></pre>"},{"location":"source/docs/creating-yocto-sdk/#autotools-based-projects","title":"Autotools-Based Projects","text":"<p>Once you have a suitable cross-toolchain installed, it is very easy to develop a project outside of the OpenEmbedded build system. This section presents a simple \"Helloworld\" example that shows how to set up, compile, and run the project.</p>"},{"location":"source/docs/creating-yocto-sdk/#creating-and-running-a-project-based-on-gnu-autotools","title":"Creating and Running a Project Based on GNU Autotools","text":"<p>Create a Project Directory</p> <p>Create and enter a clean project directory</p> <pre><code>mkdir -p $HOME/helloworld\ncd $HOME/helloworld\n</code></pre> <p>Populate the Project Files</p> <p>Create the following three files in your project directory:</p> <p>hello.c</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    printf(\"Hello World!\\n\");\n    return 0;\n}\n</code></pre> <p>Makefile.am</p> <pre><code>bin_PROGRAMS = hello\nhello_SOURCES = hello.c\n</code></pre> <p>configure.in</p> <pre><code>AC_INIT(hello.c)\nAM_INIT_AUTOMAKE(hello, 0.1)\nAC_PROG_CC\nAC_PROG_INSTALL\nAC_OUTPUT(Makefile)\n</code></pre> <p>Source the Cross-Toolchain Environment</p> <p>Before building, source the environment setup script provided by your cross-toolchain SDK. This script is typically named <code>environment-setup-*</code>.</p> <p>Example:</p> <pre><code>source /opt/rdk/2.0/environment-setup-cortexa7t2hf-neon-vfpv4-rdk-linux-gnueabi\n</code></pre> <p>Create GNU Standard Files</p> <p>Create placeholder files required by GNU coding standards:</p> <pre><code>touch NEWS README AUTHORS ChangeLog\n</code></pre> <p>Generate the <code>configure</code> Script</p> <p>Run Autotools to generate the <code>configure</code> script:</p> <pre><code>autoreconf -i\n</code></pre> <p>Configure the Build (Cross-Compile)</p> <p>Use the cross-compiler to configure the build:</p> <pre><code>./configure ${CONFIGURE_FLAGS}\n</code></pre> <p>Replace <code>${CONFIGURE_FLAGS}</code> with any required options specific to your target platform.</p> <p>Build and Install the Project</p> <p>Compile and install the project locally:</p> <pre><code>make\nmake install DESTDIR=./tmp\n</code></pre> <p>The binary will be installed to <code>./tmp/usr/local/bin/hello</code>.</p> <p>Verify the Installation</p> <p>Check the binary to ensure it's built for the correct architecture:</p> <pre><code>file ./tmp/usr/local/bin/hello\n</code></pre> <p>Run the Project</p> <p>Run the binary (either locally or on the target device):</p> <pre><code>./hello\n</code></pre> <p>Expected output:</p> <pre><code>Hello World!\n</code></pre>"},{"location":"source/docs/creating-yocto-sdk/#passing-host-options","title":"Passing Host Options","text":"<p>For an Autotools-based project, you can use the cross-toolchain by just passing the appropriate host option to\u00a0<code>configure.sh</code> . The host option you use is derived from the name of the environment setup script found in the directory in which you installed the cross-toolchain. For example, the host option for an ARM-based target that uses the GNU EABI is  <code>armv5te-poky-linux-gnueabi</code> . You will notice that the name of the script is <code>environment-setup-armv5te-poky-linux-gnueabi</code> . Thus, the following command works to update your project and rebuild it using the appropriate cross-toolchain tools:</p> <pre><code>$ ./configure --host=arm-rdk-linux-gnueabi --prefix=/usr --with-libtool-sysroot=sysroot_dir\n</code></pre> <p>Note</p> <p>If the\u00a0<code>configure</code> \u00a0script results in problems recognizing the <code>--with-libtool-sysroot=</code><code>sysroot-dir</code> \u00a0option, regenerate the script to enable the support by doing the following and then run the script again</p> <pre><code>$ libtoolize --automake\n$ aclocal -I ${OECORE_NATIVE_SYSROOT};/usr/share/aclocal   [-I dir_containing_your_project-specific_m4_macros]\n$ autoconf\n$ autoheader\n$ automake -a\n</code></pre>"},{"location":"source/docs/creating-yocto-sdk/#makefile-based-projects","title":"Makefile-Based Projects","text":"<p>For Makefile-based projects, the cross-toolchain environment variables established by running the cross-toolchain environment setup script are subject to general\u00a0<code>make</code> \u00a0rules.</p> <p>To illustrate this, consider the following four cross-toolchain environment variables: <pre><code>CC=i586-poky-linux-gcc -m32 -march=i586 --sysroot=/opt/poky/2.1/sysroots/i586-poky-linux\nLD=i586-poky-linux-ld --sysroot=/opt/poky/2.1/sysroots/i586-poky-linux\nCFLAGS=-O2 -pipe -g -feliminate-unused-debug-types\nCXXFLAGS=-O2 -pipe -g -feliminate-unused-debug-types\n</code></pre> Now, consider the following three cases:</p> <ul> <li> <p>Case 1 - No Variables Set in the <code>Makefile</code>:     Because these variables are not specifically set in the <code>Makefile</code> , the variables retain their values based on the environment.</p> </li> <li> <p>Case 2 - Variables Set in the\u00a0<code>Makefile</code> :      Specifically setting variables in the <code>Makefile</code> during the build results in the environment settings of the variables being overwritten.</p> </li> <li> <p>Case 3 - Variables Set when the\u00a0<code>Makefile</code> is Executed from the Command Line:     \u00a0Executing the\u00a0<code>Makefile</code> from the command line results in the variables being overwritten with command-line content regardless of what is being set in the <code>Makefile</code> . In this case,  environment variables are not considered unless you use the \"-e\" flag during the build: <pre><code>$ make -e file\n</code></pre> If you use this flag, then the environment values of the variables override any variables specifically set in the <code>Makefile</code></p> </li> </ul>"},{"location":"source/docs/how-to-contribute/","title":"How to Contribute","text":""},{"location":"source/docs/how-to-contribute/#before-you-contribute","title":"Before You Contribute","text":"<p>In order to contribute code, first-time users are requested to agree to the license at\u00a0RDK Central Wiki. As an unaffiliated individual, you must sign the  CLA . You can complete that process online.</p>"},{"location":"source/docs/how-to-contribute/#what-is-a-cla","title":"What is a CLA?","text":"<p>The Contributor License Agreement is necessary mainly because you own the copyright to your changes, even after your contribution becomes part of our codebase, so we need your permission to use and distribute your code. We also need to be sure of various other things \u2014 for instance that you\u2018ll tell us if you know that your code infringes on other people\u2019s patents.</p> <p>You don\u2018t have to sign the CLA until after you\u2019ve submitted your code for review and a member has approved it, but you must do it before we can put your code into our codebase. Before you start working on a larger contribution, get in touch with us to discuss your idea so that we can help out and possibly guide you. Early coordination makes it much easier to avoid frustration later on.</p>"},{"location":"source/docs/how-to-contribute/#code-reviews","title":"Code Reviews","text":"<p>All submissions, including submissions by project members, require review. We use both Gerrit ( Gerrit Code Review ) and Github ( Github Code Review ) depending on where the repo is hosted. Currently, team-member submissions are reviewed privately, and external submissions go through public reviews.</p>"},{"location":"source/docs/how-to-contribute/#code-submission-process","title":"Code Submission Process","text":"<p>The following steps explain the submission process:</p> <ul> <li>Ensure you or your company have signed the appropriate CLA as discussed in the     \u00a0     Before You Contribute     \u00a0     section above.</li> <li>Rebase your changes down into a single git commit.</li> <li>Run     \u00a0     <code>git push command</code>     \u00a0     to upload the review to     \u00a0     code.rdkcentral     .</li> <li>Someone from the maintainers team reviews the code, adding comments on any things that need to change before the code can be submitted.</li> <li>If you need to make changes, make them locally, test them, then     \u00a0     <code>git commit \u00a0 -- amend</code>     \u00a0     to add them to the     \u00a0     existing     \u00a0     commit. Then return to step 2.</li> <li>If you do not need to make any more changes, a maintainer integrates the change into our private repository, and it is pushed out to the public repository after some time.</li> </ul>"},{"location":"source/docs/how-to-contribute/#contributor-license-agreement-cla-rdk-central-github","title":"Contributor License Agreement (CLA) - RDK Central Github","text":"<p>The RDK CLA facilitates the acceptance and sharing of RDK contributions within the community.</p> <p>When you contribute to an RDK open source project on GitHub via a new pull request, a bot will evaluate whether you have signed the CLA. The bot will comment on the pull request, including a link to accept the agreement.</p> <p>CLA assistant enables contributors to sign CLAs from within a pull request. The CLA is stored as a GitHub Gist file and linked with the repository/organization in CLA assistant.</p>"},{"location":"source/docs/how-to-contribute/#cla-assistant","title":"CLA assistant","text":"<ul> <li>Comments on each opened pull request to ask the contributor to sign the CLA.</li> <li>Allows contributors to sign a CLA from within a pull request.</li> <li>Authenticates the signee with his or her GitHub account.</li> <li>Updates the status of a pull request when the contributor agrees to the CLA.</li> <li>Automatically asks users to re-sign the CLA for each new pull request in the event the associated Gist &amp; CLA has changed.</li> <li>Repository owners can review a list of users who signed the CLA for each version of it.</li> </ul> <p>Note - CLA assistant is provided by SAP as a free hosted offering under:\u00a0 cla-assistant.io </p>"},{"location":"source/docs/how-to-contribute/#code-contribution-process","title":"Code Contribution Process","text":""},{"location":"source/docs/how-to-contribute/#code-contribution-workflow","title":"Code Contribution Workflow","text":"<p>The Code Contribution Workflow is designed to facilitate community involvement in the development of RDK components. The structured process ensures that contributions are reviewed, validated and integrated effectively, maintaining high standards of quality throughout.</p>"},{"location":"source/docs/how-to-contribute/#branch-overview","title":"Branch Overview","text":"<ol> <li> <p>Product Branch</p> <ul> <li>The Product Branch is a deployment-ready branch where the community submits changes for review. This branch serves as the main integration point for code that meets rigorous testing qualifications.</li> <li>For more information on the components hosted in the product branch, refer to the CMF Gerrit and the RDK Central GitHub repository.</li> </ul> </li> <li> <p>Monthly Sprint Branch (rdk-dev-yymm)</p> <ul> <li>Created monthly as a new CMF integration branch, this branch is based on the product branch.</li> <li>It is hosted per repository and aims to incorporate community changes as early as possible.</li> <li>Once community changes are approved, they will be cherry-picked to the monthly sprint branch, making them available before the final down-streaming to the regression branch.</li> </ul> </li> <li> <p>Regression Branch</p> <ul> <li>This branch is used for validating contributions.</li> <li>Approved changes are down-streamed here for pre-deployment validation through the established testing process.</li> <li>Defects and features will be planned in monthly sprints, with timelines published to contributors.</li> <li>Contributions pending validation will be available in monthly development iteration branches.</li> </ul> </li> </ol>"},{"location":"source/docs/how-to-contribute/#contribution-process","title":"Contribution Process","text":"<ul> <li>Users will make code contributions to the rdk-next branch. This process includes:<ul> <li>Code reviews</li> <li>Build verification</li> <li>License compliance scans</li> <li>Test validation</li> </ul> </li> <li>Once the changes are successfully validated, changes are cherry-picked to the monthly sprint branch (rdk-dev-yymm).</li> <li>These changes are then down-streamed to the regression branch for further pre-deployment testing.</li> <li>After successful validation, the changes are cherry-picked to the product branch, completing the integration into the main deployment-ready branch.</li> </ul> <p>Component owners/reviewers/approvers, defined as specific groups in Gerrit, will be added to the review by default. You may request additional feedback by specifically adding reviewers via the Gerrit web GUI.\u00a0</p>"},{"location":"source/docs/how-to-contribute/#development-workflow","title":"Development Workflow","text":"<p>This section describes the general RDK development work-flow and related topics. The general pattern for successfully accepting a change is as follows:</p> <ul> <li>Discuss on mailing list to get general consensus about approach.</li> <li>Pull latest code.</li> <li>Build on your supported platform.</li> <li>Develop features or fix bugs following     \u00a0     RDK Coding standards     .</li> <li>Submit to Gerrit for review.</li> <li>Review and respond to reviewer comments.</li> <li>Change accepted and merged.</li> </ul> <p>For a detailed step by step description, please refer:\u00a0Gerrit Development Workflow .</p>"},{"location":"source/docs/how-to-contribute/#code-management-facility-cmf","title":"Code Management Facility (CMF)","text":"<p>On a periodic basis, RDK code is tested and released to the community as \u00a0 CMF releases . This will be generic RDK code without dependency to any platform. CMF code can be built for \u00a0 raspberry-pi \u00a0 or can be ported to a specific platform ( RDK Porting ). And once the component owner approves this change, it will be available to the community in RDK central.</p>"},{"location":"source/docs/how-to-contribute/#cmf-contributions","title":"CMF Contributions","text":"<p>While working with CMF stack, one might find ways to enhance RDK code by adding new features or bug fixes as RDK contribution. The general CMF contribution workflow is as follows:</p> <p></p> <p>Detailed information on contributing code changes to RDK can be found here:\u00a0 Code Management Documentation</p>"},{"location":"source/docs/how-to-contribute/#getting-support","title":"Getting Support","text":"<p>Support tickets can be raised to get request support from RDK Community Support team. This can be for the bugs you face, doubts you have or any code contributions which you think might enhance RDK. RDK Support ticket can be raised here: support@rdkcentral .</p>"},{"location":"source/docs/how-to-contribute/#jira-guidelines","title":"JIRA Guidelines","text":""},{"location":"source/docs/how-to-contribute/#where-to-create-a-jira-ticket","title":"Where to Create a JIRA ticket","text":"<ul> <li>Log in to JIRA\u00a0     jira.rdkcentral     \u00a0using rdkcentral credentials</li> <li>Create a JIRA ticket under     RDKDEV     (for Video) or     RDKBDEV     (for Broadband).</li> <li>Click on the Create button</li> </ul> <p>A Snap shot for how to create a JIRA.</p> <p></p>"},{"location":"source/docs/how-to-contribute/#jira-guideline-for-patches-contributions","title":"JIRA Guideline for Patches Contributions","text":"<p>Issue type corresponds to the type of contributions we are making. The following issue types can be possible for patches contribution \u221a Incident - Build failure incident issues with the code verification steps such as Black duck scan, Jenkins verification etc. \u221a Bug - Bugs in existing component code. To report a bug, users must create a ticket with type Bug and provide as much information as possible, including:</p> <ul> <li>A clear and concise description of the bug</li> <li>Steps to reproduce the bug</li> <li>The expected behavior</li> <li>The actual behavior</li> <li>Any relevant screenshots, logs or videos</li> </ul> <p>\u221a Task - An individual task which may be part of enhancement of existing feature, etc. \u221a\u00a0Improvement - Improvements such as code refactoring or enhancements in current code.</p> <p>Summary and Descriptions are mandatory fields need to be filled.</p> <p>Click on Create button to Create a new JIRA. Sample example is provided below.</p> <p></p> <p>Note: To know more about how to refresh the patches click\u00a0here .</p>"},{"location":"source/docs/how-to-contribute/#jira-guideline-for-new-feature-contribution","title":"JIRA Guideline for New Feature Contribution","text":"<p>A feature contribution should follow after creating an appropriate JIRA project. This will present a clear picture about the architecture, testing details and other information which will be helpful during the acceptance process of the contribution.</p>"},{"location":"source/docs/how-to-contribute/#mandatory-information","title":"Mandatory information","text":""},{"location":"source/docs/how-to-contribute/#project","title":"Project","text":"<pre><code>For Video &amp; build system (Yocto) related contributions, the ticket should be created under RDKDEV. For broadband, the ticket should be created under RDKBDEV project.\n</code></pre>"},{"location":"source/docs/how-to-contribute/#issue-type","title":"Issue Type","text":"<pre><code>\u221a\u00a0New feature - New feature contributions.\n</code></pre>"},{"location":"source/docs/how-to-contribute/#ticket-status","title":"Ticket Status","text":"<pre><code>Status should be initially Open, and transitioned to the appropriate value while the contribution is being worked on.\n</code></pre>"},{"location":"source/docs/how-to-contribute/#summary","title":"Summary","text":"<p>A brief summary about what we are trying to contribute\u00a0</p>"},{"location":"source/docs/how-to-contribute/#description","title":"Description","text":"<p>A descriptive information about the contribution should be present so that component developers &amp; architecture team can do assessment of the feature. Below details are desirable if the contribution is a new feature or having an significant impact on the current architecture.</p> <p><pre><code>Brief introduction on what the current system lacks &amp; what needs to be done:\n1. Individual task/highlighted point \\#1 brief description.\n2. Individual task/highlighted point \\#2 brief description.\n</code></pre> <pre><code>The following items should be considered/addressed in the documentation for any RDK design initiative\nJIRA Update Checklist\n-----------------------\nThe following JIRA fields MUST be filled in to be considered \"Definition Complete\":\n\\* RDK SoC, RDK OEM - populate these fields for any user story where we have dependency on OEM and/or SoC to perform work in the completion of this user story. Select all that apply, or \u201cNone\u201d if there is no dependency.\n\\* OEM/SoC Impact Details - description of impact (or \"see Solution Overview\" if included in the architecture specification)\n\\* Platforms - ensure correct list of devices\n\\* Validation - type of testing\n\\* Regression - is regression required?\n\\* Dependency - Internal/External\n\\* Description - Solution Overview and Architecture Checklist\nTesting impact/Guidance\n------------------------\n\\* Impacted modules\n\\* Test process\nAutomated Testing\n------------------\n\\* Automation test procedure.\nDiagnostics, Telemetry and Logging\n-----------------------------------\n\\* N/A\nOutbound Network Connections\n------------------------------\n\\* Does this component make outbound connection requests?\n\\* If yes, do the connection requests retry in the case of failure?\n\\*\\* Do the repeated requests use an exponential back-off?\n\\*\\* If a maximum back-off has been defined, is it greater than 10 minutes?\nSecurity\n----------\n\\* For Security Review - Do feature elements:\n\\*\\* make any changes to network port assignments?\n\\*\\* change iptables rules?\n\\*\\* require credentials, passwords, secret data?\n\\*\\* make any changes to our network connections?\n\\*\\* connect to new services or servers?\n\\*\\* use data input from users or external tools?\n\\*\\* use any cryptographic functions?\n\\*\\* create or disclose proprietary or sensitive Co. or device data?\n\\*\\* properly log operational and configuration changes?\n\\*\\* If possible describe what could happen if feature elements are:\n\\*\\*\\* spoofed?\n\\*\\*\\* tampered with?\n\\*\\*\\* used by an unauthorized actor?\n\\*\\* Advanced questions (optional)\n\\*\\*\\* what happens if a record of actions taken is destroyed?\n\\*\\*\\* what happens if an attacker attempts to DOS with the feature?\nSI Concerns\n-------------\n\\* Yes/No/Any\nPerformance expectations\n-------------------------\n\\* Yes/No/Any\nTiming consideration\n----------------------\n\\* If Any.\n</code></pre></p>"},{"location":"source/docs/how-to-contribute/#supplementary-information","title":"Supplementary Information","text":"<ol> <li>Impacted component(s) - Fill in list of impacted RDK components</li> <li>RDK SI Impact - System Integration impacts</li> <li>CPE SW Components - Component names.</li> <li>Test Notes - Describe what tests are performed to validate this contribution and the procedure.</li> <li>Unit Test Result - Description.</li> </ol>"},{"location":"source/docs/how-to-contribute/#code-submission-process-rdk-central-gerrit","title":"Code Submission Process - RDK Central Gerrit","text":"<p>In order to contribute code, first-time users are requested to agree to the license at wiki.rdkcentral .</p> <p>RDK components are hosted at\u00a0 code.rdkcentral . You can submit your code changes for review via that site using the workflow outlined below.</p>"},{"location":"source/docs/how-to-contribute/#create-a-jira-ticket","title":"Create a JIRA ticket","text":"<ul> <li>Refer to\u00a0 JIRA Guidelines for creating a JIRA before pushing your code changes in rdkcentral.</li> </ul>"},{"location":"source/docs/how-to-contribute/#clone-the-repository","title":"Clone the Repository","text":"<p>Clone the component repository from the Gerrit server code.rdkcentral\u00a0into a local workspace</p> <p>Clone with commit-msg hook \u00a0(to add Change-ID footer to commit messages)</p> <pre><code>git clone\u00a0https://code.rdkcentral.com/r/&amp;lt;component-name&amp;gt;\u00a0&amp;lt;component-name&amp;gt; -b &amp;lt;branch-name&amp;gt;\ncd &amp;lt;component-name&amp;gt;\ngitdir=$(git rev-parse --git-dir); curl -o $&amp;#123;gitdir&amp;#125;/hooks/commit-msg https://code.rdkcentral.com/r/tools/hooks/commit-msg ; chmod +x $&amp;#123;gitdir&amp;#125;/hooks/commit-msg\n</code></pre> <p>Click here to find the details about  &amp;  for code submission. <p>**Note:\u00a0** The commit-msg hook is installed in the local Git repository and is a prerequisite for Gerrit to accept commits. The inclusion of the unique Change-ID in the commit message allows Gerrit to automatically associate a new version of a change back to its original review.</p> <p>Note: \u00a0You may need to configure your Git identity on the cloned repository. The email address that your local Git uses should match the email address listed in Gerrit.</p> <p>Example commands to run are as follows:</p> <pre><code>$ git config user.name \"John Doe\"\n$ git config user.email \"john.doe@example.org\"\n</code></pre>"},{"location":"source/docs/how-to-contribute/#work-on-the-change-commit-to-local-clone","title":"Work on the change, commit to local clone","text":"<p>Each commit constitutes a change in Gerrit and must be approved separately. It is recommended to squash several commits into one that represents a change to the project.</p> <p>If necessary, it is possible to squash a series of commits into a single commit before publishing them, using interactive rebase:</p> <pre><code>$ git rebase --interactive\n</code></pre> <p>It is important to preserve the\u00a0 Change-Id \u00a0line when editing and there should only be one \"pick\" entry at the end of this process. The end result is to submit one change to Gerrit.</p>"},{"location":"source/docs/how-to-contribute/#push-the-new-changes-for-gerrit-for-review","title":"Push the new changes for Gerrit for review","text":"<p>Commits will be BLOCKED if the format of the commit message does not comply with the standard. You will see a warning as to why the commit was blocked.</p> <p>Mandatory Information in Commit Message</p> <ol> <li>Associated JIRA ticket (Following the Guideline to create a JIRA)</li> <li>Reason for change information</li> <li>Test procedure by which change can be verified</li> <li>Possible risks of failure</li> </ol> <pre><code>$ git commit --amend\n</code></pre> <p> <pre><code>&amp;lt;JIRA TICKET \\#1&amp;gt;, &amp;lt;JIRA TICKET \\#2&amp;gt;, &amp;lt;JIRA TICKET \\#n&amp;gt; : &amp;lt;one line summary of change&amp;gt;\n&amp;lt;empty line&amp;gt;\nReason\u00a0for\u00a0change: &amp;lt;explanation of change&amp;gt;\nTest Procedure: &amp;lt; test procedure&amp;gt;\nRisks: &amp;lt;side effects and other considerations&amp;gt; [Note: state None\u00a0if\u00a0there are no other considerations]\n&amp;lt;empty line&amp;gt;\nSigned-off-by: Your Name &amp;lt;your_name@email.com&amp;gt;\n</code></pre> <p>Submit your code changes for review</p> <pre><code>$ git push origin HEAD:refs/for/&amp;lt;branch&amp;gt;\n</code></pre> <p>When interfacing with Gerrit you push to a virtual branch /refs/for/&lt;branch&gt;, representing \"code review before submission to branch\". Gerrit will subsequently assign a unique URL for the change, to facilitate access and review via the web UI.</p> <p>Notes: </p> <ul> <li>HEAD \u00a0is a Git symbolic reference to the most recent commit on the current branch. When you change branches,\u00a0 HEAD \u00a0is updated to refer to the new branch's latest commit.</li> <li>The\u00a0 refspec \u00a0in the git push operation takes the form\u00a0 source:destination \u00a0( source \u00a0is the local ref being pushed,\u00a0 destination is the remote ref being updated).</li> </ul>"},{"location":"source/docs/how-to-contribute/#review-notifications-and-addition-of-new-reviewers","title":"Review notifications and addition of new reviewers","text":"<p>Component owners/reviewers/approvers, defined as specific groups in Gerrit, will be added to the review by default. You may request additional feedback by specifically adding reviewers via the Gerrit web GUI.\u00a0</p>"},{"location":"source/docs/how-to-contribute/#scan-and-build-on-code-submission","title":"Scan and build on code submission","text":"<p>BlackDuck, copyright scanning and build jobs will be triggered automatically from CMF Jenkins. The output of these jobs is integrated into the Gerrit voting process via custom labels and will reflect any 'red flag' in a file that has new code changes, whether introduced in the new change/patch-set or not. Scans will post any findings as comments in the Gerrit review. Build jobs also do that, but in addition will upload the build log to the corresponding JIRA ticket (if there is one) as an attachment.</p>"},{"location":"source/docs/how-to-contribute/#code-review-and-scoring-process","title":"Code review and scoring process","text":"<p>Reviewers can comment on and score a given change. The default set of rules for enabling a code change for submission requires:</p> <ul> <li>a Code Review score of +2; this can only be provided by the component owner or an admin;</li> <li>+1 score on any mandatory Gerrit labels configured for the project.</li> </ul> <p>The result of the scoring process and validation rules is to enable the\u00a0 Submit \u00a0action on the Gerrit Web UI and subsequent merge capability to the target branch.</p> <p>Label: Code Review (Highlighted in yellow color) \u00a0For a change to be mergeable, the latest patch set must have a '+2' value approval in this category or label, and no '-2 Do not submit'. Thus -2 on any patch set can block a submit, while +2 on the latest patch set enables it for merging.</p> <p>Labels: Blackduck/Copyright/Component-Build (Highlighted in yellow color) \u00a0For a change to be mergeable, the change must have a '+1' score on these labels, and no '-1 Fails'. Thus, '-1 Fails' can block a submit, while '+1' enables a submit.</p> <p></p>"},{"location":"source/docs/how-to-contribute/#submit-code-change","title":"Submit code change","text":"<p>Only authorized users, i.e. component owners, component approvers or admins, can submit the change allowing Gerrit to merge it to the target branch as soon as possible. A change can be submitted, having satisfied the approval conditions described earlier, by clicking the 'Submit Patch Set n' button within the Gerrit UI.\u00a0When a change has been Submitted, it is automatically merged to the target branch by Gerrit.</p>"},{"location":"source/docs/how-to-contribute/#abandon-change","title":"Abandon change","text":"<p>Depending on the review outcome, it might be decided to abandon the change. The component owner or an authorised user may abandon the change by clicking the \"Abandon Change\" button. The abandoned changes are not removed from the Gerrit database and can be restored at a later stage.</p>"},{"location":"source/docs/how-to-contribute/#submitted-merge-pending","title":"Submitted, Merge Pending","text":"<p>If a change depends on another change that is still in review, it will enter this state. It will be merged automatically by Gerrit once all its dependencies are submitted and merged.</p>"},{"location":"source/docs/how-to-contribute/#change-needs-to-be-reworked","title":"Change needs to be reworked","text":"<p>If you need to rework a change, you need to push another commit with the same\u00a0 Change-ID \u00a0as the original in its commit message. This is the mechanism Gerrit uses to associate or link the two items. The <code>--amend</code> option to the Git commit command prevents a new\u00a0 Change-ID \u00a0being generated by the\u00a0 commit-msg \u00a0hook.</p> <p>The basic steps are outlined below.</p> <p>First, fetch the change. If you still have the checkout that was used to push the original change, you can skip this step.</p> <pre><code>$ git fetch\u00a0https://user@code.rdkcentral.com/r/component1\u00a0refs/changes/02/2/1 &amp;&amp; git checkout FETCH_HEAD\n</code></pre> <p>where the numbering scheme for fetching the changes is as follows:</p> <p>refs/changes/&lt;last two digits of change number&gt; &lt;change number&gt; &lt;patch set number&gt;</p> <p></p> <p>Next, make any necessary source changes, and do:</p> <pre><code>$ git commit --amend\n$ git push origin HEAD:refs/for/&amp;lt;branch&amp;gt;\n</code></pre> <p>A new patch set is now appended to the Gerrit review item, and this will go through the same review process as before.</p>"},{"location":"source/docs/how-to-contribute/#gerrit-merge-failure-as-a-result-of-a-conflict","title":"Gerrit merge failure as a result of a conflict","text":"<p>Essentially this means that the remote branch has evolved since this change was started and now software conflicts with changes in the remote branch. The developer must resolve the merge conflicts in their local clone and then push another patch-set. The process is resumed at step 4, with the important distinction of committing with the --amend option, once the developer pulls the latest changes.\u00a0 Note: \u00a0A summary of the steps involved, assuming the local branch still exists:\u00a0</p> <p>Rebase the local branch to the latest state of origin/&lt;branch&gt;;Resolve all conflicts; Commit with the <code>--amend</code> option; Push changes to Gerrit for review. After this change a new patch set is created for the change.</p> <p>Note: If the local branch no longer exists, the steps are as follows:</p> <pre><code>$ git fetch\u00a0https://user@code.rdkcentral.com/r/rdk_component_1\u00a0refs/changes/58/58/2 &amp;&amp; git checkout FETCH_HEAD\n$ git rebase origin/&amp;lt;branch&amp;gt;\n[Edit the conflicting file, cleaning up the &amp;lt;&amp;lt;&amp;lt;&amp;lt;, ==== &amp;gt;&amp;gt;&amp;gt; markers surrounding the conflicting lines]\n$ git add &amp;lt;file&amp;gt;\n$ git commit --amend\n$ git push origin HEAD:refs/for/&amp;lt;branch&amp;gt;\n</code></pre>"},{"location":"source/docs/how-to-contribute/#rdk-components-product-branch","title":"RDK Components - Product Branch","text":"<p>Following RDK components are hosted at\u00a0 code.rdkcentral . Follow the Instructions to submit your code changes.</p> <p>Example of how to use git clone for meta-rdk-ext component:\u00a0 git clone https://code.rdkcentral.com/r/plugins/gitiles/rdk/components/generic/rdk-oe/meta-rdk-ext \u00a0-b rdk-next</p> <p>List of open-sourced and licensed repositories hosted in RDK central gerrit can be found from Source Code Repositories .</p>"},{"location":"source/docs/how-to-contribute/#code-submission-process-rdk-central-github","title":"Code Submission Process - RDK Central GitHub","text":""},{"location":"source/docs/how-to-contribute/#introduction","title":"Introduction","text":"<p>GitHub is a Git repository hosting service, but it adds many of its own features. While Git is a command line tool, GitHub provides a Web-based graphical interface.</p> <p>GitHub Enterprise is the on-premises version of GitHub and is available on VMware, AWS, and OpenStack KVM, on your own servers or in a private cloud. GitHub Enterprise operates on your infrastructure with your existing information security controls from firewalls and VPNs, to IAM and monitoring systems.</p> <p>CMF GitHub Organizations</p> <p>There is one primary RDKM Code Management organizations, namely RDKcentral. This organization hosts the open-source repositories for projects pertaining to RDK-V, RDK-B and RDK-C profiles.</p> <ul> <li>github/rdkcentral</li> </ul>"},{"location":"source/docs/how-to-contribute/#rdk-central-github-components","title":"RDK Central GitHub Components","text":"<p>Please refer to this link to see all the repositories\u00a0 Source Code Repositories .</p>"},{"location":"source/docs/how-to-contribute/#github-pull-requests","title":"GitHub Pull Requests","text":"<p>Pull requests let you tell others about changes you've pushed to a branch in a repository on GitHub. Once a pull request is opened, you can review the potential changes with collaborators and add follow-up commits before your changes are merged into the base branch. Anyone with read permissions to a repository can create a pull request, but you must have write permissions to create a branch. If you want to create a new branch for your pull request and don't have write permissions to the repository, you can fork the repository first. Pull requests can only be opened between two branches that are different.</p>"},{"location":"source/docs/how-to-contribute/#github-fork","title":"GitHub Fork","text":"<p>A \u2018fork\u2019 is a personal copy of another user's repository that lives on your GitHub account. Forks allow you to freely make changes to a project without affecting the original. A forked project also remains attached to the original, allowing you to submit a pull request to the original's author to update with your changes, ensuring you\u2019re always working off a recent or up-to-date codebase.</p>"},{"location":"source/docs/how-to-contribute/#github-workflow-steps","title":"GitHub Workflow Steps","text":"<ul> <li>Create a Fork by simply clicking on the 'fork' button of the repository page on GitHub.</li> <li>Clone your Fork, the clone command creates a local git repository from your remote fork on GitHub.</li> <li>git clone\u00a0     https://github.com/USERNAME/REPOSITORY.git</li> <li>Modify the Code in your local clone and commit the changes to your local clone using the git commit command.</li> <li>Push your Changes by invoking the git push command, from your workspace, to upload your changes to your remote fork on GitHub.</li> <li>Create a Pull Request by clicking the 'pull request' button on the GitHub page of your remote fork.</li> </ul>"},{"location":"source/docs/how-to-contribute/#configure-your-github-access-token","title":"Configure your Github access token","text":"<p>In the recent past support for direct password authentication was removed from Github. You will need to generate a Github personal token to push your code changes RDK Central Github.</p> <p>To create your personal token, you have to go to github.com -&gt; Settings -&gt; Developer Settings -&gt; Personal Access Token -&gt; Generate New Token.</p> <p>Note - While creating a new token, it will ask for Github configuration options selection \u2013 Select everything.</p> <p>Once the Github token is generated successfull, you will need to add an entry an entry to the ~/.netrc file OR you can directly use this token as your Github password in the command line to push the code changes.</p> <p>Example: how to add Github credential on ~/.netrc file <pre><code>machine\n[github.com](http://github.com)\nlogin your-github-handle-name password ghp_BCy09kNYxg82no6OnliSJQVngGi9K1234567\n</code></pre></p>"},{"location":"source/docs/how-to-contribute/#github-protected-branches","title":"GitHub Protected Branches","text":"<p>Protected branches ensure that collaborators on your repository cannot make irrevocable changes to branches. Enabling protected branches also allows you to enable other optional checks and requirements, like required status checks and required reviews.</p> <p>A custom CMF branch protection scheme is deployed in each repository in order to enforce the desired workflows. This scheme imposes the following rules:</p> <ul> <li>Require pull request reviews before merging</li> <li>Require status checks to pass before merging<ul> <li>blackduck</li> <li>copyright</li> <li>license/cla</li> <li>component-build</li> </ul> </li> </ul> <p>Required status checks ensure that all required CI tests are passing before collaborators can make changes to a protected branch. Status checks are based on external processes, such as continuous integration builds, code compliance scanning, which run for each push you make to a repository. You can see the pending, passing, or failing state of status checks next to individual commits in your pull request.</p>"},{"location":"source/docs/how-to-contribute/#contributor-license-agreement-cla","title":"Contributor License Agreement (CLA)","text":"<p>The RDK CLA facilitates the acceptance and sharing of RDK contributions within the community.</p> <p>When you contribute to an RDK open source project on GitHub via a new pull request, a bot will evaluate whether you have signed the CLA. The bot will comment on the pull request, including a link to accept the agreement.</p> <p>CLA assistant enables contributors to sign CLAs from within a pull request. The CLA is stored as a GitHub Gist file and linked with the repository/organization in CLA assistant.</p> <p>CLA assistant:</p> <ul> <li>Comments on each opened pull request to ask the contributor to sign the CLA</li> <li>Allows contributors to sign a CLA from within a pull request</li> <li>Authenticates the signee with his or her GitHub account</li> <li>Updates the status of a pull request when the contributor agrees to the CLA</li> <li>Automatically asks users to re-sign the CLA for each new pull request in the event the associated Gist &amp; CLA has changed</li> <li>Repository owners can review a list of users who signed the CLA for each version of it.</li> </ul> <p>Note - CLA assistant is provided by SAP as a free hosted offering under:\u00a0 cla-assistant.io</p>"},{"location":"source/docs/how-to-contribute/#compliance-scanning","title":"Compliance Scanning","text":"<p>CMF uses BlackDuck (Protex) to check incoming contributions for license compliance. BlackDuck is normally a very manual tool but a significant level of automation has been developed by the team to reduce manual intervention, but it still requires a human to oversee it.</p> <p>Compliance scanning is looking for several things:</p> <ul> <li>Addition of source code with a conflicting license (e.g. LGPL code in an Apache component).</li> <li>Modification of an opensource component with code of a conflicting license.</li> <li>Incorrect or proprietary copyright attribution.</li> </ul> <p>The key points are as follows:</p> <ul> <li>Scan contribution in GitHub Pull Request.</li> <li>Scan is automatically triggered by a webhook.</li> <li>Results in scan of the contribution only, i.e. only the changes.</li> <li>Required Status Check, associated with the Blackduck scan is updated.</li> <li>Summary of the scan including any code matches are provided via a link to an associated Gist.</li> </ul> <p>OSS Engineer and interested parties are notified of scan failures (violations, pending identifications or reviews etc) via AWS Mailing list and Slack.</p>"},{"location":"source/docs/how-to-contribute/#git-secrets-scanning","title":"git-secrets Scanning","text":"<p>git-secrets is a tool created by AWS Labs that scans commits and commit messages and aims to prevent passwords and other sensitive information being committed to a git repository. The tool can also scan files or folders to look for secrets such as an AWS Access Key ID and AWS Secret Access Keys in a repository. git-secrets scans commits, commit messages, and merge commits to prevent adding secrets into your git repositories. If a commit, commit message, or any commit in merge history matches one of the configured prohibited regular expression patterns, then the commit is rejected.</p>"},{"location":"source/docs/how-to-contribute/#example-of-how-to-push-the-code-changes","title":"Example of how to push the code changes","text":""},{"location":"source/docs/how-to-contribute/#step-1-fork-the-component-from-github","title":"Step 1: Fork the component from GitHub","text":"<p>Sign-in to GitHub with your own credentials.</p> <p>Search for the Component.</p> <p>Fork the component from GitHub. Forking will create a copy (i.e., your own WORKSPACE) of an original component to work.</p> <p></p>"},{"location":"source/docs/how-to-contribute/#step-2-creating-a-new-branch","title":"Step 2: Creating a new Branch","text":"<p>From the file tree view on the left, select the \u00a0 branch dropdown menu, In the \"Find or create a branch...\" text field, type a unique name for your new branch, then click \u00a0 Create branch .</p> <p></p>"},{"location":"source/docs/how-to-contribute/#step-3-clone-the-component-with-new-branch","title":"Step 3: Clone the Component with new branch","text":"<p>Click on the \"Clone or download\" button to get the clone URL from GitHub. Ensure your GitHub username present in the URL to start work with your own workspace.</p> <p></p> <pre><code>abcd123@dvm-yocto4-docker-abcd123:~/builds/meta_wan$ git clone https://github.com/Sukanya673/meta-rdk-wan.git -b new_branch_1\nCloning into 'meta-rdk-wan'...\nremote: Enumerating objects: 276, done.\nremote: Counting objects: 100% (117/117), done.\nremote: Compressing objects: 100% (71/71), done.\nremote: Total 276 (delta 95), refused 47 (delta 41), pack-reused 159 (from 1)\nReceiving objects: 100% (276/276), 59.05 kiB | 2.68 MiB/s, done.\nResolving deltas: 100% (141/141), done.\nabcd123@dvm-yocto4-docker-abcd123:~/builds/meta_wan$\n</code></pre>"},{"location":"source/docs/how-to-contribute/#step-4-work-on-changes-and-gerrit-commands-to-push-the-changes","title":"Step 4: Work on changes and Gerrit commands to push the changes","text":"<p>Make the code changes, and commit the changes</p> <p>cd\u00a0 meta_wan</p> <pre><code>git clone https://github.com/Sukanya673/meta-rdk-wan.git -b new_branch_1</code></pre> <p>Modify your code.</p> <p>$ git status \u00a0 \u00a0Here You will see the files you have locally modified.  $ git add &lt;FILE_NAME&gt; $ git commit -a\u00a0 \u00a0 \u00a0Add the following to your commit message. \u00a0 \u00a0 \u00a0 \u00a0 JIRA-ID Write a small description \u00a0 \u00a0 \u00a0 \u00a0 &lt;One empty line&gt; \u00a0 \u00a0 \u00a0 \u00a0 Reason for change: \u00a0 \u00a0 \u00a0 \u00a0 Test Procedure: \u00a0 \u00a0 \u00a0 \u00a0 Risks:\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 Signed-off-by:</p> <p>$ git push</p> <p>After submitting your changes, follow the next step to create a PR.</p>"},{"location":"source/docs/how-to-contribute/#step-5-create-pull-request-for-review-the-changes","title":"Step 5: Create pull request for review the changes","text":"<p>Once submitted the changes need to create pull request from GitHub for review. Pull requests \u00a0 let you tell others about changes you've pushed to a branch in a repository on \u00a0 GitHub . Once a \u00a0 pull request \u00a0 is opened, you can discuss and review the potential changes with collaborators and add follow-up commits before your changes are merged into the base branch.</p> <ul> <li>Click on \"Compare &amp; pull request\" button.</li> </ul> <p></p> <ul> <li>Provide the commit request and Click on\u00a0\"Create pull request\" button.</li> </ul> <p></p> <ul> <li>Pull Request page will be created.</li> </ul> <p></p>"},{"location":"source/docs/how-to-contribute/#step-6-working-on-review-comments","title":"Step 6: Working on review comments","text":"<p>Once you've created a pull request, you can push commits from your workspace to add them to your existing pull request. These commits will appear in chronological order within your pull request and the changes will be visible in the \"Files changed\" tab.</p> <p>Other contributors can review your proposed changes, add review comments, contribute to the pull request discussion, and even add commits to the pull request.  </p>"},{"location":"source/docs/how-to-contribute/#documenting-the-code","title":"Documenting the Code","text":""},{"location":"source/docs/how-to-contribute/#why-to-document","title":"Why to Document?","text":"<p>Writing documentation improves the design of your code. Talking through your API and design decisions on paper allows you to think about them in a more formalized way. A nice side effect is that it allows people to contribute code that follows your original intentions as well.</p>"},{"location":"source/docs/how-to-contribute/#how-to-document","title":"How to Document?","text":"<p>RDK component code is documented following the Doxygen standards and guidelines. Doxygen is a popular open-source tool for generating documentation from annotated C/C++ sources. Also, Doxygen supports documenting code written in other programming languages, such as Python, PHP, Java, etc.</p>"},{"location":"source/docs/how-to-contribute/#tools-required-for-doxygen-documentation","title":"Tools Required for Doxygen Documentation","text":"<p>The following tools\u00a0are required to be installed in Linux machine (through apt-get install) to generate documentation with respect to various data flow diagrams.</p> <ol> <li>doxygen : It is a tool for a documentation system for various programming languages such as C++, C, Java and Objective-C.</li> <li>graphviz : Rich set of graph drawing tools. It was required to fulfill the need for centralized documentation presenting all available tools in the graphviz package.</li> <li>dot : Filter for drawing directed graphs. A graph that can be drawn as hierarchy. It reads attributed graph files and writes drawings. By default, the output format dot is the input file with layout coordinates appended.</li> <li>perl : It is a script file used by doxygen, and it should be present in the system.</li> <li>mscgen : Message Sequence Chart Renderer. This will help to make sequence diagram for Doxygen documentation.</li> </ol>"},{"location":"source/docs/how-to-contribute/#steps-to-generate-document-using-doxygen","title":"Steps to Generate Document using Doxygen","text":"<p>The following are the steps to generate documentation using Doxygen tool.</p> <ol> <li>Create a new folder \u201cexample_name\". This is where the final report will reside.</li> <li>Go to directory \u201cexample_name\u201d.</li> <li>Reference doxygen configuration file</li> <li>Doxygen.dox: used for customizing the index page.</li> <li>doxygen.css: style sheet file used for formatting html output.</li> <li>Doxyfile: Configuration file that is needed for generating doxygen output.</li> <li>RDK-Logo.png: RDK Logo.</li> <li>Check out all the RDK component source code (Source code must be Doxygen complaint) for which document needs to be generated, for example:</li> <li>$ git clone https://code.rdkcentral.com/r/rdk/components/generic/wifi \u00a0\u00a0 wifi</li> <li>Edit Doxyfile and set all configurations as required, given below are examples</li> <li>PROJECT_NAME\u00a0 /* Name of the project */</li> <li>INPUT\u00a0\u00a0\u00a0/* Path of source code provided as input for document generation*/</li> <li>OUTPUT_DIRECTORY /* output folder path */</li> <li>Edit doxygen.dox, if the index page needs to be customized, add module names that will be shown in output index page.</li> <li>Edit doxygen.css, for output formats, fonts, etc.</li> <li>Use the following command at the command prompt, to generate html report.</li> <li>$\u00a0 doxygen Doxyfile</li> <li>Doxygen Output HTML report will be available at '/example_name/OUTPUT_DIRECTORY/html' folder, open index.html file to see Doxygen report.</li> </ol>"},{"location":"source/docs/how-to-contribute/#steps-to-add-module-level-information-to-components","title":"Steps to add module level information to components","text":"<p>Refer to below Doxygen Guideline Section for uniform style of adding Doxygen comments for the RDK system.  </p>"},{"location":"source/docs/how-to-contribute/#doxygen-guideline","title":"Doxygen Guideline","text":""},{"location":"source/docs/how-to-contribute/#introduction_1","title":"Introduction","text":"<p>The purpose of this page is to provide a uniform style of Doxygen commenting for the RDK system. It will serve as a reference for current and future developers while documenting the RDK system as it evolves. Ultimately, this will establish a consistent manner of documentation to enhance the simplicity, readability, scalability, writability, reliability, and maintainability of the system.\u00a0</p>"},{"location":"source/docs/how-to-contribute/#documentation-style","title":"Documentation Style","text":"<p>Doxygen documentation can be generated in many formats (HTML, LaTeX, RTF, PDF, DOC). HTML generation has support for more plugins and is easier to refactor as the system changes. Doxygen style should follow a consistent format to aid development across different IDEs, reducing issues when generating documentation.</p> <pre><code>/\\*\\*\n\\* @tagname\n\\*/\n</code></pre> <p>This is an example of a Java doc style Doxygen tag, since it uses the \u201c@\u201d symbol. Tags using the \u201c\\tagname\u201d style are considered Qt style Doxygen tags.There should be a header file containing only Doxygen tags or a separate Doxygen file that acts as a guide for the components, classes, methods, and variables (e.g. DoxygenMainpage.h). This can be done using the\u00a0@mainpage\u00a0tag at the top of the file.</p>"},{"location":"source/docs/how-to-contribute/#system","title":"System","text":"<p>There should be a header file containing only Doxygen tags or a separate Doxygen file that acts as a guide for the components, classes, methods, and variables (e.g., DoxygenMainpage.h). This can be done using the @mainpage\u00a0tag at the top of the file.</p> <pre><code>/\\*\\*\n\\* @mainpage Title of Document\n\\*\n\\*/\n</code></pre>"},{"location":"source/docs/how-to-contribute/#file","title":"File","text":"<p>A file should contain the\u00a0@file\u00a0tag at the top of the file. This supports generation of a file list tab on the main page. It also helps when files contain multiple classes.</p> <pre><code>/\\*\\*\n\\* @file FileName.h\n\\*\n\\* @brief Brief file description.\n\\*\n\\* Verbose file description.\n\\*/\n</code></pre>"},{"location":"source/docs/how-to-contribute/#classes","title":"Classes","text":"<p>Classes can be tagged in a number of different ways, but in general they are tagged using the\u00a0@brief\u00a0and\u00a0@class\u00a0tags before the class declaration. Having the\u00a0@author,\u00a0@date, and\u00a0@version\u00a0supports tractability as the system is versioned throughout the software lifecycle. When updating classes, update comments like this:</p> <pre><code>\\#include &amp;lt;iostream&amp;gt;\nusing namespace std;\n/\\*\\*\n\\* @brief Brief class description\n\\*\n\\* Verbose description of class.\n\\*\n\\* @class Class Name\n\\*/\nclass ClassName &amp;#123;\npublic:\nClassName();\n~ClassName();\nint var1; /\\*\\*&amp;lt; Comment about public member variable\\*/\n/\\*\\*\n\\*@brief Brief method description\n\\*\n\\* Verbose description of method\n\\*\n\\*@param Parameter in the method\u2019s definition\n\\*\n\\*@return Return value of method\n\\*/\nint Function1(int x);\nprotected:\nint var2; /\\*\\*&amp;lt; Comment about protected member variable\\*/\n/\\*\\*\n\\*@brief Brief method description\n\\*\n\\* Verbose description of method\n\\*\n\\*@param Parameter in the method\u2019s definition\n\\*\n\\*@return Return value of method\n\\*/\nint Function2(int x);\nprivate:\nint var3; /\\*\\*&amp;lt; Comment about private member variable\\*/\n/\\*\\*\n\\*@brief Brief method description\n\\*\n\\* Verbose description of method\n\\*\n\\*@param Parameter in the method\u2019s definition\n\\*\n\\*@return Return value of method\n\\*/\nint Function3(int x);\n&amp;#125;;\n</code></pre>"},{"location":"source/docs/how-to-contribute/#structs","title":"Structs","text":"<p>A struct can be tagged in the same way a class, but it is best to use the \u00a0 @struct \u00a0 tag. When updating structs, update comments like this:</p> <pre><code>/\\*\\*\n\\*@brief Brief struct description\n\\*\n\\*@struct Struct Name\n\\*/\n</code></pre>"},{"location":"source/docs/how-to-contribute/#methods","title":"Methods","text":"<p>Methods can be tagged in a number of ways, but in general the \u00a0 @brief ,\u00a0 @details ,\u00a0 @param , and \u00a0 @return \u00a0 tags are used before a method\u2019s declaration or implementation. When updating methods, update comments like this:</p> <pre><code>/\\*\\*\n\\*@brief Brief method description\n\\*\n\\* Verbose description of method\n\\*\n\\*@param Parameter in the method\u2019s definition\n\\*\n\\*@return Return value of method\n\\*@retval Verbose explanation of return values\n\\*/\nint addNumbers(int x)\n&amp;#123;\nint sum = 0;\nsum += x;\u00a0\nreturn sum;\u00a0\n&amp;#125;\n</code></pre>"},{"location":"source/docs/how-to-contribute/#variables","title":"Variables","text":"<p>When updating variables, update comments like this:</p> <pre><code>int number; /\\*\\*&amp;lt; Comment about number\\*/\n</code></pre>"},{"location":"source/docs/how-to-contribute/#enumerated-types","title":"Enumerated Types","text":"<p>Enumerated types are tagged using the\u00a0 @enum . \u00a0When updating enum types, update comments like this:</p> <pre><code>/\\*\\*\n\\*@brief Brief enum description\n\\*\n\\*@enum enum Name\n\\*/\n</code></pre>"},{"location":"source/docs/how-to-contribute/#miscellaneous","title":"Miscellaneous","text":"<p>There are many tags you can use with HTML markup to create unique Doxygen documentation for a given file, class, method, or variable. The following are common tags that should be used when appropriate.</p> <p><pre><code>/\\*\\*\n\\*@note A brief remark about the implementation to help clarify.\n\\*\n\\*@attention An important remark that may cause code to break.\n\\*\n\\*@warning An import remark that may depend on random conditions etc.\n\\*\n\\*@see A reference to a class or a link to documentation (e.g. http://document.1a.com)\n\\*/\n</code></pre> <pre><code>/\\*\\*\n\\*@bug A remark about a known bug in the code.\n\\*\n\\*@todo A remark of what needs to be done to fix issues or remaining work.\n\\*\n\\*/\n</code></pre> <pre><code>/\\*\\*\n\\*@a Formats following word in special font (used for hyperlinks)\n\\*\n\\*@b Formats following word in bold\n\\*\n\\*@em Formats following word in italic\n\\*\n\\*@c Formats following word in monospaced typewriter font\n\\*\n\\*/\n</code></pre> <pre><code>/\\*\\*\n\\* - bulleted list item1\n\\* - sub bulleted item1\n\\*\n\\* - bulleted list item2\n\\*\n\\*/\n</code></pre> <pre><code>/\\*\\*\n\\* -# numbered list item1\n\\* -# numbered list item2\n\\*\n\\*/\n</code></pre> <pre><code>/\\*\\*\n\\*@code\ni++;\n\\*@endcode\n\\*/\n</code></pre></p>"},{"location":"source/docs/how-to-contribute/#setting-up-doxygen-environment-on-linux","title":"Setting up Doxygen Environment on Linux","text":"<p>Tools Required for Doxygen Documentation:</p> <pre><code>Following Tools are need to be installed in Linux machine (through apt-get install) to generate documentation with respect to various data flow diagrams.\n\u00a0 \u00a0 $ sudo apt-get install \"doxy\\*\"\n\u00a0 \u00a0 $ sudo apt-get install graphviz\n\u00a0 \u00a0 $ sudo apt-get install dot\n\u00a0 \u00a0 $ sudo apt-get install mscgen\n\u00a0 \u00a0 $ sudo apt-get install perl\n</code></pre> <p>Check the doxygen version by using command: \u00a0 <code>$ doxygen --version</code> Graphviz:\u00a0 graphviz.org (Click the Download link on the left side of the page)</p>"},{"location":"source/docs/how-to-refresh-the-patches/","title":"How to Refresh the Patches","text":""},{"location":"source/docs/how-to-refresh-the-patches/#overview","title":"Overview","text":"<p>Sometimes while applying patches, it may face offsets mismatch and results in failure. This makes your build verification also to fail. You can get similar error in console logs for patch failures.</p> <p><pre><code>ERROR: Command Error: exit status: 1 Output:  \nApplying patch index.patch  \npatching file source/Styles/xb3/code/index.php  \nHunk \\#1 succeeded at 22 (offset 21 lines).  \nHunk \\#2 succeeded at 32 (offset 21 lines).  \nHunk \\#3 succeeded at 73 (offset 21 lines).  \nHunk \\#4 succeeded at 183 (offset 27 lines).  \nHunk \\#5 succeeded at 195 (offset 27 lines).  \nHunk \\#6 succeeded at 245 (offset 37 lines).  \nHunk \\#7 succeeded at 307 (offset 37 lines).  \nHunk \\#8 succeeded at 460 (offset 52 lines).  \nHunk \\#9 succeeded at 469 (offset 52 lines).  \nHunk \\#10 FAILED at 431.  \nHunk \\#11 FAILED at 445.  \nHunk \\#12 FAILED at 455.  \n3 out of 12 hunks FAILED -- rejects in file source/Styles/xb3/code/index.php  \nPatch index.patch does not apply (enforce with -f)\n</code></pre> From the logs, you can find out that patch is not applied to the source file properly. In such scenarios you will have to update or refersh the patch.</p>"},{"location":"source/docs/how-to-refresh-the-patches/#step-1-get-the-patch-file","title":"Step 1 : Get the patch file","text":"<p>1.Find the repo for the patch file.(For ex : here the patch file is index.patch.)</p> <p>2.Clone the repo. For ex: <pre><code>$ mkdir patch\n$ cd patch/\n$ git clone ssh://rkumar840@gerrit.teamccp.com:29418/rdk/yocto_oe/layers/meta-rdk-oem-pace-broadcom\n</code></pre> 3.Checkout the branch for which you want to create the patch.</p> <p><pre><code>$ git checkout 1905_sprint\n$ git branch\n</code></pre> 4.Find the location of the patch file in the repo.</p> <pre><code>$ find . -iname index.patch\n./meta-pacexf3/recipes-ccsp/ccsp/ccsp-webui/index.patch\n</code></pre>"},{"location":"source/docs/how-to-refresh-the-patches/#step-2-identify-the-component-repo","title":"Step 2 : Identify the component repo","text":"<ol> <li> <p>Next find the repo for the actual source file to which the patch file was getting patched. ( For ex: here the source file is index.php)</p> </li> <li> <p>clone the repo Example: <pre><code>$ mkdir source\n$ cd source/\n$ git clone ssh://rkumar840@gerrit.teamccp.com:29418/rdk/rdkb/components/opensource/ccsp/webui/generic\n</code></pre> 3.checkout the required branch</p> </li> </ol> <p><pre><code>$ git checkout 1905_sprint\n$ git branch\n</code></pre> 4.Cherry-pick the required changes also <pre><code>$ git fetch\u00a0ssh://rkumar840@gerrit.teamccp.com:29418/rdk/rdkb/components/opensource/ccsp/webui/generic\n</code></pre> 5.After cherry-picking you can verify the changes in the source file.</p>"},{"location":"source/docs/how-to-refresh-the-patches/#step-3-apply-the-patches","title":"Step 3 : Apply the patches","text":"<p>1. create another directory, and clone the source code repo (as in step 2). For ex :</p> <ul> <li>$ mkdir dummy</li> <li>$ cd dummy/</li> <li>$ git\u00a0\u00a0clone\u00a0     ssh://rkumar840@gerrit.teamccp.com:29418/rdk/rdkb/components/opensource/ccsp/webui/generi     c</li> </ul> <p>2.checkout the required branch</p> <ul> <li>$ git checkout 1905_sprint</li> <li>$ git branch</li> </ul> <p>3.Copy the patch file from the patch repo (step 1) to the current directory.</p> <ul> <li>$ cp ../patch/meta-pacexf3/recipes-ccsp/ccsp/ccsp-webui/index.patch .</li> <li>$ ls</li> </ul> <p>cmpnt_build_custom_pre_arm.mk CONTRIBUTING.md \u00a0 \u00a0 \u00a0 \u00a0debug_scripts\u00a0 \u00a0 \u00a0 LICENSE\u00a0 \u00a0 \u00a0 \u00a0 \u00a0NOTICE\u00a0 \u00a0 \u00a0 \u00a0 \u00a0scripts \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0cmpnt_build_custom_pre_pc.mk \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0COPYING\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 index.patch\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 Makefile.orig\u00a0 \u00a0 \u00a0README\u00a0 \u00a0 \u00a0 \u00a0source</p> <p>4.Apply the patch to the source file/files.</p> <ul> <li>$ patch -p1 &lt; index.patchpatching file source/Styles/xb3/code/index.php     Hunk #1 succeeded at 22 (offset 21 lines).     Hunk #2 succeeded at 32 (offset 21 lines).     Hunk #3 succeeded at 73 (offset 21 lines).     Hunk #4 succeeded at 183 (offset 27 lines).     Hunk #5 succeeded at 195 (offset 27 lines).     Hunk #6 succeeded at 245 (offset 37 lines).     Hunk #7 succeeded at 307 (offset 37 lines).     Hunk #8 succeeded at 445 (offset 37 lines).     Hunk #9 succeeded at 454 (offset 37 lines).     Hunk #10 succeeded at 468 (offset 37 lines).     Hunk #11 succeeded at 482 (offset 37 lines).     Hunk #12 succeeded at 492 (offset 37 lines).</li> </ul> <p>5.It should be applied successfully. In case of observing any failure when apply the patch to the source file/files then skip this step. If no failures observed then take a backup for the file/files got patched. For ex :\u00a0</p> <ul> <li>$ cp source/Styles/xb3/code/index.php source/Styles/xb3/code/index_bk.php</li> </ul> <p>6.In case of observing any failure when apply the patch to the source file/files, then this may\u00a0expects some other patch to be applied first. In such case,</p> <ul> <li>Find the repo init command from the full console log. Search for \"Repo Init\".\u00a0</li> </ul> <p>Example: Repo Init for - Project: &lt; clone_url&gt; Branch: 2003_sprint Manifest: ciscoxb3-3939B</p> <ul> <li>Create another directory</li> </ul> <p>$ mkdir cisco_intel_repo</p> <p>$ cd cisco_intel_repo</p> <ul> <li>Append .xml with manifest filename in repo init command and Clone the repo</li> </ul> <p>$ repo init -u &lt; clone_url&gt; -m ciscoxb3-3939B.xml -b 2003_sprint</p> <p>$\u00a0repo sync -j4 --no-clone-bundle</p> <ul> <li>grep with file name( in which patch applied failure observed) in meta-* layers, So that will find the other patch file which creates this file.</li> </ul> <p>$\u00a0grep -irn \"Filename\" meta-* \u00a0 \u00a0 \u00a0 \u00a0 \u00a0</p> <ul> <li>Analyse and apply the patch file first, and then on top of that apply the second patch file,\u00a0If no failures observed then take a backup for the file/files got patched. For ex :\u00a0</li> </ul> <p>$ cp source/Styles/xb3/code/index.php source/Styles/xb3/code/index_bk.php \u00a0 \u00a0 \u00a0</p>"},{"location":"source/docs/how-to-refresh-the-patches/#step-4-compare-the-files-and-generate-patch","title":"Step 4 : Compare the files and generate patch","text":"<p>1.Now you can use \"Meld tool\" to compare between files to refresh the patch. Here you can compare between the source file generated in step 2 (which will have the required changes) and the source file generated in step-3 (which will have the patch appied on to it).</p> <p>2.During comparing between source files make sure that you take only the required changes (changes available in actual source file step-2) to the patched file generated in step-3.</p> <p>3.Once all changes are taken , you can verify the patch by checking the option file/format as patch in the tool. Save the updated file and copy it to your repo (repo generated in step-2)</p> <p>4.Now in your repo , you will have 2 source file (for ex: one will be\u00a0index.php --original file with the required changes and\u00a0index_bk.php --updated file with patch applied and also your changes).</p> <p>5.In terminal , you can use command \"diff -ruN\u00a0 file1 file2 &gt; new_patch_file.patch\" to generate a\u00a0 new patch.</p> <p>6.For ex : diff -ruN index.php index_bk.php &gt; new_index.patch</p> <p>7.In case patch file has more than one file, then append the difference using diff -ruN next_file nextfile_bk.php &gt;&gt; new_index.patch</p>"},{"location":"source/docs/how-to-refresh-the-patches/#step-5-update-the-patch-file","title":"Step 5 : Update the patch file","text":"<p>1. Open the newly created patch file, update the file location correctly and save it. For ex :</p> <p>git/source/Styles/xb3/code/index.php 2019-05-20 05:56:54.047078876 +0000 +++ git.1/source/Styles/xb3/code/index.php 2019-05-20 06:26:56.000000000 +0000</p>"},{"location":"source/docs/how-to-refresh-the-patches/#step-6-validate-the-patch-file","title":"Step 6 : Validate the patch file","text":"<p>1.In order to verify the newly created patch, you can create a temporary folder, clone the repo, checkout the required branch. Now copy the latest patch (new_index.patch) here.\u00a0</p> <p>2.In the terminal, give the command\u00a0 patch -p1 &lt;\u00a0 new_index.patch , will apply the patch to the source file. It should not fail.</p>"},{"location":"source/docs/how-to-refresh-the-patches/#step-7-push-the-changes","title":"step 7 : Push the changes","text":"<p>1.Now for pushing the latest patch, clone the repo for patch (step-1)</p> <ul> <li>$ mkdir push</li> <li>$ cd push/</li> <li>$ git clone\u00a0     ssh://rkumar840@gerrit.teamccp.com:29418/rdk/yocto_oe/layers/meta-rdk-oem-pace-broadcom     \u00a0.</li> </ul> <p>2.checkout the required branch.</p> <ul> <li>$ git checkout 1905_sprint</li> </ul> <p>3.copy the latest patch(new_index.patch in this case) to the actual patch file available in the repo.</p> <ul> <li>$ cp ../src/new_index.patch\u00a0meta-pacexf3/recipes-ccsp/ccsp/ccsp-webui/index.patch</li> <li>$ git status</li> </ul> <p>4.It will show the file as modified. Perform git add.</p> <ul> <li>$ git add\u00a0meta-pacexf3/recipes-ccsp/ccsp/ccsp-webui/index.patch</li> <li>$ git commit</li> </ul> <p>5.Update if any commit message has to be added and try to push the changes.</p> <ul> <li>$ git push origin HEAD:refs/for/1905_sprint</li> </ul> <p>6.It fails for commit message upload. For ex : you may get error like this :</p> <ul> <li>remote: ERROR: [6b429fb] missing Change-Id in commit message footer</li> <li>remote:</li> <li>remote: Hint: To automatically insert Change-Id, install the hook:</li> <li>remote:     gitdir=$(git rev-parse --git-dir); scp -p -P 29418     rkumar840     @gerrit.teamccp.com     :hooks/commit-msg ${gitdir}/hooks/</li> <li>remote: And then amend the commit:</li> <li>remote: git commit --amend</li> </ul> <p>7.Run the command mention in logs.</p> <ul> <li>$ gitdir=$(git rev-parse --git-dir); scp -p -P 29418\u00a0     rkumar840     @gerrit.teamccp.com     :hooks/commit-msg ${gitdir}/hooks/</li> <li>$ git commit --amend (No change-id is assigned to the change.)</li> <li>$ git commit --amend\u00a0 (change-id has assigned now.)</li> <li>$ git push origin HEAD:refs/for/1905_sprint</li> </ul> <p>8.This will push the changes successfully to the branch. You can open the gerrit link and verify.</p> <p>9.Put the same topic name for the patch and the source file , trigger the verification.</p>"},{"location":"support/docs/overview/","title":"Place Holder markdown for Support page","text":""},{"location":"tools/docs/","title":"Place Holder markdown for Tools landing page","text":"<p>This page explains about the tools provided by RDKM like TDK, Automatics  This page doesnt cover any cloud/dev mgmt tools like XConf, as well as any third party test tools integrated to TDK or Automatics</p>"},{"location":"tools/docs/Automatics/","title":"Automatics","text":"<p>Automatics is the fully \u00a0integrated test automation system to support functional &amp; non-functional testing. Automatics is now available to the RDK community. Any community member can use this system to validate their RDK builds or their infrastructure.</p> <p>Automatics supports:</p> <ul> <li>Integration with CI flow to validate new changes checked in by user</li> <li>Configure test script details and test strategies</li> <li>Manual trigger of automated tests against RDK builds</li> <li>Walk through on test execution results</li> <li>End to End system is designed to support fast-paced DevOps model</li> <li>Support to execute test scripts based on Java, Python and PyTest.</li> </ul> <p>Major features of Automatics framework to work with external tools to enhance the Automatics capabilities:</p> <ul> <li>The framework supports integration with modern software tools -     Jira, ALM, Jenkins, Git, Grafana, Candela, CDRouter etc</li> <li>Dynamic device allocation and device health check is supported</li> <li>Automated defect creation and tagging can be done using the     framework</li> </ul> <p></p>"},{"location":"tools/docs/Automatics/#automatics-overview","title":"Automatics Overview","text":"<ul> <li> <ul> <li> <p> Automatics Architecture </p> </li> <li> <p></p> <p> Automatics in CI/CD </p> </li> <li> <p></p> <p> Automatics Repository Details </p> </li> <li> <p></p> <p> Automatics Tools Releases </p> </li> </ul> </li> </ul>"},{"location":"tools/docs/Automatics/#automatics-recent-updates","title":"Automatics Recent Updates","text":"<p> Automatics Framework and Tools - Release V15.0\u00a0is available</p> <p> Automatics Framework and Tools - Release V10.0\u00a0is available</p> <p> Automatics RDK-B Test script Release V10.0 is available</p>"},{"location":"tools/docs/Automatics/#automatics-useful-links","title":"Automatics Useful Links","text":"<ul> <li>Automatics Overview Webinar</li> <li>Automatics RDK-B Test Coverage Overview Webinar</li> <li>Automatics Demo Webinar</li> <li>Code Contribution Process</li> <li>Scriptless Automation Webinar</li> </ul>"},{"location":"tools/docs/Automatics/#automatics-framework","title":"Automatics Framework","text":"<ul> <li> <ul> <li> <p> Automatics Automated Build &amp; Deployment </p> </li> <li> <p></p> <p> Automatics Device Manager </p> </li> <li> <p></p> <p> Automatics Framework Repository Details </p> </li> <li> <p></p> <p> Automatics Generic Core Test Execution </p> </li> <li> <p></p> <p> Automatics Getting Started </p> </li> <li> <p></p> <p> Automatics Properties </p> </li> <li> <p></p> <p> Automatics Provider Details </p> </li> <li> <p></p> <p> Automatics Providers List </p> </li> <li> <p></p> <p> Automatics System Setup </p> </li> <li> <p></p> <p> Automatics Technology Stack - Upgrade </p> </li> <li> <p></p> <p> Automatics Tool Setup </p> </li> <li> <p></p> <p> Jenkins Setup and Deployment Guide </p> </li> </ul> </li> </ul>"},{"location":"tools/docs/Automatics/#automatics-core","title":"Automatics Core","text":"<ul> <li> <ul> <li> <p> Automatics API Specification </p> </li> <li> <p></p> <p> Automatics Core Overview </p> </li> </ul> </li> </ul>"},{"location":"tools/docs/Automatics/#automatics-rdk-b-tests","title":"Automatics RDK-B Tests","text":"<ul> <li> <ul> <li> <p> Automatics RDK-B Test case Provider Mapping </p> </li> <li> <p></p> <p> Automatics RDK-B Test Plan </p> </li> <li> <p></p> <p> Automatics RDK-B Test Property configuration </p> </li> <li> <p></p> <p> Automatics RDK-B Test Refactoring Releases &amp; Roadmap </p> </li> <li> <p></p> <p> Automatics RDKB Test Repository Details </p> </li> <li> <p></p> <p> Automatics RDK-B Test script Releases </p> </li> <li> <p></p> <p> Automatics RDK-B Test Scripts </p> </li> <li> <p></p> <p> Automatics RDK-B Tests Test Category </p> </li> <li> <p></p> <p> Automatics TCs shared by L&amp;T for open sourcing </p> </li> <li> <p></p> <p> Device Configuration in Automatics </p> </li> <li> <p></p> <p> RDKB Automatics Test - Connected Client Environment Setup </p> </li> <li> <p></p> <p> RDK-B Automatics Test Setup </p> </li> <li> <p></p> <p> RDKB - Test Reports 2023Q4 Kirkstone build </p> </li> <li> <p></p> <p> RDKB - Test Reports 2024Q2 Kirkstone build </p> </li> <li> <p></p> <p> RDKB - Test Reports 2024Q3 Kirkstone build </p> </li> <li> <p></p> <p> RDKB - Test Reports 2024Q4 Kirkstone build </p> </li> <li> <p></p> <p> RDKB Tests on Raspberry Pi device </p> </li> <li> <p></p> <p> RDKB Tests on Raspberry Pi device - Execution Status </p> </li> </ul> </li> </ul>"},{"location":"tools/docs/Automatics/#automatics-working-group","title":"Automatics Working Group","text":"<ul> <li> <ul> <li> <p> Automatics-3.0 </p> </li> <li> <p></p> <p> Automatics Candela Integration </p> </li> <li> <p></p> <p> Automatics Roadmap and Backlogs </p> </li> <li> <p></p> <p> TR181 Validation Support </p> </li> </ul> </li> </ul>"},{"location":"tools/docs/Automatics/#automatics-community-collaboration","title":"Automatics Community Collaboration","text":"<ul> <li> <ul> <li> <p> Automatics Community Contributions </p> </li> </ul> </li> </ul>"},{"location":"tools/docs/TDK/","title":"Test Development Kit (TDK) Home","text":"<p>Welcome to the TDK space!</p> <p>The RDK Test Development Kit (TDK) is a generic test kit for automated testing of generic RDK components and end-to-end scenarios facilitated by a web based user interface for configuration, test creation, execution and result aggregation. The web based UI is complemented by command line interfaces to power test automation from third party test and continuous integration tools. The TDK facilitates the testing of RDK devices in standalone environments. This page provides information regarding the TDK roadmap, usage tutorials, development processes and FAQs to facilitate the RDK community to start using the tool and provide feedback and requirements for the improvement of the tool to suite the generic community needs.</p>"},{"location":"tools/docs/TDK/#tdk-release-notes-roadmap-updates","title":"TDK Release Notes &amp; Roadmap Updates","text":"<ul> <li>TDK Releases</li> </ul>"},{"location":"tools/docs/TDK/#tdk-documentation","title":"TDK-Documentation","text":"<ul> <li> <p>TDK-V Documentation</p> </li> <li> <p>TDK-B Documentation</p> </li> <li> <p>TDK-C Documentation</p> </li> <li> <p>RDK Certification\u00a0</p> </li> </ul>"},{"location":"tools/docs/TDK/#tutorials-documents","title":"Tutorials &amp; Documents","text":"<ul> <li> <p>TDK-V Test Case Documents</p> </li> <li> <p>TDK-B Test Case Documents</p> </li> <li> <p>Docker Setup for TDK Test Manager</p> </li> <li> <p>TDK-B E2E Setup Document</p> </li> <li> <p>TDK Bug Resolution     Workflow</p> </li> <li> <p>FAQ</p> </li> <li> <p>TDK Test Manager Java8 Migration</p> </li> <li> <p>TDK - RDK Service Validation Framework</p> </li> </ul>"}]}